var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/array.js
var require_array = __commonJS({
  "node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/array.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.flatten = void 0;
    exports2.flat = flat;
    exports2.unique = unique;
    exports2.last = last;
    exports2.first = first;
    exports2.splitInChunks = splitInChunks;
    exports2.transformVariadicArgumentToArray = transformVariadicArgumentToArray;
    exports2.zip = zip;
    exports2.partition = partition2;
    exports2.filterDuplicates = filterDuplicates;
    exports2.filterDuplicatesRight = filterDuplicatesRight;
    function flat(arr2) {
      return arr2.reduce((flattened, subArr) => [...flattened, ...subArr], []);
    }
    function unique(arr2) {
      return Array.from(new Set(arr2));
    }
    function last(arr2) {
      return arr2.length ? arr2[arr2.length - 1] : void 0;
    }
    function first(arr2) {
      return arr2[0];
    }
    function splitInChunks(arr2, chunkSize) {
      const chunks = [];
      if (arr2) {
        for (let i = 0; i < arr2.length; i += chunkSize) {
          chunks.push(arr2.slice(i, i + chunkSize));
        }
      }
      return chunks;
    }
    function transformVariadicArgumentToArray(firstOrArray, rest) {
      if (Array.isArray(firstOrArray)) {
        return [...firstOrArray, ...rest];
      }
      return firstOrArray ? [firstOrArray, ...rest] : [...rest];
    }
    var flatten = (input) => {
      const flatResult = [];
      const stack = [...input];
      while (stack.length > 0) {
        const current = stack.pop();
        if (!Array.isArray(current)) {
          flatResult.push(current);
        } else {
          stack.push(...current);
        }
      }
      return flatResult.reverse();
    };
    exports2.flatten = flatten;
    function zip(left, right) {
      const longerArr = left.length > right.length ? left : right;
      return longerArr.reduce((zipped, _, i) => {
        const currentZipped = [];
        if (left.length > i) {
          currentZipped.push(left[i]);
        }
        if (right.length > i) {
          currentZipped.push(right[i]);
        }
        return [...zipped, ...currentZipped];
      }, []);
    }
    function partition2(arr2, condition) {
      return arr2.reduce(([conditionTrue, conditionFalse], item) => condition(item) ? [[...conditionTrue, item], conditionFalse] : [conditionTrue, [...conditionFalse, item]], [[], []]);
    }
    function filterDuplicates(arr2, comparator = (left, right) => left === right) {
      return arr2.filter((item, index) => !arr2.slice(0, index).find((filteredItem) => comparator(item, filteredItem)));
    }
    function filterDuplicatesRight(arr2, comparator = (left, right) => left === right) {
      return filterDuplicates(arr2.reverse(), comparator).reverse();
    }
  }
});

// node_modules/voca/index.js
var require_voca = __commonJS({
  "node_modules/voca/index.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = global2 || self, global2.v = factory());
    })(exports2, function() {
      "use strict";
      function _extends() {
        _extends = Object.assign || function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends.apply(this, arguments);
      }
      function _slicedToArray(arr2, i) {
        return _arrayWithHoles(arr2) || _iterableToArrayLimit(arr2, i) || _nonIterableRest();
      }
      function _toConsumableArray(arr2) {
        return _arrayWithoutHoles(arr2) || _iterableToArray(arr2) || _nonIterableSpread();
      }
      function _arrayWithoutHoles(arr2) {
        if (Array.isArray(arr2)) {
          for (var i = 0, arr22 = new Array(arr2.length); i < arr2.length; i++) arr22[i] = arr2[i];
          return arr22;
        }
      }
      function _arrayWithHoles(arr2) {
        if (Array.isArray(arr2)) return arr2;
      }
      function _iterableToArray(iter) {
        if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
      }
      function _iterableToArrayLimit(arr2, i) {
        if (!(Symbol.iterator in Object(arr2) || Object.prototype.toString.call(arr2) === "[object Arguments]")) {
          return;
        }
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = void 0;
        try {
          for (var _i = arr2[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"] != null) _i["return"]();
          } finally {
            if (_d) throw _e;
          }
        }
        return _arr;
      }
      function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance");
      }
      function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
      function isNil(value) {
        return value === void 0 || value === null;
      }
      function coerceToBoolean(value) {
        var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        if (isNil(value)) {
          return defaultValue;
        }
        return Boolean(value);
      }
      function isString(subject) {
        return typeof subject === "string";
      }
      function coerceToString(value) {
        var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
        if (isNil(value)) {
          return defaultValue;
        }
        if (isString(value)) {
          return value;
        }
        return String(value);
      }
      function capitalize(subject, restToLower) {
        var subjectString = coerceToString(subject);
        var restToLowerCaseBoolean = coerceToBoolean(restToLower);
        if (subjectString === "") {
          return "";
        }
        if (restToLowerCaseBoolean) {
          subjectString = subjectString.toLowerCase();
        }
        return subjectString.substr(0, 1).toUpperCase() + subjectString.substr(1);
      }
      function lowerCase(subject) {
        var subjectString = coerceToString(subject, "");
        return subjectString.toLowerCase();
      }
      var digit = "\\d";
      var whitespace = "\\s\\uFEFF\\xA0";
      var highSurrogate = "\\uD800-\\uDBFF";
      var lowSurrogate = "\\uDC00-\\uDFFF";
      var diacriticalMark = "\\u0300-\\u036F\\u1AB0-\\u1AFF\\u1DC0-\\u1DFF\\u20D0-\\u20FF\\uFE20-\\uFE2F";
      var base = "\\0-\\u02FF\\u0370-\\u1AAF\\u1B00-\\u1DBF\\u1E00-\\u20CF\\u2100-\\uD7FF\\uE000-\\uFE1F\\uFE30-\\uFFFF";
      var REGEXP_COMBINING_MARKS = new RegExp("([" + base + "]|[" + highSurrogate + "][" + lowSurrogate + "]|[" + highSurrogate + "](?![" + lowSurrogate + "])|(?:[^" + highSurrogate + "]|^)[" + lowSurrogate + "])([" + diacriticalMark + "]+)", "g");
      var REGEXP_SURROGATE_PAIRS = new RegExp("([" + highSurrogate + "])([" + lowSurrogate + "])", "g");
      var REGEXP_UNICODE_CHARACTER = new RegExp("((?:[" + base + "]|[" + highSurrogate + "][" + lowSurrogate + "]|[" + highSurrogate + "](?![" + lowSurrogate + "])|(?:[^" + highSurrogate + "]|^)[" + lowSurrogate + "])(?:[" + diacriticalMark + "]+))|([" + highSurrogate + "][" + lowSurrogate + "])|([\\n\\r\\u2028\\u2029])|(.)", "g");
      var REGEXP_WHITESPACE = new RegExp("[" + whitespace + "]");
      var REGEXP_TRIM_LEFT = new RegExp("^[" + whitespace + "]+");
      var REGEXP_TRIM_RIGHT = new RegExp("[" + whitespace + "]+$");
      var REGEXP_DIGIT = new RegExp("^" + digit + "+$");
      var REGEXP_SPECIAL_CHARACTERS = /[-[\]{}()*+!<=:?./\\^$|#,]/g;
      var REGEXP_NON_LATIN = /[^A-Za-z0-9]/g;
      var REGEXP_HTML_SPECIAL_CHARACTERS = /[<>&"'`]/g;
      var REGEXP_CONVERSION_SPECIFICATION = /(%{1,2})(?:(\d+)\$)?(\+)?([ 0]|'.{1})?(-)?(\d+)?(?:\.(\d+))?([bcdiouxXeEfgGs])?/g;
      var REGEXP_TRAILING_ZEROS = /\.?0+$/g;
      var REGEXP_TAG_LIST = /<([A-Za-z0-9]+)>/g;
      var generalPunctuationBlock = "\\u2000-\\u206F";
      var nonCharacter = "\\x00-\\x2F\\x3A-\\x40\\x5B-\\x60\\x7b-\\xBF\\xD7\\xF7";
      var dingbatBlock = "\\u2700-\\u27BF";
      var lowerCaseLetter = "a-z\\xB5\\xDF-\\xF6\\xF8-\\xFF\\u0101\\u0103\\u0105\\u0107\\u0109\\u010B\\u010D\\u010F\\u0111\\u0113\\u0115\\u0117\\u0119\\u011B\\u011D\\u011F\\u0121\\u0123\\u0125\\u0127\\u0129\\u012B\\u012D\\u012F\\u0131\\u0133\\u0135\\u0137\\u0138\\u013A\\u013C\\u013E\\u0140\\u0142\\u0144\\u0146\\u0148\\u0149\\u014B\\u014D\\u014F\\u0151\\u0153\\u0155\\u0157\\u0159\\u015B\\u015D\\u015F\\u0161\\u0163\\u0165\\u0167\\u0169\\u016B\\u016D\\u016F\\u0171\\u0173\\u0175\\u0177\\u017A\\u017C\\u017E-\\u0180\\u0183\\u0185\\u0188\\u018C\\u018D\\u0192\\u0195\\u0199-\\u019B\\u019E\\u01A1\\u01A3\\u01A5\\u01A8\\u01AA\\u01AB\\u01AD\\u01B0\\u01B4\\u01B6\\u01B9\\u01BA\\u01BD-\\u01BF\\u01C6\\u01C9\\u01CC\\u01CE\\u01D0\\u01D2\\u01D4\\u01D6\\u01D8\\u01DA\\u01DC\\u01DD\\u01DF\\u01E1\\u01E3\\u01E5\\u01E7\\u01E9\\u01EB\\u01ED\\u01EF\\u01F0\\u01F3\\u01F5\\u01F9\\u01FB\\u01FD\\u01FF\\u0201\\u0203\\u0205\\u0207\\u0209\\u020B\\u020D\\u020F\\u0211\\u0213\\u0215\\u0217\\u0219\\u021B\\u021D\\u021F\\u0221\\u0223\\u0225\\u0227\\u0229\\u022B\\u022D\\u022F\\u0231\\u0233-\\u0239\\u023C\\u023F\\u0240\\u0242\\u0247\\u0249\\u024B\\u024D\\u024F";
      var upperCaseLetter = "\\x41-\\x5a\\xc0-\\xd6\\xd8-\\xde\\u0100\\u0102\\u0104\\u0106\\u0108\\u010a\\u010c\\u010e\\u0110\\u0112\\u0114\\u0116\\u0118\\u011a\\u011c\\u011e\\u0120\\u0122\\u0124\\u0126\\u0128\\u012a\\u012c\\u012e\\u0130\\u0132\\u0134\\u0136\\u0139\\u013b\\u013d\\u013f\\u0141\\u0143\\u0145\\u0147\\u014a\\u014c\\u014e\\u0150\\u0152\\u0154\\u0156\\u0158\\u015a\\u015c\\u015e\\u0160\\u0162\\u0164\\u0166\\u0168\\u016a\\u016c\\u016e\\u0170\\u0172\\u0174\\u0176\\u0178\\u0179\\u017b\\u017d\\u0181\\u0182\\u0184\\u0186\\u0187\\u0189-\\u018b\\u018e-\\u0191\\u0193\\u0194\\u0196-\\u0198\\u019c\\u019d\\u019f\\u01a0\\u01a2\\u01a4\\u01a6\\u01a7\\u01a9\\u01ac\\u01ae\\u01af\\u01b1-\\u01b3\\u01b5\\u01b7\\u01b8\\u01bc\\u01c4\\u01c5\\u01c7\\u01c8\\u01ca\\u01cb\\u01cd\\u01cf\\u01d1\\u01d3\\u01d5\\u01d7\\u01d9\\u01db\\u01de\\u01e0\\u01e2\\u01e4\\u01e6\\u01e8\\u01ea\\u01ec\\u01ee\\u01f1\\u01f2\\u01f4\\u01f6-\\u01f8\\u01fa\\u01fc\\u01fe\\u0200\\u0202\\u0204\\u0206\\u0208\\u020a\\u020c\\u020e\\u0210\\u0212\\u0214\\u0216\\u0218\\u021a\\u021c\\u021e\\u0220\\u0222\\u0224\\u0226\\u0228\\u022a\\u022c\\u022e\\u0230\\u0232\\u023a\\u023b\\u023d\\u023e\\u0241\\u0243-\\u0246\\u0248\\u024a\\u024c\\u024e";
      var REGEXP_WORD = new RegExp("(?:[" + upperCaseLetter + "][" + diacriticalMark + "]*)?(?:[" + lowerCaseLetter + "][" + diacriticalMark + "]*)+|(?:[" + upperCaseLetter + "][" + diacriticalMark + "]*)+(?![" + lowerCaseLetter + "])|[" + digit + "]+|[" + dingbatBlock + "]|[^" + nonCharacter + generalPunctuationBlock + whitespace + "]+", "g");
      var REGEXP_LATIN_WORD = /[A-Z\xC0-\xD6\xD8-\xDE]?[a-z\xDF-\xF6\xF8-\xFF]+|[A-Z\xC0-\xD6\xD8-\xDE]+(?![a-z\xDF-\xF6\xF8-\xFF])|\d+/g;
      var REGEXP_ALPHA = new RegExp("^(?:[" + lowerCaseLetter + upperCaseLetter + "][" + diacriticalMark + "]*)+$");
      var REGEXP_ALPHA_DIGIT = new RegExp("^((?:[" + lowerCaseLetter + upperCaseLetter + "][" + diacriticalMark + "]*)|[" + digit + "])+$");
      var REGEXP_EXTENDED_ASCII = /^[\x01-\xFF]*$/;
      function nilDefault(value, defaultValue) {
        return value == null ? defaultValue : value;
      }
      function toString(value) {
        if (isNil(value)) {
          return null;
        }
        if (isString(value)) {
          return value;
        }
        return String(value);
      }
      function words(subject, pattern, flags) {
        var subjectString = coerceToString(subject);
        var patternRegExp;
        if (isNil(pattern)) {
          patternRegExp = REGEXP_EXTENDED_ASCII.test(subjectString) ? REGEXP_LATIN_WORD : REGEXP_WORD;
        } else if (pattern instanceof RegExp) {
          patternRegExp = pattern;
        } else {
          var flagsString = toString(nilDefault(flags, ""));
          patternRegExp = new RegExp(toString(pattern), flagsString);
        }
        return nilDefault(subjectString.match(patternRegExp), []);
      }
      function wordToCamel(word, index) {
        return index === 0 ? lowerCase(word) : capitalize(word, true);
      }
      function camelCase2(subject) {
        var subjectString = coerceToString(subject);
        if (subjectString === "") {
          return "";
        }
        return words(subjectString).map(wordToCamel).join("");
      }
      function decapitalize(subject) {
        var subjectString = coerceToString(subject);
        if (subjectString === "") {
          return "";
        }
        return subjectString.substr(0, 1).toLowerCase() + subjectString.substr(1);
      }
      function kebabCase(subject) {
        var subjectString = coerceToString(subject);
        if (subjectString === "") {
          return "";
        }
        return words(subjectString).map(lowerCase).join("-");
      }
      function snakeCase2(subject) {
        var subjectString = coerceToString(subject);
        if (subjectString === "") {
          return "";
        }
        return words(subjectString).map(lowerCase).join("_");
      }
      function upperCase(subject) {
        var subjectString = coerceToString(subject);
        return subjectString.toUpperCase();
      }
      function swapCase(subject) {
        var subjectString = coerceToString(subject);
        return subjectString.split("").reduce(swapAndConcat, "");
      }
      function swapAndConcat(swapped, character) {
        var lowerCase2 = character.toLowerCase();
        var upperCase2 = character.toUpperCase();
        return swapped + (character === lowerCase2 ? upperCase2 : lowerCase2);
      }
      function titleCase(subject, noSplit) {
        var subjectString = coerceToString(subject);
        var noSplitArray = Array.isArray(noSplit) ? noSplit : [];
        var wordsRegExp = REGEXP_EXTENDED_ASCII.test(subjectString) ? REGEXP_LATIN_WORD : REGEXP_WORD;
        return subjectString.replace(wordsRegExp, function(word, index) {
          var isNoSplit = index > 0 && noSplitArray.indexOf(subjectString[index - 1]) >= 0;
          return isNoSplit ? word.toLowerCase() : capitalize(word, true);
        });
      }
      function clipNumber(value, downLimit, upLimit) {
        if (value <= downLimit) {
          return downLimit;
        }
        if (value >= upLimit) {
          return upLimit;
        }
        return value;
      }
      var MAX_SAFE_INTEGER = 9007199254740991;
      function toInteger(value) {
        if (value === Infinity) {
          return MAX_SAFE_INTEGER;
        }
        if (value === -Infinity) {
          return -MAX_SAFE_INTEGER;
        }
        return ~~value;
      }
      function truncate(subject, length, end) {
        var subjectString = coerceToString(subject);
        var lengthInt = isNil(length) ? subjectString.length : clipNumber(toInteger(length), 0, MAX_SAFE_INTEGER);
        var endString = coerceToString(end, "...");
        if (lengthInt >= subjectString.length) {
          return subjectString;
        }
        return subjectString.substr(0, length - endString.length) + endString;
      }
      function charAt(subject, position) {
        var subjectString = coerceToString(subject);
        return subjectString.charAt(position);
      }
      var HIGH_SURROGATE_START = 55296;
      var HIGH_SURROGATE_END = 56319;
      var LOW_SURROGATE_START = 56320;
      var LOW_SURROGATE_END = 57343;
      function isHighSurrogate(codePoint) {
        return codePoint >= HIGH_SURROGATE_START && codePoint <= HIGH_SURROGATE_END;
      }
      function isLowSurrogate(codePoint) {
        return codePoint >= LOW_SURROGATE_START && codePoint <= LOW_SURROGATE_END;
      }
      function getAstralNumberFromSurrogatePair(highSurrogate2, lowSurrogate2) {
        return (highSurrogate2 - HIGH_SURROGATE_START) * 1024 + lowSurrogate2 - LOW_SURROGATE_START + 65536;
      }
      function coerceToNumber(value) {
        var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        if (isNil(value)) {
          return defaultValue;
        }
        if (typeof value === "number") {
          return value;
        }
        return Number(value);
      }
      function nanDefault(value, defaultValue) {
        return value !== value ? defaultValue : value;
      }
      function codePointAt(subject, position) {
        var subjectString = coerceToString(subject);
        var subjectStringLength = subjectString.length;
        var positionNumber = coerceToNumber(position);
        positionNumber = nanDefault(positionNumber, 0);
        if (positionNumber < 0 || positionNumber >= subjectStringLength) {
          return void 0;
        }
        var firstCodePoint = subjectString.charCodeAt(positionNumber);
        var secondCodePoint;
        if (isHighSurrogate(firstCodePoint) && subjectStringLength > positionNumber + 1) {
          secondCodePoint = subjectString.charCodeAt(positionNumber + 1);
          if (isLowSurrogate(secondCodePoint)) {
            return getAstralNumberFromSurrogatePair(firstCodePoint, secondCodePoint);
          }
        }
        return firstCodePoint;
      }
      function first(subject, length) {
        var subjectString = coerceToString(subject);
        var lengthInt = isNil(length) ? 1 : clipNumber(toInteger(length), 0, MAX_SAFE_INTEGER);
        if (subjectString.length <= lengthInt) {
          return subjectString;
        }
        return subjectString.substr(0, lengthInt);
      }
      function graphemeAt(subject, position) {
        var subjectString = coerceToString(subject);
        var positionNumber = coerceToNumber(position);
        var graphemeMatch;
        var graphemeMatchIndex = 0;
        positionNumber = nanDefault(positionNumber, 0);
        while ((graphemeMatch = REGEXP_UNICODE_CHARACTER.exec(subjectString)) !== null) {
          if (graphemeMatchIndex === positionNumber) {
            REGEXP_UNICODE_CHARACTER.lastIndex = 0;
            return graphemeMatch[0];
          }
          graphemeMatchIndex++;
        }
        return "";
      }
      function last(subject, length) {
        var subjectString = coerceToString(subject);
        var lengthInt = isNil(length) ? 1 : clipNumber(toInteger(length), 0, MAX_SAFE_INTEGER);
        if (subjectString.length <= lengthInt) {
          return subjectString;
        }
        return subjectString.substr(subjectString.length - lengthInt, lengthInt);
      }
      function prune(subject, length, end) {
        var subjectString = coerceToString(subject);
        var lengthInt = isNil(length) ? subjectString.length : clipNumber(toInteger(length), 0, MAX_SAFE_INTEGER);
        var endString = coerceToString(end, "...");
        if (lengthInt >= subjectString.length) {
          return subjectString;
        }
        var pattern = REGEXP_EXTENDED_ASCII.test(subjectString) ? REGEXP_LATIN_WORD : REGEXP_WORD;
        var truncatedLength = 0;
        subjectString.replace(pattern, function(word, offset) {
          var wordInsertLength = offset + word.length;
          if (wordInsertLength <= lengthInt - endString.length) {
            truncatedLength = wordInsertLength;
          }
        });
        return subjectString.substr(0, truncatedLength) + endString;
      }
      function slice(subject, start, end) {
        return coerceToString(subject).slice(start, end);
      }
      function substr(subject, start, length) {
        return coerceToString(subject).substr(start, length);
      }
      function substring(subject, start, end) {
        return coerceToString(subject).substring(start, end);
      }
      function count(subject) {
        return coerceToString(subject).length;
      }
      function countGrapheme(subject) {
        return coerceToString(subject).replace(REGEXP_COMBINING_MARKS, "*").replace(REGEXP_SURROGATE_PAIRS, "*").length;
      }
      function countSubstrings(subject, substring2) {
        var subjectString = coerceToString(subject);
        var substringString = coerceToString(substring2);
        var substringLength = substringString.length;
        var count2 = 0;
        var matchIndex = 0;
        if (subjectString === "" || substringString === "") {
          return count2;
        }
        do {
          matchIndex = subjectString.indexOf(substringString, matchIndex);
          if (matchIndex !== -1) {
            count2++;
            matchIndex += substringLength;
          }
        } while (matchIndex !== -1);
        return count2;
      }
      var reduce = Array.prototype.reduce;
      function countWhere(subject, predicate, context) {
        var subjectString = coerceToString(subject);
        if (subjectString === "" || typeof predicate !== "function") {
          return 0;
        }
        var predicateWithContext = predicate.bind(context);
        return reduce.call(subjectString, function(countTruthy, character, index) {
          return predicateWithContext(character, index, subjectString) ? countTruthy + 1 : countTruthy;
        }, 0);
      }
      function countWords(subject, pattern, flags) {
        return words(subject, pattern, flags).length;
      }
      function ReplacementIndex() {
        this.index = 0;
      }
      ReplacementIndex.prototype.increment = function() {
        this.index++;
      };
      ReplacementIndex.prototype.incrementOnEmptyPosition = function(position) {
        if (isNil(position)) {
          this.increment();
        }
      };
      ReplacementIndex.prototype.getIndexByPosition = function(position) {
        return isNil(position) ? this.index : position - 1;
      };
      var TYPE_INTEGER = "i";
      var TYPE_INTEGER_BINARY = "b";
      var TYPE_INTEGER_ASCII_CHARACTER = "c";
      var TYPE_INTEGER_DECIMAL = "d";
      var TYPE_INTEGER_OCTAL = "o";
      var TYPE_INTEGER_UNSIGNED_DECIMAL = "u";
      var TYPE_INTEGER_HEXADECIMAL = "x";
      var TYPE_INTEGER_HEXADECIMAL_UPPERCASE = "X";
      var TYPE_FLOAT_SCIENTIFIC = "e";
      var TYPE_FLOAT_SCIENTIFIC_UPPERCASE = "E";
      var TYPE_FLOAT = "f";
      var TYPE_FLOAT_SHORT = "g";
      var TYPE_FLOAT_SHORT_UPPERCASE = "G";
      var TYPE_STRING = "s";
      var LITERAL_SINGLE_QUOTE = "'";
      var LITERAL_PLUS = "+";
      var LITERAL_MINUS = "-";
      var LITERAL_PERCENT_SPECIFIER = "%%";
      var RADIX_BINARY = 2;
      var RADIX_OCTAL = 8;
      var RADIX_HEXADECIMAL = 16;
      function repeat(subject, times) {
        var subjectString = coerceToString(subject);
        var timesInt = isNil(times) ? 1 : clipNumber(toInteger(times), 0, MAX_SAFE_INTEGER);
        var repeatString = "";
        while (timesInt) {
          if (timesInt & 1) {
            repeatString += subjectString;
          }
          if (timesInt > 1) {
            subjectString += subjectString;
          }
          timesInt >>= 1;
        }
        return repeatString;
      }
      function buildPadding(padCharacters, length) {
        var padStringRepeat = toInteger(length / padCharacters.length);
        var padStringRest = length % padCharacters.length;
        return repeat(padCharacters, padStringRepeat + padStringRest).substr(0, length);
      }
      function padLeft(subject, length, pad2) {
        var subjectString = coerceToString(subject);
        var lengthInt = isNil(length) ? 0 : clipNumber(toInteger(length), 0, MAX_SAFE_INTEGER);
        var padString = coerceToString(pad2, " ");
        if (lengthInt <= subjectString.length) {
          return subjectString;
        }
        return buildPadding(padString, lengthInt - subjectString.length) + subjectString;
      }
      function padRight(subject, length, pad2) {
        var subjectString = coerceToString(subject);
        var lengthInt = isNil(length) ? 0 : clipNumber(toInteger(length), 0, MAX_SAFE_INTEGER);
        var padString = coerceToString(pad2, " ");
        if (lengthInt <= subjectString.length) {
          return subjectString;
        }
        return subjectString + buildPadding(padString, lengthInt - subjectString.length);
      }
      function alignAndPad(subject, conversion) {
        var width = conversion.width;
        if (isNil(width) || subject.length >= width) {
          return subject;
        }
        var padType = conversion.alignmentSpecifier === LITERAL_MINUS ? padRight : padLeft;
        return padType(subject, width, conversion.getPaddingCharacter());
      }
      function addSignToFormattedNumber(replacementNumber, formattedReplacement, conversion) {
        if (conversion.signSpecifier === LITERAL_PLUS && replacementNumber >= 0) {
          formattedReplacement = LITERAL_PLUS + formattedReplacement;
        }
        return formattedReplacement;
      }
      function float(replacement, conversion) {
        var replacementNumber = parseFloat(replacement);
        var formattedReplacement;
        if (isNaN(replacementNumber)) {
          replacementNumber = 0;
        }
        var precision = coerceToNumber(conversion.precision, 6);
        switch (conversion.typeSpecifier) {
          case TYPE_FLOAT:
            formattedReplacement = replacementNumber.toFixed(precision);
            break;
          case TYPE_FLOAT_SCIENTIFIC:
            formattedReplacement = replacementNumber.toExponential(precision);
            break;
          case TYPE_FLOAT_SCIENTIFIC_UPPERCASE:
            formattedReplacement = replacementNumber.toExponential(precision).toUpperCase();
            break;
          case TYPE_FLOAT_SHORT:
          case TYPE_FLOAT_SHORT_UPPERCASE:
            formattedReplacement = formatFloatAsShort(replacementNumber, precision, conversion);
            break;
        }
        formattedReplacement = addSignToFormattedNumber(replacementNumber, formattedReplacement, conversion);
        return coerceToString(formattedReplacement);
      }
      function formatFloatAsShort(replacementNumber, precision, conversion) {
        if (replacementNumber === 0) {
          return "0";
        }
        var nonZeroPrecision = precision === 0 ? 1 : precision;
        var formattedReplacement = replacementNumber.toPrecision(nonZeroPrecision).replace(REGEXP_TRAILING_ZEROS, "");
        if (conversion.typeSpecifier === TYPE_FLOAT_SHORT_UPPERCASE) {
          formattedReplacement = formattedReplacement.toUpperCase();
        }
        return formattedReplacement;
      }
      function integerBase(replacement, conversion) {
        var integer = parseInt(replacement);
        if (isNaN(integer)) {
          integer = 0;
        }
        integer = integer >>> 0;
        switch (conversion.typeSpecifier) {
          case TYPE_INTEGER_ASCII_CHARACTER:
            integer = String.fromCharCode(integer);
            break;
          case TYPE_INTEGER_BINARY:
            integer = integer.toString(RADIX_BINARY);
            break;
          case TYPE_INTEGER_OCTAL:
            integer = integer.toString(RADIX_OCTAL);
            break;
          case TYPE_INTEGER_HEXADECIMAL:
            integer = integer.toString(RADIX_HEXADECIMAL);
            break;
          case TYPE_INTEGER_HEXADECIMAL_UPPERCASE:
            integer = integer.toString(RADIX_HEXADECIMAL).toUpperCase();
            break;
        }
        return coerceToString(integer);
      }
      function integerDecimal(replacement, conversion) {
        var integer = parseInt(replacement);
        if (isNaN(integer)) {
          integer = 0;
        }
        return addSignToFormattedNumber(integer, toString(integer), conversion);
      }
      function stringFormat(replacement, conversion) {
        var formattedReplacement = replacement;
        var precision = conversion.precision;
        if (!isNil(precision) && formattedReplacement.length > precision) {
          formattedReplacement = truncate(formattedReplacement, precision, "");
        }
        return formattedReplacement;
      }
      function compute(replacement, conversion) {
        var formatFunction;
        switch (conversion.typeSpecifier) {
          case TYPE_STRING:
            formatFunction = stringFormat;
            break;
          case TYPE_INTEGER_DECIMAL:
          case TYPE_INTEGER:
            formatFunction = integerDecimal;
            break;
          case TYPE_INTEGER_ASCII_CHARACTER:
          case TYPE_INTEGER_BINARY:
          case TYPE_INTEGER_OCTAL:
          case TYPE_INTEGER_HEXADECIMAL:
          case TYPE_INTEGER_HEXADECIMAL_UPPERCASE:
          case TYPE_INTEGER_UNSIGNED_DECIMAL:
            formatFunction = integerBase;
            break;
          case TYPE_FLOAT:
          case TYPE_FLOAT_SCIENTIFIC:
          case TYPE_FLOAT_SCIENTIFIC_UPPERCASE:
          case TYPE_FLOAT_SHORT:
          case TYPE_FLOAT_SHORT_UPPERCASE:
            formatFunction = float;
            break;
        }
        var formattedString = formatFunction(replacement, conversion);
        return alignAndPad(formattedString, conversion);
      }
      function ConversionSpecification(properties) {
        this.percent = properties.percent;
        this.signSpecifier = properties.signSpecifier;
        this.paddingSpecifier = properties.paddingSpecifier;
        this.alignmentSpecifier = properties.alignmentSpecifier;
        this.width = properties.width;
        this.precision = properties.precision;
        this.typeSpecifier = properties.typeSpecifier;
      }
      ConversionSpecification.prototype.isPercentLiteral = function() {
        return LITERAL_PERCENT_SPECIFIER === this.percent;
      };
      ConversionSpecification.prototype.getPaddingCharacter = function() {
        var paddingCharacter = nilDefault(this.paddingSpecifier, " ");
        if (paddingCharacter.length === 2 && paddingCharacter[0] === LITERAL_SINGLE_QUOTE) {
          paddingCharacter = paddingCharacter[1];
        }
        return paddingCharacter;
      };
      function validate3(index, replacementsLength, conversion) {
        if (isNil(conversion.typeSpecifier)) {
          throw new Error("sprintf(): Unknown type specifier");
        }
        if (index > replacementsLength - 1) {
          throw new Error("sprintf(): Too few arguments");
        }
        if (index < 0) {
          throw new Error("sprintf(): Argument number must be greater than zero");
        }
      }
      function match(replacementIndex, replacements, conversionSpecification, percent, position, signSpecifier, paddingSpecifier, alignmentSpecifier, widthSpecifier, precisionSpecifier, typeSpecifier) {
        var conversion = new ConversionSpecification({
          percent,
          signSpecifier,
          paddingSpecifier,
          alignmentSpecifier,
          width: coerceToNumber(widthSpecifier, null),
          precision: coerceToNumber(precisionSpecifier, null),
          typeSpecifier
        });
        if (conversion.isPercentLiteral()) {
          return conversionSpecification.slice(1);
        }
        var actualReplacementIndex = replacementIndex.getIndexByPosition(position);
        replacementIndex.incrementOnEmptyPosition(position);
        validate3(actualReplacementIndex, replacements.length, conversion);
        return compute(replacements[actualReplacementIndex], conversion);
      }
      function sprintf(format) {
        var formatString = coerceToString(format);
        if (formatString === "") {
          return formatString;
        }
        for (var _len = arguments.length, replacements = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          replacements[_key - 1] = arguments[_key];
        }
        var boundReplacementMatch = match.bind(void 0, new ReplacementIndex(), replacements);
        return formatString.replace(REGEXP_CONVERSION_SPECIFICATION, boundReplacementMatch);
      }
      function vprintf(format, replacements) {
        return sprintf.apply(void 0, [format].concat(_toConsumableArray(nilDefault(replacements, []))));
      }
      var escapeCharactersMap = {
        "<": "&lt;",
        ">": "&gt;",
        "&": "&amp;",
        '"': "&quot;",
        "'": "&#x27;",
        "`": "&#x60;"
      };
      function replaceSpecialCharacter(character) {
        return escapeCharactersMap[character];
      }
      function escapeHtml(subject) {
        return coerceToString(subject).replace(REGEXP_HTML_SPECIAL_CHARACTERS, replaceSpecialCharacter);
      }
      function escapeRegExp(subject) {
        return coerceToString(subject).replace(REGEXP_SPECIAL_CHARACTERS, "\\$&");
      }
      var unescapeCharactersMap = {
        "<": /(&lt;)|(&#x0*3c;)|(&#0*60;)/gi,
        ">": /(&gt;)|(&#x0*3e;)|(&#0*62;)/gi,
        "&": /(&amp;)|(&#x0*26;)|(&#0*38;)/gi,
        '"': /(&quot;)|(&#x0*22;)|(&#0*34;)/gi,
        "'": /(&#x0*27;)|(&#0*39;)/gi,
        "`": /(&#x0*60;)|(&#0*96;)/gi
      };
      var characters = Object.keys(unescapeCharactersMap);
      function reduceUnescapedString(string, key) {
        return string.replace(unescapeCharactersMap[key], key);
      }
      function unescapeHtml(subject) {
        var subjectString = coerceToString(subject);
        return characters.reduce(reduceUnescapedString, subjectString);
      }
      function indexOf(subject, search2, fromIndex) {
        var subjectString = coerceToString(subject);
        return subjectString.indexOf(search2, fromIndex);
      }
      function lastIndexOf(subject, search2, fromIndex) {
        var subjectString = coerceToString(subject);
        return subjectString.lastIndexOf(search2, fromIndex);
      }
      function search(subject, pattern, fromIndex) {
        var subjectString = coerceToString(subject);
        var fromIndexNumber = isNil(fromIndex) ? 0 : clipNumber(toInteger(fromIndex), 0, subjectString.length);
        var matchIndex = subjectString.substr(fromIndexNumber).search(pattern);
        if (matchIndex !== -1 && !isNaN(fromIndexNumber)) {
          matchIndex += fromIndexNumber;
        }
        return matchIndex;
      }
      function insert(subject, toInsert, position) {
        var subjectString = coerceToString(subject);
        var toInsertString = coerceToString(toInsert);
        var positionNumber = coerceToNumber(position);
        if (positionNumber < 0 || positionNumber > subjectString.length || toInsertString === "") {
          return subjectString;
        }
        return subjectString.slice(0, positionNumber) + toInsertString + subjectString.slice(positionNumber);
      }
      var diacritics = {
        "3": "\u039E\u03BE",
        "8": "\u0398\u03B8",
        A: "A\xC0\xC1\xC2\xC3\xC4\xC5\u0100\u0102\u0104\u01CD\u01DE\u01E0\u01FA\u0200\u0202\u0226\u023A\u0386\u0391\u0410",
        B: "B\u0181\u0182\u0243\u0392\u0411",
        C: "C\xC7\u0106\u0108\u010A\u010C\u0187\u023B\u0426",
        D: "D\u010E\u0110\u0189\u018A\u018B\xD0\u0394\u0414",
        E: "E\xC8\xC9\xCA\xCB\u0112\u0114\u0116\u0118\u011A\u018E\u0190\u0204\u0206\u0228\u0388\u0395\u0415\u042D",
        F: "F\u0191\u03A6\u0424",
        G: "G\u011C\u011E\u0120\u0122\u0193\u01E4\u01E6\u01F4\u0393\u0413\u0490",
        H: "H\u0124\u0126\u021E\u0389\u0397\u0425",
        I: "I\xCC\xCD\xCE\xCF\u0128\u012A\u012C\u012E\u0130\u0197\u01CF\u0208\u020A\u038A\u0399\u03AA\u0406\u0418",
        J: "J\u0134\u0248\u0419",
        K: "K\u0136\u0198\u01E8\u039A\u041A",
        L: "L\u0139\u013B\u013D\u013F\u0141\u023D\u039B\u041B",
        M: "M\u019C\u039C\u041C",
        N: "N\xD1\u0143\u0145\u0147\u019D\u01F8\u0220\u039D\u041D",
        O: "O\xD2\xD3\xD4\xD5\xD6\xD8\u014C\u014E\u0150\u0186\u019F\u01A0\u01D1\u01EA\u01EC\u01FE\u020C\u020E\u022A\u022C\u022E\u0230\u038C\u039F\u041E",
        P: "P\u01A4\u03A0\u041F",
        Q: "Q\u024A",
        R: "R\u0154\u0156\u0158\u0210\u0212\u024C\u03A1\u0420",
        S: "S\u015A\u015C\u015E\u0160\u0218\u03A3\u0421",
        T: "T\u0162\u0164\u0166\u01AC\u01AE\u021A\u023E\u03A4\u0422",
        U: "U\xD9\xDA\xDB\xDC\u0168\u016A\u016C\u016E\u0170\u0172\u01AF\u01D3\u01D5\u01D7\u01D9\u01DB\u0214\u0216\u0244\u0423\u042A",
        V: "V\u01B2\u0245\u0412",
        W: "W\u0174\u038F\u03A9",
        X: "X\u03A7",
        Y: "Y\xDD\u0176\u0178\u01B3\u0232\u024E\u038E\u03A5\u03AB\u042B",
        Z: "Z\u0179\u017B\u017D\u01B5\u0224\u0396\u0417",
        a: "a\xE0\xE1\xE2\xE3\xE4\xE5\u0101\u0103\u0105\u01CE\u01DF\u01E1\u01FB\u0201\u0203\u0227\u0250\u03AC\u03B1\u0430",
        b: "b\u0180\u0183\u0253\u03B2\u0431",
        c: "c\xE7\u0107\u0109\u010B\u010D\u0188\u023C\u0446",
        d: "d\u010F\u0111\u018C\u0256\u0257\xF0\u03B4\u0434",
        e: "e\xE8\xE9\xEA\xEB\u0113\u0115\u0117\u0119\u011B\u01DD\u0205\u0207\u0229\u0247\u025B\u03AD\u03B5\u0435\u044D",
        f: "f\u0192\u03C6\u0444",
        g: "g\u011D\u011F\u0121\u0123\u01E5\u01E7\u01F5\u0260\u03B3\u0433\u0491",
        h: "h\u0125\u0127\u021F\u0265\u03AE\u03B7\u0445",
        i: "i\xEC\xED\xEE\xEF\u0129\u012B\u012D\u012F\u0131\u01D0\u0209\u020B\u0268\u0390\u03AF\u03B9\u03CA\u0438\u0456",
        j: "j\u0135\u01F0\u0249\u0439",
        k: "k\u0137\u0199\u01E9\u03BA\u043A",
        l: "l\u013A\u013C\u013E\u0140\u0142\u017F\u019A\u026B\u03BB\u043B",
        m: "m\u026F\u0271\u03BC\u043C",
        n: "n\xF1\u0144\u0146\u0148\u0149\u019E\u01F9\u0272\u03BD\u043D",
        o: "o\xF2\xF3\xF4\xF5\xF6\xF8\u014D\u014F\u0151\u01A1\u01D2\u01EB\u01ED\u01FF\u020D\u020F\u022B\u022D\u022F\u0231\u0254\u0275\u03BF\u03CC\u043E",
        p: "p\u01A5\u03C0\u043F",
        q: "q\u024B",
        r: "r\u0155\u0157\u0159\u0211\u0213\u024D\u027D\u03C1\u0440",
        s: "s\xDF\u015B\u015D\u015F\u0161\u0219\u023F\u03C2\u03C3\u0441",
        t: "t\u0163\u0165\u0167\u01AD\u021B\u0288\u03C4\u0442",
        u: "u\xF9\xFA\xFB\xFC\u0169\u016B\u016D\u016F\u0171\u0173\u01B0\u01D4\u01D6\u01D8\u01DA\u01DC\u0215\u0217\u0289\u0443\u044A",
        v: "v\u028B\u028C\u0432",
        w: "w\u0175\u03C9\u03CE",
        x: "x\u03C7",
        y: "y\xFD\xFF\u0177\u01B4\u0233\u024F\u03B0\u03C5\u03CB\u03CD\u044B",
        z: "z\u017A\u017C\u017E\u01B6\u0225\u0240\u03B6\u0437",
        OE: "\x8C\u0152",
        oe: "\x9C\u0153",
        AE: "\xC6\u01E2\u01FC",
        ae: "\xE6\u01E3\u01FD",
        hv: "\u0195",
        OI: "\u01A2",
        oi: "\u01A3",
        DZ: "\u01C4\u01F1",
        Dz: "\u01C5\u01F2",
        dz: "\u01C6\u01F3",
        LJ: "\u01C7",
        Lj: "\u01C8",
        lj: "\u01C9",
        NJ: "\u01CA",
        Nj: "\u01CB",
        nj: "\u01CC",
        OU: "\u0222",
        ou: "\u0223",
        TH: "\xDE",
        th: "\xFE",
        PS: "\u03A8",
        ps: "\u03C8",
        Yo: "\u0401",
        Ye: "\u0404",
        Yi: "\u0407",
        Zh: "\u0416",
        Ch: "\u0427",
        Sh: "\u0428\u0429",
        "": "\u042A\u042C\u044C",
        Yu: "\u042E",
        Ya: "\u042F",
        zh: "\u0436",
        ch: "\u0447",
        sh: "\u0448\u0449",
        yu: "\u044E",
        ya: "\u044F",
        yo: "\u0451",
        ye: "\u0454",
        yi: "\u0457"
      };
      var diacriticsMap = null;
      function getDiacriticsMap() {
        if (diacriticsMap !== null) {
          return diacriticsMap;
        }
        diacriticsMap = {};
        Object.keys(diacritics).forEach(function(key) {
          var characters2 = diacritics[key];
          for (var index = 0; index < characters2.length; index++) {
            var character = characters2[index];
            diacriticsMap[character] = key;
          }
        });
        return diacriticsMap;
      }
      function getLatinCharacter(character) {
        var characterWithoutDiacritic = getDiacriticsMap()[character];
        return characterWithoutDiacritic ? characterWithoutDiacritic : character;
      }
      function removeCombiningMarks(character, cleanCharacter) {
        return cleanCharacter;
      }
      function latinise(subject) {
        var subjectString = coerceToString(subject);
        if (subjectString === "") {
          return "";
        }
        return subjectString.replace(REGEXP_NON_LATIN, getLatinCharacter).replace(REGEXP_COMBINING_MARKS, removeCombiningMarks);
      }
      function pad(subject, length, pad2) {
        var subjectString = coerceToString(subject);
        var lengthInt = isNil(length) ? 0 : clipNumber(toInteger(length), 0, MAX_SAFE_INTEGER);
        var padString = coerceToString(pad2, " ");
        if (lengthInt <= subjectString.length) {
          return subjectString;
        }
        var paddingLength = lengthInt - subjectString.length;
        var paddingSideLength = toInteger(paddingLength / 2);
        var paddingSideRemainingLength = paddingLength % 2;
        return buildPadding(padString, paddingSideLength) + subjectString + buildPadding(padString, paddingSideLength + paddingSideRemainingLength);
      }
      function replace(subject, search2, replace2) {
        var subjectString = coerceToString(subject);
        return subjectString.replace(search2, replace2);
      }
      function replaceAll(subject, search2, replace2) {
        var subjectString = coerceToString(subject);
        if (search2 instanceof RegExp) {
          if (search2.flags.indexOf("g") === -1) {
            throw new TypeError("search argument is a non-global regular expression");
          }
          return subjectString.replace(search2, replace2);
        }
        var searchString = coerceToString(search2);
        var isFunctionalReplace = typeof replace2 === "function";
        if (!isFunctionalReplace) {
          replace2 = coerceToString(replace2);
        }
        var searchLength = searchString.length;
        if (searchLength === 0) {
          return replaceAll(subject, /(?:)/g, replace2);
        }
        var advanceBy = searchLength > 1 ? searchLength : 1;
        var matchPositions = [];
        var position = subjectString.indexOf(searchString, 0);
        while (position !== -1) {
          matchPositions.push(position);
          position = subjectString.indexOf(searchString, position + advanceBy);
        }
        var endOfLastMatch = 0;
        var result = "";
        for (var i = 0; i < matchPositions.length; i++) {
          var _position = matchPositions[i];
          var replacement = replace2;
          if (isFunctionalReplace) {
            replacement = coerceToString(replace2.call(void 0, searchString, _position, subjectString));
          }
          result += subjectString.slice(endOfLastMatch, _position) + replacement;
          endOfLastMatch = _position + searchLength;
        }
        if (endOfLastMatch < subjectString.length) {
          result += subjectString.slice(endOfLastMatch);
        }
        return result;
      }
      function reverse(subject) {
        var subjectString = coerceToString(subject);
        return subjectString.split("").reverse().join("");
      }
      function reverseGrapheme(subject) {
        var subjectString = coerceToString(subject);
        subjectString = subjectString.replace(REGEXP_COMBINING_MARKS, function($0, $1, $2) {
          return reverseGrapheme($2) + $1;
        }).replace(REGEXP_SURROGATE_PAIRS, "$2$1");
        var reversedString = "";
        var index = subjectString.length;
        while (index--) {
          reversedString += subjectString.charAt(index);
        }
        return reversedString;
      }
      function slugify(subject) {
        var subjectString = coerceToString(subject);
        if (subjectString === "") {
          return "";
        }
        var cleanSubjectString = latinise(subjectString).replace(REGEXP_NON_LATIN, "-");
        return kebabCase(cleanSubjectString);
      }
      function splice(subject, start, deleteCount, toAdd) {
        var subjectString = coerceToString(subject);
        var toAddString = coerceToString(toAdd);
        var startPosition = coerceToNumber(start);
        if (startPosition < 0) {
          startPosition = subjectString.length + startPosition;
          if (startPosition < 0) {
            startPosition = 0;
          }
        } else if (startPosition > subjectString.length) {
          startPosition = subjectString.length;
        }
        var deleteCountNumber = coerceToNumber(deleteCount, subjectString.length - startPosition);
        if (deleteCountNumber < 0) {
          deleteCountNumber = 0;
        }
        return subjectString.slice(0, startPosition) + toAddString + subjectString.slice(startPosition + deleteCountNumber);
      }
      function tr(subject, from, to) {
        var subjectString = coerceToString(subject);
        var keys;
        var values;
        if (isString(from) && isString(to)) {
          keys = from.split("");
          values = to.split("");
        } else {
          var _extractKeysAndValues = extractKeysAndValues(nilDefault(from, {}));
          var _extractKeysAndValues2 = _slicedToArray(_extractKeysAndValues, 2);
          keys = _extractKeysAndValues2[0];
          values = _extractKeysAndValues2[1];
        }
        var keysLength = keys.length;
        if (keysLength === 0) {
          return subjectString;
        }
        var result = "";
        var valuesLength = values.length;
        for (var index = 0; index < subjectString.length; index++) {
          var isMatch = false;
          var matchValue = void 0;
          for (var keyIndex = 0; keyIndex < keysLength && keyIndex < valuesLength; keyIndex++) {
            var key = keys[keyIndex];
            if (subjectString.substr(index, key.length) === key) {
              isMatch = true;
              matchValue = values[keyIndex];
              index = index + key.length - 1;
              break;
            }
          }
          result += isMatch ? matchValue : subjectString[index];
        }
        return result;
      }
      function extractKeysAndValues(object) {
        var keys = Object.keys(object);
        var values = keys.sort(sortStringByLength).map(function(key) {
          return object[key];
        });
        return [keys, values];
      }
      function sortStringByLength(str1, str2) {
        if (str1.length === str2.length) {
          return 0;
        }
        return str1.length < str2.length ? 1 : -1;
      }
      function includes(subject, search2, position) {
        var subjectString = coerceToString(subject);
        var searchString = toString(search2);
        if (searchString === null) {
          return false;
        }
        if (searchString === "") {
          return true;
        }
        position = isNil(position) ? 0 : clipNumber(toInteger(position), 0, subjectString.length);
        return subjectString.indexOf(searchString, position) !== -1;
      }
      var reduce$1 = Array.prototype.reduce;
      function trimLeft(subject, whitespace2) {
        var subjectString = coerceToString(subject);
        if (whitespace2 === "" || subjectString === "") {
          return subjectString;
        }
        var whitespaceString = toString(whitespace2);
        if (isNil(whitespaceString)) {
          return subjectString.replace(REGEXP_TRIM_LEFT, "");
        }
        var matchWhitespace = true;
        return reduce$1.call(subjectString, function(trimmed, character) {
          if (matchWhitespace && includes(whitespaceString, character)) {
            return trimmed;
          }
          matchWhitespace = false;
          return trimmed + character;
        }, "");
      }
      var reduceRight = Array.prototype.reduceRight;
      function trimRight(subject, whitespace2) {
        var subjectString = coerceToString(subject);
        if (whitespace2 === "" || subjectString === "") {
          return subjectString;
        }
        var whitespaceString = toString(whitespace2);
        if (isNil(whitespaceString)) {
          return subjectString.replace(REGEXP_TRIM_RIGHT, "");
        }
        var matchWhitespace = true;
        return reduceRight.call(subjectString, function(trimmed, character) {
          if (matchWhitespace && includes(whitespaceString, character)) {
            return trimmed;
          }
          matchWhitespace = false;
          return character + trimmed;
        }, "");
      }
      function trim(subject, whitespace2) {
        var subjectString = coerceToString(subject);
        if (whitespace2 === "" || subjectString === "") {
          return subjectString;
        }
        var whitespaceString = toString(whitespace2);
        if (isNil(whitespaceString)) {
          return subjectString.trim();
        }
        return trimRight(trimLeft(subjectString, whitespaceString), whitespaceString);
      }
      var OPTION_WIDTH = "width";
      var OPTION_NEW_LINE = "newLine";
      var OPTION_INDENT = "indent";
      var OPTION_CUT = "cut";
      function wordWrap(subject) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var subjectString = coerceToString(subject);
        var _determineOptions = determineOptions(options), width = _determineOptions.width, newLine = _determineOptions.newLine, indent = _determineOptions.indent, cut = _determineOptions.cut;
        if (subjectString === "" || width <= 0) {
          return indent;
        }
        var subjectLength = subjectString.length;
        var substring2 = subjectString.substring.bind(subjectString);
        var offset = 0;
        var wrappedLine = "";
        while (subjectLength - offset > width) {
          if (subjectString[offset] === " ") {
            offset++;
            continue;
          }
          var spaceToWrapAt = subjectString.lastIndexOf(" ", width + offset);
          if (spaceToWrapAt >= offset) {
            wrappedLine += indent + substring2(offset, spaceToWrapAt) + newLine;
            offset = spaceToWrapAt + 1;
          } else {
            if (cut) {
              wrappedLine += indent + substring2(offset, width + offset) + newLine;
              offset += width;
            } else {
              spaceToWrapAt = subjectString.indexOf(" ", width + offset);
              if (spaceToWrapAt >= 0) {
                wrappedLine += indent + substring2(offset, spaceToWrapAt) + newLine;
                offset = spaceToWrapAt + 1;
              } else {
                wrappedLine += indent + substring2(offset);
                offset = subjectLength;
              }
            }
          }
        }
        if (offset < subjectLength) {
          wrappedLine += indent + substring2(offset);
        }
        return wrappedLine;
      }
      function determineOptions(options) {
        return {
          width: coerceToNumber(options[OPTION_WIDTH], 75),
          newLine: coerceToString(options[OPTION_NEW_LINE], "\n"),
          indent: coerceToString(options[OPTION_INDENT], ""),
          cut: coerceToBoolean(options[OPTION_CUT], false)
        };
      }
      function endsWith(subject, end, position) {
        if (isNil(end)) {
          return false;
        }
        var subjectString = coerceToString(subject);
        var endString = coerceToString(end);
        if (endString === "") {
          return true;
        }
        position = isNil(position) ? subjectString.length : clipNumber(toInteger(position), 0, subjectString.length);
        position -= endString.length;
        var lastIndex = subjectString.indexOf(endString, position);
        return lastIndex !== -1 && lastIndex === position;
      }
      function isAlpha(subject) {
        var subjectString = coerceToString(subject);
        return REGEXP_ALPHA.test(subjectString);
      }
      function isAlphaDigit(subject) {
        var subjectString = coerceToString(subject);
        return REGEXP_ALPHA_DIGIT.test(subjectString);
      }
      function isBlank(subject) {
        var subjectString = coerceToString(subject);
        return subjectString.trim().length === 0;
      }
      function isDigit(subject) {
        var subjectString = coerceToString(subject);
        return REGEXP_DIGIT.test(subjectString);
      }
      function isEmpty(subject) {
        var subjectString = coerceToString(subject);
        return subjectString.length === 0;
      }
      function isLowerCase(subject) {
        var valueString = coerceToString(subject);
        return isAlpha(valueString) && valueString.toLowerCase() === valueString;
      }
      function isNumeric(subject) {
        var valueNumeric = typeof subject === "object" && !isNil(subject) ? Number(subject) : subject;
        return (typeof valueNumeric === "number" || typeof valueNumeric === "string") && !isNaN(valueNumeric - parseFloat(valueNumeric));
      }
      function isUpperCase(subject) {
        var subjectString = coerceToString(subject);
        return isAlpha(subjectString) && subjectString.toUpperCase() === subjectString;
      }
      function matches(subject, pattern, flags) {
        var subjectString = coerceToString(subject);
        var flagsString = coerceToString(flags);
        var patternString;
        if (!(pattern instanceof RegExp)) {
          patternString = toString(pattern);
          if (patternString === null) {
            return false;
          }
          pattern = new RegExp(patternString, flagsString);
        }
        return pattern.test(subjectString);
      }
      function startsWith(subject, start, position) {
        var subjectString = coerceToString(subject);
        var startString = toString(start);
        if (startString === null) {
          return false;
        }
        if (startString === "") {
          return true;
        }
        position = isNil(position) ? 0 : clipNumber(toInteger(position), 0, subjectString.length);
        return subjectString.substr(position, startString.length) === startString;
      }
      function chars(subject) {
        var subjectString = coerceToString(subject);
        return subjectString.split("");
      }
      function codePoints(subject) {
        var subjectString = coerceToString(subject);
        var subjectStringLength = subjectString.length;
        var codePointArray = [];
        var index = 0;
        var codePointNumber;
        while (index < subjectStringLength) {
          codePointNumber = codePointAt(subjectString, index);
          codePointArray.push(codePointNumber);
          index += codePointNumber > 65535 ? 2 : 1;
        }
        return codePointArray;
      }
      function graphemes(subject) {
        var subjectString = coerceToString(subject);
        return nilDefault(subjectString.match(REGEXP_UNICODE_CHARACTER), []);
      }
      function split(subject, separator, limit) {
        var subjectString = coerceToString(subject);
        return subjectString.split(separator, limit);
      }
      var BYRE_ORDER_MARK = "\uFEFF";
      function trim$1(subject) {
        var subjectString = coerceToString(subject);
        if (subjectString === "") {
          return "";
        }
        if (subjectString[0] === BYRE_ORDER_MARK) {
          return subjectString.substring(1);
        }
        return subjectString;
      }
      function hasSubstringAtIndex(subject, substring2, index) {
        var lookBehind = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
        var indexOffset = 0;
        if (lookBehind) {
          indexOffset = -substring2.length + 1;
        }
        var extractedSubstring = subject.substr(index + indexOffset, substring2.length);
        return extractedSubstring.toLowerCase() === substring2;
      }
      function parseTagList(tags) {
        var tagsList = [];
        var match2;
        while ((match2 = REGEXP_TAG_LIST.exec(tags)) !== null) {
          tagsList.push(match2[1]);
        }
        return tagsList;
      }
      var STATE_START_TAG = 0;
      var STATE_NON_WHITESPACE = 1;
      var STATE_DONE = 2;
      function parseTagName(tagContent) {
        var state = STATE_START_TAG;
        var tagName = "";
        var index = 0;
        while (state !== STATE_DONE) {
          var char = tagContent[index++].toLowerCase();
          switch (char) {
            case "<":
              break;
            case ">":
              state = STATE_DONE;
              break;
            default:
              if (REGEXP_WHITESPACE.test(char)) {
                if (state === STATE_NON_WHITESPACE) {
                  state = STATE_DONE;
                }
              } else {
                if (state === STATE_START_TAG) {
                  state = STATE_NON_WHITESPACE;
                }
                if (char !== "/") {
                  tagName += char;
                }
              }
              break;
          }
        }
        return tagName;
      }
      var STATE_OUTPUT = 0;
      var STATE_HTML = 1;
      var STATE_EXCLAMATION = 2;
      var STATE_COMMENT = 3;
      function trim$2(subject, allowableTags, replacement) {
        subject = coerceToString(subject);
        if (subject === "") {
          return "";
        }
        if (!Array.isArray(allowableTags)) {
          var allowableTagsString = coerceToString(allowableTags);
          allowableTags = allowableTagsString === "" ? [] : parseTagList(allowableTagsString);
        }
        var replacementString = coerceToString(replacement);
        var length = subject.length;
        var hasAllowableTags = allowableTags.length > 0;
        var hasSubstring = hasSubstringAtIndex.bind(null, subject);
        var state = STATE_OUTPUT;
        var depth = 0;
        var output = "";
        var tagContent = "";
        var quote = null;
        for (var index = 0; index < length; index++) {
          var char = subject[index];
          var advance = false;
          switch (char) {
            case "<":
              if (quote) {
                break;
              }
              if (hasSubstring("< ", index, false)) {
                advance = true;
                break;
              }
              if (state === STATE_OUTPUT) {
                advance = true;
                state = STATE_HTML;
                break;
              }
              if (state === STATE_HTML) {
                depth++;
                break;
              }
              advance = true;
              break;
            case "!":
              if (state === STATE_HTML && hasSubstring("<!", index)) {
                state = STATE_EXCLAMATION;
                break;
              }
              advance = true;
              break;
            case "-":
              if (state === STATE_EXCLAMATION && hasSubstring("!--", index)) {
                state = STATE_COMMENT;
                break;
              }
              advance = true;
              break;
            case '"':
            case "'":
              if (state === STATE_HTML) {
                if (quote === char) {
                  quote = null;
                } else if (!quote) {
                  quote = char;
                }
              }
              advance = true;
              break;
            case "E":
            case "e":
              if (state === STATE_EXCLAMATION && hasSubstring("doctype", index)) {
                state = STATE_HTML;
                break;
              }
              advance = true;
              break;
            case ">":
              if (depth > 0) {
                depth--;
                break;
              }
              if (quote) {
                break;
              }
              if (state === STATE_HTML) {
                quote = null;
                state = STATE_OUTPUT;
                if (hasAllowableTags) {
                  tagContent += ">";
                  var tagName = parseTagName(tagContent);
                  if (allowableTags.indexOf(tagName.toLowerCase()) !== -1) {
                    output += tagContent;
                  } else {
                    output += replacementString;
                  }
                  tagContent = "";
                } else {
                  output += replacementString;
                }
                break;
              }
              if (state === STATE_EXCLAMATION || state === STATE_COMMENT && hasSubstring("-->", index)) {
                quote = null;
                state = STATE_OUTPUT;
                tagContent = "";
                break;
              }
              advance = true;
              break;
            default:
              advance = true;
          }
          if (advance) {
            switch (state) {
              case STATE_OUTPUT:
                output += char;
                break;
              case STATE_HTML:
                if (hasAllowableTags) {
                  tagContent += char;
                }
                break;
            }
          }
        }
        return output;
      }
      var globalObject = null;
      function getGlobalObject() {
        if (globalObject !== null) {
          return globalObject;
        }
        if (typeof global === "object" && global.Object === Object) {
          globalObject = global;
        } else if (typeof self === "object" && self.Object === Object) {
          globalObject = self;
        } else {
          globalObject = new Function("return this")();
        }
        return globalObject;
      }
      var globalObject$1 = getGlobalObject();
      var previousV = globalObject$1.v;
      function noConflict() {
        if (this === globalObject$1.v) {
          globalObject$1.v = previousV;
        }
        return this;
      }
      var version = "1.4.0";
      var functions = {
        camelCase: camelCase2,
        capitalize,
        decapitalize,
        kebabCase,
        lowerCase,
        snakeCase: snakeCase2,
        swapCase,
        titleCase,
        upperCase,
        count,
        countGraphemes: countGrapheme,
        countSubstrings,
        countWhere,
        countWords,
        escapeHtml,
        escapeRegExp,
        unescapeHtml,
        sprintf,
        vprintf,
        indexOf,
        lastIndexOf,
        search,
        charAt,
        codePointAt,
        first,
        graphemeAt,
        last,
        prune,
        slice,
        substr,
        substring,
        truncate,
        insert,
        latinise,
        pad,
        padLeft,
        padRight,
        repeat,
        replace,
        replaceAll,
        reverse,
        reverseGrapheme,
        slugify,
        splice,
        tr,
        trim,
        trimLeft,
        trimRight,
        wordWrap,
        endsWith,
        includes,
        isAlpha,
        isAlphaDigit,
        isBlank,
        isDigit,
        isEmpty,
        isLowerCase,
        isNumeric,
        isString,
        isUpperCase,
        matches,
        startsWith,
        chars,
        codePoints,
        graphemes,
        split,
        words,
        stripBom: trim$1,
        stripTags: trim$2,
        noConflict,
        version
      };
      function ChainWrapper(subject, explicitChain) {
        this._wrappedValue = subject;
        this._explicitChain = explicitChain;
      }
      ChainWrapper.prototype.value = function() {
        return this._wrappedValue;
      };
      ChainWrapper.prototype.valueOf = function() {
        return this.value();
      };
      ChainWrapper.prototype.toJSON = function() {
        return this.value();
      };
      ChainWrapper.prototype.toString = function() {
        return String(this.value());
      };
      ChainWrapper.prototype.chain = function() {
        return new ChainWrapper(this._wrappedValue, true);
      };
      ChainWrapper.prototype.thru = function(changer) {
        if (typeof changer === "function") {
          return new ChainWrapper(changer(this._wrappedValue), this._explicitChain);
        }
        return this;
      };
      ChainWrapper.prototype._explicitChain = true;
      function makeFunctionChainable(functionInstance) {
        return function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          var result = functionInstance.apply(void 0, [this._wrappedValue].concat(args));
          if (this._explicitChain || typeof result === "string") {
            return new ChainWrapper(result, this._explicitChain);
          } else {
            return result;
          }
        };
      }
      Object.keys(functions).forEach(function(name) {
        ChainWrapper.prototype[name] = makeFunctionChainable(functions[name]);
      });
      function chain(subject) {
        return new ChainWrapper(subject, true);
      }
      function Voca(subject) {
        return new ChainWrapper(subject, false);
      }
      _extends(Voca, functions, {
        chain
      });
      return Voca;
    });
  }
});

// node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/string-formatter.js
var require_string_formatter = __commonJS({
  "node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/string-formatter.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.webEOL = exports2.unixEOL = void 0;
    exports2.upperCaseSnakeCase = upperCaseSnakeCase;
    exports2.camelCase = camelCase2;
    exports2.titleFormat = titleFormat;
    exports2.pascalCase = pascalCase;
    exports2.kebabCase = kebabCase;
    exports2.formatJson = formatJson;
    var voca_1 = __importDefault(require_voca());
    exports2.unixEOL = "\n";
    exports2.webEOL = "\r\n";
    function upperCaseSnakeCase(str) {
      return voca_1.default.upperCase(voca_1.default.snakeCase(str));
    }
    function camelCase2(str) {
      return voca_1.default.camelCase(str);
    }
    function titleFormat(str) {
      return voca_1.default.titleCase(voca_1.default.words(str).join(" "));
    }
    function pascalCase(str) {
      return voca_1.default.words(str).map((word) => voca_1.default.capitalize(word)).join("");
    }
    function kebabCase(str) {
      return voca_1.default.kebabCase(str);
    }
    function formatJson(json2) {
      return JSON.stringify(json2, null, 2) + exports2.unixEOL;
    }
  }
});

// node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/string.js
var require_string = __commonJS({
  "node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/string.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encodeBase64 = encodeBase64;
    exports2.trimLeft = trimLeft;
    exports2.trimRight = trimRight;
    exports2.trim = trim;
    exports2.removeFileExtension = removeFileExtension;
    var string_formatter_1 = require_string_formatter();
    function encodeBase64(str) {
      return Buffer.from(str).toString("base64");
    }
    function trimLeft(string) {
      const subStrings = string.split(string_formatter_1.unixEOL);
      const leftTrimmed = subStrings[0].trimStart();
      if (!leftTrimmed) {
        subStrings.shift();
      } else {
        subStrings[0] = leftTrimmed;
      }
      return subStrings.join(string_formatter_1.unixEOL);
    }
    function trimRight(string) {
      const subStrings = string.split(string_formatter_1.unixEOL);
      const rightTrimmed = subStrings[subStrings.length - 1].trimEnd();
      if (!rightTrimmed) {
        subStrings.pop();
      } else {
        subStrings[subStrings.length - 1] = rightTrimmed;
      }
      return subStrings.join(string_formatter_1.unixEOL);
    }
    function trim(string) {
      return trimRight(trimLeft(string));
    }
    function removeFileExtension(fileName) {
      return fileName.includes(".") ? fileName.split(".").slice(0, -1).join(".") : fileName;
    }
  }
});

// node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/code-block.js
var require_code_block = __commonJS({
  "node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/code-block.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.codeBlock = codeBlock;
    var string_formatter_1 = require_string_formatter();
    var array_1 = require_array();
    var string_1 = require_string();
    function codeBlock(strings, ...args) {
      const pre = strings.slice(0, -1).map((string) => {
        const trimmed = trimRightNewlines(string);
        return trimmed.length === string.length ? string : trimmed + string_formatter_1.unixEOL;
      });
      pre.push(strings[strings.length - 1]);
      const indents = strings.slice(0, -1).map((s) => {
        const indentation = s.split(string_formatter_1.unixEOL).pop();
        return !indentation.trim() ? indentation : "";
      });
      const post = args.map((arg, i) => ("" + arg).split(string_formatter_1.unixEOL).map((subArg) => indents[i] + subArg).join(string_formatter_1.unixEOL));
      const zipped = (0, array_1.zip)(pre, post);
      return (0, string_1.trim)(zipped.join(""));
    }
    function trimRightNewlines(string) {
      let subStrings = string.split(string_formatter_1.unixEOL);
      if (!subStrings[subStrings.length - 1].trim()) {
        subStrings = subStrings.slice(0, -1);
      }
      return subStrings.join(string_formatter_1.unixEOL);
    }
  }
});

// node_modules/logform/format.js
var require_format = __commonJS({
  "node_modules/logform/format.js"(exports2, module2) {
    "use strict";
    var InvalidFormatError = class _InvalidFormatError extends Error {
      constructor(formatFn) {
        super(`Format functions must be synchronous taking a two arguments: (info, opts)
Found: ${formatFn.toString().split("\n")[0]}
`);
        Error.captureStackTrace(this, _InvalidFormatError);
      }
    };
    module2.exports = (formatFn) => {
      if (formatFn.length > 2) {
        throw new InvalidFormatError(formatFn);
      }
      function Format(options = {}) {
        this.options = options;
      }
      Format.prototype.transform = formatFn;
      function createFormatWrap(opts) {
        return new Format(opts);
      }
      createFormatWrap.Format = Format;
      return createFormatWrap;
    };
  }
});

// node_modules/@colors/colors/lib/styles.js
var require_styles = __commonJS({
  "node_modules/@colors/colors/lib/styles.js"(exports2, module2) {
    var styles2 = {};
    module2["exports"] = styles2;
    var codes = {
      reset: [0, 0],
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29],
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      gray: [90, 39],
      grey: [90, 39],
      brightRed: [91, 39],
      brightGreen: [92, 39],
      brightYellow: [93, 39],
      brightBlue: [94, 39],
      brightMagenta: [95, 39],
      brightCyan: [96, 39],
      brightWhite: [97, 39],
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
      bgGray: [100, 49],
      bgGrey: [100, 49],
      bgBrightRed: [101, 49],
      bgBrightGreen: [102, 49],
      bgBrightYellow: [103, 49],
      bgBrightBlue: [104, 49],
      bgBrightMagenta: [105, 49],
      bgBrightCyan: [106, 49],
      bgBrightWhite: [107, 49],
      // legacy styles for colors pre v1.0.0
      blackBG: [40, 49],
      redBG: [41, 49],
      greenBG: [42, 49],
      yellowBG: [43, 49],
      blueBG: [44, 49],
      magentaBG: [45, 49],
      cyanBG: [46, 49],
      whiteBG: [47, 49]
    };
    Object.keys(codes).forEach(function(key) {
      var val = codes[key];
      var style = styles2[key] = [];
      style.open = "\x1B[" + val[0] + "m";
      style.close = "\x1B[" + val[1] + "m";
    });
  }
});

// node_modules/@colors/colors/lib/system/has-flag.js
var require_has_flag = __commonJS({
  "node_modules/@colors/colors/lib/system/has-flag.js"(exports2, module2) {
    "use strict";
    module2.exports = function(flag, argv) {
      argv = argv || process.argv || [];
      var terminatorPos = argv.indexOf("--");
      var prefix = /^-{1,2}/.test(flag) ? "" : "--";
      var pos = argv.indexOf(prefix + flag);
      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };
  }
});

// node_modules/@colors/colors/lib/system/supports-colors.js
var require_supports_colors = __commonJS({
  "node_modules/@colors/colors/lib/system/supports-colors.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var hasFlag = require_has_flag();
    var env = process.env;
    var forceColor = void 0;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
      forceColor = false;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = true;
    }
    if ("FORCE_COLOR" in env) {
      forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(stream) {
      if (forceColor === false) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (stream && !stream.isTTY && forceColor !== true) {
        return 0;
      }
      var min = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        var osRelease = os.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some(function(sign) {
          return sign in env;
        }) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if ("TERM_PROGRAM" in env) {
        var version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Hyper":
            return 3;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      if (env.TERM === "dumb") {
        return min;
      }
      return min;
    }
    function getSupportLevel(stream) {
      var level = supportsColor(stream);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});

// node_modules/@colors/colors/lib/custom/trap.js
var require_trap = __commonJS({
  "node_modules/@colors/colors/lib/custom/trap.js"(exports2, module2) {
    module2["exports"] = function runTheTrap(text, options) {
      var result = "";
      text = text || "Run the trap, drop the bass";
      text = text.split("");
      var trap = {
        a: ["@", "\u0104", "\u023A", "\u0245", "\u0394", "\u039B", "\u0414"],
        b: ["\xDF", "\u0181", "\u0243", "\u026E", "\u03B2", "\u0E3F"],
        c: ["\xA9", "\u023B", "\u03FE"],
        d: ["\xD0", "\u018A", "\u0500", "\u0501", "\u0502", "\u0503"],
        e: [
          "\xCB",
          "\u0115",
          "\u018E",
          "\u0258",
          "\u03A3",
          "\u03BE",
          "\u04BC",
          "\u0A6C"
        ],
        f: ["\u04FA"],
        g: ["\u0262"],
        h: ["\u0126", "\u0195", "\u04A2", "\u04BA", "\u04C7", "\u050A"],
        i: ["\u0F0F"],
        j: ["\u0134"],
        k: ["\u0138", "\u04A0", "\u04C3", "\u051E"],
        l: ["\u0139"],
        m: ["\u028D", "\u04CD", "\u04CE", "\u0520", "\u0521", "\u0D69"],
        n: ["\xD1", "\u014B", "\u019D", "\u0376", "\u03A0", "\u048A"],
        o: [
          "\xD8",
          "\xF5",
          "\xF8",
          "\u01FE",
          "\u0298",
          "\u047A",
          "\u05DD",
          "\u06DD",
          "\u0E4F"
        ],
        p: ["\u01F7", "\u048E"],
        q: ["\u09CD"],
        r: ["\xAE", "\u01A6", "\u0210", "\u024C", "\u0280", "\u042F"],
        s: ["\xA7", "\u03DE", "\u03DF", "\u03E8"],
        t: ["\u0141", "\u0166", "\u0373"],
        u: ["\u01B1", "\u054D"],
        v: ["\u05D8"],
        w: ["\u0428", "\u0460", "\u047C", "\u0D70"],
        x: ["\u04B2", "\u04FE", "\u04FC", "\u04FD"],
        y: ["\xA5", "\u04B0", "\u04CB"],
        z: ["\u01B5", "\u0240"]
      };
      text.forEach(function(c) {
        c = c.toLowerCase();
        var chars = trap[c] || [" "];
        var rand = Math.floor(Math.random() * chars.length);
        if (typeof trap[c] !== "undefined") {
          result += trap[c][rand];
        } else {
          result += c;
        }
      });
      return result;
    };
  }
});

// node_modules/@colors/colors/lib/custom/zalgo.js
var require_zalgo = __commonJS({
  "node_modules/@colors/colors/lib/custom/zalgo.js"(exports2, module2) {
    module2["exports"] = function zalgo(text, options) {
      text = text || "   he is here   ";
      var soul = {
        "up": [
          "\u030D",
          "\u030E",
          "\u0304",
          "\u0305",
          "\u033F",
          "\u0311",
          "\u0306",
          "\u0310",
          "\u0352",
          "\u0357",
          "\u0351",
          "\u0307",
          "\u0308",
          "\u030A",
          "\u0342",
          "\u0313",
          "\u0308",
          "\u034A",
          "\u034B",
          "\u034C",
          "\u0303",
          "\u0302",
          "\u030C",
          "\u0350",
          "\u0300",
          "\u0301",
          "\u030B",
          "\u030F",
          "\u0312",
          "\u0313",
          "\u0314",
          "\u033D",
          "\u0309",
          "\u0363",
          "\u0364",
          "\u0365",
          "\u0366",
          "\u0367",
          "\u0368",
          "\u0369",
          "\u036A",
          "\u036B",
          "\u036C",
          "\u036D",
          "\u036E",
          "\u036F",
          "\u033E",
          "\u035B",
          "\u0346",
          "\u031A"
        ],
        "down": [
          "\u0316",
          "\u0317",
          "\u0318",
          "\u0319",
          "\u031C",
          "\u031D",
          "\u031E",
          "\u031F",
          "\u0320",
          "\u0324",
          "\u0325",
          "\u0326",
          "\u0329",
          "\u032A",
          "\u032B",
          "\u032C",
          "\u032D",
          "\u032E",
          "\u032F",
          "\u0330",
          "\u0331",
          "\u0332",
          "\u0333",
          "\u0339",
          "\u033A",
          "\u033B",
          "\u033C",
          "\u0345",
          "\u0347",
          "\u0348",
          "\u0349",
          "\u034D",
          "\u034E",
          "\u0353",
          "\u0354",
          "\u0355",
          "\u0356",
          "\u0359",
          "\u035A",
          "\u0323"
        ],
        "mid": [
          "\u0315",
          "\u031B",
          "\u0300",
          "\u0301",
          "\u0358",
          "\u0321",
          "\u0322",
          "\u0327",
          "\u0328",
          "\u0334",
          "\u0335",
          "\u0336",
          "\u035C",
          "\u035D",
          "\u035E",
          "\u035F",
          "\u0360",
          "\u0362",
          "\u0338",
          "\u0337",
          "\u0361",
          " \u0489"
        ]
      };
      var all = [].concat(soul.up, soul.down, soul.mid);
      function randomNumber(range) {
        var r = Math.floor(Math.random() * range);
        return r;
      }
      function isChar(character) {
        var bool = false;
        all.filter(function(i) {
          bool = i === character;
        });
        return bool;
      }
      function heComes(text2, options2) {
        var result = "";
        var counts;
        var l;
        options2 = options2 || {};
        options2["up"] = typeof options2["up"] !== "undefined" ? options2["up"] : true;
        options2["mid"] = typeof options2["mid"] !== "undefined" ? options2["mid"] : true;
        options2["down"] = typeof options2["down"] !== "undefined" ? options2["down"] : true;
        options2["size"] = typeof options2["size"] !== "undefined" ? options2["size"] : "maxi";
        text2 = text2.split("");
        for (l in text2) {
          if (isChar(l)) {
            continue;
          }
          result = result + text2[l];
          counts = { "up": 0, "down": 0, "mid": 0 };
          switch (options2.size) {
            case "mini":
              counts.up = randomNumber(8);
              counts.mid = randomNumber(2);
              counts.down = randomNumber(8);
              break;
            case "maxi":
              counts.up = randomNumber(16) + 3;
              counts.mid = randomNumber(4) + 1;
              counts.down = randomNumber(64) + 3;
              break;
            default:
              counts.up = randomNumber(8) + 1;
              counts.mid = randomNumber(6) / 2;
              counts.down = randomNumber(8) + 1;
              break;
          }
          var arr2 = ["up", "mid", "down"];
          for (var d in arr2) {
            var index = arr2[d];
            for (var i = 0; i <= counts[index]; i++) {
              if (options2[index]) {
                result = result + soul[index][randomNumber(soul[index].length)];
              }
            }
          }
        }
        return result;
      }
      return heComes(text, options);
    };
  }
});

// node_modules/@colors/colors/lib/maps/america.js
var require_america = __commonJS({
  "node_modules/@colors/colors/lib/maps/america.js"(exports2, module2) {
    module2["exports"] = function(colors) {
      return function(letter, i, exploded) {
        if (letter === " ") return letter;
        switch (i % 3) {
          case 0:
            return colors.red(letter);
          case 1:
            return colors.white(letter);
          case 2:
            return colors.blue(letter);
        }
      };
    };
  }
});

// node_modules/@colors/colors/lib/maps/zebra.js
var require_zebra = __commonJS({
  "node_modules/@colors/colors/lib/maps/zebra.js"(exports2, module2) {
    module2["exports"] = function(colors) {
      return function(letter, i, exploded) {
        return i % 2 === 0 ? letter : colors.inverse(letter);
      };
    };
  }
});

// node_modules/@colors/colors/lib/maps/rainbow.js
var require_rainbow = __commonJS({
  "node_modules/@colors/colors/lib/maps/rainbow.js"(exports2, module2) {
    module2["exports"] = function(colors) {
      var rainbowColors = ["red", "yellow", "green", "blue", "magenta"];
      return function(letter, i, exploded) {
        if (letter === " ") {
          return letter;
        } else {
          return colors[rainbowColors[i++ % rainbowColors.length]](letter);
        }
      };
    };
  }
});

// node_modules/@colors/colors/lib/maps/random.js
var require_random = __commonJS({
  "node_modules/@colors/colors/lib/maps/random.js"(exports2, module2) {
    module2["exports"] = function(colors) {
      var available = [
        "underline",
        "inverse",
        "grey",
        "yellow",
        "red",
        "green",
        "blue",
        "white",
        "cyan",
        "magenta",
        "brightYellow",
        "brightRed",
        "brightGreen",
        "brightBlue",
        "brightWhite",
        "brightCyan",
        "brightMagenta"
      ];
      return function(letter, i, exploded) {
        return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 2))]](letter);
      };
    };
  }
});

// node_modules/@colors/colors/lib/colors.js
var require_colors = __commonJS({
  "node_modules/@colors/colors/lib/colors.js"(exports2, module2) {
    var colors = {};
    module2["exports"] = colors;
    colors.themes = {};
    var util = require("util");
    var ansiStyles = colors.styles = require_styles();
    var defineProps = Object.defineProperties;
    var newLineRegex = new RegExp(/[\r\n]+/g);
    colors.supportsColor = require_supports_colors().supportsColor;
    if (typeof colors.enabled === "undefined") {
      colors.enabled = colors.supportsColor() !== false;
    }
    colors.enable = function() {
      colors.enabled = true;
    };
    colors.disable = function() {
      colors.enabled = false;
    };
    colors.stripColors = colors.strip = function(str) {
      return ("" + str).replace(/\x1B\[\d+m/g, "");
    };
    var stylize = colors.stylize = function stylize2(str, style) {
      if (!colors.enabled) {
        return str + "";
      }
      var styleMap = ansiStyles[style];
      if (!styleMap && style in colors) {
        return colors[style](str);
      }
      return styleMap.open + str + styleMap.close;
    };
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    var escapeStringRegexp = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
    function build(_styles) {
      var builder = function builder2() {
        return applyStyle.apply(builder2, arguments);
      };
      builder._styles = _styles;
      builder.__proto__ = proto;
      return builder;
    }
    var styles2 = function() {
      var ret = {};
      ansiStyles.grey = ansiStyles.gray;
      Object.keys(ansiStyles).forEach(function(key) {
        ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
        ret[key] = {
          get: function() {
            return build(this._styles.concat(key));
          }
        };
      });
      return ret;
    }();
    var proto = defineProps(function colors2() {
    }, styles2);
    function applyStyle() {
      var args = Array.prototype.slice.call(arguments);
      var str = args.map(function(arg) {
        if (arg != null && arg.constructor === String) {
          return arg;
        } else {
          return util.inspect(arg);
        }
      }).join(" ");
      if (!colors.enabled || !str) {
        return str;
      }
      var newLinesPresent = str.indexOf("\n") != -1;
      var nestedStyles = this._styles;
      var i = nestedStyles.length;
      while (i--) {
        var code = ansiStyles[nestedStyles[i]];
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
        if (newLinesPresent) {
          str = str.replace(newLineRegex, function(match) {
            return code.close + match + code.open;
          });
        }
      }
      return str;
    }
    colors.setTheme = function(theme) {
      if (typeof theme === "string") {
        console.log("colors.setTheme now only accepts an object, not a string.  If you are trying to set a theme from a file, it is now your (the caller's) responsibility to require the file.  The old syntax looked like colors.setTheme(__dirname + '/../themes/generic-logging.js'); The new syntax looks like colors.setTheme(require(__dirname + '/../themes/generic-logging.js'));");
        return;
      }
      for (var style in theme) {
        (function(style2) {
          colors[style2] = function(str) {
            if (typeof theme[style2] === "object") {
              var out = str;
              for (var i in theme[style2]) {
                out = colors[theme[style2][i]](out);
              }
              return out;
            }
            return colors[theme[style2]](str);
          };
        })(style);
      }
    };
    function init() {
      var ret = {};
      Object.keys(styles2).forEach(function(name) {
        ret[name] = {
          get: function() {
            return build([name]);
          }
        };
      });
      return ret;
    }
    var sequencer = function sequencer2(map2, str) {
      var exploded = str.split("");
      exploded = exploded.map(map2);
      return exploded.join("");
    };
    colors.trap = require_trap();
    colors.zalgo = require_zalgo();
    colors.maps = {};
    colors.maps.america = require_america()(colors);
    colors.maps.zebra = require_zebra()(colors);
    colors.maps.rainbow = require_rainbow()(colors);
    colors.maps.random = require_random()(colors);
    for (map in colors.maps) {
      (function(map2) {
        colors[map2] = function(str) {
          return sequencer(colors.maps[map2], str);
        };
      })(map);
    }
    var map;
    defineProps(colors, init());
  }
});

// node_modules/@colors/colors/safe.js
var require_safe = __commonJS({
  "node_modules/@colors/colors/safe.js"(exports2, module2) {
    var colors = require_colors();
    module2["exports"] = colors;
  }
});

// node_modules/triple-beam/config/cli.js
var require_cli = __commonJS({
  "node_modules/triple-beam/config/cli.js"(exports2) {
    "use strict";
    exports2.levels = {
      error: 0,
      warn: 1,
      help: 2,
      data: 3,
      info: 4,
      debug: 5,
      prompt: 6,
      verbose: 7,
      input: 8,
      silly: 9
    };
    exports2.colors = {
      error: "red",
      warn: "yellow",
      help: "cyan",
      data: "grey",
      info: "green",
      debug: "blue",
      prompt: "grey",
      verbose: "cyan",
      input: "grey",
      silly: "magenta"
    };
  }
});

// node_modules/triple-beam/config/npm.js
var require_npm = __commonJS({
  "node_modules/triple-beam/config/npm.js"(exports2) {
    "use strict";
    exports2.levels = {
      error: 0,
      warn: 1,
      info: 2,
      http: 3,
      verbose: 4,
      debug: 5,
      silly: 6
    };
    exports2.colors = {
      error: "red",
      warn: "yellow",
      info: "green",
      http: "green",
      verbose: "cyan",
      debug: "blue",
      silly: "magenta"
    };
  }
});

// node_modules/triple-beam/config/syslog.js
var require_syslog = __commonJS({
  "node_modules/triple-beam/config/syslog.js"(exports2) {
    "use strict";
    exports2.levels = {
      emerg: 0,
      alert: 1,
      crit: 2,
      error: 3,
      warning: 4,
      notice: 5,
      info: 6,
      debug: 7
    };
    exports2.colors = {
      emerg: "red",
      alert: "yellow",
      crit: "red",
      error: "red",
      warning: "red",
      notice: "yellow",
      info: "green",
      debug: "blue"
    };
  }
});

// node_modules/triple-beam/config/index.js
var require_config = __commonJS({
  "node_modules/triple-beam/config/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "cli", {
      value: require_cli()
    });
    Object.defineProperty(exports2, "npm", {
      value: require_npm()
    });
    Object.defineProperty(exports2, "syslog", {
      value: require_syslog()
    });
  }
});

// node_modules/triple-beam/index.js
var require_triple_beam = __commonJS({
  "node_modules/triple-beam/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "LEVEL", {
      value: Symbol.for("level")
    });
    Object.defineProperty(exports2, "MESSAGE", {
      value: Symbol.for("message")
    });
    Object.defineProperty(exports2, "SPLAT", {
      value: Symbol.for("splat")
    });
    Object.defineProperty(exports2, "configs", {
      value: require_config()
    });
  }
});

// node_modules/logform/colorize.js
var require_colorize = __commonJS({
  "node_modules/logform/colorize.js"(exports2, module2) {
    "use strict";
    var colors = require_safe();
    var { LEVEL, MESSAGE } = require_triple_beam();
    colors.enabled = true;
    var hasSpace = /\s+/;
    var Colorizer = class _Colorizer {
      constructor(opts = {}) {
        if (opts.colors) {
          this.addColors(opts.colors);
        }
        this.options = opts;
      }
      /*
       * Adds the colors Object to the set of allColors
       * known by the Colorizer
       *
       * @param {Object} colors Set of color mappings to add.
       */
      static addColors(clrs) {
        const nextColors = Object.keys(clrs).reduce((acc, level) => {
          acc[level] = hasSpace.test(clrs[level]) ? clrs[level].split(hasSpace) : clrs[level];
          return acc;
        }, {});
        _Colorizer.allColors = Object.assign({}, _Colorizer.allColors || {}, nextColors);
        return _Colorizer.allColors;
      }
      /*
       * Adds the colors Object to the set of allColors
       * known by the Colorizer
       *
       * @param {Object} colors Set of color mappings to add.
       */
      addColors(clrs) {
        return _Colorizer.addColors(clrs);
      }
      /*
       * function colorize (lookup, level, message)
       * Performs multi-step colorization using @colors/colors/safe
       */
      colorize(lookup, level, message) {
        if (typeof message === "undefined") {
          message = level;
        }
        if (!Array.isArray(_Colorizer.allColors[lookup])) {
          return colors[_Colorizer.allColors[lookup]](message);
        }
        for (let i = 0, len = _Colorizer.allColors[lookup].length; i < len; i++) {
          message = colors[_Colorizer.allColors[lookup][i]](message);
        }
        return message;
      }
      /*
       * function transform (info, opts)
       * Attempts to colorize the { level, message } of the given
       * `logform` info object.
       */
      transform(info, opts) {
        if (opts.all && typeof info[MESSAGE] === "string") {
          info[MESSAGE] = this.colorize(info[LEVEL], info.level, info[MESSAGE]);
        }
        if (opts.level || opts.all || !opts.message) {
          info.level = this.colorize(info[LEVEL], info.level);
        }
        if (opts.all || opts.message) {
          info.message = this.colorize(info[LEVEL], info.level, info.message);
        }
        return info;
      }
    };
    module2.exports = (opts) => new Colorizer(opts);
    module2.exports.Colorizer = module2.exports.Format = Colorizer;
  }
});

// node_modules/logform/levels.js
var require_levels = __commonJS({
  "node_modules/logform/levels.js"(exports2, module2) {
    "use strict";
    var { Colorizer } = require_colorize();
    module2.exports = (config) => {
      Colorizer.addColors(config.colors || config);
      return config;
    };
  }
});

// node_modules/logform/align.js
var require_align = __commonJS({
  "node_modules/logform/align.js"(exports2, module2) {
    "use strict";
    var format = require_format();
    module2.exports = format((info) => {
      info.message = `	${info.message}`;
      return info;
    });
  }
});

// node_modules/logform/errors.js
var require_errors = __commonJS({
  "node_modules/logform/errors.js"(exports2, module2) {
    "use strict";
    var format = require_format();
    var { LEVEL, MESSAGE } = require_triple_beam();
    module2.exports = format((einfo, { stack, cause }) => {
      if (einfo instanceof Error) {
        const info = Object.assign({}, einfo, {
          level: einfo.level,
          [LEVEL]: einfo[LEVEL] || einfo.level,
          message: einfo.message,
          [MESSAGE]: einfo[MESSAGE] || einfo.message
        });
        if (stack) info.stack = einfo.stack;
        if (cause) info.cause = einfo.cause;
        return info;
      }
      if (!(einfo.message instanceof Error)) return einfo;
      const err = einfo.message;
      Object.assign(einfo, err);
      einfo.message = err.message;
      einfo[MESSAGE] = err.message;
      if (stack) einfo.stack = err.stack;
      if (cause) einfo.cause = err.cause;
      return einfo;
    });
  }
});

// node_modules/logform/pad-levels.js
var require_pad_levels = __commonJS({
  "node_modules/logform/pad-levels.js"(exports2, module2) {
    "use strict";
    var { configs, LEVEL, MESSAGE } = require_triple_beam();
    var Padder = class _Padder {
      constructor(opts = { levels: configs.npm.levels }) {
        this.paddings = _Padder.paddingForLevels(opts.levels, opts.filler);
        this.options = opts;
      }
      /**
       * Returns the maximum length of keys in the specified `levels` Object.
       * @param  {Object} levels Set of all levels to calculate longest level against.
       * @returns {Number} Maximum length of the longest level string.
       */
      static getLongestLevel(levels) {
        const lvls = Object.keys(levels).map((level) => level.length);
        return Math.max(...lvls);
      }
      /**
       * Returns the padding for the specified `level` assuming that the
       * maximum length of all levels it's associated with is `maxLength`.
       * @param  {String} level Level to calculate padding for.
       * @param  {String} filler Repeatable text to use for padding.
       * @param  {Number} maxLength Length of the longest level
       * @returns {String} Padding string for the `level`
       */
      static paddingForLevel(level, filler, maxLength) {
        const targetLen = maxLength + 1 - level.length;
        const rep = Math.floor(targetLen / filler.length);
        const padding = `${filler}${filler.repeat(rep)}`;
        return padding.slice(0, targetLen);
      }
      /**
       * Returns an object with the string paddings for the given `levels`
       * using the specified `filler`.
       * @param  {Object} levels Set of all levels to calculate padding for.
       * @param  {String} filler Repeatable text to use for padding.
       * @returns {Object} Mapping of level to desired padding.
       */
      static paddingForLevels(levels, filler = " ") {
        const maxLength = _Padder.getLongestLevel(levels);
        return Object.keys(levels).reduce((acc, level) => {
          acc[level] = _Padder.paddingForLevel(level, filler, maxLength);
          return acc;
        }, {});
      }
      /**
       * Prepends the padding onto the `message` based on the `LEVEL` of
       * the `info`. This is based on the behavior of `winston@2` which also
       * prepended the level onto the message.
       *
       * See: https://github.com/winstonjs/winston/blob/2.x/lib/winston/logger.js#L198-L201
       *
       * @param  {Info} info Logform info object
       * @param  {Object} opts Options passed along to this instance.
       * @returns {Info} Modified logform info object.
       */
      transform(info, opts) {
        info.message = `${this.paddings[info[LEVEL]]}${info.message}`;
        if (info[MESSAGE]) {
          info[MESSAGE] = `${this.paddings[info[LEVEL]]}${info[MESSAGE]}`;
        }
        return info;
      }
    };
    module2.exports = (opts) => new Padder(opts);
    module2.exports.Padder = module2.exports.Format = Padder;
  }
});

// node_modules/logform/cli.js
var require_cli2 = __commonJS({
  "node_modules/logform/cli.js"(exports2, module2) {
    "use strict";
    var { Colorizer } = require_colorize();
    var { Padder } = require_pad_levels();
    var { configs, MESSAGE } = require_triple_beam();
    var CliFormat = class {
      constructor(opts = {}) {
        if (!opts.levels) {
          opts.levels = configs.cli.levels;
        }
        this.colorizer = new Colorizer(opts);
        this.padder = new Padder(opts);
        this.options = opts;
      }
      /*
       * function transform (info, opts)
       * Attempts to both:
       * 1. Pad the { level }
       * 2. Colorize the { level, message }
       * of the given `logform` info object depending on the `opts`.
       */
      transform(info, opts) {
        this.colorizer.transform(
          this.padder.transform(info, opts),
          opts
        );
        info[MESSAGE] = `${info.level}:${info.message}`;
        return info;
      }
    };
    module2.exports = (opts) => new CliFormat(opts);
    module2.exports.Format = CliFormat;
  }
});

// node_modules/logform/combine.js
var require_combine = __commonJS({
  "node_modules/logform/combine.js"(exports2, module2) {
    "use strict";
    var format = require_format();
    function cascade(formats) {
      if (!formats.every(isValidFormat)) {
        return;
      }
      return (info) => {
        let obj = info;
        for (let i = 0; i < formats.length; i++) {
          obj = formats[i].transform(obj, formats[i].options);
          if (!obj) {
            return false;
          }
        }
        return obj;
      };
    }
    function isValidFormat(fmt) {
      if (typeof fmt.transform !== "function") {
        throw new Error([
          "No transform function found on format. Did you create a format instance?",
          "const myFormat = format(formatFn);",
          "const instance = myFormat();"
        ].join("\n"));
      }
      return true;
    }
    module2.exports = (...formats) => {
      const combinedFormat = format(cascade(formats));
      const instance = combinedFormat();
      instance.Format = combinedFormat.Format;
      return instance;
    };
    module2.exports.cascade = cascade;
  }
});

// node_modules/safe-stable-stringify/index.js
var require_safe_stable_stringify = __commonJS({
  "node_modules/safe-stable-stringify/index.js"(exports2, module2) {
    "use strict";
    var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
    var stringify = configure();
    stringify.configure = configure;
    stringify.stringify = stringify;
    stringify.default = stringify;
    exports2.stringify = stringify;
    exports2.configure = configure;
    module2.exports = stringify;
    var strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
    function strEscape(str) {
      if (str.length < 5e3 && !strEscapeSequencesRegExp.test(str)) {
        return `"${str}"`;
      }
      return JSON.stringify(str);
    }
    function sort(array, comparator) {
      if (array.length > 200 || comparator) {
        return array.sort(comparator);
      }
      for (let i = 1; i < array.length; i++) {
        const currentValue = array[i];
        let position = i;
        while (position !== 0 && array[position - 1] > currentValue) {
          array[position] = array[position - 1];
          position--;
        }
        array[position] = currentValue;
      }
      return array;
    }
    var typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(
      Object.getPrototypeOf(
        Object.getPrototypeOf(
          new Int8Array()
        )
      ),
      Symbol.toStringTag
    ).get;
    function isTypedArrayWithEntries(value) {
      return typedArrayPrototypeGetSymbolToStringTag.call(value) !== void 0 && value.length !== 0;
    }
    function stringifyTypedArray(array, separator, maximumBreadth) {
      if (array.length < maximumBreadth) {
        maximumBreadth = array.length;
      }
      const whitespace = separator === "," ? "" : " ";
      let res = `"0":${whitespace}${array[0]}`;
      for (let i = 1; i < maximumBreadth; i++) {
        res += `${separator}"${i}":${whitespace}${array[i]}`;
      }
      return res;
    }
    function getCircularValueOption(options) {
      if (hasOwnProperty2.call(options, "circularValue")) {
        const circularValue = options.circularValue;
        if (typeof circularValue === "string") {
          return `"${circularValue}"`;
        }
        if (circularValue == null) {
          return circularValue;
        }
        if (circularValue === Error || circularValue === TypeError) {
          return {
            toString() {
              throw new TypeError("Converting circular structure to JSON");
            }
          };
        }
        throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
      }
      return '"[Circular]"';
    }
    function getDeterministicOption(options) {
      let value;
      if (hasOwnProperty2.call(options, "deterministic")) {
        value = options.deterministic;
        if (typeof value !== "boolean" && typeof value !== "function") {
          throw new TypeError('The "deterministic" argument must be of type boolean or comparator function');
        }
      }
      return value === void 0 ? true : value;
    }
    function getBooleanOption(options, key) {
      let value;
      if (hasOwnProperty2.call(options, key)) {
        value = options[key];
        if (typeof value !== "boolean") {
          throw new TypeError(`The "${key}" argument must be of type boolean`);
        }
      }
      return value === void 0 ? true : value;
    }
    function getPositiveIntegerOption(options, key) {
      let value;
      if (hasOwnProperty2.call(options, key)) {
        value = options[key];
        if (typeof value !== "number") {
          throw new TypeError(`The "${key}" argument must be of type number`);
        }
        if (!Number.isInteger(value)) {
          throw new TypeError(`The "${key}" argument must be an integer`);
        }
        if (value < 1) {
          throw new RangeError(`The "${key}" argument must be >= 1`);
        }
      }
      return value === void 0 ? Infinity : value;
    }
    function getItemCount(number) {
      if (number === 1) {
        return "1 item";
      }
      return `${number} items`;
    }
    function getUniqueReplacerSet(replacerArray) {
      const replacerSet = /* @__PURE__ */ new Set();
      for (const value of replacerArray) {
        if (typeof value === "string" || typeof value === "number") {
          replacerSet.add(String(value));
        }
      }
      return replacerSet;
    }
    function getStrictOption(options) {
      if (hasOwnProperty2.call(options, "strict")) {
        const value = options.strict;
        if (typeof value !== "boolean") {
          throw new TypeError('The "strict" argument must be of type boolean');
        }
        if (value) {
          return (value2) => {
            let message = `Object can not safely be stringified. Received type ${typeof value2}`;
            if (typeof value2 !== "function") message += ` (${value2.toString()})`;
            throw new Error(message);
          };
        }
      }
    }
    function configure(options) {
      options = { ...options };
      const fail = getStrictOption(options);
      if (fail) {
        if (options.bigint === void 0) {
          options.bigint = false;
        }
        if (!("circularValue" in options)) {
          options.circularValue = Error;
        }
      }
      const circularValue = getCircularValueOption(options);
      const bigint = getBooleanOption(options, "bigint");
      const deterministic = getDeterministicOption(options);
      const comparator = typeof deterministic === "function" ? deterministic : void 0;
      const maximumDepth = getPositiveIntegerOption(options, "maximumDepth");
      const maximumBreadth = getPositiveIntegerOption(options, "maximumBreadth");
      function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
        let value = parent[key];
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        value = replacer.call(parent, key, value);
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = "";
            let join = ",";
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join;
              }
              const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let whitespace = "";
            let separator = "";
            if (spacer !== "") {
              indentation += spacer;
              join = `,
${indentation}`;
              whitespace = " ";
            }
            const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (deterministic && !isTypedArrayWithEntries(value)) {
              keys = sort(keys, comparator);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifyFnReplacer(key2, value, stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
              separator = join;
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            let res = "";
            let join = ",";
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join;
              }
              const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            stack.push(value);
            let whitespace = "";
            if (spacer !== "") {
              indentation += spacer;
              join = `,
${indentation}`;
              whitespace = " ";
            }
            let separator = "";
            for (const key2 of replacer) {
              const tmp = stringifyArrayReplacer(key2, value[key2], stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join;
              }
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyIndent(key, value, stack, spacer, indentation) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifyIndent(key, value, stack, spacer, indentation);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              indentation += spacer;
              let res2 = `
${indentation}`;
              const join2 = `,
${indentation}`;
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyIndent(String(i), value[i], stack, spacer, indentation);
                res2 += tmp2 !== void 0 ? tmp2 : "null";
                res2 += join2;
              }
              const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);
              res2 += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res2 += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              res2 += `
${originalIndentation}`;
              stack.pop();
              return `[${res2}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            indentation += spacer;
            const join = `,
${indentation}`;
            let res = "";
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, join, maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = join;
            }
            if (deterministic) {
              keys = sort(keys, comparator);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifyIndent(key2, value[key2], stack, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}: ${tmp}`;
                separator = join;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
              separator = join;
            }
            if (separator !== "") {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifySimple(key, value, stack) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifySimple(key, value, stack);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = "";
            const hasLength = value.length !== void 0;
            if (hasLength && Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifySimple(String(i), value[i], stack);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += ",";
              }
              const tmp = stringifySimple(String(i), value[i], stack);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `,"... ${getItemCount(removedKeys)} not stringified"`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (hasLength && isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, ",", maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = ",";
            }
            if (deterministic) {
              keys = sort(keys, comparator);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifySimple(key2, value[key2], stack);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${tmp}`;
                separator = ",";
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringify2(value, replacer, space) {
        if (arguments.length > 1) {
          let spacer = "";
          if (typeof space === "number") {
            spacer = " ".repeat(Math.min(space, 10));
          } else if (typeof space === "string") {
            spacer = space.slice(0, 10);
          }
          if (replacer != null) {
            if (typeof replacer === "function") {
              return stringifyFnReplacer("", { "": value }, [], replacer, spacer, "");
            }
            if (Array.isArray(replacer)) {
              return stringifyArrayReplacer("", value, [], getUniqueReplacerSet(replacer), spacer, "");
            }
          }
          if (spacer.length !== 0) {
            return stringifyIndent("", value, [], spacer, "");
          }
        }
        return stringifySimple("", value, []);
      }
      return stringify2;
    }
  }
});

// node_modules/logform/json.js
var require_json = __commonJS({
  "node_modules/logform/json.js"(exports2, module2) {
    "use strict";
    var format = require_format();
    var { MESSAGE } = require_triple_beam();
    var stringify = require_safe_stable_stringify();
    function replacer(key, value) {
      if (typeof value === "bigint")
        return value.toString();
      return value;
    }
    module2.exports = format((info, opts) => {
      const jsonStringify = stringify.configure(opts);
      info[MESSAGE] = jsonStringify(info, opts.replacer || replacer, opts.space);
      return info;
    });
  }
});

// node_modules/logform/label.js
var require_label = __commonJS({
  "node_modules/logform/label.js"(exports2, module2) {
    "use strict";
    var format = require_format();
    module2.exports = format((info, opts) => {
      if (opts.message) {
        info.message = `[${opts.label}] ${info.message}`;
        return info;
      }
      info.label = opts.label;
      return info;
    });
  }
});

// node_modules/logform/logstash.js
var require_logstash = __commonJS({
  "node_modules/logform/logstash.js"(exports2, module2) {
    "use strict";
    var format = require_format();
    var { MESSAGE } = require_triple_beam();
    var jsonStringify = require_safe_stable_stringify();
    module2.exports = format((info) => {
      const logstash = {};
      if (info.message) {
        logstash["@message"] = info.message;
        delete info.message;
      }
      if (info.timestamp) {
        logstash["@timestamp"] = info.timestamp;
        delete info.timestamp;
      }
      logstash["@fields"] = info;
      info[MESSAGE] = jsonStringify(logstash);
      return info;
    });
  }
});

// node_modules/logform/metadata.js
var require_metadata = __commonJS({
  "node_modules/logform/metadata.js"(exports2, module2) {
    "use strict";
    var format = require_format();
    function fillExcept(info, fillExceptKeys, metadataKey) {
      const savedKeys = fillExceptKeys.reduce((acc, key) => {
        acc[key] = info[key];
        delete info[key];
        return acc;
      }, {});
      const metadata = Object.keys(info).reduce((acc, key) => {
        acc[key] = info[key];
        delete info[key];
        return acc;
      }, {});
      Object.assign(info, savedKeys, {
        [metadataKey]: metadata
      });
      return info;
    }
    function fillWith(info, fillWithKeys, metadataKey) {
      info[metadataKey] = fillWithKeys.reduce((acc, key) => {
        acc[key] = info[key];
        delete info[key];
        return acc;
      }, {});
      return info;
    }
    module2.exports = format((info, opts = {}) => {
      let metadataKey = "metadata";
      if (opts.key) {
        metadataKey = opts.key;
      }
      let fillExceptKeys = [];
      if (!opts.fillExcept && !opts.fillWith) {
        fillExceptKeys.push("level");
        fillExceptKeys.push("message");
      }
      if (opts.fillExcept) {
        fillExceptKeys = opts.fillExcept;
      }
      if (fillExceptKeys.length > 0) {
        return fillExcept(info, fillExceptKeys, metadataKey);
      }
      if (opts.fillWith) {
        return fillWith(info, opts.fillWith, metadataKey);
      }
      return info;
    });
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/logform/ms.js
var require_ms2 = __commonJS({
  "node_modules/logform/ms.js"(exports2, module2) {
    "use strict";
    var format = require_format();
    var ms = require_ms();
    module2.exports = format((info) => {
      const curr = +/* @__PURE__ */ new Date();
      exports2.diff = curr - (exports2.prevTime || curr);
      exports2.prevTime = curr;
      info.ms = `+${ms(exports2.diff)}`;
      return info;
    });
  }
});

// node_modules/logform/pretty-print.js
var require_pretty_print = __commonJS({
  "node_modules/logform/pretty-print.js"(exports2, module2) {
    "use strict";
    var inspect = require("util").inspect;
    var format = require_format();
    var { LEVEL, MESSAGE, SPLAT } = require_triple_beam();
    module2.exports = format((info, opts = {}) => {
      const stripped = Object.assign({}, info);
      delete stripped[LEVEL];
      delete stripped[MESSAGE];
      delete stripped[SPLAT];
      info[MESSAGE] = inspect(stripped, false, opts.depth || null, opts.colorize);
      return info;
    });
  }
});

// node_modules/logform/printf.js
var require_printf = __commonJS({
  "node_modules/logform/printf.js"(exports2, module2) {
    "use strict";
    var { MESSAGE } = require_triple_beam();
    var Printf = class {
      constructor(templateFn) {
        this.template = templateFn;
      }
      transform(info) {
        info[MESSAGE] = this.template(info);
        return info;
      }
    };
    module2.exports = (opts) => new Printf(opts);
    module2.exports.Printf = module2.exports.Format = Printf;
  }
});

// node_modules/logform/simple.js
var require_simple = __commonJS({
  "node_modules/logform/simple.js"(exports2, module2) {
    "use strict";
    var format = require_format();
    var { MESSAGE } = require_triple_beam();
    var jsonStringify = require_safe_stable_stringify();
    module2.exports = format((info) => {
      const stringifiedRest = jsonStringify(Object.assign({}, info, {
        level: void 0,
        message: void 0,
        splat: void 0
      }));
      const padding = info.padding && info.padding[info.level] || "";
      if (stringifiedRest !== "{}") {
        info[MESSAGE] = `${info.level}:${padding} ${info.message} ${stringifiedRest}`;
      } else {
        info[MESSAGE] = `${info.level}:${padding} ${info.message}`;
      }
      return info;
    });
  }
});

// node_modules/logform/splat.js
var require_splat = __commonJS({
  "node_modules/logform/splat.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var { SPLAT } = require_triple_beam();
    var formatRegExp = /%[scdjifoO%]/g;
    var escapedPercent = /%%/g;
    var Splatter = class {
      constructor(opts) {
        this.options = opts;
      }
      /**
         * Check to see if tokens <= splat.length, assign { splat, meta } into the
         * `info` accordingly, and write to this instance.
         *
         * @param  {Info} info Logform info message.
         * @param  {String[]} tokens Set of string interpolation tokens.
         * @returns {Info} Modified info message
         * @private
         */
      _splat(info, tokens) {
        const msg = info.message;
        const splat = info[SPLAT] || info.splat || [];
        const percents = msg.match(escapedPercent);
        const escapes = percents && percents.length || 0;
        const expectedSplat = tokens.length - escapes;
        const extraSplat = expectedSplat - splat.length;
        const metas = extraSplat < 0 ? splat.splice(extraSplat, -1 * extraSplat) : [];
        const metalen = metas.length;
        if (metalen) {
          for (let i = 0; i < metalen; i++) {
            Object.assign(info, metas[i]);
          }
        }
        info.message = util.format(msg, ...splat);
        return info;
      }
      /**
        * Transforms the `info` message by using `util.format` to complete
        * any `info.message` provided it has string interpolation tokens.
        * If no tokens exist then `info` is immutable.
        *
        * @param  {Info} info Logform info message.
        * @param  {Object} opts Options for this instance.
        * @returns {Info} Modified info message
        */
      transform(info) {
        const msg = info.message;
        const splat = info[SPLAT] || info.splat;
        if (!splat || !splat.length) {
          return info;
        }
        const tokens = msg && msg.match && msg.match(formatRegExp);
        if (!tokens && (splat || splat.length)) {
          const metas = splat.length > 1 ? splat.splice(0) : splat;
          const metalen = metas.length;
          if (metalen) {
            for (let i = 0; i < metalen; i++) {
              Object.assign(info, metas[i]);
            }
          }
          return info;
        }
        if (tokens) {
          return this._splat(info, tokens);
        }
        return info;
      }
    };
    module2.exports = (opts) => new Splatter(opts);
  }
});

// node_modules/fecha/lib/fecha.umd.js
var require_fecha_umd = __commonJS({
  "node_modules/fecha/lib/fecha.umd.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.fecha = {});
    })(exports2, function(exports3) {
      "use strict";
      var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
      var twoDigitsOptional = "\\d\\d?";
      var twoDigits = "\\d\\d";
      var threeDigits = "\\d{3}";
      var fourDigits = "\\d{4}";
      var word = "[^\\s]+";
      var literal = /\[([^]*?)\]/gm;
      function shorten(arr2, sLen) {
        var newArr = [];
        for (var i = 0, len = arr2.length; i < len; i++) {
          newArr.push(arr2[i].substr(0, sLen));
        }
        return newArr;
      }
      var monthUpdate = function(arrName) {
        return function(v, i18n) {
          var lowerCaseArr = i18n[arrName].map(function(v2) {
            return v2.toLowerCase();
          });
          var index = lowerCaseArr.indexOf(v.toLowerCase());
          if (index > -1) {
            return index;
          }
          return null;
        };
      };
      function assign(origObj) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
          var obj = args_1[_a];
          for (var key in obj) {
            origObj[key] = obj[key];
          }
        }
        return origObj;
      }
      var dayNames = [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday"
      ];
      var monthNames = [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December"
      ];
      var monthNamesShort = shorten(monthNames, 3);
      var dayNamesShort = shorten(dayNames, 3);
      var defaultI18n = {
        dayNamesShort,
        dayNames,
        monthNamesShort,
        monthNames,
        amPm: ["am", "pm"],
        DoFn: function(dayOfMonth) {
          return dayOfMonth + ["th", "st", "nd", "rd"][dayOfMonth % 10 > 3 ? 0 : (dayOfMonth - dayOfMonth % 10 !== 10 ? 1 : 0) * dayOfMonth % 10];
        }
      };
      var globalI18n = assign({}, defaultI18n);
      var setGlobalDateI18n = function(i18n) {
        return globalI18n = assign(globalI18n, i18n);
      };
      var regexEscape = function(str) {
        return str.replace(/[|\\{()[^$+*?.-]/g, "\\$&");
      };
      var pad = function(val, len) {
        if (len === void 0) {
          len = 2;
        }
        val = String(val);
        while (val.length < len) {
          val = "0" + val;
        }
        return val;
      };
      var formatFlags = {
        D: function(dateObj) {
          return String(dateObj.getDate());
        },
        DD: function(dateObj) {
          return pad(dateObj.getDate());
        },
        Do: function(dateObj, i18n) {
          return i18n.DoFn(dateObj.getDate());
        },
        d: function(dateObj) {
          return String(dateObj.getDay());
        },
        dd: function(dateObj) {
          return pad(dateObj.getDay());
        },
        ddd: function(dateObj, i18n) {
          return i18n.dayNamesShort[dateObj.getDay()];
        },
        dddd: function(dateObj, i18n) {
          return i18n.dayNames[dateObj.getDay()];
        },
        M: function(dateObj) {
          return String(dateObj.getMonth() + 1);
        },
        MM: function(dateObj) {
          return pad(dateObj.getMonth() + 1);
        },
        MMM: function(dateObj, i18n) {
          return i18n.monthNamesShort[dateObj.getMonth()];
        },
        MMMM: function(dateObj, i18n) {
          return i18n.monthNames[dateObj.getMonth()];
        },
        YY: function(dateObj) {
          return pad(String(dateObj.getFullYear()), 4).substr(2);
        },
        YYYY: function(dateObj) {
          return pad(dateObj.getFullYear(), 4);
        },
        h: function(dateObj) {
          return String(dateObj.getHours() % 12 || 12);
        },
        hh: function(dateObj) {
          return pad(dateObj.getHours() % 12 || 12);
        },
        H: function(dateObj) {
          return String(dateObj.getHours());
        },
        HH: function(dateObj) {
          return pad(dateObj.getHours());
        },
        m: function(dateObj) {
          return String(dateObj.getMinutes());
        },
        mm: function(dateObj) {
          return pad(dateObj.getMinutes());
        },
        s: function(dateObj) {
          return String(dateObj.getSeconds());
        },
        ss: function(dateObj) {
          return pad(dateObj.getSeconds());
        },
        S: function(dateObj) {
          return String(Math.round(dateObj.getMilliseconds() / 100));
        },
        SS: function(dateObj) {
          return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
        },
        SSS: function(dateObj) {
          return pad(dateObj.getMilliseconds(), 3);
        },
        a: function(dateObj, i18n) {
          return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
        },
        A: function(dateObj, i18n) {
          return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
        },
        ZZ: function(dateObj) {
          var offset = dateObj.getTimezoneOffset();
          return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60) * 100 + Math.abs(offset) % 60, 4);
        },
        Z: function(dateObj) {
          var offset = dateObj.getTimezoneOffset();
          return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60), 2) + ":" + pad(Math.abs(offset) % 60, 2);
        }
      };
      var monthParse = function(v) {
        return +v - 1;
      };
      var emptyDigits = [null, twoDigitsOptional];
      var emptyWord = [null, word];
      var amPm = [
        "isPm",
        word,
        function(v, i18n) {
          var val = v.toLowerCase();
          if (val === i18n.amPm[0]) {
            return 0;
          } else if (val === i18n.amPm[1]) {
            return 1;
          }
          return null;
        }
      ];
      var timezoneOffset = [
        "timezoneOffset",
        "[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z?",
        function(v) {
          var parts = (v + "").match(/([+-]|\d\d)/gi);
          if (parts) {
            var minutes = +parts[1] * 60 + parseInt(parts[2], 10);
            return parts[0] === "+" ? minutes : -minutes;
          }
          return 0;
        }
      ];
      var parseFlags = {
        D: ["day", twoDigitsOptional],
        DD: ["day", twoDigits],
        Do: ["day", twoDigitsOptional + word, function(v) {
          return parseInt(v, 10);
        }],
        M: ["month", twoDigitsOptional, monthParse],
        MM: ["month", twoDigits, monthParse],
        YY: [
          "year",
          twoDigits,
          function(v) {
            var now = /* @__PURE__ */ new Date();
            var cent = +("" + now.getFullYear()).substr(0, 2);
            return +("" + (+v > 68 ? cent - 1 : cent) + v);
          }
        ],
        h: ["hour", twoDigitsOptional, void 0, "isPm"],
        hh: ["hour", twoDigits, void 0, "isPm"],
        H: ["hour", twoDigitsOptional],
        HH: ["hour", twoDigits],
        m: ["minute", twoDigitsOptional],
        mm: ["minute", twoDigits],
        s: ["second", twoDigitsOptional],
        ss: ["second", twoDigits],
        YYYY: ["year", fourDigits],
        S: ["millisecond", "\\d", function(v) {
          return +v * 100;
        }],
        SS: ["millisecond", twoDigits, function(v) {
          return +v * 10;
        }],
        SSS: ["millisecond", threeDigits],
        d: emptyDigits,
        dd: emptyDigits,
        ddd: emptyWord,
        dddd: emptyWord,
        MMM: ["month", word, monthUpdate("monthNamesShort")],
        MMMM: ["month", word, monthUpdate("monthNames")],
        a: amPm,
        A: amPm,
        ZZ: timezoneOffset,
        Z: timezoneOffset
      };
      var globalMasks = {
        default: "ddd MMM DD YYYY HH:mm:ss",
        shortDate: "M/D/YY",
        mediumDate: "MMM D, YYYY",
        longDate: "MMMM D, YYYY",
        fullDate: "dddd, MMMM D, YYYY",
        isoDate: "YYYY-MM-DD",
        isoDateTime: "YYYY-MM-DDTHH:mm:ssZ",
        shortTime: "HH:mm",
        mediumTime: "HH:mm:ss",
        longTime: "HH:mm:ss.SSS"
      };
      var setGlobalDateMasks = function(masks) {
        return assign(globalMasks, masks);
      };
      var format = function(dateObj, mask, i18n) {
        if (mask === void 0) {
          mask = globalMasks["default"];
        }
        if (i18n === void 0) {
          i18n = {};
        }
        if (typeof dateObj === "number") {
          dateObj = new Date(dateObj);
        }
        if (Object.prototype.toString.call(dateObj) !== "[object Date]" || isNaN(dateObj.getTime())) {
          throw new Error("Invalid Date pass to format");
        }
        mask = globalMasks[mask] || mask;
        var literals = [];
        mask = mask.replace(literal, function($0, $1) {
          literals.push($1);
          return "@@@";
        });
        var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
        mask = mask.replace(token, function($0) {
          return formatFlags[$0](dateObj, combinedI18nSettings);
        });
        return mask.replace(/@@@/g, function() {
          return literals.shift();
        });
      };
      function parse2(dateStr, format2, i18n) {
        if (i18n === void 0) {
          i18n = {};
        }
        if (typeof format2 !== "string") {
          throw new Error("Invalid format in fecha parse");
        }
        format2 = globalMasks[format2] || format2;
        if (dateStr.length > 1e3) {
          return null;
        }
        var today = /* @__PURE__ */ new Date();
        var dateInfo = {
          year: today.getFullYear(),
          month: 0,
          day: 1,
          hour: 0,
          minute: 0,
          second: 0,
          millisecond: 0,
          isPm: null,
          timezoneOffset: null
        };
        var parseInfo = [];
        var literals = [];
        var newFormat = format2.replace(literal, function($0, $1) {
          literals.push(regexEscape($1));
          return "@@@";
        });
        var specifiedFields = {};
        var requiredFields = {};
        newFormat = regexEscape(newFormat).replace(token, function($0) {
          var info = parseFlags[$0];
          var field2 = info[0], regex = info[1], requiredField = info[3];
          if (specifiedFields[field2]) {
            throw new Error("Invalid format. " + field2 + " specified twice in format");
          }
          specifiedFields[field2] = true;
          if (requiredField) {
            requiredFields[requiredField] = true;
          }
          parseInfo.push(info);
          return "(" + regex + ")";
        });
        Object.keys(requiredFields).forEach(function(field2) {
          if (!specifiedFields[field2]) {
            throw new Error("Invalid format. " + field2 + " is required in specified format");
          }
        });
        newFormat = newFormat.replace(/@@@/g, function() {
          return literals.shift();
        });
        var matches = dateStr.match(new RegExp(newFormat, "i"));
        if (!matches) {
          return null;
        }
        var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
        for (var i = 1; i < matches.length; i++) {
          var _a = parseInfo[i - 1], field = _a[0], parser = _a[2];
          var value = parser ? parser(matches[i], combinedI18nSettings) : +matches[i];
          if (value == null) {
            return null;
          }
          dateInfo[field] = value;
        }
        if (dateInfo.isPm === 1 && dateInfo.hour != null && +dateInfo.hour !== 12) {
          dateInfo.hour = +dateInfo.hour + 12;
        } else if (dateInfo.isPm === 0 && +dateInfo.hour === 12) {
          dateInfo.hour = 0;
        }
        var dateTZ;
        if (dateInfo.timezoneOffset == null) {
          dateTZ = new Date(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute, dateInfo.second, dateInfo.millisecond);
          var validateFields = [
            ["month", "getMonth"],
            ["day", "getDate"],
            ["hour", "getHours"],
            ["minute", "getMinutes"],
            ["second", "getSeconds"]
          ];
          for (var i = 0, len = validateFields.length; i < len; i++) {
            if (specifiedFields[validateFields[i][0]] && dateInfo[validateFields[i][0]] !== dateTZ[validateFields[i][1]]()) {
              return null;
            }
          }
        } else {
          dateTZ = new Date(Date.UTC(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute - dateInfo.timezoneOffset, dateInfo.second, dateInfo.millisecond));
          if (dateInfo.month > 11 || dateInfo.month < 0 || dateInfo.day > 31 || dateInfo.day < 1 || dateInfo.hour > 23 || dateInfo.hour < 0 || dateInfo.minute > 59 || dateInfo.minute < 0 || dateInfo.second > 59 || dateInfo.second < 0) {
            return null;
          }
        }
        return dateTZ;
      }
      var fecha = {
        format,
        parse: parse2,
        defaultI18n,
        setGlobalDateI18n,
        setGlobalDateMasks
      };
      exports3.assign = assign;
      exports3.default = fecha;
      exports3.format = format;
      exports3.parse = parse2;
      exports3.defaultI18n = defaultI18n;
      exports3.setGlobalDateI18n = setGlobalDateI18n;
      exports3.setGlobalDateMasks = setGlobalDateMasks;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// node_modules/logform/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/logform/timestamp.js"(exports2, module2) {
    "use strict";
    var fecha = require_fecha_umd();
    var format = require_format();
    module2.exports = format((info, opts = {}) => {
      if (opts.format) {
        info.timestamp = typeof opts.format === "function" ? opts.format() : fecha.format(/* @__PURE__ */ new Date(), opts.format);
      }
      if (!info.timestamp) {
        info.timestamp = (/* @__PURE__ */ new Date()).toISOString();
      }
      if (opts.alias) {
        info[opts.alias] = info.timestamp;
      }
      return info;
    });
  }
});

// node_modules/logform/uncolorize.js
var require_uncolorize = __commonJS({
  "node_modules/logform/uncolorize.js"(exports2, module2) {
    "use strict";
    var colors = require_safe();
    var format = require_format();
    var { MESSAGE } = require_triple_beam();
    module2.exports = format((info, opts) => {
      if (opts.level !== false) {
        info.level = colors.strip(info.level);
      }
      if (opts.message !== false) {
        info.message = colors.strip(String(info.message));
      }
      if (opts.raw !== false && info[MESSAGE]) {
        info[MESSAGE] = colors.strip(String(info[MESSAGE]));
      }
      return info;
    });
  }
});

// node_modules/logform/index.js
var require_logform = __commonJS({
  "node_modules/logform/index.js"(exports2) {
    "use strict";
    var format = exports2.format = require_format();
    exports2.levels = require_levels();
    function exposeFormat(name, requireFormat) {
      Object.defineProperty(format, name, {
        get() {
          return requireFormat();
        },
        configurable: true
      });
    }
    exposeFormat("align", function() {
      return require_align();
    });
    exposeFormat("errors", function() {
      return require_errors();
    });
    exposeFormat("cli", function() {
      return require_cli2();
    });
    exposeFormat("combine", function() {
      return require_combine();
    });
    exposeFormat("colorize", function() {
      return require_colorize();
    });
    exposeFormat("json", function() {
      return require_json();
    });
    exposeFormat("label", function() {
      return require_label();
    });
    exposeFormat("logstash", function() {
      return require_logstash();
    });
    exposeFormat("metadata", function() {
      return require_metadata();
    });
    exposeFormat("ms", function() {
      return require_ms2();
    });
    exposeFormat("padLevels", function() {
      return require_pad_levels();
    });
    exposeFormat("prettyPrint", function() {
      return require_pretty_print();
    });
    exposeFormat("printf", function() {
      return require_printf();
    });
    exposeFormat("simple", function() {
      return require_simple();
    });
    exposeFormat("splat", function() {
      return require_splat();
    });
    exposeFormat("timestamp", function() {
      return require_timestamp();
    });
    exposeFormat("uncolorize", function() {
      return require_uncolorize();
    });
  }
});

// node_modules/winston/lib/winston/common.js
var require_common = __commonJS({
  "node_modules/winston/lib/winston/common.js"(exports2) {
    "use strict";
    var { format } = require("util");
    exports2.warn = {
      deprecated(prop) {
        return () => {
          throw new Error(format("{ %s } was removed in winston@3.0.0.", prop));
        };
      },
      useFormat(prop) {
        return () => {
          throw new Error([
            format("{ %s } was removed in winston@3.0.0.", prop),
            "Use a custom winston.format = winston.format(function) instead."
          ].join("\n"));
        };
      },
      forFunctions(obj, type, props) {
        props.forEach((prop) => {
          obj[prop] = exports2.warn[type](prop);
        });
      },
      forProperties(obj, type, props) {
        props.forEach((prop) => {
          const notice = exports2.warn[type](prop);
          Object.defineProperty(obj, prop, {
            get: notice,
            set: notice
          });
        });
      }
    };
  }
});

// node_modules/winston/package.json
var require_package = __commonJS({
  "node_modules/winston/package.json"(exports2, module2) {
    module2.exports = {
      name: "winston",
      description: "A logger for just about everything.",
      version: "3.17.0",
      author: "Charlie Robbins <charlie.robbins@gmail.com>",
      maintainers: [
        "David Hyde <dabh@alumni.stanford.edu>"
      ],
      repository: {
        type: "git",
        url: "https://github.com/winstonjs/winston.git"
      },
      keywords: [
        "winston",
        "logger",
        "logging",
        "logs",
        "sysadmin",
        "bunyan",
        "pino",
        "loglevel",
        "tools",
        "json",
        "stream"
      ],
      dependencies: {
        "@dabh/diagnostics": "^2.0.2",
        "@colors/colors": "^1.6.0",
        async: "^3.2.3",
        "is-stream": "^2.0.0",
        logform: "^2.7.0",
        "one-time": "^1.0.0",
        "readable-stream": "^3.4.0",
        "safe-stable-stringify": "^2.3.1",
        "stack-trace": "0.0.x",
        "triple-beam": "^1.3.0",
        "winston-transport": "^4.9.0"
      },
      devDependencies: {
        "@babel/cli": "^7.23.9",
        "@babel/core": "^7.24.0",
        "@babel/preset-env": "^7.24.0",
        "@dabh/eslint-config-populist": "^4.4.0",
        "@types/node": "^20.11.24",
        "abstract-winston-transport": "^0.5.1",
        assume: "^2.2.0",
        "cross-spawn-async": "^2.2.5",
        eslint: "^8.57.0",
        hock: "^1.4.1",
        mocha: "^10.3.0",
        nyc: "^17.1.0",
        rimraf: "5.0.1",
        split2: "^4.1.0",
        "std-mocks": "^2.0.0",
        through2: "^4.0.2",
        "winston-compat": "^0.1.5"
      },
      main: "./lib/winston.js",
      browser: "./dist/winston",
      types: "./index.d.ts",
      scripts: {
        lint: "eslint lib/*.js lib/winston/*.js lib/winston/**/*.js --resolve-plugins-relative-to ./node_modules/@dabh/eslint-config-populist",
        test: "rimraf test/fixtures/logs/* && mocha",
        "test:coverage": "nyc npm run test:unit",
        "test:unit": "mocha test/unit",
        "test:integration": "mocha test/integration",
        build: "rimraf dist && babel lib -d dist",
        prepublishOnly: "npm run build"
      },
      engines: {
        node: ">= 12.0.0"
      },
      license: "MIT"
    };
  }
});

// node_modules/util-deprecate/node.js
var require_node = __commonJS({
  "node_modules/util-deprecate/node.js"(exports2, module2) {
    module2.exports = require("util").deprecate;
  }
});

// node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    module2.exports = require("stream");
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose) return;
      if (self2._readableState && !self2._readableState.emitClose) return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
      else stream.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/readable-stream/errors.js
var require_errors2 = __commonJS({
  "node_modules/readable-stream/errors.js"(exports2, module2) {
    "use strict";
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      class NodeError extends Base {
        constructor(arg1, arg2, arg3) {
          super(getMessage(arg1, arg2, arg3));
        }
      }
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        const len = expected.length;
        expected = expected.map((i) => String(i));
        if (len > 2) {
          return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        } else if (len === 2) {
          return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        } else {
          return `of ${thing} ${expected[0]}`;
        }
      } else {
        return `of ${thing} ${String(expected)}`;
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      let determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      let msg;
      if (endsWith(name, " argument")) {
        msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
      } else {
        const type = includes(name, ".") ? "property" : "argument";
        msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
      }
      msg += `. Received type ${typeof actual}`;
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module2.exports.codes = codes;
  }
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/state.js"(exports2, module2) {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors2().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module2.exports = {
      getHighWaterMark
    };
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports2, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function") throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports2, module2) {
    "use strict";
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = require("buffer");
    var Buffer2 = _require.Buffer;
    var _require2 = require("util");
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer2.prototype.copy.call(src, target, offset);
    }
    module2.exports = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0) this.tail.next = entry;
          else this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0) this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0) return;
          var ret = this.head.data;
          if (this.length === 1) this.head = this.tail = null;
          else this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s) {
          if (this.length === 0) return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next) ret += s + p.data;
          return ret;
        }
      }, {
        key: "concat",
        value: function concat2(n) {
          if (this.length === 0) return Buffer2.alloc(0);
          var ret = Buffer2.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret;
          if (n < this.head.data.length) {
            ret = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret = p.data;
          n -= ret.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length) ret += str;
            else ret += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next) this.head = p.next;
                else this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret = Buffer2.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret, ret.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next) this.head = p.next;
                else this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_, options) {
          return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc) return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried) return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0) return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127) return 0;
      else if (byte >> 5 === 6) return 2;
      else if (byte >> 4 === 14) return 3;
      else if (byte >> 3 === 30) return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i) return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2) nb = 0;
          else self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0) return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed) return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0) return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports2, module2) {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors2().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called) return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function") return eos(stream, null, opts);
      if (!opts) opts = {};
      callback = once(callback || noop);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable) onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable) callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable) callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req) onrequest();
        else stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false) stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module2.exports = eos;
  }
});

// node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports2, module2) {
    "use strict";
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module2.exports = createReadableStreamAsyncIterator;
  }
});

// node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/from.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var ERR_INVALID_ARG_TYPE = require_errors2().codes.ERR_INVALID_ARG_TYPE;
    function from(Readable2, iterable, opts) {
      var iterator;
      if (iterable && typeof iterable.next === "function") {
        iterator = iterable;
      } else if (iterable && iterable[Symbol.asyncIterator]) iterator = iterable[Symbol.asyncIterator]();
      else if (iterable && iterable[Symbol.iterator]) iterator = iterable[Symbol.iterator]();
      else throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
      var readable = new Readable2(_objectSpread({
        objectMode: true
      }, opts));
      var reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      function next() {
        return _next2.apply(this, arguments);
      }
      function _next2() {
        _next2 = _asyncToGenerator(function* () {
          try {
            var _yield$iterator$next = yield iterator.next(), value = _yield$iterator$next.value, done = _yield$iterator$next.done;
            if (done) {
              readable.push(null);
            } else if (readable.push(yield value)) {
              next();
            } else {
              reading = false;
            }
          } catch (err) {
            readable.destroy(err);
          }
        });
        return _next2.apply(this, arguments);
      }
      return readable;
    }
    module2.exports = from;
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    module2.exports = Readable2;
    var Duplex;
    Readable2.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require("util");
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors2().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits()(Readable2, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
      else emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable2(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable2)) return new Readable2(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable2.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable2.prototype.destroy = destroyImpl.destroy;
    Readable2.prototype._undestroy = destroyImpl.undestroy;
    Readable2.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable2.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable2.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck) er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
              else maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if (state.needReadable) emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable2.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable2.prototype.setEncoding = function(enc) {
      if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "") this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended) return 0;
      if (state.objectMode) return 1;
      if (n !== n) {
        if (state.flowing && state.length) return state.buffer.head.data.length;
        else return state.length;
      }
      if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length) return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable2.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0) state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0) state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading) n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0) ret = fromList(n, state);
      else ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended) state.needReadable = true;
        if (nOrig !== n && state.ended) endReadable(this);
      }
      if (ret !== null) this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended) return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable2.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable2.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted) process.nextTick(endFn);
      else src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable2.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0) return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) dests[i].emit("unpipe", this, {
          hasUnpiped: false
        });
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1) return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1) state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable2.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false) this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable2.prototype.addListener = Readable2.prototype.on;
    Readable2.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable2.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable2.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading) stream.read(0);
    }
    Readable2.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) ;
    }
    Readable2.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder) chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0)) return;
        else if (!state.objectMode && (!chunk || !chunk.length)) return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = /* @__PURE__ */ function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable2.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable2.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable2.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable2._fromList = fromList;
    Object.defineProperty(Readable2.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0) return null;
      var ret;
      if (state.objectMode) ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.first();
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable2.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from();
        }
        return from(Readable2, iterable, opts);
      };
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
      }
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) keys2.push(key);
      return keys2;
    };
    module2.exports = Duplex;
    var Readable2 = require_stream_readable();
    var Writable = require_stream_writable();
    require_inherits()(Duplex, Readable2);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex)) return new Duplex(options);
      Readable2.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false) this.readable = false;
        if (options.writable === false) this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended) return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream = require_stream();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors2().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits()(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object)) return true;
          if (this !== Writable) return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf) encoding = "buffer";
      else if (!encoding) encoding = state.defaultEncoding;
      if (typeof cb !== "function") cb = nop;
      if (state.ending) writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string") encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret) state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev) stream._writev(chunk, state.onwrite);
      else stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er) onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished) onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf) allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null) state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending) endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished) process.nextTick(cb);
        else stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// node_modules/winston-transport/modern.js
var require_modern = __commonJS({
  "node_modules/winston-transport/modern.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var Writable = require_stream_writable();
    var { LEVEL } = require_triple_beam();
    var TransportStream = module2.exports = function TransportStream2(options = {}) {
      Writable.call(this, { objectMode: true, highWaterMark: options.highWaterMark });
      this.format = options.format;
      this.level = options.level;
      this.handleExceptions = options.handleExceptions;
      this.handleRejections = options.handleRejections;
      this.silent = options.silent;
      if (options.log) this.log = options.log;
      if (options.logv) this.logv = options.logv;
      if (options.close) this.close = options.close;
      this.once("pipe", (logger8) => {
        this.levels = logger8.levels;
        this.parent = logger8;
      });
      this.once("unpipe", (src) => {
        if (src === this.parent) {
          this.parent = null;
          if (this.close) {
            this.close();
          }
        }
      });
    };
    util.inherits(TransportStream, Writable);
    TransportStream.prototype._write = function _write(info, enc, callback) {
      if (this.silent || info.exception === true && !this.handleExceptions) {
        return callback(null);
      }
      const level = this.level || this.parent && this.parent.level;
      if (!level || this.levels[level] >= this.levels[info[LEVEL]]) {
        if (info && !this.format) {
          return this.log(info, callback);
        }
        let errState;
        let transformed;
        try {
          transformed = this.format.transform(Object.assign({}, info), this.format.options);
        } catch (err) {
          errState = err;
        }
        if (errState || !transformed) {
          callback();
          if (errState) throw errState;
          return;
        }
        return this.log(transformed, callback);
      }
      this._writableState.sync = false;
      return callback(null);
    };
    TransportStream.prototype._writev = function _writev(chunks, callback) {
      if (this.logv) {
        const infos = chunks.filter(this._accept, this);
        if (!infos.length) {
          return callback(null);
        }
        return this.logv(infos, callback);
      }
      for (let i = 0; i < chunks.length; i++) {
        if (!this._accept(chunks[i])) continue;
        if (chunks[i].chunk && !this.format) {
          this.log(chunks[i].chunk, chunks[i].callback);
          continue;
        }
        let errState;
        let transformed;
        try {
          transformed = this.format.transform(
            Object.assign({}, chunks[i].chunk),
            this.format.options
          );
        } catch (err) {
          errState = err;
        }
        if (errState || !transformed) {
          chunks[i].callback();
          if (errState) {
            callback(null);
            throw errState;
          }
        } else {
          this.log(transformed, chunks[i].callback);
        }
      }
      return callback(null);
    };
    TransportStream.prototype._accept = function _accept(write) {
      const info = write.chunk;
      if (this.silent) {
        return false;
      }
      const level = this.level || this.parent && this.parent.level;
      if (info.exception === true || !level || this.levels[level] >= this.levels[info[LEVEL]]) {
        if (this.handleExceptions || info.exception !== true) {
          return true;
        }
      }
      return false;
    };
    TransportStream.prototype._nop = function _nop() {
      return void 0;
    };
  }
});

// node_modules/winston-transport/legacy.js
var require_legacy = __commonJS({
  "node_modules/winston-transport/legacy.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var { LEVEL } = require_triple_beam();
    var TransportStream = require_modern();
    var LegacyTransportStream = module2.exports = function LegacyTransportStream2(options = {}) {
      TransportStream.call(this, options);
      if (!options.transport || typeof options.transport.log !== "function") {
        throw new Error("Invalid transport, must be an object with a log method.");
      }
      this.transport = options.transport;
      this.level = this.level || options.transport.level;
      this.handleExceptions = this.handleExceptions || options.transport.handleExceptions;
      this._deprecated();
      function transportError(err) {
        this.emit("error", err, this.transport);
      }
      if (!this.transport.__winstonError) {
        this.transport.__winstonError = transportError.bind(this);
        this.transport.on("error", this.transport.__winstonError);
      }
    };
    util.inherits(LegacyTransportStream, TransportStream);
    LegacyTransportStream.prototype._write = function _write(info, enc, callback) {
      if (this.silent || info.exception === true && !this.handleExceptions) {
        return callback(null);
      }
      if (!this.level || this.levels[this.level] >= this.levels[info[LEVEL]]) {
        this.transport.log(info[LEVEL], info.message, info, this._nop);
      }
      callback(null);
    };
    LegacyTransportStream.prototype._writev = function _writev(chunks, callback) {
      for (let i = 0; i < chunks.length; i++) {
        if (this._accept(chunks[i])) {
          this.transport.log(
            chunks[i].chunk[LEVEL],
            chunks[i].chunk.message,
            chunks[i].chunk,
            this._nop
          );
          chunks[i].callback();
        }
      }
      return callback(null);
    };
    LegacyTransportStream.prototype._deprecated = function _deprecated() {
      console.error([
        `${this.transport.name} is a legacy winston transport. Consider upgrading: `,
        "- Upgrade docs: https://github.com/winstonjs/winston/blob/master/UPGRADE-3.0.md"
      ].join("\n"));
    };
    LegacyTransportStream.prototype.close = function close() {
      if (this.transport.close) {
        this.transport.close();
      }
      if (this.transport.__winstonError) {
        this.transport.removeListener("error", this.transport.__winstonError);
        this.transport.__winstonError = null;
      }
    };
  }
});

// node_modules/winston-transport/index.js
var require_winston_transport = __commonJS({
  "node_modules/winston-transport/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_modern();
    module2.exports.LegacyTransportStream = require_legacy();
  }
});

// node_modules/winston/lib/winston/transports/console.js
var require_console = __commonJS({
  "node_modules/winston/lib/winston/transports/console.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var { LEVEL, MESSAGE } = require_triple_beam();
    var TransportStream = require_winston_transport();
    module2.exports = class Console extends TransportStream {
      /**
       * Constructor function for the Console transport object responsible for
       * persisting log messages and metadata to a terminal or TTY.
       * @param {!Object} [options={}] - Options for this instance.
       */
      constructor(options = {}) {
        super(options);
        this.name = options.name || "console";
        this.stderrLevels = this._stringArrayToSet(options.stderrLevels);
        this.consoleWarnLevels = this._stringArrayToSet(options.consoleWarnLevels);
        this.eol = typeof options.eol === "string" ? options.eol : os.EOL;
        this.forceConsole = options.forceConsole || false;
        this._consoleLog = console.log.bind(console);
        this._consoleWarn = console.warn.bind(console);
        this._consoleError = console.error.bind(console);
        this.setMaxListeners(30);
      }
      /**
       * Core logging method exposed to Winston.
       * @param {Object} info - TODO: add param description.
       * @param {Function} callback - TODO: add param description.
       * @returns {undefined}
       */
      log(info, callback) {
        setImmediate(() => this.emit("logged", info));
        if (this.stderrLevels[info[LEVEL]]) {
          if (console._stderr && !this.forceConsole) {
            console._stderr.write(`${info[MESSAGE]}${this.eol}`);
          } else {
            this._consoleError(info[MESSAGE]);
          }
          if (callback) {
            callback();
          }
          return;
        } else if (this.consoleWarnLevels[info[LEVEL]]) {
          if (console._stderr && !this.forceConsole) {
            console._stderr.write(`${info[MESSAGE]}${this.eol}`);
          } else {
            this._consoleWarn(info[MESSAGE]);
          }
          if (callback) {
            callback();
          }
          return;
        }
        if (console._stdout && !this.forceConsole) {
          console._stdout.write(`${info[MESSAGE]}${this.eol}`);
        } else {
          this._consoleLog(info[MESSAGE]);
        }
        if (callback) {
          callback();
        }
      }
      /**
       * Returns a Set-like object with strArray's elements as keys (each with the
       * value true).
       * @param {Array} strArray - Array of Set-elements as strings.
       * @param {?string} [errMsg] - Custom error message thrown on invalid input.
       * @returns {Object} - TODO: add return description.
       * @private
       */
      _stringArrayToSet(strArray, errMsg) {
        if (!strArray) return {};
        errMsg = errMsg || "Cannot make set from type other than Array of string elements";
        if (!Array.isArray(strArray)) {
          throw new Error(errMsg);
        }
        return strArray.reduce((set, el) => {
          if (typeof el !== "string") {
            throw new Error(errMsg);
          }
          set[el] = true;
          return set;
        }, {});
      }
    };
  }
});

// node_modules/async/internal/isArrayLike.js
var require_isArrayLike = __commonJS({
  "node_modules/async/internal/isArrayLike.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isArrayLike;
    function isArrayLike(value) {
      return value && typeof value.length === "number" && value.length >= 0 && value.length % 1 === 0;
    }
    module2.exports = exports2.default;
  }
});

// node_modules/async/internal/initialParams.js
var require_initialParams = __commonJS({
  "node_modules/async/internal/initialParams.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = function(fn) {
      return function(...args) {
        var callback = args.pop();
        return fn.call(this, args, callback);
      };
    };
    module2.exports = exports2.default;
  }
});

// node_modules/async/internal/setImmediate.js
var require_setImmediate = __commonJS({
  "node_modules/async/internal/setImmediate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.fallback = fallback;
    exports2.wrap = wrap2;
    var hasQueueMicrotask = exports2.hasQueueMicrotask = typeof queueMicrotask === "function" && queueMicrotask;
    var hasSetImmediate = exports2.hasSetImmediate = typeof setImmediate === "function" && setImmediate;
    var hasNextTick = exports2.hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
    function fallback(fn) {
      setTimeout(fn, 0);
    }
    function wrap2(defer) {
      return (fn, ...args) => defer(() => fn(...args));
    }
    var _defer;
    if (hasQueueMicrotask) {
      _defer = queueMicrotask;
    } else if (hasSetImmediate) {
      _defer = setImmediate;
    } else if (hasNextTick) {
      _defer = process.nextTick;
    } else {
      _defer = fallback;
    }
    exports2.default = wrap2(_defer);
  }
});

// node_modules/async/asyncify.js
var require_asyncify = __commonJS({
  "node_modules/async/asyncify.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = asyncify;
    var _initialParams = require_initialParams();
    var _initialParams2 = _interopRequireDefault(_initialParams);
    var _setImmediate = require_setImmediate();
    var _setImmediate2 = _interopRequireDefault(_setImmediate);
    var _wrapAsync = require_wrapAsync();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function asyncify(func) {
      if ((0, _wrapAsync.isAsync)(func)) {
        return function(...args) {
          const callback = args.pop();
          const promise = func.apply(this, args);
          return handlePromise(promise, callback);
        };
      }
      return (0, _initialParams2.default)(function(args, callback) {
        var result;
        try {
          result = func.apply(this, args);
        } catch (e) {
          return callback(e);
        }
        if (result && typeof result.then === "function") {
          return handlePromise(result, callback);
        } else {
          callback(null, result);
        }
      });
    }
    function handlePromise(promise, callback) {
      return promise.then((value) => {
        invokeCallback(callback, null, value);
      }, (err) => {
        invokeCallback(callback, err && (err instanceof Error || err.message) ? err : new Error(err));
      });
    }
    function invokeCallback(callback, error, value) {
      try {
        callback(error, value);
      } catch (err) {
        (0, _setImmediate2.default)((e) => {
          throw e;
        }, err);
      }
    }
    module2.exports = exports2.default;
  }
});

// node_modules/async/internal/wrapAsync.js
var require_wrapAsync = __commonJS({
  "node_modules/async/internal/wrapAsync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isAsyncIterable = exports2.isAsyncGenerator = exports2.isAsync = void 0;
    var _asyncify = require_asyncify();
    var _asyncify2 = _interopRequireDefault(_asyncify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isAsync(fn) {
      return fn[Symbol.toStringTag] === "AsyncFunction";
    }
    function isAsyncGenerator(fn) {
      return fn[Symbol.toStringTag] === "AsyncGenerator";
    }
    function isAsyncIterable2(obj) {
      return typeof obj[Symbol.asyncIterator] === "function";
    }
    function wrapAsync(asyncFn) {
      if (typeof asyncFn !== "function") throw new Error("expected a function");
      return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;
    }
    exports2.default = wrapAsync;
    exports2.isAsync = isAsync;
    exports2.isAsyncGenerator = isAsyncGenerator;
    exports2.isAsyncIterable = isAsyncIterable2;
  }
});

// node_modules/async/internal/awaitify.js
var require_awaitify = __commonJS({
  "node_modules/async/internal/awaitify.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = awaitify;
    function awaitify(asyncFn, arity) {
      if (!arity) arity = asyncFn.length;
      if (!arity) throw new Error("arity is undefined");
      function awaitable(...args) {
        if (typeof args[arity - 1] === "function") {
          return asyncFn.apply(this, args);
        }
        return new Promise((resolve, reject) => {
          args[arity - 1] = (err, ...cbArgs) => {
            if (err) return reject(err);
            resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
          };
          asyncFn.apply(this, args);
        });
      }
      return awaitable;
    }
    module2.exports = exports2.default;
  }
});

// node_modules/async/internal/parallel.js
var require_parallel = __commonJS({
  "node_modules/async/internal/parallel.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _isArrayLike = require_isArrayLike();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports2.default = (0, _awaitify2.default)((eachfn, tasks, callback) => {
      var results = (0, _isArrayLike2.default)(tasks) ? [] : {};
      eachfn(tasks, (task, key, taskCb) => {
        (0, _wrapAsync2.default)(task)((err, ...result) => {
          if (result.length < 2) {
            [result] = result;
          }
          results[key] = result;
          taskCb(err);
        });
      }, (err) => callback(err, results));
    }, 3);
    module2.exports = exports2.default;
  }
});

// node_modules/async/internal/once.js
var require_once = __commonJS({
  "node_modules/async/internal/once.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = once;
    function once(fn) {
      function wrapper(...args) {
        if (fn === null) return;
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
      }
      Object.assign(wrapper, fn);
      return wrapper;
    }
    module2.exports = exports2.default;
  }
});

// node_modules/async/internal/getIterator.js
var require_getIterator = __commonJS({
  "node_modules/async/internal/getIterator.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = function(coll) {
      return coll[Symbol.iterator] && coll[Symbol.iterator]();
    };
    module2.exports = exports2.default;
  }
});

// node_modules/async/internal/iterator.js
var require_iterator = __commonJS({
  "node_modules/async/internal/iterator.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = createIterator;
    var _isArrayLike = require_isArrayLike();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _getIterator = require_getIterator();
    var _getIterator2 = _interopRequireDefault(_getIterator);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function createArrayIterator(coll) {
      var i = -1;
      var len = coll.length;
      return function next() {
        return ++i < len ? { value: coll[i], key: i } : null;
      };
    }
    function createES2015Iterator(iterator) {
      var i = -1;
      return function next() {
        var item = iterator.next();
        if (item.done) return null;
        i++;
        return { value: item.value, key: i };
      };
    }
    function createObjectIterator(obj) {
      var okeys = obj ? Object.keys(obj) : [];
      var i = -1;
      var len = okeys.length;
      return function next() {
        var key = okeys[++i];
        if (key === "__proto__") {
          return next();
        }
        return i < len ? { value: obj[key], key } : null;
      };
    }
    function createIterator(coll) {
      if ((0, _isArrayLike2.default)(coll)) {
        return createArrayIterator(coll);
      }
      var iterator = (0, _getIterator2.default)(coll);
      return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
    }
    module2.exports = exports2.default;
  }
});

// node_modules/async/internal/onlyOnce.js
var require_onlyOnce = __commonJS({
  "node_modules/async/internal/onlyOnce.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = onlyOnce;
    function onlyOnce(fn) {
      return function(...args) {
        if (fn === null) throw new Error("Callback was already called.");
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
      };
    }
    module2.exports = exports2.default;
  }
});

// node_modules/async/internal/breakLoop.js
var require_breakLoop = __commonJS({
  "node_modules/async/internal/breakLoop.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var breakLoop = {};
    exports2.default = breakLoop;
    module2.exports = exports2.default;
  }
});

// node_modules/async/internal/asyncEachOfLimit.js
var require_asyncEachOfLimit = __commonJS({
  "node_modules/async/internal/asyncEachOfLimit.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = asyncEachOfLimit;
    var _breakLoop = require_breakLoop();
    var _breakLoop2 = _interopRequireDefault(_breakLoop);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function asyncEachOfLimit(generator, limit, iteratee, callback) {
      let done = false;
      let canceled = false;
      let awaiting = false;
      let running = 0;
      let idx = 0;
      function replenish() {
        if (running >= limit || awaiting || done) return;
        awaiting = true;
        generator.next().then(({ value, done: iterDone }) => {
          if (canceled || done) return;
          awaiting = false;
          if (iterDone) {
            done = true;
            if (running <= 0) {
              callback(null);
            }
            return;
          }
          running++;
          iteratee(value, idx, iterateeCallback);
          idx++;
          replenish();
        }).catch(handleError);
      }
      function iterateeCallback(err, result) {
        running -= 1;
        if (canceled) return;
        if (err) return handleError(err);
        if (err === false) {
          done = true;
          canceled = true;
          return;
        }
        if (result === _breakLoop2.default || done && running <= 0) {
          done = true;
          return callback(null);
        }
        replenish();
      }
      function handleError(err) {
        if (canceled) return;
        awaiting = false;
        done = true;
        callback(err);
      }
      replenish();
    }
    module2.exports = exports2.default;
  }
});

// node_modules/async/internal/eachOfLimit.js
var require_eachOfLimit = __commonJS({
  "node_modules/async/internal/eachOfLimit.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _once = require_once();
    var _once2 = _interopRequireDefault(_once);
    var _iterator = require_iterator();
    var _iterator2 = _interopRequireDefault(_iterator);
    var _onlyOnce = require_onlyOnce();
    var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
    var _wrapAsync = require_wrapAsync();
    var _asyncEachOfLimit = require_asyncEachOfLimit();
    var _asyncEachOfLimit2 = _interopRequireDefault(_asyncEachOfLimit);
    var _breakLoop = require_breakLoop();
    var _breakLoop2 = _interopRequireDefault(_breakLoop);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports2.default = (limit) => {
      return (obj, iteratee, callback) => {
        callback = (0, _once2.default)(callback);
        if (limit <= 0) {
          throw new RangeError("concurrency limit cannot be less than 1");
        }
        if (!obj) {
          return callback(null);
        }
        if ((0, _wrapAsync.isAsyncGenerator)(obj)) {
          return (0, _asyncEachOfLimit2.default)(obj, limit, iteratee, callback);
        }
        if ((0, _wrapAsync.isAsyncIterable)(obj)) {
          return (0, _asyncEachOfLimit2.default)(obj[Symbol.asyncIterator](), limit, iteratee, callback);
        }
        var nextElem = (0, _iterator2.default)(obj);
        var done = false;
        var canceled = false;
        var running = 0;
        var looping = false;
        function iterateeCallback(err, value) {
          if (canceled) return;
          running -= 1;
          if (err) {
            done = true;
            callback(err);
          } else if (err === false) {
            done = true;
            canceled = true;
          } else if (value === _breakLoop2.default || done && running <= 0) {
            done = true;
            return callback(null);
          } else if (!looping) {
            replenish();
          }
        }
        function replenish() {
          looping = true;
          while (running < limit && !done) {
            var elem = nextElem();
            if (elem === null) {
              done = true;
              if (running <= 0) {
                callback(null);
              }
              return;
            }
            running += 1;
            iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));
          }
          looping = false;
        }
        replenish();
      };
    };
    module2.exports = exports2.default;
  }
});

// node_modules/async/eachOfLimit.js
var require_eachOfLimit2 = __commonJS({
  "node_modules/async/eachOfLimit.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _eachOfLimit2 = require_eachOfLimit();
    var _eachOfLimit3 = _interopRequireDefault(_eachOfLimit2);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachOfLimit(coll, limit, iteratee, callback) {
      return (0, _eachOfLimit3.default)(limit)(coll, (0, _wrapAsync2.default)(iteratee), callback);
    }
    exports2.default = (0, _awaitify2.default)(eachOfLimit, 4);
    module2.exports = exports2.default;
  }
});

// node_modules/async/eachOfSeries.js
var require_eachOfSeries = __commonJS({
  "node_modules/async/eachOfSeries.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _eachOfLimit = require_eachOfLimit2();
    var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachOfSeries(coll, iteratee, callback) {
      return (0, _eachOfLimit2.default)(coll, 1, iteratee, callback);
    }
    exports2.default = (0, _awaitify2.default)(eachOfSeries, 3);
    module2.exports = exports2.default;
  }
});

// node_modules/async/series.js
var require_series = __commonJS({
  "node_modules/async/series.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = series;
    var _parallel2 = require_parallel();
    var _parallel3 = _interopRequireDefault(_parallel2);
    var _eachOfSeries = require_eachOfSeries();
    var _eachOfSeries2 = _interopRequireDefault(_eachOfSeries);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function series(tasks, callback) {
      return (0, _parallel3.default)(_eachOfSeries2.default, tasks, callback);
    }
    module2.exports = exports2.default;
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform;
    var _require$codes = require_errors2().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex();
    require_inherits()(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform)) return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er) return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    require_inherits()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough)) return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports2, module2) {
    "use strict";
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called) return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors2().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop(err) {
      if (err) throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0) eos = require_end_of_stream();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err) return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed) return;
        if (destroyed) return;
        destroyed = true;
        if (isRequest(stream)) return stream.abort();
        if (typeof stream.destroy === "function") return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length) return noop;
      if (typeof streams[streams.length - 1] !== "function") return noop;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0])) streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error) error = err;
          if (err) destroys.forEach(call);
          if (reading) return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    module2.exports = pipeline;
  }
});

// node_modules/readable-stream/readable.js
var require_readable = __commonJS({
  "node_modules/readable-stream/readable.js"(exports2, module2) {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream.Readable;
      Object.assign(module2.exports, Stream);
      module2.exports.Stream = Stream;
    } else {
      exports2 = module2.exports = require_stream_readable();
      exports2.Stream = Stream || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable();
      exports2.Duplex = require_stream_duplex();
      exports2.Transform = require_stream_transform();
      exports2.PassThrough = require_stream_passthrough();
      exports2.finished = require_end_of_stream();
      exports2.pipeline = require_pipeline();
    }
  }
});

// node_modules/@dabh/diagnostics/diagnostics.js
var require_diagnostics = __commonJS({
  "node_modules/@dabh/diagnostics/diagnostics.js"(exports2, module2) {
    var adapters = [];
    var modifiers = [];
    var logger8 = function devnull() {
    };
    function use(adapter) {
      if (~adapters.indexOf(adapter)) return false;
      adapters.push(adapter);
      return true;
    }
    function set(custom) {
      logger8 = custom;
    }
    function enabled(namespace) {
      var async = [];
      for (var i = 0; i < adapters.length; i++) {
        if (adapters[i].async) {
          async.push(adapters[i]);
          continue;
        }
        if (adapters[i](namespace)) return true;
      }
      if (!async.length) return false;
      return new Promise(function pinky(resolve) {
        Promise.all(
          async.map(function prebind(fn) {
            return fn(namespace);
          })
        ).then(function resolved(values) {
          resolve(values.some(Boolean));
        });
      });
    }
    function modify(fn) {
      if (~modifiers.indexOf(fn)) return false;
      modifiers.push(fn);
      return true;
    }
    function write() {
      logger8.apply(logger8, arguments);
    }
    function process2(message) {
      for (var i = 0; i < modifiers.length; i++) {
        message = modifiers[i].apply(modifiers[i], arguments);
      }
      return message;
    }
    function introduce(fn, options) {
      var has = Object.prototype.hasOwnProperty;
      for (var key in options) {
        if (has.call(options, key)) {
          fn[key] = options[key];
        }
      }
      return fn;
    }
    function nope(options) {
      options.enabled = false;
      options.modify = modify;
      options.set = set;
      options.use = use;
      return introduce(function diagnopes() {
        return false;
      }, options);
    }
    function yep(options) {
      function diagnostics() {
        var args = Array.prototype.slice.call(arguments, 0);
        write.call(write, options, process2(args, options));
        return true;
      }
      options.enabled = true;
      options.modify = modify;
      options.set = set;
      options.use = use;
      return introduce(diagnostics, options);
    }
    module2.exports = function create(diagnostics) {
      diagnostics.introduce = introduce;
      diagnostics.enabled = enabled;
      diagnostics.process = process2;
      diagnostics.modify = modify;
      diagnostics.write = write;
      diagnostics.nope = nope;
      diagnostics.yep = yep;
      diagnostics.set = set;
      diagnostics.use = use;
      return diagnostics;
    };
  }
});

// node_modules/@dabh/diagnostics/node/production.js
var require_production = __commonJS({
  "node_modules/@dabh/diagnostics/node/production.js"(exports2, module2) {
    var create = require_diagnostics();
    var diagnostics = create(function prod(namespace, options) {
      options = options || {};
      options.namespace = namespace;
      options.prod = true;
      options.dev = false;
      if (!(options.force || prod.force)) return prod.nope(options);
      return prod.yep(options);
    });
    module2.exports = diagnostics;
  }
});

// node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/is-arrayish/index.js
var require_is_arrayish = __commonJS({
  "node_modules/is-arrayish/index.js"(exports2, module2) {
    module2.exports = function isArrayish(obj) {
      if (!obj || typeof obj === "string") {
        return false;
      }
      return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
    };
  }
});

// node_modules/simple-swizzle/index.js
var require_simple_swizzle = __commonJS({
  "node_modules/simple-swizzle/index.js"(exports2, module2) {
    "use strict";
    var isArrayish = require_is_arrayish();
    var concat2 = Array.prototype.concat;
    var slice = Array.prototype.slice;
    var swizzle = module2.exports = function swizzle2(args) {
      var results = [];
      for (var i = 0, len = args.length; i < len; i++) {
        var arg = args[i];
        if (isArrayish(arg)) {
          results = concat2.call(results, slice.call(arg));
        } else {
          results.push(arg);
        }
      }
      return results;
    };
    swizzle.wrap = function(fn) {
      return function() {
        return fn(swizzle(arguments));
      };
    };
  }
});

// node_modules/color-string/index.js
var require_color_string = __commonJS({
  "node_modules/color-string/index.js"(exports2, module2) {
    var colorNames = require_color_name();
    var swizzle = require_simple_swizzle();
    var hasOwnProperty2 = Object.hasOwnProperty;
    var reverseNames = /* @__PURE__ */ Object.create(null);
    for (name in colorNames) {
      if (hasOwnProperty2.call(colorNames, name)) {
        reverseNames[colorNames[name]] = name;
      }
    }
    var name;
    var cs = module2.exports = {
      to: {},
      get: {}
    };
    cs.get = function(string) {
      var prefix = string.substring(0, 3).toLowerCase();
      var val;
      var model;
      switch (prefix) {
        case "hsl":
          val = cs.get.hsl(string);
          model = "hsl";
          break;
        case "hwb":
          val = cs.get.hwb(string);
          model = "hwb";
          break;
        default:
          val = cs.get.rgb(string);
          model = "rgb";
          break;
      }
      if (!val) {
        return null;
      }
      return { model, value: val };
    };
    cs.get.rgb = function(string) {
      if (!string) {
        return null;
      }
      var abbr = /^#([a-f0-9]{3,4})$/i;
      var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
      var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var keyword = /^(\w+)$/;
      var rgb = [0, 0, 0, 1];
      var match;
      var i;
      var hexAlpha;
      if (match = string.match(hex)) {
        hexAlpha = match[2];
        match = match[1];
        for (i = 0; i < 3; i++) {
          var i2 = i * 2;
          rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha, 16) / 255;
        }
      } else if (match = string.match(abbr)) {
        match = match[1];
        hexAlpha = match[3];
        for (i = 0; i < 3; i++) {
          rgb[i] = parseInt(match[i] + match[i], 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
        }
      } else if (match = string.match(rgba)) {
        for (i = 0; i < 3; i++) {
          rgb[i] = parseInt(match[i + 1], 0);
        }
        if (match[4]) {
          if (match[5]) {
            rgb[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string.match(per)) {
        for (i = 0; i < 3; i++) {
          rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
        }
        if (match[4]) {
          if (match[5]) {
            rgb[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string.match(keyword)) {
        if (match[1] === "transparent") {
          return [0, 0, 0, 0];
        }
        if (!hasOwnProperty2.call(colorNames, match[1])) {
          return null;
        }
        rgb = colorNames[match[1]];
        rgb[3] = 1;
        return rgb;
      } else {
        return null;
      }
      for (i = 0; i < 3; i++) {
        rgb[i] = clamp(rgb[i], 0, 255);
      }
      rgb[3] = clamp(rgb[3], 0, 1);
      return rgb;
    };
    cs.get.hsl = function(string) {
      if (!string) {
        return null;
      }
      var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string.match(hsl);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h = (parseFloat(match[1]) % 360 + 360) % 360;
        var s = clamp(parseFloat(match[2]), 0, 100);
        var l = clamp(parseFloat(match[3]), 0, 100);
        var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, s, l, a];
      }
      return null;
    };
    cs.get.hwb = function(string) {
      if (!string) {
        return null;
      }
      var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string.match(hwb);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h = (parseFloat(match[1]) % 360 + 360) % 360;
        var w = clamp(parseFloat(match[2]), 0, 100);
        var b = clamp(parseFloat(match[3]), 0, 100);
        var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, w, b, a];
      }
      return null;
    };
    cs.to.hex = function() {
      var rgba = swizzle(arguments);
      return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
    };
    cs.to.rgb = function() {
      var rgba = swizzle(arguments);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
    };
    cs.to.rgb.percent = function() {
      var rgba = swizzle(arguments);
      var r = Math.round(rgba[0] / 255 * 100);
      var g = Math.round(rgba[1] / 255 * 100);
      var b = Math.round(rgba[2] / 255 * 100);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r + "%, " + g + "%, " + b + "%)" : "rgba(" + r + "%, " + g + "%, " + b + "%, " + rgba[3] + ")";
    };
    cs.to.hsl = function() {
      var hsla = swizzle(arguments);
      return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
    };
    cs.to.hwb = function() {
      var hwba = swizzle(arguments);
      var a = "";
      if (hwba.length >= 4 && hwba[3] !== 1) {
        a = ", " + hwba[3];
      }
      return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a + ")";
    };
    cs.to.keyword = function(rgb) {
      return reverseNames[rgb.slice(0, 3)];
    };
    function clamp(num, min, max) {
      return Math.min(Math.max(min, num), max);
    }
    function hexDouble(num) {
      var str = Math.round(num).toString(16).toUpperCase();
      return str.length < 2 ? "0" + str : str;
    }
  }
});

// node_modules/color/node_modules/color-name/index.js
var require_color_name2 = __commonJS({
  "node_modules/color/node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/color/node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/color/node_modules/color-convert/conversions.js"(exports2, module2) {
    var cssKeywords = require_color_name2();
    var reverseKeywords = {};
    for (key in cssKeywords) {
      if (cssKeywords.hasOwnProperty(key)) {
        reverseKeywords[cssKeywords[key]] = key;
      }
    }
    var key;
    var convert = module2.exports = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    for (model in convert) {
      if (convert.hasOwnProperty(model)) {
        if (!("channels" in convert[model])) {
          throw new Error("missing channels property: " + model);
        }
        if (!("labels" in convert[model])) {
          throw new Error("missing channel labels property: " + model);
        }
        if (convert[model].labels.length !== convert[model].channels) {
          throw new Error("channel and label counts mismatch: " + model);
        }
        channels = convert[model].channels;
        labels = convert[model].labels;
        delete convert[model].channels;
        delete convert[model].labels;
        Object.defineProperty(convert[model], "channels", { value: channels });
        Object.defineProperty(convert[model], "labels", { value: labels });
      }
    }
    var channels;
    var labels;
    var model;
    convert.rgb.hsl = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var min = Math.min(r, g, b);
      var max = Math.max(r, g, b);
      var delta = max - min;
      var h;
      var s;
      var l;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      var rdif;
      var gdif;
      var bdif;
      var h;
      var s;
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var v = Math.max(r, g, b);
      var diff = v - Math.min(r, g, b);
      var diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      var r = rgb[0];
      var g = rgb[1];
      var b = rgb[2];
      var h = convert.rgb.hsl(rgb)[0];
      var w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var c;
      var m;
      var y;
      var k;
      k = Math.min(1 - r, 1 - g, 1 - b);
      c = (1 - r - k) / (1 - k) || 0;
      m = (1 - g - k) / (1 - k) || 0;
      y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
    }
    convert.rgb.keyword = function(rgb) {
      var reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      var currentClosestDistance = Infinity;
      var currentClosestKeyword;
      for (var keyword in cssKeywords) {
        if (cssKeywords.hasOwnProperty(keyword)) {
          var value = cssKeywords[keyword];
          var distance = comparativeDistance(rgb, value);
          if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
          }
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      var xyz = convert.rgb.xyz(rgb);
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      var h = hsl[0] / 360;
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var t1;
      var t2;
      var t3;
      var rgb;
      var val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      t1 = 2 * l - t2;
      rgb = [0, 0, 0];
      for (var i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      var h = hsl[0];
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var smin = s;
      var lmin = Math.max(l, 0.01);
      var sv;
      var v;
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      v = (l + s) / 2;
      sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      var h = hsv[0] / 60;
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var hi = Math.floor(h) % 6;
      var f = h - Math.floor(h);
      var p = 255 * v * (1 - s);
      var q = 255 * v * (1 - s * f);
      var t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      var h = hsv[0];
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var vmin = Math.max(v, 0.01);
      var lmin;
      var sl;
      var l;
      l = (2 - s) * v;
      lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      var h = hwb[0] / 360;
      var wh = hwb[1] / 100;
      var bl = hwb[2] / 100;
      var ratio = wh + bl;
      var i;
      var v;
      var f;
      var n;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      i = Math.floor(6 * h);
      v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      n = wh + f * (v - wh);
      var r;
      var g;
      var b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      var c = cmyk[0] / 100;
      var m = cmyk[1] / 100;
      var y = cmyk[2] / 100;
      var k = cmyk[3] / 100;
      var r;
      var g;
      var b;
      r = 1 - Math.min(1, c * (1 - k) + k);
      g = 1 - Math.min(1, m * (1 - k) + k);
      b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      var x = xyz[0] / 100;
      var y = xyz[1] / 100;
      var z = xyz[2] / 100;
      var r;
      var g;
      var b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var x;
      var y;
      var z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      var y2 = Math.pow(y, 3);
      var x2 = Math.pow(x, 3);
      var z2 = Math.pow(z, 3);
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var hr;
      var h;
      var c;
      hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      var l = lch[0];
      var c = lch[1];
      var h = lch[2];
      var a;
      var b;
      var hr;
      hr = h / 360 * 2 * Math.PI;
      a = c * Math.cos(hr);
      b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      var color2 = args % 10;
      if (color2 === 0 || color2 === 7) {
        if (args > 50) {
          color2 += 3.5;
        }
        color2 = color2 / 10.5 * 255;
        return [color2, color2, color2];
      }
      var mult = (~~(args > 50) + 1) * 0.5;
      var r = (color2 & 1) * mult * 255;
      var g = (color2 >> 1 & 1) * mult * 255;
      var b = (color2 >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        var c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      var rem;
      var r = Math.floor(args / 36) / 5 * 255;
      var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      var b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      var colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map(function(char) {
          return char + char;
        }).join("");
      }
      var integer = parseInt(colorString, 16);
      var r = integer >> 16 & 255;
      var g = integer >> 8 & 255;
      var b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var max = Math.max(Math.max(r, g), b);
      var min = Math.min(Math.min(r, g), b);
      var chroma = max - min;
      var grayscale;
      var hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma + 4;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var c = 1;
      var f = 0;
      if (l < 0.5) {
        c = 2 * s * l;
      } else {
        c = 2 * s * (1 - l);
      }
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var c = s * v;
      var f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      var h = hcg[0] / 360;
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      var pure = [0, 0, 0];
      var hi = h % 1 * 6;
      var v = hi % 1;
      var w = 1 - v;
      var mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      var f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var l = g * (1 - c) + 0.5 * c;
      var s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      var w = hwb[1] / 100;
      var b = hwb[2] / 100;
      var v = 1 - b;
      var c = v - w;
      var g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = convert.gray.hsv = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      var val = Math.round(gray[0] / 100 * 255) & 255;
      var integer = (val << 16) + (val << 8) + val;
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/color/node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/color/node_modules/color-convert/route.js"(exports2, module2) {
    var conversions = require_conversions();
    function buildGraph() {
      var graph = {};
      var models = Object.keys(conversions);
      for (var len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      var graph = buildGraph();
      var queue2 = [fromModel];
      graph[fromModel].distance = 0;
      while (queue2.length) {
        var current = queue2.pop();
        var adjacents = Object.keys(conversions[current]);
        for (var len = adjacents.length, i = 0; i < len; i++) {
          var adjacent = adjacents[i];
          var node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue2.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      var path = [graph[toModel].parent, toModel];
      var fn = conversions[graph[toModel].parent][toModel];
      var cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module2.exports = function(fromModel) {
      var graph = deriveBFS(fromModel);
      var conversion = {};
      var models = Object.keys(graph);
      for (var len = models.length, i = 0; i < len; i++) {
        var toModel = models[i];
        var node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/color/node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/color/node_modules/color-convert/index.js"(exports2, module2) {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        var result = fn(args);
        if (typeof result === "object") {
          for (var len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach(function(fromModel) {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      var routes = route(fromModel);
      var routeModels = Object.keys(routes);
      routeModels.forEach(function(toModel) {
        var fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// node_modules/color/index.js
var require_color = __commonJS({
  "node_modules/color/index.js"(exports2, module2) {
    "use strict";
    var colorString = require_color_string();
    var convert = require_color_convert();
    var _slice = [].slice;
    var skippedModels = [
      // to be honest, I don't really feel like keyword belongs in color convert, but eh.
      "keyword",
      // gray conflicts with some method names, and has its own method defined.
      "gray",
      // shouldn't really be in color-convert either...
      "hex"
    ];
    var hashedModelKeys = {};
    Object.keys(convert).forEach(function(model) {
      hashedModelKeys[_slice.call(convert[model].labels).sort().join("")] = model;
    });
    var limiters = {};
    function Color(obj, model) {
      if (!(this instanceof Color)) {
        return new Color(obj, model);
      }
      if (model && model in skippedModels) {
        model = null;
      }
      if (model && !(model in convert)) {
        throw new Error("Unknown model: " + model);
      }
      var i;
      var channels;
      if (obj == null) {
        this.model = "rgb";
        this.color = [0, 0, 0];
        this.valpha = 1;
      } else if (obj instanceof Color) {
        this.model = obj.model;
        this.color = obj.color.slice();
        this.valpha = obj.valpha;
      } else if (typeof obj === "string") {
        var result = colorString.get(obj);
        if (result === null) {
          throw new Error("Unable to parse color from string: " + obj);
        }
        this.model = result.model;
        channels = convert[this.model].channels;
        this.color = result.value.slice(0, channels);
        this.valpha = typeof result.value[channels] === "number" ? result.value[channels] : 1;
      } else if (obj.length) {
        this.model = model || "rgb";
        channels = convert[this.model].channels;
        var newArr = _slice.call(obj, 0, channels);
        this.color = zeroArray(newArr, channels);
        this.valpha = typeof obj[channels] === "number" ? obj[channels] : 1;
      } else if (typeof obj === "number") {
        obj &= 16777215;
        this.model = "rgb";
        this.color = [
          obj >> 16 & 255,
          obj >> 8 & 255,
          obj & 255
        ];
        this.valpha = 1;
      } else {
        this.valpha = 1;
        var keys = Object.keys(obj);
        if ("alpha" in obj) {
          keys.splice(keys.indexOf("alpha"), 1);
          this.valpha = typeof obj.alpha === "number" ? obj.alpha : 0;
        }
        var hashedKeys = keys.sort().join("");
        if (!(hashedKeys in hashedModelKeys)) {
          throw new Error("Unable to parse color from object: " + JSON.stringify(obj));
        }
        this.model = hashedModelKeys[hashedKeys];
        var labels = convert[this.model].labels;
        var color2 = [];
        for (i = 0; i < labels.length; i++) {
          color2.push(obj[labels[i]]);
        }
        this.color = zeroArray(color2);
      }
      if (limiters[this.model]) {
        channels = convert[this.model].channels;
        for (i = 0; i < channels; i++) {
          var limit = limiters[this.model][i];
          if (limit) {
            this.color[i] = limit(this.color[i]);
          }
        }
      }
      this.valpha = Math.max(0, Math.min(1, this.valpha));
      if (Object.freeze) {
        Object.freeze(this);
      }
    }
    Color.prototype = {
      toString: function() {
        return this.string();
      },
      toJSON: function() {
        return this[this.model]();
      },
      string: function(places) {
        var self2 = this.model in colorString.to ? this : this.rgb();
        self2 = self2.round(typeof places === "number" ? places : 1);
        var args = self2.valpha === 1 ? self2.color : self2.color.concat(this.valpha);
        return colorString.to[self2.model](args);
      },
      percentString: function(places) {
        var self2 = this.rgb().round(typeof places === "number" ? places : 1);
        var args = self2.valpha === 1 ? self2.color : self2.color.concat(this.valpha);
        return colorString.to.rgb.percent(args);
      },
      array: function() {
        return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);
      },
      object: function() {
        var result = {};
        var channels = convert[this.model].channels;
        var labels = convert[this.model].labels;
        for (var i = 0; i < channels; i++) {
          result[labels[i]] = this.color[i];
        }
        if (this.valpha !== 1) {
          result.alpha = this.valpha;
        }
        return result;
      },
      unitArray: function() {
        var rgb = this.rgb().color;
        rgb[0] /= 255;
        rgb[1] /= 255;
        rgb[2] /= 255;
        if (this.valpha !== 1) {
          rgb.push(this.valpha);
        }
        return rgb;
      },
      unitObject: function() {
        var rgb = this.rgb().object();
        rgb.r /= 255;
        rgb.g /= 255;
        rgb.b /= 255;
        if (this.valpha !== 1) {
          rgb.alpha = this.valpha;
        }
        return rgb;
      },
      round: function(places) {
        places = Math.max(places || 0, 0);
        return new Color(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);
      },
      alpha: function(val) {
        if (arguments.length) {
          return new Color(this.color.concat(Math.max(0, Math.min(1, val))), this.model);
        }
        return this.valpha;
      },
      // rgb
      red: getset("rgb", 0, maxfn(255)),
      green: getset("rgb", 1, maxfn(255)),
      blue: getset("rgb", 2, maxfn(255)),
      hue: getset(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, function(val) {
        return (val % 360 + 360) % 360;
      }),
      // eslint-disable-line brace-style
      saturationl: getset("hsl", 1, maxfn(100)),
      lightness: getset("hsl", 2, maxfn(100)),
      saturationv: getset("hsv", 1, maxfn(100)),
      value: getset("hsv", 2, maxfn(100)),
      chroma: getset("hcg", 1, maxfn(100)),
      gray: getset("hcg", 2, maxfn(100)),
      white: getset("hwb", 1, maxfn(100)),
      wblack: getset("hwb", 2, maxfn(100)),
      cyan: getset("cmyk", 0, maxfn(100)),
      magenta: getset("cmyk", 1, maxfn(100)),
      yellow: getset("cmyk", 2, maxfn(100)),
      black: getset("cmyk", 3, maxfn(100)),
      x: getset("xyz", 0, maxfn(100)),
      y: getset("xyz", 1, maxfn(100)),
      z: getset("xyz", 2, maxfn(100)),
      l: getset("lab", 0, maxfn(100)),
      a: getset("lab", 1),
      b: getset("lab", 2),
      keyword: function(val) {
        if (arguments.length) {
          return new Color(val);
        }
        return convert[this.model].keyword(this.color);
      },
      hex: function(val) {
        if (arguments.length) {
          return new Color(val);
        }
        return colorString.to.hex(this.rgb().round().color);
      },
      rgbNumber: function() {
        var rgb = this.rgb().color;
        return (rgb[0] & 255) << 16 | (rgb[1] & 255) << 8 | rgb[2] & 255;
      },
      luminosity: function() {
        var rgb = this.rgb().color;
        var lum = [];
        for (var i = 0; i < rgb.length; i++) {
          var chan = rgb[i] / 255;
          lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
        }
        return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
      },
      contrast: function(color2) {
        var lum1 = this.luminosity();
        var lum2 = color2.luminosity();
        if (lum1 > lum2) {
          return (lum1 + 0.05) / (lum2 + 0.05);
        }
        return (lum2 + 0.05) / (lum1 + 0.05);
      },
      level: function(color2) {
        var contrastRatio = this.contrast(color2);
        if (contrastRatio >= 7.1) {
          return "AAA";
        }
        return contrastRatio >= 4.5 ? "AA" : "";
      },
      isDark: function() {
        var rgb = this.rgb().color;
        var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1e3;
        return yiq < 128;
      },
      isLight: function() {
        return !this.isDark();
      },
      negate: function() {
        var rgb = this.rgb();
        for (var i = 0; i < 3; i++) {
          rgb.color[i] = 255 - rgb.color[i];
        }
        return rgb;
      },
      lighten: function(ratio) {
        var hsl = this.hsl();
        hsl.color[2] += hsl.color[2] * ratio;
        return hsl;
      },
      darken: function(ratio) {
        var hsl = this.hsl();
        hsl.color[2] -= hsl.color[2] * ratio;
        return hsl;
      },
      saturate: function(ratio) {
        var hsl = this.hsl();
        hsl.color[1] += hsl.color[1] * ratio;
        return hsl;
      },
      desaturate: function(ratio) {
        var hsl = this.hsl();
        hsl.color[1] -= hsl.color[1] * ratio;
        return hsl;
      },
      whiten: function(ratio) {
        var hwb = this.hwb();
        hwb.color[1] += hwb.color[1] * ratio;
        return hwb;
      },
      blacken: function(ratio) {
        var hwb = this.hwb();
        hwb.color[2] += hwb.color[2] * ratio;
        return hwb;
      },
      grayscale: function() {
        var rgb = this.rgb().color;
        var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
        return Color.rgb(val, val, val);
      },
      fade: function(ratio) {
        return this.alpha(this.valpha - this.valpha * ratio);
      },
      opaquer: function(ratio) {
        return this.alpha(this.valpha + this.valpha * ratio);
      },
      rotate: function(degrees) {
        var hsl = this.hsl();
        var hue = hsl.color[0];
        hue = (hue + degrees) % 360;
        hue = hue < 0 ? 360 + hue : hue;
        hsl.color[0] = hue;
        return hsl;
      },
      mix: function(mixinColor, weight) {
        if (!mixinColor || !mixinColor.rgb) {
          throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
        }
        var color1 = mixinColor.rgb();
        var color2 = this.rgb();
        var p = weight === void 0 ? 0.5 : weight;
        var w = 2 * p - 1;
        var a = color1.alpha() - color2.alpha();
        var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
        var w2 = 1 - w1;
        return Color.rgb(
          w1 * color1.red() + w2 * color2.red(),
          w1 * color1.green() + w2 * color2.green(),
          w1 * color1.blue() + w2 * color2.blue(),
          color1.alpha() * p + color2.alpha() * (1 - p)
        );
      }
    };
    Object.keys(convert).forEach(function(model) {
      if (skippedModels.indexOf(model) !== -1) {
        return;
      }
      var channels = convert[model].channels;
      Color.prototype[model] = function() {
        if (this.model === model) {
          return new Color(this);
        }
        if (arguments.length) {
          return new Color(arguments, model);
        }
        var newAlpha = typeof arguments[channels] === "number" ? channels : this.valpha;
        return new Color(assertArray(convert[this.model][model].raw(this.color)).concat(newAlpha), model);
      };
      Color[model] = function(color2) {
        if (typeof color2 === "number") {
          color2 = zeroArray(_slice.call(arguments), channels);
        }
        return new Color(color2, model);
      };
    });
    function roundTo(num, places) {
      return Number(num.toFixed(places));
    }
    function roundToPlace(places) {
      return function(num) {
        return roundTo(num, places);
      };
    }
    function getset(model, channel, modifier) {
      model = Array.isArray(model) ? model : [model];
      model.forEach(function(m) {
        (limiters[m] || (limiters[m] = []))[channel] = modifier;
      });
      model = model[0];
      return function(val) {
        var result;
        if (arguments.length) {
          if (modifier) {
            val = modifier(val);
          }
          result = this[model]();
          result.color[channel] = val;
          return result;
        }
        result = this[model]().color[channel];
        if (modifier) {
          result = modifier(result);
        }
        return result;
      };
    }
    function maxfn(max) {
      return function(v) {
        return Math.max(0, Math.min(max, v));
      };
    }
    function assertArray(val) {
      return Array.isArray(val) ? val : [val];
    }
    function zeroArray(arr2, length) {
      for (var i = 0; i < length; i++) {
        if (typeof arr2[i] !== "number") {
          arr2[i] = 0;
        }
      }
      return arr2;
    }
    module2.exports = Color;
  }
});

// node_modules/text-hex/index.js
var require_text_hex = __commonJS({
  "node_modules/text-hex/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function hex(str) {
      for (var i = 0, hash = 0; i < str.length; hash = str.charCodeAt(i++) + ((hash << 5) - hash)) ;
      var color2 = Math.floor(
        Math.abs(
          Math.sin(hash) * 1e4 % 1 * 16777216
        )
      ).toString(16);
      return "#" + Array(6 - color2.length + 1).join("0") + color2;
    };
  }
});

// node_modules/colorspace/index.js
var require_colorspace = __commonJS({
  "node_modules/colorspace/index.js"(exports2, module2) {
    "use strict";
    var color2 = require_color();
    var hex = require_text_hex();
    module2.exports = function colorspace(namespace, delimiter) {
      var split = namespace.split(delimiter || ":");
      var base = hex(split[0]);
      if (!split.length) return base;
      for (var i = 0, l = split.length - 1; i < l; i++) {
        base = color2(base).mix(color2(hex(split[i + 1]))).saturate(1).hex();
      }
      return base;
    };
  }
});

// node_modules/kuler/index.js
var require_kuler = __commonJS({
  "node_modules/kuler/index.js"(exports2, module2) {
    "use strict";
    function Kuler(text, color2) {
      if (color2) return new Kuler(text).style(color2);
      if (!(this instanceof Kuler)) return new Kuler(text);
      this.text = text;
    }
    Kuler.prototype.prefix = "\x1B[";
    Kuler.prototype.suffix = "m";
    Kuler.prototype.hex = function hex(color2) {
      color2 = color2[0] === "#" ? color2.substring(1) : color2;
      if (color2.length === 3) {
        color2 = color2.split("");
        color2[5] = color2[2];
        color2[4] = color2[2];
        color2[3] = color2[1];
        color2[2] = color2[1];
        color2[1] = color2[0];
        color2 = color2.join("");
      }
      var r = color2.substring(0, 2), g = color2.substring(2, 4), b = color2.substring(4, 6);
      return [parseInt(r, 16), parseInt(g, 16), parseInt(b, 16)];
    };
    Kuler.prototype.rgb = function rgb(r, g, b) {
      var red = r / 255 * 5, green = g / 255 * 5, blue = b / 255 * 5;
      return this.ansi(red, green, blue);
    };
    Kuler.prototype.ansi = function ansi(r, g, b) {
      var red = Math.round(r), green = Math.round(g), blue = Math.round(b);
      return 16 + red * 36 + green * 6 + blue;
    };
    Kuler.prototype.reset = function reset() {
      return this.prefix + "39;49" + this.suffix;
    };
    Kuler.prototype.style = function style(color2) {
      return this.prefix + "38;5;" + this.rgb.apply(this, this.hex(color2)) + this.suffix + this.text + this.reset();
    };
    module2.exports = Kuler;
  }
});

// node_modules/@dabh/diagnostics/modifiers/namespace-ansi.js
var require_namespace_ansi = __commonJS({
  "node_modules/@dabh/diagnostics/modifiers/namespace-ansi.js"(exports2, module2) {
    var colorspace = require_colorspace();
    var kuler = require_kuler();
    module2.exports = function ansiModifier(args, options) {
      var namespace = options.namespace;
      var ansi = options.colors !== false ? kuler(namespace + ":", colorspace(namespace)) : namespace + ":";
      args[0] = ansi + " " + args[0];
      return args;
    };
  }
});

// node_modules/enabled/index.js
var require_enabled = __commonJS({
  "node_modules/enabled/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function enabled(name, variable) {
      if (!variable) return false;
      var variables = variable.split(/[\s,]+/), i = 0;
      for (; i < variables.length; i++) {
        variable = variables[i].replace("*", ".*?");
        if ("-" === variable.charAt(0)) {
          if (new RegExp("^" + variable.substr(1) + "$").test(name)) {
            return false;
          }
          continue;
        }
        if (new RegExp("^" + variable + "$").test(name)) {
          return true;
        }
      }
      return false;
    };
  }
});

// node_modules/@dabh/diagnostics/adapters/index.js
var require_adapters = __commonJS({
  "node_modules/@dabh/diagnostics/adapters/index.js"(exports2, module2) {
    var enabled = require_enabled();
    module2.exports = function create(fn) {
      return function adapter(namespace) {
        try {
          return enabled(namespace, fn());
        } catch (e) {
        }
        return false;
      };
    };
  }
});

// node_modules/@dabh/diagnostics/adapters/process.env.js
var require_process_env = __commonJS({
  "node_modules/@dabh/diagnostics/adapters/process.env.js"(exports2, module2) {
    var adapter = require_adapters();
    module2.exports = adapter(function processenv() {
      return process.env.DEBUG || process.env.DIAGNOSTICS;
    });
  }
});

// node_modules/@dabh/diagnostics/logger/console.js
var require_console2 = __commonJS({
  "node_modules/@dabh/diagnostics/logger/console.js"(exports2, module2) {
    module2.exports = function(meta, messages) {
      try {
        Function.prototype.apply.call(console.log, console, messages);
      } catch (e) {
      }
    };
  }
});

// node_modules/@dabh/diagnostics/node/development.js
var require_development = __commonJS({
  "node_modules/@dabh/diagnostics/node/development.js"(exports2, module2) {
    var create = require_diagnostics();
    var tty = require("tty").isatty(1);
    var diagnostics = create(function dev(namespace, options) {
      options = options || {};
      options.colors = "colors" in options ? options.colors : tty;
      options.namespace = namespace;
      options.prod = false;
      options.dev = true;
      if (!dev.enabled(namespace) && !(options.force || dev.force)) {
        return dev.nope(options);
      }
      return dev.yep(options);
    });
    diagnostics.modify(require_namespace_ansi());
    diagnostics.use(require_process_env());
    diagnostics.set(require_console2());
    module2.exports = diagnostics;
  }
});

// node_modules/@dabh/diagnostics/node/index.js
var require_node2 = __commonJS({
  "node_modules/@dabh/diagnostics/node/index.js"(exports2, module2) {
    if (process.env.NODE_ENV === "production") {
      module2.exports = require_production();
    } else {
      module2.exports = require_development();
    }
  }
});

// node_modules/winston/lib/winston/tail-file.js
var require_tail_file = __commonJS({
  "node_modules/winston/lib/winston/tail-file.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var { StringDecoder } = require("string_decoder");
    var { Stream } = require_readable();
    function noop() {
    }
    module2.exports = (options, iter) => {
      const buffer = Buffer.alloc(64 * 1024);
      const decode = new StringDecoder("utf8");
      const stream = new Stream();
      let buff = "";
      let pos = 0;
      let row = 0;
      if (options.start === -1) {
        delete options.start;
      }
      stream.readable = true;
      stream.destroy = () => {
        stream.destroyed = true;
        stream.emit("end");
        stream.emit("close");
      };
      fs.open(options.file, "a+", "0644", (err, fd) => {
        if (err) {
          if (!iter) {
            stream.emit("error", err);
          } else {
            iter(err);
          }
          stream.destroy();
          return;
        }
        (function read() {
          if (stream.destroyed) {
            fs.close(fd, noop);
            return;
          }
          return fs.read(fd, buffer, 0, buffer.length, pos, (error, bytes) => {
            if (error) {
              if (!iter) {
                stream.emit("error", error);
              } else {
                iter(error);
              }
              stream.destroy();
              return;
            }
            if (!bytes) {
              if (buff) {
                if (options.start == null || row > options.start) {
                  if (!iter) {
                    stream.emit("line", buff);
                  } else {
                    iter(null, buff);
                  }
                }
                row++;
                buff = "";
              }
              return setTimeout(read, 1e3);
            }
            let data = decode.write(buffer.slice(0, bytes));
            if (!iter) {
              stream.emit("data", data);
            }
            data = (buff + data).split(/\n+/);
            const l = data.length - 1;
            let i = 0;
            for (; i < l; i++) {
              if (options.start == null || row > options.start) {
                if (!iter) {
                  stream.emit("line", data[i]);
                } else {
                  iter(null, data[i]);
                }
              }
              row++;
            }
            buff = data[l];
            pos += bytes;
            return read();
          });
        })();
      });
      if (!iter) {
        return stream;
      }
      return stream.destroy;
    };
  }
});

// node_modules/winston/lib/winston/transports/file.js
var require_file = __commonJS({
  "node_modules/winston/lib/winston/transports/file.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var asyncSeries = require_series();
    var zlib = require("zlib");
    var { MESSAGE } = require_triple_beam();
    var { Stream, PassThrough } = require_readable();
    var TransportStream = require_winston_transport();
    var debug = require_node2()("winston:file");
    var os = require("os");
    var tailFile = require_tail_file();
    module2.exports = class File extends TransportStream {
      /**
       * Constructor function for the File transport object responsible for
       * persisting log messages and metadata to one or more files.
       * @param {Object} options - Options for this instance.
       */
      constructor(options = {}) {
        super(options);
        this.name = options.name || "file";
        function throwIf(target, ...args) {
          args.slice(1).forEach((name) => {
            if (options[name]) {
              throw new Error(`Cannot set ${name} and ${target} together`);
            }
          });
        }
        this._stream = new PassThrough();
        this._stream.setMaxListeners(30);
        this._onError = this._onError.bind(this);
        if (options.filename || options.dirname) {
          throwIf("filename or dirname", "stream");
          this._basename = this.filename = options.filename ? path.basename(options.filename) : "winston.log";
          this.dirname = options.dirname || path.dirname(options.filename);
          this.options = options.options || { flags: "a" };
        } else if (options.stream) {
          console.warn("options.stream will be removed in winston@4. Use winston.transports.Stream");
          throwIf("stream", "filename", "maxsize");
          this._dest = this._stream.pipe(this._setupStream(options.stream));
          this.dirname = path.dirname(this._dest.path);
        } else {
          throw new Error("Cannot log to file without filename or stream.");
        }
        this.maxsize = options.maxsize || null;
        this.rotationFormat = options.rotationFormat || false;
        this.zippedArchive = options.zippedArchive || false;
        this.maxFiles = options.maxFiles || null;
        this.eol = typeof options.eol === "string" ? options.eol : os.EOL;
        this.tailable = options.tailable || false;
        this.lazy = options.lazy || false;
        this._size = 0;
        this._pendingSize = 0;
        this._created = 0;
        this._drain = false;
        this._opening = false;
        this._ending = false;
        this._fileExist = false;
        if (this.dirname) this._createLogDirIfNotExist(this.dirname);
        if (!this.lazy) this.open();
      }
      finishIfEnding() {
        if (this._ending) {
          if (this._opening) {
            this.once("open", () => {
              this._stream.once("finish", () => this.emit("finish"));
              setImmediate(() => this._stream.end());
            });
          } else {
            this._stream.once("finish", () => this.emit("finish"));
            setImmediate(() => this._stream.end());
          }
        }
      }
      /**
       * Core logging method exposed to Winston. Metadata is optional.
       * @param {Object} info - TODO: add param description.
       * @param {Function} callback - TODO: add param description.
       * @returns {undefined}
       */
      log(info, callback = () => {
      }) {
        if (this.silent) {
          callback();
          return true;
        }
        if (this._drain) {
          this._stream.once("drain", () => {
            this._drain = false;
            this.log(info, callback);
          });
          return;
        }
        if (this._rotate) {
          this._stream.once("rotate", () => {
            this._rotate = false;
            this.log(info, callback);
          });
          return;
        }
        if (this.lazy) {
          if (!this._fileExist) {
            if (!this._opening) {
              this.open();
            }
            this.once("open", () => {
              this._fileExist = true;
              this.log(info, callback);
              return;
            });
            return;
          }
          if (this._needsNewFile(this._pendingSize)) {
            this._dest.once("close", () => {
              if (!this._opening) {
                this.open();
              }
              this.once("open", () => {
                this.log(info, callback);
                return;
              });
              return;
            });
            return;
          }
        }
        const output = `${info[MESSAGE]}${this.eol}`;
        const bytes = Buffer.byteLength(output);
        function logged() {
          this._size += bytes;
          this._pendingSize -= bytes;
          debug("logged %s %s", this._size, output);
          this.emit("logged", info);
          if (this._rotate) {
            return;
          }
          if (this._opening) {
            return;
          }
          if (!this._needsNewFile()) {
            return;
          }
          if (this.lazy) {
            this._endStream(() => {
              this.emit("fileclosed");
            });
            return;
          }
          this._rotate = true;
          this._endStream(() => this._rotateFile());
        }
        this._pendingSize += bytes;
        if (this._opening && !this.rotatedWhileOpening && this._needsNewFile(this._size + this._pendingSize)) {
          this.rotatedWhileOpening = true;
        }
        const written = this._stream.write(output, logged.bind(this));
        if (!written) {
          this._drain = true;
          this._stream.once("drain", () => {
            this._drain = false;
            callback();
          });
        } else {
          callback();
        }
        debug("written", written, this._drain);
        this.finishIfEnding();
        return written;
      }
      /**
       * Query the transport. Options object is optional.
       * @param {Object} options - Loggly-like query options for this instance.
       * @param {function} callback - Continuation to respond to when complete.
       * TODO: Refactor me.
       */
      query(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = normalizeQuery(options);
        const file = path.join(this.dirname, this.filename);
        let buff = "";
        let results = [];
        let row = 0;
        const stream = fs.createReadStream(file, {
          encoding: "utf8"
        });
        stream.on("error", (err) => {
          if (stream.readable) {
            stream.destroy();
          }
          if (!callback) {
            return;
          }
          return err.code !== "ENOENT" ? callback(err) : callback(null, results);
        });
        stream.on("data", (data) => {
          data = (buff + data).split(/\n+/);
          const l = data.length - 1;
          let i = 0;
          for (; i < l; i++) {
            if (!options.start || row >= options.start) {
              add(data[i]);
            }
            row++;
          }
          buff = data[l];
        });
        stream.on("close", () => {
          if (buff) {
            add(buff, true);
          }
          if (options.order === "desc") {
            results = results.reverse();
          }
          if (callback) callback(null, results);
        });
        function add(buff2, attempt) {
          try {
            const log = JSON.parse(buff2);
            if (check(log)) {
              push(log);
            }
          } catch (e) {
            if (!attempt) {
              stream.emit("error", e);
            }
          }
        }
        function push(log) {
          if (options.rows && results.length >= options.rows && options.order !== "desc") {
            if (stream.readable) {
              stream.destroy();
            }
            return;
          }
          if (options.fields) {
            log = options.fields.reduce((obj, key) => {
              obj[key] = log[key];
              return obj;
            }, {});
          }
          if (options.order === "desc") {
            if (results.length >= options.rows) {
              results.shift();
            }
          }
          results.push(log);
        }
        function check(log) {
          if (!log) {
            return;
          }
          if (typeof log !== "object") {
            return;
          }
          const time = new Date(log.timestamp);
          if (options.from && time < options.from || options.until && time > options.until || options.level && options.level !== log.level) {
            return;
          }
          return true;
        }
        function normalizeQuery(options2) {
          options2 = options2 || {};
          options2.rows = options2.rows || options2.limit || 10;
          options2.start = options2.start || 0;
          options2.until = options2.until || /* @__PURE__ */ new Date();
          if (typeof options2.until !== "object") {
            options2.until = new Date(options2.until);
          }
          options2.from = options2.from || options2.until - 24 * 60 * 60 * 1e3;
          if (typeof options2.from !== "object") {
            options2.from = new Date(options2.from);
          }
          options2.order = options2.order || "desc";
          return options2;
        }
      }
      /**
       * Returns a log stream for this transport. Options object is optional.
       * @param {Object} options - Stream options for this instance.
       * @returns {Stream} - TODO: add return description.
       * TODO: Refactor me.
       */
      stream(options = {}) {
        const file = path.join(this.dirname, this.filename);
        const stream = new Stream();
        const tail = {
          file,
          start: options.start
        };
        stream.destroy = tailFile(tail, (err, line) => {
          if (err) {
            return stream.emit("error", err);
          }
          try {
            stream.emit("data", line);
            line = JSON.parse(line);
            stream.emit("log", line);
          } catch (e) {
            stream.emit("error", e);
          }
        });
        return stream;
      }
      /**
       * Checks to see the filesize of.
       * @returns {undefined}
       */
      open() {
        if (!this.filename) return;
        if (this._opening) return;
        this._opening = true;
        this.stat((err, size) => {
          if (err) {
            return this.emit("error", err);
          }
          debug("stat done: %s { size: %s }", this.filename, size);
          this._size = size;
          this._dest = this._createStream(this._stream);
          this._opening = false;
          this.once("open", () => {
            if (!this._stream.emit("rotate")) {
              this._rotate = false;
            }
          });
        });
      }
      /**
       * Stat the file and assess information in order to create the proper stream.
       * @param {function} callback - TODO: add param description.
       * @returns {undefined}
       */
      stat(callback) {
        const target = this._getFile();
        const fullpath = path.join(this.dirname, target);
        fs.stat(fullpath, (err, stat) => {
          if (err && err.code === "ENOENT") {
            debug("ENOENT\xA0ok", fullpath);
            this.filename = target;
            return callback(null, 0);
          }
          if (err) {
            debug(`err ${err.code} ${fullpath}`);
            return callback(err);
          }
          if (!stat || this._needsNewFile(stat.size)) {
            return this._incFile(() => this.stat(callback));
          }
          this.filename = target;
          callback(null, stat.size);
        });
      }
      /**
       * Closes the stream associated with this instance.
       * @param {function} cb - TODO: add param description.
       * @returns {undefined}
       */
      close(cb) {
        if (!this._stream) {
          return;
        }
        this._stream.end(() => {
          if (cb) {
            cb();
          }
          this.emit("flush");
          this.emit("closed");
        });
      }
      /**
       * TODO: add method description.
       * @param {number} size - TODO: add param description.
       * @returns {undefined}
       */
      _needsNewFile(size) {
        size = size || this._size;
        return this.maxsize && size >= this.maxsize;
      }
      /**
       * TODO: add method description.
       * @param {Error} err - TODO: add param description.
       * @returns {undefined}
       */
      _onError(err) {
        this.emit("error", err);
      }
      /**
       * TODO: add method description.
       * @param {Stream} stream - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       */
      _setupStream(stream) {
        stream.on("error", this._onError);
        return stream;
      }
      /**
       * TODO: add method description.
       * @param {Stream} stream - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       */
      _cleanupStream(stream) {
        stream.removeListener("error", this._onError);
        stream.destroy();
        return stream;
      }
      /**
       * TODO: add method description.
       */
      _rotateFile() {
        this._incFile(() => this.open());
      }
      /**
       * Unpipe from the stream that has been marked as full and end it so it
       * flushes to disk.
       *
       * @param {function} callback - Callback for when the current file has closed.
       * @private
       */
      _endStream(callback = () => {
      }) {
        if (this._dest) {
          this._stream.unpipe(this._dest);
          this._dest.end(() => {
            this._cleanupStream(this._dest);
            callback();
          });
        } else {
          callback();
        }
      }
      /**
       * Returns the WritableStream for the active file on this instance. If we
       * should gzip the file then a zlib stream is returned.
       *
       * @param {ReadableStream} source PassThrough to pipe to the file when open.
       * @returns {WritableStream} Stream that writes to disk for the active file.
       */
      _createStream(source) {
        const fullpath = path.join(this.dirname, this.filename);
        debug("create stream start", fullpath, this.options);
        const dest = fs.createWriteStream(fullpath, this.options).on("error", (err) => debug(err)).on("close", () => debug("close", dest.path, dest.bytesWritten)).on("open", () => {
          debug("file open ok", fullpath);
          this.emit("open", fullpath);
          source.pipe(dest);
          if (this.rotatedWhileOpening) {
            this._stream = new PassThrough();
            this._stream.setMaxListeners(30);
            this._rotateFile();
            this.rotatedWhileOpening = false;
            this._cleanupStream(dest);
            source.end();
          }
        });
        debug("create stream ok", fullpath);
        return dest;
      }
      /**
       * TODO: add method description.
       * @param {function} callback - TODO: add param description.
       * @returns {undefined}
       */
      _incFile(callback) {
        debug("_incFile", this.filename);
        const ext = path.extname(this._basename);
        const basename = path.basename(this._basename, ext);
        const tasks = [];
        if (this.zippedArchive) {
          tasks.push(
            function(cb) {
              const num = this._created > 0 && !this.tailable ? this._created : "";
              this._compressFile(
                path.join(this.dirname, `${basename}${num}${ext}`),
                path.join(this.dirname, `${basename}${num}${ext}.gz`),
                cb
              );
            }.bind(this)
          );
        }
        tasks.push(
          function(cb) {
            if (!this.tailable) {
              this._created += 1;
              this._checkMaxFilesIncrementing(ext, basename, cb);
            } else {
              this._checkMaxFilesTailable(ext, basename, cb);
            }
          }.bind(this)
        );
        asyncSeries(tasks, callback);
      }
      /**
       * Gets the next filename to use for this instance in the case that log
       * filesizes are being capped.
       * @returns {string} - TODO: add return description.
       * @private
       */
      _getFile() {
        const ext = path.extname(this._basename);
        const basename = path.basename(this._basename, ext);
        const isRotation = this.rotationFormat ? this.rotationFormat() : this._created;
        return !this.tailable && this._created ? `${basename}${isRotation}${ext}` : `${basename}${ext}`;
      }
      /**
       * Increment the number of files created or checked by this instance.
       * @param {mixed} ext - TODO: add param description.
       * @param {mixed} basename - TODO: add param description.
       * @param {mixed} callback - TODO: add param description.
       * @returns {undefined}
       * @private
       */
      _checkMaxFilesIncrementing(ext, basename, callback) {
        if (!this.maxFiles || this._created < this.maxFiles) {
          return setImmediate(callback);
        }
        const oldest = this._created - this.maxFiles;
        const isOldest = oldest !== 0 ? oldest : "";
        const isZipped = this.zippedArchive ? ".gz" : "";
        const filePath = `${basename}${isOldest}${ext}${isZipped}`;
        const target = path.join(this.dirname, filePath);
        fs.unlink(target, callback);
      }
      /**
       * Roll files forward based on integer, up to maxFiles. e.g. if base if
       * file.log and it becomes oversized, roll to file1.log, and allow file.log
       * to be re-used. If file is oversized again, roll file1.log to file2.log,
       * roll file.log to file1.log, and so on.
       * @param {mixed} ext - TODO: add param description.
       * @param {mixed} basename - TODO: add param description.
       * @param {mixed} callback - TODO: add param description.
       * @returns {undefined}
       * @private
       */
      _checkMaxFilesTailable(ext, basename, callback) {
        const tasks = [];
        if (!this.maxFiles) {
          return;
        }
        const isZipped = this.zippedArchive ? ".gz" : "";
        for (let x = this.maxFiles - 1; x > 1; x--) {
          tasks.push(function(i, cb) {
            let fileName = `${basename}${i - 1}${ext}${isZipped}`;
            const tmppath = path.join(this.dirname, fileName);
            fs.exists(tmppath, (exists) => {
              if (!exists) {
                return cb(null);
              }
              fileName = `${basename}${i}${ext}${isZipped}`;
              fs.rename(tmppath, path.join(this.dirname, fileName), cb);
            });
          }.bind(this, x));
        }
        asyncSeries(tasks, () => {
          fs.rename(
            path.join(this.dirname, `${basename}${ext}${isZipped}`),
            path.join(this.dirname, `${basename}1${ext}${isZipped}`),
            callback
          );
        });
      }
      /**
       * Compresses src to dest with gzip and unlinks src
       * @param {string} src - path to source file.
       * @param {string} dest - path to zipped destination file.
       * @param {Function} callback - callback called after file has been compressed.
       * @returns {undefined}
       * @private
       */
      _compressFile(src, dest, callback) {
        fs.access(src, fs.F_OK, (err) => {
          if (err) {
            return callback();
          }
          var gzip = zlib.createGzip();
          var inp = fs.createReadStream(src);
          var out = fs.createWriteStream(dest);
          out.on("finish", () => {
            fs.unlink(src, callback);
          });
          inp.pipe(gzip).pipe(out);
        });
      }
      _createLogDirIfNotExist(dirPath) {
        if (!fs.existsSync(dirPath)) {
          fs.mkdirSync(dirPath, { recursive: true });
        }
      }
    };
  }
});

// node_modules/winston/lib/winston/transports/http.js
var require_http = __commonJS({
  "node_modules/winston/lib/winston/transports/http.js"(exports2, module2) {
    "use strict";
    var http = require("http");
    var https = require("https");
    var { Stream } = require_readable();
    var TransportStream = require_winston_transport();
    var { configure } = require_safe_stable_stringify();
    module2.exports = class Http extends TransportStream {
      /**
       * Constructor function for the Http transport object responsible for
       * persisting log messages and metadata to a terminal or TTY.
       * @param {!Object} [options={}] - Options for this instance.
       */
      // eslint-disable-next-line max-statements
      constructor(options = {}) {
        super(options);
        this.options = options;
        this.name = options.name || "http";
        this.ssl = !!options.ssl;
        this.host = options.host || "localhost";
        this.port = options.port;
        this.auth = options.auth;
        this.path = options.path || "";
        this.maximumDepth = options.maximumDepth;
        this.agent = options.agent;
        this.headers = options.headers || {};
        this.headers["content-type"] = "application/json";
        this.batch = options.batch || false;
        this.batchInterval = options.batchInterval || 5e3;
        this.batchCount = options.batchCount || 10;
        this.batchOptions = [];
        this.batchTimeoutID = -1;
        this.batchCallback = {};
        if (!this.port) {
          this.port = this.ssl ? 443 : 80;
        }
      }
      /**
       * Core logging method exposed to Winston.
       * @param {Object} info - TODO: add param description.
       * @param {function} callback - TODO: add param description.
       * @returns {undefined}
       */
      log(info, callback) {
        this._request(info, null, null, (err, res) => {
          if (res && res.statusCode !== 200) {
            err = new Error(`Invalid HTTP Status Code: ${res.statusCode}`);
          }
          if (err) {
            this.emit("warn", err);
          } else {
            this.emit("logged", info);
          }
        });
        if (callback) {
          setImmediate(callback);
        }
      }
      /**
       * Query the transport. Options object is optional.
       * @param {Object} options -  Loggly-like query options for this instance.
       * @param {function} callback - Continuation to respond to when complete.
       * @returns {undefined}
       */
      query(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = {
          method: "query",
          params: this.normalizeQuery(options)
        };
        const auth = options.params.auth || null;
        delete options.params.auth;
        const path = options.params.path || null;
        delete options.params.path;
        this._request(options, auth, path, (err, res, body) => {
          if (res && res.statusCode !== 200) {
            err = new Error(`Invalid HTTP Status Code: ${res.statusCode}`);
          }
          if (err) {
            return callback(err);
          }
          if (typeof body === "string") {
            try {
              body = JSON.parse(body);
            } catch (e) {
              return callback(e);
            }
          }
          callback(null, body);
        });
      }
      /**
       * Returns a log stream for this transport. Options object is optional.
       * @param {Object} options - Stream options for this instance.
       * @returns {Stream} - TODO: add return description
       */
      stream(options = {}) {
        const stream = new Stream();
        options = {
          method: "stream",
          params: options
        };
        const path = options.params.path || null;
        delete options.params.path;
        const auth = options.params.auth || null;
        delete options.params.auth;
        let buff = "";
        const req = this._request(options, auth, path);
        stream.destroy = () => req.destroy();
        req.on("data", (data) => {
          data = (buff + data).split(/\n+/);
          const l = data.length - 1;
          let i = 0;
          for (; i < l; i++) {
            try {
              stream.emit("log", JSON.parse(data[i]));
            } catch (e) {
              stream.emit("error", e);
            }
          }
          buff = data[l];
        });
        req.on("error", (err) => stream.emit("error", err));
        return stream;
      }
      /**
       * Make a request to a winstond server or any http server which can
       * handle json-rpc.
       * @param {function} options - Options to sent the request.
       * @param {Object?} auth - authentication options
       * @param {string} path - request path
       * @param {function} callback - Continuation to respond to when complete.
       */
      _request(options, auth, path, callback) {
        options = options || {};
        auth = auth || this.auth;
        path = path || this.path || "";
        if (this.batch) {
          this._doBatch(options, callback, auth, path);
        } else {
          this._doRequest(options, callback, auth, path);
        }
      }
      /**
       * Send or memorize the options according to batch configuration
       * @param {function} options - Options to sent the request.
       * @param {function} callback - Continuation to respond to when complete.
       * @param {Object?} auth - authentication options
       * @param {string} path - request path
       */
      _doBatch(options, callback, auth, path) {
        this.batchOptions.push(options);
        if (this.batchOptions.length === 1) {
          const me = this;
          this.batchCallback = callback;
          this.batchTimeoutID = setTimeout(function() {
            me.batchTimeoutID = -1;
            me._doBatchRequest(me.batchCallback, auth, path);
          }, this.batchInterval);
        }
        if (this.batchOptions.length === this.batchCount) {
          this._doBatchRequest(this.batchCallback, auth, path);
        }
      }
      /**
       * Initiate a request with the memorized batch options, stop the batch timeout
       * @param {function} callback - Continuation to respond to when complete.
       * @param {Object?} auth - authentication options
       * @param {string} path - request path
       */
      _doBatchRequest(callback, auth, path) {
        if (this.batchTimeoutID > 0) {
          clearTimeout(this.batchTimeoutID);
          this.batchTimeoutID = -1;
        }
        const batchOptionsCopy = this.batchOptions.slice();
        this.batchOptions = [];
        this._doRequest(batchOptionsCopy, callback, auth, path);
      }
      /**
       * Make a request to a winstond server or any http server which can
       * handle json-rpc.
       * @param {function} options - Options to sent the request.
       * @param {function} callback - Continuation to respond to when complete.
       * @param {Object?} auth - authentication options
       * @param {string} path - request path
       */
      _doRequest(options, callback, auth, path) {
        const headers = Object.assign({}, this.headers);
        if (auth && auth.bearer) {
          headers.Authorization = `Bearer ${auth.bearer}`;
        }
        const req = (this.ssl ? https : http).request({
          ...this.options,
          method: "POST",
          host: this.host,
          port: this.port,
          path: `/${path.replace(/^\//, "")}`,
          headers,
          auth: auth && auth.username && auth.password ? `${auth.username}:${auth.password}` : "",
          agent: this.agent
        });
        req.on("error", callback);
        req.on("response", (res) => res.on("end", () => callback(null, res)).resume());
        const jsonStringify = configure({
          ...this.maximumDepth && { maximumDepth: this.maximumDepth }
        });
        req.end(Buffer.from(jsonStringify(options, this.options.replacer), "utf8"));
      }
    };
  }
});

// node_modules/is-stream/index.js
var require_is_stream = __commonJS({
  "node_modules/is-stream/index.js"(exports2, module2) {
    "use strict";
    var isStream = (stream) => stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
    isStream.writable = (stream) => isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
    isStream.readable = (stream) => isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
    isStream.duplex = (stream) => isStream.writable(stream) && isStream.readable(stream);
    isStream.transform = (stream) => isStream.duplex(stream) && typeof stream._transform === "function";
    module2.exports = isStream;
  }
});

// node_modules/winston/lib/winston/transports/stream.js
var require_stream2 = __commonJS({
  "node_modules/winston/lib/winston/transports/stream.js"(exports2, module2) {
    "use strict";
    var isStream = require_is_stream();
    var { MESSAGE } = require_triple_beam();
    var os = require("os");
    var TransportStream = require_winston_transport();
    module2.exports = class Stream extends TransportStream {
      /**
       * Constructor function for the Console transport object responsible for
       * persisting log messages and metadata to a terminal or TTY.
       * @param {!Object} [options={}] - Options for this instance.
       */
      constructor(options = {}) {
        super(options);
        if (!options.stream || !isStream(options.stream)) {
          throw new Error("options.stream is required.");
        }
        this._stream = options.stream;
        this._stream.setMaxListeners(Infinity);
        this.isObjectMode = options.stream._writableState.objectMode;
        this.eol = typeof options.eol === "string" ? options.eol : os.EOL;
      }
      /**
       * Core logging method exposed to Winston.
       * @param {Object} info - TODO: add param description.
       * @param {Function} callback - TODO: add param description.
       * @returns {undefined}
       */
      log(info, callback) {
        setImmediate(() => this.emit("logged", info));
        if (this.isObjectMode) {
          this._stream.write(info);
          if (callback) {
            callback();
          }
          return;
        }
        this._stream.write(`${info[MESSAGE]}${this.eol}`);
        if (callback) {
          callback();
        }
        return;
      }
    };
  }
});

// node_modules/winston/lib/winston/transports/index.js
var require_transports = __commonJS({
  "node_modules/winston/lib/winston/transports/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "Console", {
      configurable: true,
      enumerable: true,
      get() {
        return require_console();
      }
    });
    Object.defineProperty(exports2, "File", {
      configurable: true,
      enumerable: true,
      get() {
        return require_file();
      }
    });
    Object.defineProperty(exports2, "Http", {
      configurable: true,
      enumerable: true,
      get() {
        return require_http();
      }
    });
    Object.defineProperty(exports2, "Stream", {
      configurable: true,
      enumerable: true,
      get() {
        return require_stream2();
      }
    });
  }
});

// node_modules/winston/lib/winston/config/index.js
var require_config2 = __commonJS({
  "node_modules/winston/lib/winston/config/index.js"(exports2) {
    "use strict";
    var logform = require_logform();
    var { configs } = require_triple_beam();
    exports2.cli = logform.levels(configs.cli);
    exports2.npm = logform.levels(configs.npm);
    exports2.syslog = logform.levels(configs.syslog);
    exports2.addColors = logform.levels;
  }
});

// node_modules/async/eachOf.js
var require_eachOf = __commonJS({
  "node_modules/async/eachOf.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _isArrayLike = require_isArrayLike();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _breakLoop = require_breakLoop();
    var _breakLoop2 = _interopRequireDefault(_breakLoop);
    var _eachOfLimit = require_eachOfLimit2();
    var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
    var _once = require_once();
    var _once2 = _interopRequireDefault(_once);
    var _onlyOnce = require_onlyOnce();
    var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachOfArrayLike(coll, iteratee, callback) {
      callback = (0, _once2.default)(callback);
      var index = 0, completed = 0, { length } = coll, canceled = false;
      if (length === 0) {
        callback(null);
      }
      function iteratorCallback(err, value) {
        if (err === false) {
          canceled = true;
        }
        if (canceled === true) return;
        if (err) {
          callback(err);
        } else if (++completed === length || value === _breakLoop2.default) {
          callback(null);
        }
      }
      for (; index < length; index++) {
        iteratee(coll[index], index, (0, _onlyOnce2.default)(iteratorCallback));
      }
    }
    function eachOfGeneric(coll, iteratee, callback) {
      return (0, _eachOfLimit2.default)(coll, Infinity, iteratee, callback);
    }
    function eachOf(coll, iteratee, callback) {
      var eachOfImplementation = (0, _isArrayLike2.default)(coll) ? eachOfArrayLike : eachOfGeneric;
      return eachOfImplementation(coll, (0, _wrapAsync2.default)(iteratee), callback);
    }
    exports2.default = (0, _awaitify2.default)(eachOf, 3);
    module2.exports = exports2.default;
  }
});

// node_modules/async/internal/withoutIndex.js
var require_withoutIndex = __commonJS({
  "node_modules/async/internal/withoutIndex.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = _withoutIndex;
    function _withoutIndex(iteratee) {
      return (value, index, callback) => iteratee(value, callback);
    }
    module2.exports = exports2.default;
  }
});

// node_modules/async/forEach.js
var require_forEach = __commonJS({
  "node_modules/async/forEach.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _eachOf = require_eachOf();
    var _eachOf2 = _interopRequireDefault(_eachOf);
    var _withoutIndex = require_withoutIndex();
    var _withoutIndex2 = _interopRequireDefault(_withoutIndex);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachLimit(coll, iteratee, callback) {
      return (0, _eachOf2.default)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);
    }
    exports2.default = (0, _awaitify2.default)(eachLimit, 3);
    module2.exports = exports2.default;
  }
});

// node_modules/fn.name/index.js
var require_fn = __commonJS({
  "node_modules/fn.name/index.js"(exports2, module2) {
    "use strict";
    var toString = Object.prototype.toString;
    module2.exports = function name(fn) {
      if ("string" === typeof fn.displayName && fn.constructor.name) {
        return fn.displayName;
      } else if ("string" === typeof fn.name && fn.name) {
        return fn.name;
      }
      if ("object" === typeof fn && fn.constructor && "string" === typeof fn.constructor.name) return fn.constructor.name;
      var named = fn.toString(), type = toString.call(fn).slice(8, -1);
      if ("Function" === type) {
        named = named.substring(named.indexOf("(") + 1, named.indexOf(")"));
      } else {
        named = type;
      }
      return named || "anonymous";
    };
  }
});

// node_modules/one-time/index.js
var require_one_time = __commonJS({
  "node_modules/one-time/index.js"(exports2, module2) {
    "use strict";
    var name = require_fn();
    module2.exports = function one(fn) {
      var called = 0, value;
      function onetime() {
        if (called) return value;
        called = 1;
        value = fn.apply(this, arguments);
        fn = null;
        return value;
      }
      onetime.displayName = name(fn);
      return onetime;
    };
  }
});

// node_modules/stack-trace/lib/stack-trace.js
var require_stack_trace = __commonJS({
  "node_modules/stack-trace/lib/stack-trace.js"(exports2) {
    exports2.get = function(belowFn) {
      var oldLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = Infinity;
      var dummyObject = {};
      var v8Handler = Error.prepareStackTrace;
      Error.prepareStackTrace = function(dummyObject2, v8StackTrace2) {
        return v8StackTrace2;
      };
      Error.captureStackTrace(dummyObject, belowFn || exports2.get);
      var v8StackTrace = dummyObject.stack;
      Error.prepareStackTrace = v8Handler;
      Error.stackTraceLimit = oldLimit;
      return v8StackTrace;
    };
    exports2.parse = function(err) {
      if (!err.stack) {
        return [];
      }
      var self2 = this;
      var lines = err.stack.split("\n").slice(1);
      return lines.map(function(line) {
        if (line.match(/^\s*[-]{4,}$/)) {
          return self2._createParsedCallSite({
            fileName: line,
            lineNumber: null,
            functionName: null,
            typeName: null,
            methodName: null,
            columnNumber: null,
            "native": null
          });
        }
        var lineMatch = line.match(/at (?:(.+)\s+\()?(?:(.+?):(\d+)(?::(\d+))?|([^)]+))\)?/);
        if (!lineMatch) {
          return;
        }
        var object = null;
        var method = null;
        var functionName = null;
        var typeName = null;
        var methodName = null;
        var isNative = lineMatch[5] === "native";
        if (lineMatch[1]) {
          functionName = lineMatch[1];
          var methodStart = functionName.lastIndexOf(".");
          if (functionName[methodStart - 1] == ".")
            methodStart--;
          if (methodStart > 0) {
            object = functionName.substr(0, methodStart);
            method = functionName.substr(methodStart + 1);
            var objectEnd = object.indexOf(".Module");
            if (objectEnd > 0) {
              functionName = functionName.substr(objectEnd + 1);
              object = object.substr(0, objectEnd);
            }
          }
          typeName = null;
        }
        if (method) {
          typeName = object;
          methodName = method;
        }
        if (method === "<anonymous>") {
          methodName = null;
          functionName = null;
        }
        var properties = {
          fileName: lineMatch[2] || null,
          lineNumber: parseInt(lineMatch[3], 10) || null,
          functionName,
          typeName,
          methodName,
          columnNumber: parseInt(lineMatch[4], 10) || null,
          "native": isNative
        };
        return self2._createParsedCallSite(properties);
      }).filter(function(callSite) {
        return !!callSite;
      });
    };
    function CallSite(properties) {
      for (var property in properties) {
        this[property] = properties[property];
      }
    }
    var strProperties = [
      "this",
      "typeName",
      "functionName",
      "methodName",
      "fileName",
      "lineNumber",
      "columnNumber",
      "function",
      "evalOrigin"
    ];
    var boolProperties = [
      "topLevel",
      "eval",
      "native",
      "constructor"
    ];
    strProperties.forEach(function(property) {
      CallSite.prototype[property] = null;
      CallSite.prototype["get" + property[0].toUpperCase() + property.substr(1)] = function() {
        return this[property];
      };
    });
    boolProperties.forEach(function(property) {
      CallSite.prototype[property] = false;
      CallSite.prototype["is" + property[0].toUpperCase() + property.substr(1)] = function() {
        return this[property];
      };
    });
    exports2._createParsedCallSite = function(properties) {
      return new CallSite(properties);
    };
  }
});

// node_modules/winston/lib/winston/exception-stream.js
var require_exception_stream = __commonJS({
  "node_modules/winston/lib/winston/exception-stream.js"(exports2, module2) {
    "use strict";
    var { Writable } = require_readable();
    module2.exports = class ExceptionStream extends Writable {
      /**
       * Constructor function for the ExceptionStream responsible for wrapping a
       * TransportStream; only allowing writes of `info` objects with
       * `info.exception` set to true.
       * @param {!TransportStream} transport - Stream to filter to exceptions
       */
      constructor(transport) {
        super({ objectMode: true });
        if (!transport) {
          throw new Error("ExceptionStream requires a TransportStream instance.");
        }
        this.handleExceptions = true;
        this.transport = transport;
      }
      /**
       * Writes the info object to our transport instance if (and only if) the
       * `exception` property is set on the info.
       * @param {mixed} info - TODO: add param description.
       * @param {mixed} enc - TODO: add param description.
       * @param {mixed} callback - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       * @private
       */
      _write(info, enc, callback) {
        if (info.exception) {
          return this.transport.log(info, callback);
        }
        callback();
        return true;
      }
    };
  }
});

// node_modules/winston/lib/winston/exception-handler.js
var require_exception_handler = __commonJS({
  "node_modules/winston/lib/winston/exception-handler.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var asyncForEach = require_forEach();
    var debug = require_node2()("winston:exception");
    var once = require_one_time();
    var stackTrace = require_stack_trace();
    var ExceptionStream = require_exception_stream();
    module2.exports = class ExceptionHandler {
      /**
       * TODO: add contructor description
       * @param {!Logger} logger - TODO: add param description
       */
      constructor(logger8) {
        if (!logger8) {
          throw new Error("Logger is required to handle exceptions");
        }
        this.logger = logger8;
        this.handlers = /* @__PURE__ */ new Map();
      }
      /**
       * Handles `uncaughtException` events for the current process by adding any
       * handlers passed in.
       * @returns {undefined}
       */
      handle(...args) {
        args.forEach((arg) => {
          if (Array.isArray(arg)) {
            return arg.forEach((handler) => this._addHandler(handler));
          }
          this._addHandler(arg);
        });
        if (!this.catcher) {
          this.catcher = this._uncaughtException.bind(this);
          process.on("uncaughtException", this.catcher);
        }
      }
      /**
       * Removes any handlers to `uncaughtException` events for the current
       * process. This does not modify the state of the `this.handlers` set.
       * @returns {undefined}
       */
      unhandle() {
        if (this.catcher) {
          process.removeListener("uncaughtException", this.catcher);
          this.catcher = false;
          Array.from(this.handlers.values()).forEach((wrapper) => this.logger.unpipe(wrapper));
        }
      }
      /**
       * TODO: add method description
       * @param {Error} err - Error to get information about.
       * @returns {mixed} - TODO: add return description.
       */
      getAllInfo(err) {
        let message = null;
        if (err) {
          message = typeof err === "string" ? err : err.message;
        }
        return {
          error: err,
          // TODO (indexzero): how do we configure this?
          level: "error",
          message: [
            `uncaughtException: ${message || "(no error message)"}`,
            err && err.stack || "  No stack trace"
          ].join("\n"),
          stack: err && err.stack,
          exception: true,
          date: (/* @__PURE__ */ new Date()).toString(),
          process: this.getProcessInfo(),
          os: this.getOsInfo(),
          trace: this.getTrace(err)
        };
      }
      /**
       * Gets all relevant process information for the currently running process.
       * @returns {mixed} - TODO: add return description.
       */
      getProcessInfo() {
        return {
          pid: process.pid,
          uid: process.getuid ? process.getuid() : null,
          gid: process.getgid ? process.getgid() : null,
          cwd: process.cwd(),
          execPath: process.execPath,
          version: process.version,
          argv: process.argv,
          memoryUsage: process.memoryUsage()
        };
      }
      /**
       * Gets all relevant OS information for the currently running process.
       * @returns {mixed} - TODO: add return description.
       */
      getOsInfo() {
        return {
          loadavg: os.loadavg(),
          uptime: os.uptime()
        };
      }
      /**
       * Gets a stack trace for the specified error.
       * @param {mixed} err - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       */
      getTrace(err) {
        const trace = err ? stackTrace.parse(err) : stackTrace.get();
        return trace.map((site) => {
          return {
            column: site.getColumnNumber(),
            file: site.getFileName(),
            function: site.getFunctionName(),
            line: site.getLineNumber(),
            method: site.getMethodName(),
            native: site.isNative()
          };
        });
      }
      /**
       * Helper method to add a transport as an exception handler.
       * @param {Transport} handler - The transport to add as an exception handler.
       * @returns {void}
       */
      _addHandler(handler) {
        if (!this.handlers.has(handler)) {
          handler.handleExceptions = true;
          const wrapper = new ExceptionStream(handler);
          this.handlers.set(handler, wrapper);
          this.logger.pipe(wrapper);
        }
      }
      /**
       * Logs all relevant information around the `err` and exits the current
       * process.
       * @param {Error} err - Error to handle
       * @returns {mixed} - TODO: add return description.
       * @private
       */
      _uncaughtException(err) {
        const info = this.getAllInfo(err);
        const handlers = this._getExceptionHandlers();
        let doExit = typeof this.logger.exitOnError === "function" ? this.logger.exitOnError(err) : this.logger.exitOnError;
        let timeout;
        if (!handlers.length && doExit) {
          console.warn("winston: exitOnError cannot be true with no exception handlers.");
          console.warn("winston: not exiting process.");
          doExit = false;
        }
        function gracefulExit() {
          debug("doExit", doExit);
          debug("process._exiting", process._exiting);
          if (doExit && !process._exiting) {
            if (timeout) {
              clearTimeout(timeout);
            }
            process.exit(1);
          }
        }
        if (!handlers || handlers.length === 0) {
          return process.nextTick(gracefulExit);
        }
        asyncForEach(handlers, (handler, next) => {
          const done = once(next);
          const transport = handler.transport || handler;
          function onDone(event) {
            return () => {
              debug(event);
              done();
            };
          }
          transport._ending = true;
          transport.once("finish", onDone("finished"));
          transport.once("error", onDone("error"));
        }, () => doExit && gracefulExit());
        this.logger.log(info);
        if (doExit) {
          timeout = setTimeout(gracefulExit, 3e3);
        }
      }
      /**
       * Returns the list of transports and exceptionHandlers for this instance.
       * @returns {Array} - List of transports and exceptionHandlers for this
       * instance.
       * @private
       */
      _getExceptionHandlers() {
        return this.logger.transports.filter((wrap2) => {
          const transport = wrap2.transport || wrap2;
          return transport.handleExceptions;
        });
      }
    };
  }
});

// node_modules/winston/lib/winston/rejection-stream.js
var require_rejection_stream = __commonJS({
  "node_modules/winston/lib/winston/rejection-stream.js"(exports2, module2) {
    "use strict";
    var { Writable } = require_readable();
    module2.exports = class RejectionStream extends Writable {
      /**
       * Constructor function for the RejectionStream responsible for wrapping a
       * TransportStream; only allowing writes of `info` objects with
       * `info.rejection` set to true.
       * @param {!TransportStream} transport - Stream to filter to rejections
       */
      constructor(transport) {
        super({ objectMode: true });
        if (!transport) {
          throw new Error("RejectionStream requires a TransportStream instance.");
        }
        this.handleRejections = true;
        this.transport = transport;
      }
      /**
       * Writes the info object to our transport instance if (and only if) the
       * `rejection` property is set on the info.
       * @param {mixed} info - TODO: add param description.
       * @param {mixed} enc - TODO: add param description.
       * @param {mixed} callback - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       * @private
       */
      _write(info, enc, callback) {
        if (info.rejection) {
          return this.transport.log(info, callback);
        }
        callback();
        return true;
      }
    };
  }
});

// node_modules/winston/lib/winston/rejection-handler.js
var require_rejection_handler = __commonJS({
  "node_modules/winston/lib/winston/rejection-handler.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var asyncForEach = require_forEach();
    var debug = require_node2()("winston:rejection");
    var once = require_one_time();
    var stackTrace = require_stack_trace();
    var RejectionStream = require_rejection_stream();
    module2.exports = class RejectionHandler {
      /**
       * TODO: add contructor description
       * @param {!Logger} logger - TODO: add param description
       */
      constructor(logger8) {
        if (!logger8) {
          throw new Error("Logger is required to handle rejections");
        }
        this.logger = logger8;
        this.handlers = /* @__PURE__ */ new Map();
      }
      /**
       * Handles `unhandledRejection` events for the current process by adding any
       * handlers passed in.
       * @returns {undefined}
       */
      handle(...args) {
        args.forEach((arg) => {
          if (Array.isArray(arg)) {
            return arg.forEach((handler) => this._addHandler(handler));
          }
          this._addHandler(arg);
        });
        if (!this.catcher) {
          this.catcher = this._unhandledRejection.bind(this);
          process.on("unhandledRejection", this.catcher);
        }
      }
      /**
       * Removes any handlers to `unhandledRejection` events for the current
       * process. This does not modify the state of the `this.handlers` set.
       * @returns {undefined}
       */
      unhandle() {
        if (this.catcher) {
          process.removeListener("unhandledRejection", this.catcher);
          this.catcher = false;
          Array.from(this.handlers.values()).forEach(
            (wrapper) => this.logger.unpipe(wrapper)
          );
        }
      }
      /**
       * TODO: add method description
       * @param {Error} err - Error to get information about.
       * @returns {mixed} - TODO: add return description.
       */
      getAllInfo(err) {
        let message = null;
        if (err) {
          message = typeof err === "string" ? err : err.message;
        }
        return {
          error: err,
          // TODO (indexzero): how do we configure this?
          level: "error",
          message: [
            `unhandledRejection: ${message || "(no error message)"}`,
            err && err.stack || "  No stack trace"
          ].join("\n"),
          stack: err && err.stack,
          rejection: true,
          date: (/* @__PURE__ */ new Date()).toString(),
          process: this.getProcessInfo(),
          os: this.getOsInfo(),
          trace: this.getTrace(err)
        };
      }
      /**
       * Gets all relevant process information for the currently running process.
       * @returns {mixed} - TODO: add return description.
       */
      getProcessInfo() {
        return {
          pid: process.pid,
          uid: process.getuid ? process.getuid() : null,
          gid: process.getgid ? process.getgid() : null,
          cwd: process.cwd(),
          execPath: process.execPath,
          version: process.version,
          argv: process.argv,
          memoryUsage: process.memoryUsage()
        };
      }
      /**
       * Gets all relevant OS information for the currently running process.
       * @returns {mixed} - TODO: add return description.
       */
      getOsInfo() {
        return {
          loadavg: os.loadavg(),
          uptime: os.uptime()
        };
      }
      /**
       * Gets a stack trace for the specified error.
       * @param {mixed} err - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       */
      getTrace(err) {
        const trace = err ? stackTrace.parse(err) : stackTrace.get();
        return trace.map((site) => {
          return {
            column: site.getColumnNumber(),
            file: site.getFileName(),
            function: site.getFunctionName(),
            line: site.getLineNumber(),
            method: site.getMethodName(),
            native: site.isNative()
          };
        });
      }
      /**
       * Helper method to add a transport as an exception handler.
       * @param {Transport} handler - The transport to add as an exception handler.
       * @returns {void}
       */
      _addHandler(handler) {
        if (!this.handlers.has(handler)) {
          handler.handleRejections = true;
          const wrapper = new RejectionStream(handler);
          this.handlers.set(handler, wrapper);
          this.logger.pipe(wrapper);
        }
      }
      /**
       * Logs all relevant information around the `err` and exits the current
       * process.
       * @param {Error} err - Error to handle
       * @returns {mixed} - TODO: add return description.
       * @private
       */
      _unhandledRejection(err) {
        const info = this.getAllInfo(err);
        const handlers = this._getRejectionHandlers();
        let doExit = typeof this.logger.exitOnError === "function" ? this.logger.exitOnError(err) : this.logger.exitOnError;
        let timeout;
        if (!handlers.length && doExit) {
          console.warn("winston: exitOnError cannot be true with no rejection handlers.");
          console.warn("winston: not exiting process.");
          doExit = false;
        }
        function gracefulExit() {
          debug("doExit", doExit);
          debug("process._exiting", process._exiting);
          if (doExit && !process._exiting) {
            if (timeout) {
              clearTimeout(timeout);
            }
            process.exit(1);
          }
        }
        if (!handlers || handlers.length === 0) {
          return process.nextTick(gracefulExit);
        }
        asyncForEach(
          handlers,
          (handler, next) => {
            const done = once(next);
            const transport = handler.transport || handler;
            function onDone(event) {
              return () => {
                debug(event);
                done();
              };
            }
            transport._ending = true;
            transport.once("finish", onDone("finished"));
            transport.once("error", onDone("error"));
          },
          () => doExit && gracefulExit()
        );
        this.logger.log(info);
        if (doExit) {
          timeout = setTimeout(gracefulExit, 3e3);
        }
      }
      /**
       * Returns the list of transports and exceptionHandlers for this instance.
       * @returns {Array} - List of transports and exceptionHandlers for this
       * instance.
       * @private
       */
      _getRejectionHandlers() {
        return this.logger.transports.filter((wrap2) => {
          const transport = wrap2.transport || wrap2;
          return transport.handleRejections;
        });
      }
    };
  }
});

// node_modules/winston/lib/winston/profiler.js
var require_profiler = __commonJS({
  "node_modules/winston/lib/winston/profiler.js"(exports2, module2) {
    "use strict";
    var Profiler = class {
      /**
       * Constructor function for the Profiler instance used by
       * `Logger.prototype.startTimer`. When done is called the timer will finish
       * and log the duration.
       * @param {!Logger} logger - TODO: add param description.
       * @private
       */
      constructor(logger8) {
        const Logger = require_logger();
        if (typeof logger8 !== "object" || Array.isArray(logger8) || !(logger8 instanceof Logger)) {
          throw new Error("Logger is required for profiling");
        } else {
          this.logger = logger8;
          this.start = Date.now();
        }
      }
      /**
       * Ends the current timer (i.e. Profiler) instance and logs the `msg` along
       * with the duration since creation.
       * @returns {mixed} - TODO: add return description.
       * @private
       */
      done(...args) {
        if (typeof args[args.length - 1] === "function") {
          console.warn("Callback function no longer supported as of winston@3.0.0");
          args.pop();
        }
        const info = typeof args[args.length - 1] === "object" ? args.pop() : {};
        info.level = info.level || "info";
        info.durationMs = Date.now() - this.start;
        return this.logger.write(info);
      }
    };
    module2.exports = Profiler;
  }
});

// node_modules/winston/lib/winston/logger.js
var require_logger = __commonJS({
  "node_modules/winston/lib/winston/logger.js"(exports2, module2) {
    "use strict";
    var { Stream, Transform } = require_readable();
    var asyncForEach = require_forEach();
    var { LEVEL, SPLAT } = require_triple_beam();
    var isStream = require_is_stream();
    var ExceptionHandler = require_exception_handler();
    var RejectionHandler = require_rejection_handler();
    var LegacyTransportStream = require_legacy();
    var Profiler = require_profiler();
    var { warn } = require_common();
    var config = require_config2();
    var formatRegExp = /%[scdjifoO%]/g;
    var Logger = class extends Transform {
      /**
       * Constructor function for the Logger object responsible for persisting log
       * messages and metadata to one or more transports.
       * @param {!Object} options - foo
       */
      constructor(options) {
        super({ objectMode: true });
        this.configure(options);
      }
      child(defaultRequestMetadata) {
        const logger8 = this;
        return Object.create(logger8, {
          write: {
            value: function(info) {
              const infoClone = Object.assign(
                {},
                defaultRequestMetadata,
                info
              );
              if (info instanceof Error) {
                infoClone.stack = info.stack;
                infoClone.message = info.message;
              }
              logger8.write(infoClone);
            }
          }
        });
      }
      /**
       * This will wholesale reconfigure this instance by:
       * 1. Resetting all transports. Older transports will be removed implicitly.
       * 2. Set all other options including levels, colors, rewriters, filters,
       *    exceptionHandlers, etc.
       * @param {!Object} options - TODO: add param description.
       * @returns {undefined}
       */
      configure({
        silent,
        format,
        defaultMeta,
        levels,
        level = "info",
        exitOnError = true,
        transports,
        colors,
        emitErrs,
        formatters,
        padLevels,
        rewriters,
        stripColors,
        exceptionHandlers,
        rejectionHandlers
      } = {}) {
        if (this.transports.length) {
          this.clear();
        }
        this.silent = silent;
        this.format = format || this.format || require_json()();
        this.defaultMeta = defaultMeta || null;
        this.levels = levels || this.levels || config.npm.levels;
        this.level = level;
        if (this.exceptions) {
          this.exceptions.unhandle();
        }
        if (this.rejections) {
          this.rejections.unhandle();
        }
        this.exceptions = new ExceptionHandler(this);
        this.rejections = new RejectionHandler(this);
        this.profilers = {};
        this.exitOnError = exitOnError;
        if (transports) {
          transports = Array.isArray(transports) ? transports : [transports];
          transports.forEach((transport) => this.add(transport));
        }
        if (colors || emitErrs || formatters || padLevels || rewriters || stripColors) {
          throw new Error(
            [
              "{ colors, emitErrs, formatters, padLevels, rewriters, stripColors } were removed in winston@3.0.0.",
              "Use a custom winston.format(function) instead.",
              "See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md"
            ].join("\n")
          );
        }
        if (exceptionHandlers) {
          this.exceptions.handle(exceptionHandlers);
        }
        if (rejectionHandlers) {
          this.rejections.handle(rejectionHandlers);
        }
      }
      isLevelEnabled(level) {
        const givenLevelValue = getLevelValue(this.levels, level);
        if (givenLevelValue === null) {
          return false;
        }
        const configuredLevelValue = getLevelValue(this.levels, this.level);
        if (configuredLevelValue === null) {
          return false;
        }
        if (!this.transports || this.transports.length === 0) {
          return configuredLevelValue >= givenLevelValue;
        }
        const index = this.transports.findIndex((transport) => {
          let transportLevelValue = getLevelValue(this.levels, transport.level);
          if (transportLevelValue === null) {
            transportLevelValue = configuredLevelValue;
          }
          return transportLevelValue >= givenLevelValue;
        });
        return index !== -1;
      }
      /* eslint-disable valid-jsdoc */
      /**
       * Ensure backwards compatibility with a `log` method
       * @param {mixed} level - Level the log message is written at.
       * @param {mixed} msg - TODO: add param description.
       * @param {mixed} meta - TODO: add param description.
       * @returns {Logger} - TODO: add return description.
       *
       * @example
       *    // Supports the existing API:
       *    logger.log('info', 'Hello world', { custom: true });
       *    logger.log('info', new Error('Yo, it\'s on fire'));
       *
       *    // Requires winston.format.splat()
       *    logger.log('info', '%s %d%%', 'A string', 50, { thisIsMeta: true });
       *
       *    // And the new API with a single JSON literal:
       *    logger.log({ level: 'info', message: 'Hello world', custom: true });
       *    logger.log({ level: 'info', message: new Error('Yo, it\'s on fire') });
       *
       *    // Also requires winston.format.splat()
       *    logger.log({
       *      level: 'info',
       *      message: '%s %d%%',
       *      [SPLAT]: ['A string', 50],
       *      meta: { thisIsMeta: true }
       *    });
       *
       */
      /* eslint-enable valid-jsdoc */
      log(level, msg, ...splat) {
        if (arguments.length === 1) {
          level[LEVEL] = level.level;
          this._addDefaultMeta(level);
          this.write(level);
          return this;
        }
        if (arguments.length === 2) {
          if (msg && typeof msg === "object") {
            msg[LEVEL] = msg.level = level;
            this._addDefaultMeta(msg);
            this.write(msg);
            return this;
          }
          msg = { [LEVEL]: level, level, message: msg };
          this._addDefaultMeta(msg);
          this.write(msg);
          return this;
        }
        const [meta] = splat;
        if (typeof meta === "object" && meta !== null) {
          const tokens = msg && msg.match && msg.match(formatRegExp);
          if (!tokens) {
            const info = Object.assign({}, this.defaultMeta, meta, {
              [LEVEL]: level,
              [SPLAT]: splat,
              level,
              message: msg
            });
            if (meta.message) info.message = `${info.message} ${meta.message}`;
            if (meta.stack) info.stack = meta.stack;
            if (meta.cause) info.cause = meta.cause;
            this.write(info);
            return this;
          }
        }
        this.write(Object.assign({}, this.defaultMeta, {
          [LEVEL]: level,
          [SPLAT]: splat,
          level,
          message: msg
        }));
        return this;
      }
      /**
       * Pushes data so that it can be picked up by all of our pipe targets.
       * @param {mixed} info - TODO: add param description.
       * @param {mixed} enc - TODO: add param description.
       * @param {mixed} callback - Continues stream processing.
       * @returns {undefined}
       * @private
       */
      _transform(info, enc, callback) {
        if (this.silent) {
          return callback();
        }
        if (!info[LEVEL]) {
          info[LEVEL] = info.level;
        }
        if (!this.levels[info[LEVEL]] && this.levels[info[LEVEL]] !== 0) {
          console.error("[winston] Unknown logger level: %s", info[LEVEL]);
        }
        if (!this._readableState.pipes) {
          console.error(
            "[winston] Attempt to write logs with no transports, which can increase memory usage: %j",
            info
          );
        }
        try {
          this.push(this.format.transform(info, this.format.options));
        } finally {
          this._writableState.sync = false;
          callback();
        }
      }
      /**
       * Delays the 'finish' event until all transport pipe targets have
       * also emitted 'finish' or are already finished.
       * @param {mixed} callback - Continues stream processing.
       */
      _final(callback) {
        const transports = this.transports.slice();
        asyncForEach(
          transports,
          (transport, next) => {
            if (!transport || transport.finished) return setImmediate(next);
            transport.once("finish", next);
            transport.end();
          },
          callback
        );
      }
      /**
       * Adds the transport to this logger instance by piping to it.
       * @param {mixed} transport - TODO: add param description.
       * @returns {Logger} - TODO: add return description.
       */
      add(transport) {
        const target = !isStream(transport) || transport.log.length > 2 ? new LegacyTransportStream({ transport }) : transport;
        if (!target._writableState || !target._writableState.objectMode) {
          throw new Error(
            "Transports must WritableStreams in objectMode. Set { objectMode: true }."
          );
        }
        this._onEvent("error", target);
        this._onEvent("warn", target);
        this.pipe(target);
        if (transport.handleExceptions) {
          this.exceptions.handle();
        }
        if (transport.handleRejections) {
          this.rejections.handle();
        }
        return this;
      }
      /**
       * Removes the transport from this logger instance by unpiping from it.
       * @param {mixed} transport - TODO: add param description.
       * @returns {Logger} - TODO: add return description.
       */
      remove(transport) {
        if (!transport) return this;
        let target = transport;
        if (!isStream(transport) || transport.log.length > 2) {
          target = this.transports.filter(
            (match) => match.transport === transport
          )[0];
        }
        if (target) {
          this.unpipe(target);
        }
        return this;
      }
      /**
       * Removes all transports from this logger instance.
       * @returns {Logger} - TODO: add return description.
       */
      clear() {
        this.unpipe();
        return this;
      }
      /**
       * Cleans up resources (streams, event listeners) for all transports
       * associated with this instance (if necessary).
       * @returns {Logger} - TODO: add return description.
       */
      close() {
        this.exceptions.unhandle();
        this.rejections.unhandle();
        this.clear();
        this.emit("close");
        return this;
      }
      /**
       * Sets the `target` levels specified on this instance.
       * @param {Object} Target levels to use on this instance.
       */
      setLevels() {
        warn.deprecated("setLevels");
      }
      /**
       * Queries the all transports for this instance with the specified `options`.
       * This will aggregate each transport's results into one object containing
       * a property per transport.
       * @param {Object} options - Query options for this instance.
       * @param {function} callback - Continuation to respond to when complete.
       */
      query(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = options || {};
        const results = {};
        const queryObject = Object.assign({}, options.query || {});
        function queryTransport(transport, next) {
          if (options.query && typeof transport.formatQuery === "function") {
            options.query = transport.formatQuery(queryObject);
          }
          transport.query(options, (err, res) => {
            if (err) {
              return next(err);
            }
            if (typeof transport.formatResults === "function") {
              res = transport.formatResults(res, options.format);
            }
            next(null, res);
          });
        }
        function addResults(transport, next) {
          queryTransport(transport, (err, result) => {
            if (next) {
              result = err || result;
              if (result) {
                results[transport.name] = result;
              }
              next();
            }
            next = null;
          });
        }
        asyncForEach(
          this.transports.filter((transport) => !!transport.query),
          addResults,
          () => callback(null, results)
        );
      }
      /**
       * Returns a log stream for all transports. Options object is optional.
       * @param{Object} options={} - Stream options for this instance.
       * @returns {Stream} - TODO: add return description.
       */
      stream(options = {}) {
        const out = new Stream();
        const streams = [];
        out._streams = streams;
        out.destroy = () => {
          let i = streams.length;
          while (i--) {
            streams[i].destroy();
          }
        };
        this.transports.filter((transport) => !!transport.stream).forEach((transport) => {
          const str = transport.stream(options);
          if (!str) {
            return;
          }
          streams.push(str);
          str.on("log", (log) => {
            log.transport = log.transport || [];
            log.transport.push(transport.name);
            out.emit("log", log);
          });
          str.on("error", (err) => {
            err.transport = err.transport || [];
            err.transport.push(transport.name);
            out.emit("error", err);
          });
        });
        return out;
      }
      /**
       * Returns an object corresponding to a specific timing. When done is called
       * the timer will finish and log the duration. e.g.:
       * @returns {Profile} - TODO: add return description.
       * @example
       *    const timer = winston.startTimer()
       *    setTimeout(() => {
       *      timer.done({
       *        message: 'Logging message'
       *      });
       *    }, 1000);
       */
      startTimer() {
        return new Profiler(this);
      }
      /**
       * Tracks the time inbetween subsequent calls to this method with the same
       * `id` parameter. The second call to this method will log the difference in
       * milliseconds along with the message.
       * @param {string} id Unique id of the profiler
       * @returns {Logger} - TODO: add return description.
       */
      profile(id, ...args) {
        const time = Date.now();
        if (this.profilers[id]) {
          const timeEnd = this.profilers[id];
          delete this.profilers[id];
          if (typeof args[args.length - 2] === "function") {
            console.warn(
              "Callback function no longer supported as of winston@3.0.0"
            );
            args.pop();
          }
          const info = typeof args[args.length - 1] === "object" ? args.pop() : {};
          info.level = info.level || "info";
          info.durationMs = time - timeEnd;
          info.message = info.message || id;
          return this.write(info);
        }
        this.profilers[id] = time;
        return this;
      }
      /**
       * Backwards compatibility to `exceptions.handle` in winston < 3.0.0.
       * @returns {undefined}
       * @deprecated
       */
      handleExceptions(...args) {
        console.warn(
          "Deprecated: .handleExceptions() will be removed in winston@4. Use .exceptions.handle()"
        );
        this.exceptions.handle(...args);
      }
      /**
       * Backwards compatibility to `exceptions.handle` in winston < 3.0.0.
       * @returns {undefined}
       * @deprecated
       */
      unhandleExceptions(...args) {
        console.warn(
          "Deprecated: .unhandleExceptions() will be removed in winston@4. Use .exceptions.unhandle()"
        );
        this.exceptions.unhandle(...args);
      }
      /**
       * Throw a more meaningful deprecation notice
       * @throws {Error} - TODO: add throws description.
       */
      cli() {
        throw new Error(
          [
            "Logger.cli() was removed in winston@3.0.0",
            "Use a custom winston.formats.cli() instead.",
            "See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md"
          ].join("\n")
        );
      }
      /**
       * Bubbles the `event` that occured on the specified `transport` up
       * from this instance.
       * @param {string} event - The event that occured
       * @param {Object} transport - Transport on which the event occured
       * @private
       */
      _onEvent(event, transport) {
        function transportEvent(err) {
          if (event === "error" && !this.transports.includes(transport)) {
            this.add(transport);
          }
          this.emit(event, err, transport);
        }
        if (!transport["__winston" + event]) {
          transport["__winston" + event] = transportEvent.bind(this);
          transport.on(event, transport["__winston" + event]);
        }
      }
      _addDefaultMeta(msg) {
        if (this.defaultMeta) {
          Object.assign(msg, this.defaultMeta);
        }
      }
    };
    function getLevelValue(levels, level) {
      const value = levels[level];
      if (!value && value !== 0) {
        return null;
      }
      return value;
    }
    Object.defineProperty(Logger.prototype, "transports", {
      configurable: false,
      enumerable: true,
      get() {
        const { pipes } = this._readableState;
        return !Array.isArray(pipes) ? [pipes].filter(Boolean) : pipes;
      }
    });
    module2.exports = Logger;
  }
});

// node_modules/winston/lib/winston/create-logger.js
var require_create_logger = __commonJS({
  "node_modules/winston/lib/winston/create-logger.js"(exports2, module2) {
    "use strict";
    var { LEVEL } = require_triple_beam();
    var config = require_config2();
    var Logger = require_logger();
    var debug = require_node2()("winston:create-logger");
    function isLevelEnabledFunctionName(level) {
      return "is" + level.charAt(0).toUpperCase() + level.slice(1) + "Enabled";
    }
    module2.exports = function(opts = {}) {
      opts.levels = opts.levels || config.npm.levels;
      class DerivedLogger extends Logger {
        /**
         * Create a new class derived logger for which the levels can be attached to
         * the prototype of. This is a V8 optimization that is well know to increase
         * performance of prototype functions.
         * @param {!Object} options - Options for the created logger.
         */
        constructor(options) {
          super(options);
        }
      }
      const logger8 = new DerivedLogger(opts);
      Object.keys(opts.levels).forEach(function(level) {
        debug('Define prototype method for "%s"', level);
        if (level === "log") {
          console.warn('Level "log" not defined: conflicts with the method "log". Use a different level name.');
          return;
        }
        DerivedLogger.prototype[level] = function(...args) {
          const self2 = this || logger8;
          if (args.length === 1) {
            const [msg] = args;
            const info = msg && msg.message && msg || { message: msg };
            info.level = info[LEVEL] = level;
            self2._addDefaultMeta(info);
            self2.write(info);
            return this || logger8;
          }
          if (args.length === 0) {
            self2.log(level, "");
            return self2;
          }
          return self2.log(level, ...args);
        };
        DerivedLogger.prototype[isLevelEnabledFunctionName(level)] = function() {
          return (this || logger8).isLevelEnabled(level);
        };
      });
      return logger8;
    };
  }
});

// node_modules/winston/lib/winston/container.js
var require_container = __commonJS({
  "node_modules/winston/lib/winston/container.js"(exports2, module2) {
    "use strict";
    var createLogger8 = require_create_logger();
    module2.exports = class Container {
      /**
       * Constructor function for the Container object responsible for managing a
       * set of `winston.Logger` instances based on string ids.
       * @param {!Object} [options={}] - Default pass-thru options for Loggers.
       */
      constructor(options = {}) {
        this.loggers = /* @__PURE__ */ new Map();
        this.options = options;
      }
      /**
       * Retrieves a `winston.Logger` instance for the specified `id`. If an
       * instance does not exist, one is created.
       * @param {!string} id - The id of the Logger to get.
       * @param {?Object} [options] - Options for the Logger instance.
       * @returns {Logger} - A configured Logger instance with a specified id.
       */
      add(id, options) {
        if (!this.loggers.has(id)) {
          options = Object.assign({}, options || this.options);
          const existing = options.transports || this.options.transports;
          if (existing) {
            options.transports = Array.isArray(existing) ? existing.slice() : [existing];
          } else {
            options.transports = [];
          }
          const logger8 = createLogger8(options);
          logger8.on("close", () => this._delete(id));
          this.loggers.set(id, logger8);
        }
        return this.loggers.get(id);
      }
      /**
       * Retreives a `winston.Logger` instance for the specified `id`. If
       * an instance does not exist, one is created.
       * @param {!string} id - The id of the Logger to get.
       * @param {?Object} [options] - Options for the Logger instance.
       * @returns {Logger} - A configured Logger instance with a specified id.
       */
      get(id, options) {
        return this.add(id, options);
      }
      /**
       * Check if the container has a logger with the id.
       * @param {?string} id - The id of the Logger instance to find.
       * @returns {boolean} - Boolean value indicating if this instance has a
       * logger with the specified `id`.
       */
      has(id) {
        return !!this.loggers.has(id);
      }
      /**
       * Closes a `Logger` instance with the specified `id` if it exists.
       * If no `id` is supplied then all Loggers are closed.
       * @param {?string} id - The id of the Logger instance to close.
       * @returns {undefined}
       */
      close(id) {
        if (id) {
          return this._removeLogger(id);
        }
        this.loggers.forEach((val, key) => this._removeLogger(key));
      }
      /**
       * Remove a logger based on the id.
       * @param {!string} id - The id of the logger to remove.
       * @returns {undefined}
       * @private
       */
      _removeLogger(id) {
        if (!this.loggers.has(id)) {
          return;
        }
        const logger8 = this.loggers.get(id);
        logger8.close();
        this._delete(id);
      }
      /**
       * Deletes a `Logger` instance with the specified `id`.
       * @param {!string} id - The id of the Logger instance to delete from
       * container.
       * @returns {undefined}
       * @private
       */
      _delete(id) {
        this.loggers.delete(id);
      }
    };
  }
});

// node_modules/winston/lib/winston.js
var require_winston = __commonJS({
  "node_modules/winston/lib/winston.js"(exports2) {
    "use strict";
    var logform = require_logform();
    var { warn } = require_common();
    exports2.version = require_package().version;
    exports2.transports = require_transports();
    exports2.config = require_config2();
    exports2.addColors = logform.levels;
    exports2.format = logform.format;
    exports2.createLogger = require_create_logger();
    exports2.Logger = require_logger();
    exports2.ExceptionHandler = require_exception_handler();
    exports2.RejectionHandler = require_rejection_handler();
    exports2.Container = require_container();
    exports2.Transport = require_winston_transport();
    exports2.loggers = new exports2.Container();
    var defaultLogger = exports2.createLogger();
    Object.keys(exports2.config.npm.levels).concat([
      "log",
      "query",
      "stream",
      "add",
      "remove",
      "clear",
      "profile",
      "startTimer",
      "handleExceptions",
      "unhandleExceptions",
      "handleRejections",
      "unhandleRejections",
      "configure",
      "child"
    ]).forEach(
      (method) => exports2[method] = (...args) => defaultLogger[method](...args)
    );
    Object.defineProperty(exports2, "level", {
      get() {
        return defaultLogger.level;
      },
      set(val) {
        defaultLogger.level = val;
      }
    });
    Object.defineProperty(exports2, "exceptions", {
      get() {
        return defaultLogger.exceptions;
      }
    });
    Object.defineProperty(exports2, "rejections", {
      get() {
        return defaultLogger.rejections;
      }
    });
    ["exitOnError"].forEach((prop) => {
      Object.defineProperty(exports2, prop, {
        get() {
          return defaultLogger[prop];
        },
        set(val) {
          defaultLogger[prop] = val;
        }
      });
    });
    Object.defineProperty(exports2, "default", {
      get() {
        return {
          exceptionHandlers: defaultLogger.exceptionHandlers,
          rejectionHandlers: defaultLogger.rejectionHandlers,
          transports: defaultLogger.transports
        };
      }
    });
    warn.deprecated(exports2, "setLevels");
    warn.forFunctions(exports2, "useFormat", ["cli"]);
    warn.forProperties(exports2, "useFormat", ["padLevels", "stripColors"]);
    warn.forFunctions(exports2, "deprecated", [
      "addRewriter",
      "addFilter",
      "clone",
      "extend"
    ]);
    warn.forProperties(exports2, "deprecated", ["emitErrs", "levelLength"]);
  }
});

// node_modules/color-convert/conversions.js
var require_conversions2 = __commonJS({
  "node_modules/color-convert/conversions.js"(exports2, module2) {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    module2.exports = convert;
    for (const model of Object.keys(convert)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert[model];
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", { value: channels });
      Object.defineProperty(convert[model], "labels", { value: labels });
    }
    convert.rgb.hsl = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min = Math.min(r, g, b);
      const max = Math.max(r, g, b);
      const delta = max - min;
      let h;
      let s;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      const l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h;
      let s;
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v = Math.max(r, g, b);
      const diff = v - Math.min(r, g, b);
      const diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = 0;
        s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      const r = rgb[0];
      const g = rgb[1];
      let b = rgb[2];
      const h = convert.rgb.hsl(rgb)[0];
      const w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k = Math.min(1 - r, 1 - g, 1 - b);
      const c = (1 - r - k) / (1 - k) || 0;
      const m = (1 - g - k) / (1 - k) || 0;
      const y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
    }
    convert.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;
      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      const xyz = convert.rgb.xyz(rgb);
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      const h = hsl[0] / 360;
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      const t1 = 2 * l - t2;
      const rgb = [0, 0, 0];
      for (let i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      const h = hsl[0];
      let s = hsl[1] / 100;
      let l = hsl[2] / 100;
      let smin = s;
      const lmin = Math.max(l, 0.01);
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (l + s) / 2;
      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      const h = hsv[0] / 60;
      const s = hsv[1] / 100;
      let v = hsv[2] / 100;
      const hi = Math.floor(h) % 6;
      const f = h - Math.floor(h);
      const p = 255 * v * (1 - s);
      const q = 255 * v * (1 - s * f);
      const t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      const h = hsv[0];
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const vmin = Math.max(v, 0.01);
      let sl;
      let l;
      l = (2 - s) * v;
      const lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      const h = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i = Math.floor(6 * h);
      const v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      const n = wh + f * (v - wh);
      let r;
      let g;
      let b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      const c = cmyk[0] / 100;
      const m = cmyk[1] / 100;
      const y = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r = 1 - Math.min(1, c * (1 - k) + k);
      const g = 1 - Math.min(1, m * (1 - k) + k);
      const b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      const x = xyz[0] / 100;
      const y = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r;
      let g;
      let b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let x;
      let y;
      let z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      const y2 = y ** 3;
      const x2 = x ** 3;
      const z2 = z ** 3;
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let h;
      const hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      const c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      const l = lch[0];
      const c = lch[1];
      const h = lch[2];
      const hr = h / 360 * 2 * Math.PI;
      const a = c * Math.cos(hr);
      const b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args, saturation = null) {
      const [r, g, b] = args;
      let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      const r = args[0];
      const g = args[1];
      const b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      let color2 = args % 10;
      if (color2 === 0 || color2 === 7) {
        if (args > 50) {
          color2 += 3.5;
        }
        color2 = color2 / 10.5 * 255;
        return [color2, color2, color2];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r = (color2 & 1) * mult * 255;
      const g = (color2 >> 1 & 1) * mult * 255;
      const b = (color2 >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      let rem;
      const r = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max = Math.max(Math.max(r, g), b);
      const min = Math.min(Math.min(r, g), b);
      const chroma = max - min;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
      let f = 0;
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const c = s * v;
      let f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      const h = hcg[0] / 360;
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h % 1 * 6;
      const v = hi % 1;
      const w = 1 - v;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      let f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l = g * (1 - c) + 0.5 * c;
      let s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      const w = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v = 1 - b;
      const c = v - w;
      let g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hsv = convert.gray.hsl;
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/color-convert/route.js
var require_route2 = __commonJS({
  "node_modules/color-convert/route.js"(exports2, module2) {
    var conversions = require_conversions2();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue2 = [fromModel];
      graph[fromModel].distance = 0;
      while (queue2.length) {
        const current = queue2.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i = 0; i < len; i++) {
          const adjacent = adjacents[i];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue2.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module2.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i = 0; i < len; i++) {
        const toModel = models[i];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/color-convert/index.js
var require_color_convert2 = __commonJS({
  "node_modules/color-convert/index.js"(exports2, module2) {
    var conversions = require_conversions2();
    var route = require_route2();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "node_modules/ansi-styles/index.js"(exports2, module2) {
    "use strict";
    var wrapAnsi16 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => (...args) => {
      const rgb = fn(...args);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    var ansi2ansi = (n) => n;
    var rgb2rgb = (r, g, b) => [r, g, b];
    var setLazyProperty = (object, property, get) => {
      Object.defineProperty(object, property, {
        get: () => {
          const value = get();
          Object.defineProperty(object, property, {
            value,
            enumerable: true,
            configurable: true
          });
          return value;
        },
        enumerable: true,
        configurable: true
      });
    };
    var colorConvert;
    var makeDynamicStyles = (wrap2, targetSpace, identity, isBackground) => {
      if (colorConvert === void 0) {
        colorConvert = require_color_convert2();
      }
      const offset = isBackground ? 10 : 0;
      const styles2 = {};
      for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
        const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) {
          styles2[name] = wrap2(identity, offset);
        } else if (typeof suite === "object") {
          styles2[name] = wrap2(suite[targetSpace], offset);
        }
      }
      return styles2;
    };
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles2 = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles2.color.gray = styles2.color.blackBright;
      styles2.bgColor.bgGray = styles2.bgColor.bgBlackBright;
      styles2.color.grey = styles2.color.blackBright;
      styles2.bgColor.bgGrey = styles2.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles2)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles2[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles2[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles2, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles2, "codes", {
        value: codes,
        enumerable: false
      });
      styles2.color.close = "\x1B[39m";
      styles2.bgColor.close = "\x1B[49m";
      setLazyProperty(styles2.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
      setLazyProperty(styles2.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
      setLazyProperty(styles2.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
      setLazyProperty(styles2.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
      setLazyProperty(styles2.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
      setLazyProperty(styles2.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
      return styles2;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/has-flag/index.js
var require_has_flag2 = __commonJS({
  "node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag2();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/chalk/source/util.js
var require_util = __commonJS({
  "node_modules/chalk/source/util.js"(exports2, module2) {
    "use strict";
    var stringReplaceAll = (string, substring, replacer) => {
      let index = string.indexOf(substring);
      if (index === -1) {
        return string;
      }
      const substringLength = substring.length;
      let endIndex = 0;
      let returnValue = "";
      do {
        returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
        endIndex = index + substringLength;
        index = string.indexOf(substring, endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    var stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
      let endIndex = 0;
      let returnValue = "";
      do {
        const gotCR = string[index - 1] === "\r";
        returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
        endIndex = index + 1;
        index = string.indexOf("\n", endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    module2.exports = {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    };
  }
});

// node_modules/chalk/source/templates.js
var require_templates = __commonJS({
  "node_modules/chalk/source/templates.js"(exports2, module2) {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = /* @__PURE__ */ new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", "\x1B"],
      ["a", "\x07"]
    ]);
    function unescape2(c) {
      const u = c[0] === "u";
      const bracket = c[1] === "{";
      if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
        return String.fromCharCode(parseInt(c.slice(1), 16));
      }
      if (u && bracket) {
        return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
      }
      return ESCAPES.get(c) || c;
    }
    function parseArguments(name, arguments_) {
      const results = [];
      const chunks = arguments_.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        const number = Number(chunk);
        if (!Number.isNaN(number)) {
          results.push(number);
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape2(escape) : character));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }
      return results;
    }
    function buildStyle(chalk, styles2) {
      const enabled = {};
      for (const layer of styles2) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk;
      for (const [styleName, styles3] of Object.entries(enabled)) {
        if (!Array.isArray(styles3)) {
          continue;
        }
        if (!(styleName in current)) {
          throw new Error(`Unknown Chalk style: ${styleName}`);
        }
        current = styles3.length > 0 ? current[styleName](...styles3) : current[styleName];
      }
      return current;
    }
    module2.exports = (chalk, temporary) => {
      const styles2 = [];
      const chunks = [];
      let chunk = [];
      temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
        if (escapeCharacter) {
          chunk.push(unescape2(escapeCharacter));
        } else if (style) {
          const string = chunk.join("");
          chunk = [];
          chunks.push(styles2.length === 0 ? string : buildStyle(chalk, styles2)(string));
          styles2.push({ inverse, styles: parseStyle(style) });
        } else if (close) {
          if (styles2.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk, styles2)(chunk.join("")));
          chunk = [];
          styles2.pop();
        } else {
          chunk.push(character);
        }
      });
      chunks.push(chunk.join(""));
      if (styles2.length > 0) {
        const errMessage = `Chalk template literal is missing ${styles2.length} closing bracket${styles2.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMessage);
      }
      return chunks.join("");
    };
  }
});

// node_modules/chalk/source/index.js
var require_source = __commonJS({
  "node_modules/chalk/source/index.js"(exports2, module2) {
    "use strict";
    var ansiStyles = require_ansi_styles();
    var { stdout: stdoutColor, stderr: stderrColor } = require_supports_color();
    var {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    } = require_util();
    var { isArray } = Array;
    var levelMapping = [
      "ansi",
      "ansi",
      "ansi256",
      "ansi16m"
    ];
    var styles2 = /* @__PURE__ */ Object.create(null);
    var applyOptions = (object, options = {}) => {
      if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
        throw new Error("The `level` option should be an integer from 0 to 3");
      }
      const colorLevel = stdoutColor ? stdoutColor.level : 0;
      object.level = options.level === void 0 ? colorLevel : options.level;
    };
    var ChalkClass = class {
      constructor(options) {
        return chalkFactory(options);
      }
    };
    var chalkFactory = (options) => {
      const chalk2 = {};
      applyOptions(chalk2, options);
      chalk2.template = (...arguments_) => chalkTag(chalk2.template, ...arguments_);
      Object.setPrototypeOf(chalk2, Chalk.prototype);
      Object.setPrototypeOf(chalk2.template, chalk2);
      chalk2.template.constructor = () => {
        throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
      };
      chalk2.template.Instance = ChalkClass;
      return chalk2.template;
    };
    function Chalk(options) {
      return chalkFactory(options);
    }
    for (const [styleName, style] of Object.entries(ansiStyles)) {
      styles2[styleName] = {
        get() {
          const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
          Object.defineProperty(this, styleName, { value: builder });
          return builder;
        }
      };
    }
    styles2.visible = {
      get() {
        const builder = createBuilder(this, this._styler, true);
        Object.defineProperty(this, "visible", { value: builder });
        return builder;
      }
    };
    var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
    for (const model of usedModels) {
      styles2[model] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    for (const model of usedModels) {
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles2[bgModel] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, {
      ...styles2,
      level: {
        enumerable: true,
        get() {
          return this._generator.level;
        },
        set(level) {
          this._generator.level = level;
        }
      }
    });
    var createStyler = (open, close, parent) => {
      let openAll;
      let closeAll;
      if (parent === void 0) {
        openAll = open;
        closeAll = close;
      } else {
        openAll = parent.openAll + open;
        closeAll = close + parent.closeAll;
      }
      return {
        open,
        close,
        openAll,
        closeAll,
        parent
      };
    };
    var createBuilder = (self2, _styler, _isEmpty) => {
      const builder = (...arguments_) => {
        if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
          return applyStyle(builder, chalkTag(builder, ...arguments_));
        }
        return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
      };
      Object.setPrototypeOf(builder, proto);
      builder._generator = self2;
      builder._styler = _styler;
      builder._isEmpty = _isEmpty;
      return builder;
    };
    var applyStyle = (self2, string) => {
      if (self2.level <= 0 || !string) {
        return self2._isEmpty ? "" : string;
      }
      let styler = self2._styler;
      if (styler === void 0) {
        return string;
      }
      const { openAll, closeAll } = styler;
      if (string.indexOf("\x1B") !== -1) {
        while (styler !== void 0) {
          string = stringReplaceAll(string, styler.close, styler.open);
          styler = styler.parent;
        }
      }
      const lfIndex = string.indexOf("\n");
      if (lfIndex !== -1) {
        string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
      }
      return openAll + string + closeAll;
    };
    var template;
    var chalkTag = (chalk2, ...strings) => {
      const [firstString] = strings;
      if (!isArray(firstString) || !isArray(firstString.raw)) {
        return strings.join(" ");
      }
      const arguments_ = strings.slice(1);
      const parts = [firstString.raw[0]];
      for (let i = 1; i < firstString.length; i++) {
        parts.push(
          String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"),
          String(firstString.raw[i])
        );
      }
      if (template === void 0) {
        template = require_templates();
      }
      return template(chalk2, parts.join(""));
    };
    Object.defineProperties(Chalk.prototype, styles2);
    var chalk = Chalk();
    chalk.supportsColor = stdoutColor;
    chalk.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
    chalk.stderr.supportsColor = stderrColor;
    module2.exports = chalk;
  }
});

// node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/logger/format/local.js
var require_local = __commonJS({
  "node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/logger/format/local.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.local = void 0;
    exports2.getMessageOrStack = getMessageOrStack;
    var chalk_1 = __importDefault(require_source());
    var winston_1 = require_winston();
    var { combine, timestamp, cli, printf, errors } = winston_1.format;
    exports2.local = combine(errors({ stack: true }), timestamp(), (0, winston_1.format)(localTransformer)(), cli(), printf((info) => {
      const messageContext = info.custom_fields && typeof info.custom_fields === "object" && "messageContext" in info.custom_fields ? `${chalk_1.default.blue(`(${info.custom_fields.messageContext})`)}: ` : "";
      const message = typeof info.message === "string" ? info.message : "";
      const trimmedMessage = message.replace(/^\s*/, "");
      const paddingLength = message.length - trimmedMessage.length + messageContext.length;
      if (info.error) {
        info.level = chalk_1.default.inverse(info.level);
      }
      return `${chalk_1.default.gray(`[${info.timestamp}]`)} ${info.level} ${messageContext.padStart(paddingLength, " ")}${trimmedMessage}`;
    }));
    function getMessageOrStack(info) {
      const isString = (value) => typeof value === "string";
      const hasStackTrace = info.stack && info.level === "error";
      if (hasStackTrace && isString(info.stack)) {
        return info.stack;
      }
      if (isString(info.message)) {
        return info.message;
      }
      return "";
    }
    function localTransformer(info) {
      return {
        ...info,
        level: info.level.toUpperCase(),
        message: getMessageOrStack(info)
      };
    }
  }
});

// node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/logger/format/kibana.js
var require_kibana = __commonJS({
  "node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/logger/format/kibana.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.kibana = void 0;
    var winston_1 = require_winston();
    var local_1 = require_local();
    var { combine, timestamp, json: json2, errors } = winston_1.format;
    exports2.kibana = combine(errors({ stack: true }), timestamp(), (0, winston_1.format)(kibanaTransformer)(), json2());
    function kibanaTransformer(info) {
      return {
        ...info,
        msg: (0, local_1.getMessageOrStack)(info),
        written_ts: new Date(info.timestamp).getTime(),
        written_at: info.timestamp
      };
    }
  }
});

// node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/logger/format/index.js
var require_format2 = __commonJS({
  "node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/logger/format/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_kibana(), exports2);
    __exportStar(require_local(), exports2);
  }
});

// node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/logger/cloud-sdk-logger.js
var require_cloud_sdk_logger = __commonJS({
  "node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/logger/cloud-sdk-logger.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.cloudSdkExceptionLogger = exports2.logFormat = void 0;
    exports2.muteLoggers = muteLoggers;
    exports2.unmuteLoggers = unmuteLoggers;
    exports2.disableExceptionLogger = disableExceptionLogger;
    exports2.enableExceptionLogger = enableExceptionLogger;
    exports2.createLogger = createLogger8;
    exports2.getLogger = getLogger;
    exports2.setLogLevel = setLogLevel;
    exports2.setGlobalLogLevel = setGlobalLogLevel;
    exports2.getGlobalLogLevel = getGlobalLogLevel;
    exports2.setGlobalTransports = setGlobalTransports;
    exports2.setLogFormat = setLogFormat;
    exports2.setGlobalLogFormat = setGlobalLogFormat;
    exports2.getGlobalLogFormat = getGlobalLogFormat;
    exports2.sanitizeRecord = sanitizeRecord;
    exports2.resetCustomLogLevels = resetCustomLogLevels;
    exports2.resetCustomLogFormats = resetCustomLogFormats;
    var winston_1 = require_winston();
    var format_1 = require_format2();
    var loggerReference = "sap-cloud-sdk-logger";
    var exceptionLoggerId = "sap-cloud-sdk-exception-logger";
    var container = new winston_1.Container();
    exports2.logFormat = {
      kibana: format_1.kibana,
      local: format_1.local
    };
    container.options.format = process.env.NODE_ENV === "production" ? exports2.logFormat.kibana : exports2.logFormat.local;
    var exceptionTransport = new winston_1.transports.Console();
    var customLogLevels = {};
    var customLogFormats = {};
    var DEFAULT_LOGGER__MESSAGE_CONTEXT = "__DEFAULT_LOGGER__MESSAGE_CONTEXT";
    var silent = false;
    var moduleLogger = createLogger8({
      package: "util",
      messageContext: "cloud-sdk-logger"
    });
    function toggleMuteLoggers(silence) {
      silent = silence;
      container.loggers.forEach((logger8) => toggleSilenceTransports(logger8, silence));
    }
    function toggleSilenceTransports(logger8, silence) {
      logger8.transports.forEach((transport) => transport.silent = silence);
    }
    function muteLoggers() {
      toggleMuteLoggers(true);
    }
    function unmuteLoggers() {
      toggleMuteLoggers(false);
    }
    exports2.cloudSdkExceptionLogger = container.get(exceptionLoggerId, {
      defaultMeta: { logger: loggerReference, test: "exception" },
      format: container.options.format,
      exceptionHandlers: [exceptionTransport]
    });
    function disableExceptionLogger() {
      exports2.cloudSdkExceptionLogger.exceptions.unhandle();
    }
    function enableExceptionLogger() {
      disableExceptionLogger();
      exports2.cloudSdkExceptionLogger.exceptions.handle(exceptionTransport);
    }
    function createLogger8(messageContext) {
      const customFields = typeof messageContext === "string" ? { messageContext } : { ...messageContext };
      const logger8 = container.get(customFields.messageContext, {
        level: process.env.SAP_CLOUD_SDK_LOG_LEVEL || customLogLevels[customFields.messageContext] || customFields.level || container.options.level || "info",
        defaultMeta: {
          ...Object.entries(customFields).length && {
            custom_fields: customFields
          },
          logger: customFields.logger || loggerReference
        },
        format: customLogFormats[customFields.messageContext] || customFields.format || container.options.format || exports2.logFormat.local,
        transports: [new winston_1.transports.Console()]
      });
      toggleSilenceTransports(logger8, silent);
      return logger8;
    }
    function getLogger(messageContext = DEFAULT_LOGGER__MESSAGE_CONTEXT) {
      if (container.has(messageContext)) {
        return container.get(messageContext);
      }
    }
    function setLogLevel(level, messageContextOrLogger = DEFAULT_LOGGER__MESSAGE_CONTEXT) {
      const messageContext = typeof messageContextOrLogger === "string" ? messageContextOrLogger : getMessageContext(messageContextOrLogger);
      if (messageContext) {
        customLogLevels[messageContext] = level;
        if (container.has(messageContext)) {
          const logger8 = container.get(messageContext);
          logger8.level = level;
        }
      } else if (typeof messageContextOrLogger !== "string") {
        moduleLogger.warn("Setting log level for logger with unknown message context");
        messageContextOrLogger.level = level;
      }
    }
    function setGlobalLogLevel(level) {
      container.options.level = level;
      container.loggers.forEach((logger8) => {
        logger8.level = level;
      });
    }
    function getGlobalLogLevel() {
      return container.options.level;
    }
    function setGlobalTransports(customTransports) {
      container.options.transports = customTransports;
      container.loggers.forEach((logger8) => {
        logger8.clear();
        return Array.isArray(customTransports) ? customTransports.forEach((transport) => logger8.add(transport)) : logger8.add(customTransports);
      });
    }
    function setLogFormat(format, messageContextOrLogger = DEFAULT_LOGGER__MESSAGE_CONTEXT) {
      const messageContext = typeof messageContextOrLogger === "string" ? messageContextOrLogger : getMessageContext(messageContextOrLogger);
      if (messageContext) {
        customLogFormats[messageContext] = format;
        if (container.has(messageContext)) {
          const logger8 = container.get(messageContext);
          logger8.format = format;
        }
      } else if (typeof messageContextOrLogger !== "string") {
        moduleLogger.warn("Setting log format for logger with unknown message context");
        messageContextOrLogger.format = format;
      }
    }
    function setGlobalLogFormat(format) {
      container.options.format = format;
      container.loggers.forEach((logger8) => {
        logger8.format = format;
      });
    }
    function getGlobalLogFormat() {
      return container.options.format;
    }
    var defaultSensitiveKeys = [
      "access_token",
      "authentication",
      "authorization",
      "apiKey",
      "credentials",
      "csrf",
      "xsrf",
      "secret",
      "password",
      "JTENANT",
      "JSESSION"
    ];
    function isSensitive(inputKey, value, sensitiveKeys) {
      const normalizedKeys = sensitiveKeys.map((key) => key.toLowerCase());
      const input = isCookieHeader(inputKey, value) ? value : inputKey;
      return normalizedKeys.some((normalizedKey) => input.toLowerCase().includes(normalizedKey));
    }
    function isCookieHeader(inputKey, value) {
      return inputKey.toLowerCase() === "cookie" && typeof value === "string";
    }
    function sanitizeRecord(input, replacementString = "<DATA NOT LOGGED TO PREVENT LEAKING SENSITIVE DATA>", sensitiveKeys = defaultSensitiveKeys) {
      return Object.fromEntries(Object.entries(input).map(([inputKey, value]) => isSensitive(inputKey, value, sensitiveKeys) ? [inputKey, replacementString] : [inputKey, value]));
    }
    function getMessageContext(logger8) {
      const loggerOptions = logger8;
      if (loggerOptions && loggerOptions.defaultMeta && loggerOptions.defaultMeta.custom_fields) {
        return loggerOptions.defaultMeta.custom_fields.messageContext;
      }
    }
    function resetCustomLogLevels() {
      Object.keys(customLogLevels).forEach((key) => delete customLogLevels[key]);
    }
    function resetCustomLogFormats() {
      Object.keys(customLogFormats).forEach((key) => delete customLogFormats[key]);
    }
  }
});

// node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/logger/index.js
var require_logger2 = __commonJS({
  "node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/logger/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_cloud_sdk_logger(), exports2);
    __exportStar(require_format2(), exports2);
  }
});

// node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/documentation-block.js
var require_documentation_block = __commonJS({
  "node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/documentation-block.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.documentationBlock = documentationBlock;
    var array_1 = require_array();
    var logger_1 = require_logger2();
    var string_formatter_1 = require_string_formatter();
    var logger8 = (0, logger_1.createLogger)("documentation-block");
    function documentationBlock(strings, ...args) {
      const firstLineTrimmed = removeLeadingEmptyLines(strings.raw[0]);
      const textIndentation = getIndentation(firstLineTrimmed);
      const argsWithIndentation = addIndentationToArguments(args, textIndentation);
      let content = (0, array_1.zip)([firstLineTrimmed, ...strings.raw.slice(1)], argsWithIndentation).join("");
      if (!content.match(/\w/)) {
        return "";
      }
      content = maskProblematicCharacters(content);
      let lines = content.split(string_formatter_1.unixEOL);
      lines = adjustIndentation(lines, textIndentation);
      content = lines.join(`${string_formatter_1.unixEOL} * `);
      const result = ["/**", ` * ${content}`, " */"].join(string_formatter_1.unixEOL);
      return result;
    }
    function removeLeadingEmptyLines(firstLine) {
      const lines = firstLine.split(string_formatter_1.unixEOL);
      const indexFirstNonEmpty = lines.findIndex((str) => str.match(/\w/)) || 0;
      return lines.splice(indexFirstNonEmpty).join(string_formatter_1.unixEOL);
    }
    function addIndentationToArguments(args, textIndentation) {
      const argsWithIndentation = args.map((arg) => arg.replace(/\n/g, string_formatter_1.unixEOL + " ".repeat(textIndentation)));
      return argsWithIndentation;
    }
    function adjustIndentation(lines, textIndentation) {
      return lines.map((str) => str.slice(textIndentation));
    }
    function getIndentation(firstLine) {
      const removeStarting = firstLine?.replace(/^\n*/g, "");
      const countEmptySpaces = removeStarting?.search(/\S/);
      return countEmptySpaces > 0 ? countEmptySpaces : 0;
    }
    function maskProblematicCharacters(str) {
      if (str.includes("*/")) {
        logger8.warn(`The documentation block ${str}'
      )} contained */ in the text will be masked as \\*\\/.`);
      }
      return str.replace(/\*\//g, "\\*\\/");
    }
  }
});

// node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/nullish.js
var require_nullish = __commonJS({
  "node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/nullish.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isNullish = isNullish;
    function isNullish(val) {
      return val === null || val === void 0;
    }
  }
});

// node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/equal.js
var require_equal = __commonJS({
  "node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/equal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.equalObjects = equalObjects;
    exports2.equal = equal;
    exports2.equalArrays = equalArrays;
    var nullish_1 = require_nullish();
    function equalObjects(obj1, obj2) {
      const keys1 = Object.keys(obj1);
      return Object.keys(obj1).length === Object.keys(obj2).length && keys1.every((key) => equal(obj1[key], obj2[key]));
    }
    function equal(item1, item2) {
      if (Array.isArray(item1) && Array.isArray(item2)) {
        return equalArrays(item1, item2);
      }
      if (typeof item1 === "object" && typeof item2 === "object" && !(0, nullish_1.isNullish)(item1) && !(0, nullish_1.isNullish)(item2)) {
        return equalObjects(item1, item2);
      }
      return item1 === item2;
    }
    function equalArrays(arr1, arr2) {
      return arr1.length === arr2.length && arr1.every((item1, i) => equal(item1, arr2[i]));
    }
  }
});

// node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/error-with-cause.js
var require_error_with_cause = __commonJS({
  "node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/error-with-cause.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ErrorWithCause = void 0;
    exports2.isErrorWithCause = isErrorWithCause;
    var string_formatter_1 = require_string_formatter();
    var logger_1 = require_logger2();
    var logger8 = (0, logger_1.createLogger)({
      package: "util",
      messageContext: "error-with-cause"
    });
    var ErrorWithCause3 = class extends Error {
      /**
       * Create an instance of ErrorWithCause.
       * @param message - Error message.
       * @param cause - Original error, causing this error.
       */
      constructor(message, cause) {
        super(message);
        this.cause = cause;
        Object.setPrototypeOf(this, new.target.prototype);
        this.name = "ErrorWithCause";
        this.addStack(cause);
      }
      isAxiosError(err) {
        return err["isAxiosError"] === true;
      }
      addStack(cause) {
        if (this.isAxiosError(cause)) {
          let response = "";
          if (cause.response?.data) {
            try {
              response = `${string_formatter_1.unixEOL}${JSON.stringify(cause.response?.data, null, 2)}`;
            } catch (error) {
              logger8.warn(`Failed to stringify response data: ${error.message}`);
              response = `${string_formatter_1.unixEOL}${cause.response?.data}`;
            }
          }
          this.stack = `${this.stack}${string_formatter_1.unixEOL}Caused by:${string_formatter_1.unixEOL}HTTP Response: ${cause.message}${response}`;
        } else if (this.stack && cause?.stack) {
          this.stack = `${this.stack}${string_formatter_1.unixEOL}Caused by:${string_formatter_1.unixEOL}${cause.stack}`;
        }
      }
      /**
       * Root cause of the error.
       * If there are multiple errors caused one by another, the root cause is the first error that occurred.
       * In case there is no root cause.
       * @returns The root cause.
       */
      get rootCause() {
        return isErrorWithCause(this.cause) ? this.cause.rootCause : this.cause;
      }
    };
    exports2.ErrorWithCause = ErrorWithCause3;
    function isErrorWithCause(err) {
      return err?.name === "ErrorWithCause";
    }
  }
});

// node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/fs.js
var require_fs = __commonJS({
  "node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.findProjectRoot = findProjectRoot;
    exports2.readJSON = readJSON;
    var fs_1 = require("fs");
    var path_1 = require("path");
    var logger_1 = require_logger2();
    var logger8 = (0, logger_1.createLogger)({
      package: "util",
      messageContext: "fs"
    });
    function findProjectRoot(path, lastPath = path) {
      if (!path) {
        return lastPath;
      }
      const inProject = (0, fs_1.readdirSync)(path).includes("package.json") || (0, fs_1.readdirSync)(path).includes("node_modules") || path.includes("node_modules");
      if (!inProject) {
        return lastPath;
      }
      return findProjectRoot((0, path_1.resolve)(path, ".."), path);
    }
    function readJSON(path) {
      if ((0, fs_1.existsSync)(path)) {
        return JSON.parse((0, fs_1.readFileSync)(path, "utf8"));
      }
      logger8.warn(`File "${path}" does not exist, return empty object.`);
      return {};
    }
  }
});

// node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/object.js
var require_object = __commonJS({
  "node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/object.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.exclude = exports2.pick = exports2.renameKeys = void 0;
    exports2.propertyExists = propertyExists;
    exports2.toSanitizedObject = toSanitizedObject;
    exports2.pickIgnoreCase = pickIgnoreCase;
    exports2.pickValueIgnoreCase = pickValueIgnoreCase;
    exports2.pickNonNullish = pickNonNullish;
    exports2.mergeLeftIgnoreCase = mergeLeftIgnoreCase;
    exports2.mergeIgnoreCase = mergeIgnoreCase2;
    var nullish_1 = require_nullish();
    function propertyExists(obj, ...properties) {
      if (!properties.length) {
        return true;
      }
      if (obj && obj.hasOwnProperty(properties[0])) {
        return propertyExists(obj[properties[0]], ...properties.slice(1));
      }
      return false;
    }
    var renameKeys = (keyMapping, obj) => {
      const unchangedEntries = Object.keys(obj).filter((k) => !Object.keys(keyMapping).includes(k)).reduce((newObj, key) => ({ ...newObj, [key]: obj[key] }), {});
      return Object.entries(keyMapping).reduce((newObj, [oldKey, newKey]) => ({ ...newObj, [newKey]: obj[oldKey] }), unchangedEntries);
    };
    exports2.renameKeys = renameKeys;
    var pick = (keys, obj) => {
      const result = {};
      keys.forEach((key) => {
        const value = obj[key];
        if (Object.keys(obj).includes(key)) {
          result[key] = value;
        }
      });
      return result;
    };
    exports2.pick = pick;
    var exclude = (keys, obj) => {
      const result = {};
      Object.keys(obj).forEach((key) => {
        const value = obj[key];
        if (!keys.includes(key)) {
          result[key] = value;
        }
      });
      return result;
    };
    exports2.exclude = exclude;
    function toSanitizedObject(key, value) {
      return (0, nullish_1.isNullish)(key) || (0, nullish_1.isNullish)(value) ? {} : { [key]: value };
    }
    function pickIgnoreCase(obj = {}, ...keys) {
      return keys.reduce((filteredHeaders, providedKey) => {
        const originalKey = Object.keys(obj).find((objKey) => objKey.toLowerCase() === providedKey.toLowerCase());
        return {
          ...filteredHeaders,
          ...originalKey && { [originalKey]: obj[originalKey] }
        };
      }, {});
    }
    function pickValueIgnoreCase(obj = {}, key) {
      return Object.values(pickIgnoreCase(obj, key))[0];
    }
    function pickNonNullish(obj = {}) {
      return Object.entries(obj).filter(([key, value]) => !(0, nullish_1.isNullish)(key) && !(0, nullish_1.isNullish)(value)).reduce((filtered, [key, value]) => ({ ...filtered, [key]: value }), {});
    }
    function mergeLeftIgnoreCase(left = {}, right = {}) {
      return Object.entries(left).map(([key, value]) => pickValueIgnoreCase(right, key) ? pickIgnoreCase(right, key) : { [key]: value }).reduce((replaced, obj) => ({ ...replaced, ...obj }), {});
    }
    function mergeIgnoreCase2(left = {}, right = {}) {
      return {
        ...mergeLeftIgnoreCase(left, right),
        ...right
      };
    }
  }
});

// node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/pipe.js
var require_pipe = __commonJS({
  "node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/pipe.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.identity = identity;
    function identity(value) {
      return value;
    }
  }
});

// node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/promise.js
var require_promise = __commonJS({
  "node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/promise.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.finishAll = finishAll;
    async function finishAll(promises, errorMessage) {
      const settledPromises = await Promise.allSettled(promises);
      const rejectedPromises = settledPromises.filter((promise) => promise.status === "rejected");
      if (rejectedPromises.length) {
        const reasons = rejectedPromises.map((promise) => `	${promise.reason}`).join("\n");
        const message = errorMessage ? `${errorMessage} ` : "";
        throw new Error(`${message}Errors: [
${reasons}
]`);
      }
    }
  }
});

// node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/remove-slashes.js
var require_remove_slashes = __commonJS({
  "node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/remove-slashes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.removeSlashes = removeSlashes;
    exports2.removeTrailingSlashes = removeTrailingSlashes2;
    exports2.removeLeadingSlashes = removeLeadingSlashes2;
    function removeSlashes(path) {
      path = removeLeadingSlashes2(path);
      path = removeTrailingSlashes2(path);
      return path;
    }
    function removeTrailingSlashes2(path) {
      return path.endsWith("/") ? path.slice(0, -1) : path;
    }
    function removeLeadingSlashes2(path) {
      return path.startsWith("/") ? path.slice(1) : path;
    }
  }
});

// node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/types.js
var require_types = __commonJS({
  "node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.caps = caps;
    function caps(oDataVersion) {
      return oDataVersion ? oDataVersion.toUpperCase() : "V2";
    }
  }
});

// node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/unique-name-generator.js
var require_unique_name_generator = __commonJS({
  "node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/unique-name-generator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UniqueNameGenerator = void 0;
    var UniqueNameGenerator = class _UniqueNameGenerator {
      static getNameForComparison(name, caseSensitive) {
        return caseSensitive ? name : name.toLowerCase();
      }
      /**
       * Creates an instance of UniqueNameGenerator.
       * @param indexSeparator - The separator to be used when adding an index.
       * @param usedNames - Sets the already used names considered in the finding process.
       */
      constructor(indexSeparator = "_", usedNames = []) {
        this.indexSeparator = indexSeparator;
        this.usedNames = [];
        this.addToUsedNames(...usedNames);
      }
      /**
       * Adds the name(s) to the already used names.
       * @param names - Names to be added.
       */
      addToUsedNames(...names) {
        this.usedNames.push(...names);
      }
      /**
       * Generate a unique name by appending an index separated by the `indexSeparator` if necessary, e.g. if `MyName` is already taken `MyName_1` will be found by default.
       * If the name is already unique nothing is appended.
       * @param name - The name to get a unique name from.
       * @param caseSensitive - Whether to check the already used names in a case sensitive manner.
       * @returns A unique name.
       */
      generateUniqueName(name, caseSensitive = true) {
        return this.generateUniqueNamesWithSuffixes(name, [], caseSensitive)[0];
      }
      /**
       * Generate a unique name by appending an index separated by the `indexSeparator` if necessary, e.g. if `MyName` is already taken `MyName_1` will be found by default.
       * The generated name is added to the used names.
       * If the name is already unique nothing is appended.
       * @param name - The name to get a unique name from.
       * @param caseSensitive - Whether to check the already used names in a case sensitive manner.
       * @returns A unique name.
       */
      generateAndSaveUniqueName(name, caseSensitive = true) {
        const uniqueName = this.generateUniqueName(name, caseSensitive);
        this.addToUsedNames(uniqueName);
        return uniqueName;
      }
      /**
       * Generate unique names by appending an index separated by the `indexSeparator` if necessary, while respecting the given suffixes.
       * If the name is already unique nothing is appended.
       * Each given suffix is appended to the unique name in the result.
       * The resulting names are also checked for uniqueness.
       * All names in the result have the same number suffix.
       * @example if `MyName` and `MyName_1MySuffix` is already taken, `[MyName_2, MyName_2MySuffix]` will be generated by default.
       * @param name - The name to get a unique name from.
       * @param suffixes - Additional name of suffixes to be considered for the finding process, as well as the output.
       * @param caseSensitive - Whether to check the already used names in a case sensitive manner.
       * @returns A list of unique names. The length of this array is one plus the number of suffixes provided. The first entry corresponds to the given name.
       */
      generateUniqueNamesWithSuffixes(name, suffixes, caseSensitive = true) {
        const relevantUsedNames = this.getUsedNamesStartingWith(name, caseSensitive);
        const namesWithSuffixes = this.generateNamesWithSuffixes(name, suffixes);
        if (!this.areNamesUsed(namesWithSuffixes, relevantUsedNames, caseSensitive)) {
          return [name, ...namesWithSuffixes];
        }
        const index = this.getUniqueIndex(name, relevantUsedNames, suffixes, caseSensitive);
        return this.generateNamesWithIndexAndSuffixes(name, index, suffixes);
      }
      /**
       * Generate unique names by appending an index separated by the `indexSeparator` if necessary, while respecting the given suffixes.
       * If the name is already unique nothing is appended.
       * The generated names are added to the used names.
       * Each given suffix is appended to the unique name in the result.
       * The resulting names are also checked for uniqueness.
       * All names in the result have the same number suffix.
       * @example if `MyName` and `MyName_1MySuffix` is already taken, `[MyName_2, MyName_2MySuffix]` will be generated by default.
       * @param name - The name to get a unique name from.
       * @param suffixes - Additional name of suffixes to be considered for the finding process, as well as the output.
       * @param caseSensitive - Whether to check the already used names in a case sensitive manner.
       * @returns A list of unique names. The length of this array is one plus the number of suffixes provided. The first entry corresponds to the given name.
       */
      generateAndSaveUniqueNamesWithSuffixes(name, suffixes, caseSensitive = true) {
        const uniqueNames = this.generateUniqueNamesWithSuffixes(name, suffixes, caseSensitive);
        this.addToUsedNames(...uniqueNames);
        return uniqueNames;
      }
      getUsedNamesForComparison(caseSensitive) {
        return this.usedNames.map((name) => _UniqueNameGenerator.getNameForComparison(name, caseSensitive));
      }
      areNamesUsed(names, usedNames, caseSensitive) {
        return names.some((name) => usedNames.map((usedName) => _UniqueNameGenerator.getNameForComparison(usedName, caseSensitive)).includes(_UniqueNameGenerator.getNameForComparison(name, caseSensitive)));
      }
      generateNamesWithIndexAndSuffixes(name, index, suffixes) {
        const nameWithoutIndex = this.getNameWithoutIndex(name);
        return this.generateNamesWithSuffixes(`${nameWithoutIndex}${this.indexSeparator}${index}`, suffixes);
      }
      generateNamesWithSuffixes(name, suffixes) {
        return [name, ...suffixes.map((nameSuffix) => `${name}${nameSuffix}`)];
      }
      getUsedNamesStartingWith(name, caseSensitive) {
        const modifiedName = this.getNameWithoutIndex(name);
        return this.getUsedNamesForComparison(caseSensitive).filter((used) => used.startsWith(_UniqueNameGenerator.getNameForComparison(modifiedName, caseSensitive)));
      }
      getUniqueIndex(name, usedNames, suffixes, caseSensitive) {
        let index = 1;
        while (index < _UniqueNameGenerator.MAXIMUM_NUMBER_OF_SUFFIX) {
          const newNames = this.generateNamesWithIndexAndSuffixes(name, index, suffixes);
          if (!this.areNamesUsed(newNames, usedNames, caseSensitive)) {
            return index;
          }
          index++;
        }
        throw new Error(`Unable to find a unique name for ${name} within the range of ${_UniqueNameGenerator.MAXIMUM_NUMBER_OF_SUFFIX} suffixes.`);
      }
      getNameWithoutIndex(name) {
        return name.replace(new RegExp(`${this.indexSeparator}\\d+$`), "");
      }
    };
    exports2.UniqueNameGenerator = UniqueNameGenerator;
    UniqueNameGenerator.MAXIMUM_NUMBER_OF_SUFFIX = 1e3;
  }
});

// node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS({
  "node_modules/delayed-stream/lib/delayed_stream.js"(exports2, module2) {
    var Stream = require("stream").Stream;
    var util = require("util");
    module2.exports = DelayedStream;
    function DelayedStream() {
      this.source = null;
      this.dataSize = 0;
      this.maxDataSize = 1024 * 1024;
      this.pauseStream = true;
      this._maxDataSizeExceeded = false;
      this._released = false;
      this._bufferedEvents = [];
    }
    util.inherits(DelayedStream, Stream);
    DelayedStream.create = function(source, options) {
      var delayedStream = new this();
      options = options || {};
      for (var option in options) {
        delayedStream[option] = options[option];
      }
      delayedStream.source = source;
      var realEmit = source.emit;
      source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
      };
      source.on("error", function() {
      });
      if (delayedStream.pauseStream) {
        source.pause();
      }
      return delayedStream;
    };
    Object.defineProperty(DelayedStream.prototype, "readable", {
      configurable: true,
      enumerable: true,
      get: function() {
        return this.source.readable;
      }
    });
    DelayedStream.prototype.setEncoding = function() {
      return this.source.setEncoding.apply(this.source, arguments);
    };
    DelayedStream.prototype.resume = function() {
      if (!this._released) {
        this.release();
      }
      this.source.resume();
    };
    DelayedStream.prototype.pause = function() {
      this.source.pause();
    };
    DelayedStream.prototype.release = function() {
      this._released = true;
      this._bufferedEvents.forEach(function(args) {
        this.emit.apply(this, args);
      }.bind(this));
      this._bufferedEvents = [];
    };
    DelayedStream.prototype.pipe = function() {
      var r = Stream.prototype.pipe.apply(this, arguments);
      this.resume();
      return r;
    };
    DelayedStream.prototype._handleEmit = function(args) {
      if (this._released) {
        this.emit.apply(this, args);
        return;
      }
      if (args[0] === "data") {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
      }
      this._bufferedEvents.push(args);
    };
    DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
      if (this._maxDataSizeExceeded) {
        return;
      }
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      this._maxDataSizeExceeded = true;
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this.emit("error", new Error(message));
    };
  }
});

// node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS({
  "node_modules/combined-stream/lib/combined_stream.js"(exports2, module2) {
    var util = require("util");
    var Stream = require("stream").Stream;
    var DelayedStream = require_delayed_stream();
    module2.exports = CombinedStream;
    function CombinedStream() {
      this.writable = false;
      this.readable = true;
      this.dataSize = 0;
      this.maxDataSize = 2 * 1024 * 1024;
      this.pauseStreams = true;
      this._released = false;
      this._streams = [];
      this._currentStream = null;
      this._insideLoop = false;
      this._pendingNext = false;
    }
    util.inherits(CombinedStream, Stream);
    CombinedStream.create = function(options) {
      var combinedStream = new this();
      options = options || {};
      for (var option in options) {
        combinedStream[option] = options[option];
      }
      return combinedStream;
    };
    CombinedStream.isStreamLike = function(stream) {
      return typeof stream !== "function" && typeof stream !== "string" && typeof stream !== "boolean" && typeof stream !== "number" && !Buffer.isBuffer(stream);
    };
    CombinedStream.prototype.append = function(stream) {
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        if (!(stream instanceof DelayedStream)) {
          var newStream = DelayedStream.create(stream, {
            maxDataSize: Infinity,
            pauseStream: this.pauseStreams
          });
          stream.on("data", this._checkDataSize.bind(this));
          stream = newStream;
        }
        this._handleErrors(stream);
        if (this.pauseStreams) {
          stream.pause();
        }
      }
      this._streams.push(stream);
      return this;
    };
    CombinedStream.prototype.pipe = function(dest, options) {
      Stream.prototype.pipe.call(this, dest, options);
      this.resume();
      return dest;
    };
    CombinedStream.prototype._getNext = function() {
      this._currentStream = null;
      if (this._insideLoop) {
        this._pendingNext = true;
        return;
      }
      this._insideLoop = true;
      try {
        do {
          this._pendingNext = false;
          this._realGetNext();
        } while (this._pendingNext);
      } finally {
        this._insideLoop = false;
      }
    };
    CombinedStream.prototype._realGetNext = function() {
      var stream = this._streams.shift();
      if (typeof stream == "undefined") {
        this.end();
        return;
      }
      if (typeof stream !== "function") {
        this._pipeNext(stream);
        return;
      }
      var getStream = stream;
      getStream(function(stream2) {
        var isStreamLike = CombinedStream.isStreamLike(stream2);
        if (isStreamLike) {
          stream2.on("data", this._checkDataSize.bind(this));
          this._handleErrors(stream2);
        }
        this._pipeNext(stream2);
      }.bind(this));
    };
    CombinedStream.prototype._pipeNext = function(stream) {
      this._currentStream = stream;
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        stream.on("end", this._getNext.bind(this));
        stream.pipe(this, { end: false });
        return;
      }
      var value = stream;
      this.write(value);
      this._getNext();
    };
    CombinedStream.prototype._handleErrors = function(stream) {
      var self2 = this;
      stream.on("error", function(err) {
        self2._emitError(err);
      });
    };
    CombinedStream.prototype.write = function(data) {
      this.emit("data", data);
    };
    CombinedStream.prototype.pause = function() {
      if (!this.pauseStreams) {
        return;
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function") this._currentStream.pause();
      this.emit("pause");
    };
    CombinedStream.prototype.resume = function() {
      if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function") this._currentStream.resume();
      this.emit("resume");
    };
    CombinedStream.prototype.end = function() {
      this._reset();
      this.emit("end");
    };
    CombinedStream.prototype.destroy = function() {
      this._reset();
      this.emit("close");
    };
    CombinedStream.prototype._reset = function() {
      this.writable = false;
      this._streams = [];
      this._currentStream = null;
    };
    CombinedStream.prototype._checkDataSize = function() {
      this._updateDataSize();
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this._emitError(new Error(message));
    };
    CombinedStream.prototype._updateDataSize = function() {
      this.dataSize = 0;
      var self2 = this;
      this._streams.forEach(function(stream) {
        if (!stream.dataSize) {
          return;
        }
        self2.dataSize += stream.dataSize;
      });
      if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
      }
    };
    CombinedStream.prototype._emitError = function(err) {
      this._reset();
      this.emit("error", err);
    };
  }
});

// node_modules/mime-db/db.json
var require_db = __commonJS({
  "node_modules/mime-db/db.json"(exports2, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "node_modules/mime-db/index.js"(exports2, module2) {
    module2.exports = require_db();
  }
});

// node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  "node_modules/mime-types/index.js"(exports2) {
    "use strict";
    var db = require_mime_db();
    var extname = require("path").extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports2.charset = charset;
    exports2.charsets = { lookup: charset };
    exports2.contentType = contentType;
    exports2.extension = extension;
    exports2.extensions = /* @__PURE__ */ Object.create(null);
    exports2.lookup = lookup;
    exports2.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports2.extensions, exports2.types);
    function charset(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports2.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports2.charset(mime);
        if (charset2) mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var exts = match && exports2.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path) {
      if (!path || typeof path !== "string") {
        return false;
      }
      var extension2 = extname("x." + path).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports2.types[extension2] || false;
    }
    function populateMaps(extensions, types) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types[extension2]) {
            var from = preference.indexOf(db[types[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types[extension2] = type;
        }
      });
    }
  }
});

// node_modules/asynckit/lib/defer.js
var require_defer = __commonJS({
  "node_modules/asynckit/lib/defer.js"(exports2, module2) {
    module2.exports = defer;
    function defer(fn) {
      var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
      if (nextTick) {
        nextTick(fn);
      } else {
        setTimeout(fn, 0);
      }
    }
  }
});

// node_modules/asynckit/lib/async.js
var require_async = __commonJS({
  "node_modules/asynckit/lib/async.js"(exports2, module2) {
    var defer = require_defer();
    module2.exports = async;
    function async(callback) {
      var isAsync = false;
      defer(function() {
        isAsync = true;
      });
      return function async_callback(err, result) {
        if (isAsync) {
          callback(err, result);
        } else {
          defer(function nextTick_callback() {
            callback(err, result);
          });
        }
      };
    }
  }
});

// node_modules/asynckit/lib/abort.js
var require_abort = __commonJS({
  "node_modules/asynckit/lib/abort.js"(exports2, module2) {
    module2.exports = abort;
    function abort(state) {
      Object.keys(state.jobs).forEach(clean.bind(state));
      state.jobs = {};
    }
    function clean(key) {
      if (typeof this.jobs[key] == "function") {
        this.jobs[key]();
      }
    }
  }
});

// node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS({
  "node_modules/asynckit/lib/iterate.js"(exports2, module2) {
    var async = require_async();
    var abort = require_abort();
    module2.exports = iterate;
    function iterate(list, iterator, state, callback) {
      var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
      state.jobs[key] = runJob(iterator, key, list[key], function(error, output) {
        if (!(key in state.jobs)) {
          return;
        }
        delete state.jobs[key];
        if (error) {
          abort(state);
        } else {
          state.results[key] = output;
        }
        callback(error, state.results);
      });
    }
    function runJob(iterator, key, item, callback) {
      var aborter;
      if (iterator.length == 2) {
        aborter = iterator(item, async(callback));
      } else {
        aborter = iterator(item, key, async(callback));
      }
      return aborter;
    }
  }
});

// node_modules/asynckit/lib/state.js
var require_state2 = __commonJS({
  "node_modules/asynckit/lib/state.js"(exports2, module2) {
    module2.exports = state;
    function state(list, sortMethod) {
      var isNamedList = !Array.isArray(list), initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list).length : list.length
      };
      if (sortMethod) {
        initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
          return sortMethod(list[a], list[b]);
        });
      }
      return initState;
    }
  }
});

// node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS({
  "node_modules/asynckit/lib/terminator.js"(exports2, module2) {
    var abort = require_abort();
    var async = require_async();
    module2.exports = terminator;
    function terminator(callback) {
      if (!Object.keys(this.jobs).length) {
        return;
      }
      this.index = this.size;
      abort(this);
      async(callback)(null, this.results);
    }
  }
});

// node_modules/asynckit/parallel.js
var require_parallel2 = __commonJS({
  "node_modules/asynckit/parallel.js"(exports2, module2) {
    var iterate = require_iterate();
    var initState = require_state2();
    var terminator = require_terminator();
    module2.exports = parallel;
    function parallel(list, iterator, callback) {
      var state = initState(list);
      while (state.index < (state["keyedList"] || list).length) {
        iterate(list, iterator, state, function(error, result) {
          if (error) {
            callback(error, result);
            return;
          }
          if (Object.keys(state.jobs).length === 0) {
            callback(null, state.results);
            return;
          }
        });
        state.index++;
      }
      return terminator.bind(state, callback);
    }
  }
});

// node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS({
  "node_modules/asynckit/serialOrdered.js"(exports2, module2) {
    var iterate = require_iterate();
    var initState = require_state2();
    var terminator = require_terminator();
    module2.exports = serialOrdered;
    module2.exports.ascending = ascending;
    module2.exports.descending = descending;
    function serialOrdered(list, iterator, sortMethod, callback) {
      var state = initState(list, sortMethod);
      iterate(list, iterator, state, function iteratorHandler(error, result) {
        if (error) {
          callback(error, result);
          return;
        }
        state.index++;
        if (state.index < (state["keyedList"] || list).length) {
          iterate(list, iterator, state, iteratorHandler);
          return;
        }
        callback(null, state.results);
      });
      return terminator.bind(state, callback);
    }
    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }
    function descending(a, b) {
      return -1 * ascending(a, b);
    }
  }
});

// node_modules/asynckit/serial.js
var require_serial = __commonJS({
  "node_modules/asynckit/serial.js"(exports2, module2) {
    var serialOrdered = require_serialOrdered();
    module2.exports = serial;
    function serial(list, iterator, callback) {
      return serialOrdered(list, iterator, null, callback);
    }
  }
});

// node_modules/asynckit/index.js
var require_asynckit = __commonJS({
  "node_modules/asynckit/index.js"(exports2, module2) {
    module2.exports = {
      parallel: require_parallel2(),
      serial: require_serial(),
      serialOrdered: require_serialOrdered()
    };
  }
});

// node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS({
  "node_modules/es-object-atoms/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Object;
  }
});

// node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "node_modules/es-errors/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Error;
  }
});

// node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "node_modules/es-errors/eval.js"(exports2, module2) {
    "use strict";
    module2.exports = EvalError;
  }
});

// node_modules/es-errors/range.js
var require_range = __commonJS({
  "node_modules/es-errors/range.js"(exports2, module2) {
    "use strict";
    module2.exports = RangeError;
  }
});

// node_modules/es-errors/ref.js
var require_ref = __commonJS({
  "node_modules/es-errors/ref.js"(exports2, module2) {
    "use strict";
    module2.exports = ReferenceError;
  }
});

// node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "node_modules/es-errors/syntax.js"(exports2, module2) {
    "use strict";
    module2.exports = SyntaxError;
  }
});

// node_modules/es-errors/type.js
var require_type = __commonJS({
  "node_modules/es-errors/type.js"(exports2, module2) {
    "use strict";
    module2.exports = TypeError;
  }
});

// node_modules/es-errors/uri.js
var require_uri = __commonJS({
  "node_modules/es-errors/uri.js"(exports2, module2) {
    "use strict";
    module2.exports = URIError;
  }
});

// node_modules/math-intrinsics/abs.js
var require_abs = __commonJS({
  "node_modules/math-intrinsics/abs.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.abs;
  }
});

// node_modules/math-intrinsics/floor.js
var require_floor = __commonJS({
  "node_modules/math-intrinsics/floor.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.floor;
  }
});

// node_modules/math-intrinsics/max.js
var require_max = __commonJS({
  "node_modules/math-intrinsics/max.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.max;
  }
});

// node_modules/math-intrinsics/min.js
var require_min = __commonJS({
  "node_modules/math-intrinsics/min.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.min;
  }
});

// node_modules/math-intrinsics/pow.js
var require_pow = __commonJS({
  "node_modules/math-intrinsics/pow.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.pow;
  }
});

// node_modules/math-intrinsics/round.js
var require_round = __commonJS({
  "node_modules/math-intrinsics/round.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.round;
  }
});

// node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS({
  "node_modules/math-intrinsics/isNaN.js"(exports2, module2) {
    "use strict";
    module2.exports = Number.isNaN || function isNaN2(a) {
      return a !== a;
    };
  }
});

// node_modules/math-intrinsics/sign.js
var require_sign = __commonJS({
  "node_modules/math-intrinsics/sign.js"(exports2, module2) {
    "use strict";
    var $isNaN = require_isNaN();
    module2.exports = function sign(number) {
      if ($isNaN(number) || number === 0) {
        return number;
      }
      return number < 0 ? -1 : 1;
    };
  }
});

// node_modules/gopd/gOPD.js
var require_gOPD = __commonJS({
  "node_modules/gopd/gOPD.js"(exports2, module2) {
    "use strict";
    module2.exports = Object.getOwnPropertyDescriptor;
  }
});

// node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/gopd/index.js"(exports2, module2) {
    "use strict";
    var $gOPD = require_gOPD();
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module2.exports = $gOPD;
  }
});

// node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "node_modules/es-define-property/index.js"(exports2, module2) {
    "use strict";
    var $defineProperty = Object.defineProperty || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    module2.exports = $defineProperty;
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports2, module2) {
    "use strict";
    module2.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (var _ in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(obj, sym)
        );
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports2, module2) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS({
  "node_modules/get-proto/Reflect.getPrototypeOf.js"(exports2, module2) {
    "use strict";
    module2.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  }
});

// node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS({
  "node_modules/get-proto/Object.getPrototypeOf.js"(exports2, module2) {
    "use strict";
    var $Object = require_es_object_atoms();
    module2.exports = $Object.getPrototypeOf || null;
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b) {
      var arr2 = [];
      for (var i = 0; i < a.length; i += 1) {
        arr2[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr2[j + a.length] = b[j];
      }
      return arr2;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr2 = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr2[j] = arrLike[i];
      }
      return arr2;
    };
    var joiny = function(arr2, joiner) {
      var str = "";
      for (var i = 0; i < arr2.length; i += 1) {
        str += arr2[i];
        if (i + 1 < arr2.length) {
          str += joiner;
        }
      }
      return str;
    };
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS({
  "node_modules/call-bind-apply-helpers/functionCall.js"(exports2, module2) {
    "use strict";
    module2.exports = Function.prototype.call;
  }
});

// node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS({
  "node_modules/call-bind-apply-helpers/functionApply.js"(exports2, module2) {
    "use strict";
    module2.exports = Function.prototype.apply;
  }
});

// node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS({
  "node_modules/call-bind-apply-helpers/reflectApply.js"(exports2, module2) {
    "use strict";
    module2.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  }
});

// node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS({
  "node_modules/call-bind-apply-helpers/actualApply.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var $reflectApply = require_reflectApply();
    module2.exports = $reflectApply || bind.call($call, $apply);
  }
});

// node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS({
  "node_modules/call-bind-apply-helpers/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var $TypeError = require_type();
    var $call = require_functionCall();
    var $actualApply = require_actualApply();
    module2.exports = function callBindBasic(args) {
      if (args.length < 1 || typeof args[0] !== "function") {
        throw new $TypeError("a function is required");
      }
      return $actualApply(bind, $call, args);
    };
  }
});

// node_modules/dunder-proto/get.js
var require_get = __commonJS({
  "node_modules/dunder-proto/get.js"(exports2, module2) {
    "use strict";
    var callBind = require_call_bind_apply_helpers();
    var gOPD = require_gopd();
    var hasProtoAccessor;
    try {
      hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
      [].__proto__ === Array.prototype;
    } catch (e) {
      if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
        throw e;
      }
    }
    var desc = !!hasProtoAccessor && gOPD && gOPD(
      Object.prototype,
      /** @type {keyof typeof Object.prototype} */
      "__proto__"
    );
    var $Object = Object;
    var $getPrototypeOf = $Object.getPrototypeOf;
    module2.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
      /** @type {import('./get')} */
      function getDunder(value) {
        return $getPrototypeOf(value == null ? value : $Object(value));
      }
    ) : false;
  }
});

// node_modules/get-proto/index.js
var require_get_proto = __commonJS({
  "node_modules/get-proto/index.js"(exports2, module2) {
    "use strict";
    var reflectGetProto = require_Reflect_getPrototypeOf();
    var originalGetProto = require_Object_getPrototypeOf();
    var getDunderProto = require_get();
    module2.exports = reflectGetProto ? function getProto(O) {
      return reflectGetProto(O);
    } : originalGetProto ? function getProto(O) {
      if (!O || typeof O !== "object" && typeof O !== "function") {
        throw new TypeError("getProto: not an object");
      }
      return originalGetProto(O);
    } : getDunderProto ? function getProto(O) {
      return getDunderProto(O);
    } : null;
  }
});

// node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/hasown/index.js"(exports2, module2) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module2.exports = bind.call(call, $hasOwn);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports2, module2) {
    "use strict";
    var undefined2;
    var $Object = require_es_object_atoms();
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var abs = require_abs();
    var floor = require_floor();
    var max = require_max();
    var min = require_min();
    var pow = require_pow();
    var round = require_round();
    var sign = require_sign();
    var $Function = Function;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = require_gopd();
    var $defineProperty = require_es_define_property();
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = require_get_proto();
    var $ObjectGPO = require_Object_getPrototypeOf();
    var $ReflectGPO = require_Reflect_getPrototypeOf();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": $Object,
      "%Object.getOwnPropertyDescriptor%": $gOPD,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
      "%Function.prototype.call%": $call,
      "%Function.prototype.apply%": $apply,
      "%Object.defineProperty%": $defineProperty,
      "%Object.getPrototypeOf%": $ObjectGPO,
      "%Math.abs%": abs,
      "%Math.floor%": floor,
      "%Math.max%": max,
      "%Math.min%": min,
      "%Math.pow%": pow,
      "%Math.round%": round,
      "%Math.sign%": sign,
      "%Reflect.getPrototypeOf%": $ReflectGPO
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind.call($call, Array.prototype.concat);
    var $spliceApply = bind.call($apply, Array.prototype.splice);
    var $replace = bind.call($call, String.prototype.replace);
    var $strSlice = bind.call($call, String.prototype.slice);
    var $exec = bind.call($call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void undefined2;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "node_modules/has-tostringtag/shams.js"(exports2, module2) {
    "use strict";
    var hasSymbols = require_shams();
    module2.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});

// node_modules/es-set-tostringtag/index.js
var require_es_set_tostringtag = __commonJS({
  "node_modules/es-set-tostringtag/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var hasToStringTag = require_shams2()();
    var hasOwn = require_hasown();
    var $TypeError = require_type();
    var toStringTag = hasToStringTag ? Symbol.toStringTag : null;
    module2.exports = function setToStringTag(object, value) {
      var overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;
      var nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
      if (typeof overrideIfSet !== "undefined" && typeof overrideIfSet !== "boolean" || typeof nonConfigurable !== "undefined" && typeof nonConfigurable !== "boolean") {
        throw new $TypeError("if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans");
      }
      if (toStringTag && (overrideIfSet || !hasOwn(object, toStringTag))) {
        if ($defineProperty) {
          $defineProperty(object, toStringTag, {
            configurable: !nonConfigurable,
            enumerable: false,
            value,
            writable: false
          });
        } else {
          object[toStringTag] = value;
        }
      }
    };
  }
});

// node_modules/form-data/lib/populate.js
var require_populate = __commonJS({
  "node_modules/form-data/lib/populate.js"(exports2, module2) {
    "use strict";
    module2.exports = function(dst, src) {
      Object.keys(src).forEach(function(prop) {
        dst[prop] = dst[prop] || src[prop];
      });
      return dst;
    };
  }
});

// node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS({
  "node_modules/form-data/lib/form_data.js"(exports2, module2) {
    "use strict";
    var CombinedStream = require_combined_stream();
    var util = require("util");
    var path = require("path");
    var http = require("http");
    var https = require("https");
    var parseUrl = require("url").parse;
    var fs = require("fs");
    var Stream = require("stream").Stream;
    var crypto6 = require("crypto");
    var mime = require_mime_types();
    var asynckit = require_asynckit();
    var setToStringTag = require_es_set_tostringtag();
    var hasOwn = require_hasown();
    var populate = require_populate();
    function FormData2(options) {
      if (!(this instanceof FormData2)) {
        return new FormData2(options);
      }
      this._overheadLength = 0;
      this._valueLength = 0;
      this._valuesToMeasure = [];
      CombinedStream.call(this);
      options = options || {};
      for (var option in options) {
        this[option] = options[option];
      }
    }
    util.inherits(FormData2, CombinedStream);
    FormData2.LINE_BREAK = "\r\n";
    FormData2.DEFAULT_CONTENT_TYPE = "application/octet-stream";
    FormData2.prototype.append = function(field, value, options) {
      options = options || {};
      if (typeof options === "string") {
        options = { filename: options };
      }
      var append = CombinedStream.prototype.append.bind(this);
      if (typeof value === "number" || value == null) {
        value = String(value);
      }
      if (Array.isArray(value)) {
        this._error(new Error("Arrays are not supported."));
        return;
      }
      var header = this._multiPartHeader(field, value, options);
      var footer = this._multiPartFooter();
      append(header);
      append(value);
      append(footer);
      this._trackLength(header, value, options);
    };
    FormData2.prototype._trackLength = function(header, value, options) {
      var valueLength = 0;
      if (options.knownLength != null) {
        valueLength += Number(options.knownLength);
      } else if (Buffer.isBuffer(value)) {
        valueLength = value.length;
      } else if (typeof value === "string") {
        valueLength = Buffer.byteLength(value);
      }
      this._valueLength += valueLength;
      this._overheadLength += Buffer.byteLength(header) + FormData2.LINE_BREAK.length;
      if (!value || !value.path && !(value.readable && hasOwn(value, "httpVersion")) && !(value instanceof Stream)) {
        return;
      }
      if (!options.knownLength) {
        this._valuesToMeasure.push(value);
      }
    };
    FormData2.prototype._lengthRetriever = function(value, callback) {
      if (hasOwn(value, "fd")) {
        if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
          callback(null, value.end + 1 - (value.start ? value.start : 0));
        } else {
          fs.stat(value.path, function(err, stat) {
            if (err) {
              callback(err);
              return;
            }
            var fileSize = stat.size - (value.start ? value.start : 0);
            callback(null, fileSize);
          });
        }
      } else if (hasOwn(value, "httpVersion")) {
        callback(null, Number(value.headers["content-length"]));
      } else if (hasOwn(value, "httpModule")) {
        value.on("response", function(response) {
          value.pause();
          callback(null, Number(response.headers["content-length"]));
        });
        value.resume();
      } else {
        callback("Unknown stream");
      }
    };
    FormData2.prototype._multiPartHeader = function(field, value, options) {
      if (typeof options.header === "string") {
        return options.header;
      }
      var contentDisposition = this._getContentDisposition(value, options);
      var contentType = this._getContentType(value, options);
      var contents = "";
      var headers = {
        // add custom disposition as third element or keep it two elements if not
        "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
        // if no content type. allow it to be empty array
        "Content-Type": [].concat(contentType || [])
      };
      if (typeof options.header === "object") {
        populate(headers, options.header);
      }
      var header;
      for (var prop in headers) {
        if (hasOwn(headers, prop)) {
          header = headers[prop];
          if (header == null) {
            continue;
          }
          if (!Array.isArray(header)) {
            header = [header];
          }
          if (header.length) {
            contents += prop + ": " + header.join("; ") + FormData2.LINE_BREAK;
          }
        }
      }
      return "--" + this.getBoundary() + FormData2.LINE_BREAK + contents + FormData2.LINE_BREAK;
    };
    FormData2.prototype._getContentDisposition = function(value, options) {
      var filename;
      if (typeof options.filepath === "string") {
        filename = path.normalize(options.filepath).replace(/\\/g, "/");
      } else if (options.filename || value && (value.name || value.path)) {
        filename = path.basename(options.filename || value && (value.name || value.path));
      } else if (value && value.readable && hasOwn(value, "httpVersion")) {
        filename = path.basename(value.client._httpMessage.path || "");
      }
      if (filename) {
        return 'filename="' + filename + '"';
      }
    };
    FormData2.prototype._getContentType = function(value, options) {
      var contentType = options.contentType;
      if (!contentType && value && value.name) {
        contentType = mime.lookup(value.name);
      }
      if (!contentType && value && value.path) {
        contentType = mime.lookup(value.path);
      }
      if (!contentType && value && value.readable && hasOwn(value, "httpVersion")) {
        contentType = value.headers["content-type"];
      }
      if (!contentType && (options.filepath || options.filename)) {
        contentType = mime.lookup(options.filepath || options.filename);
      }
      if (!contentType && value && typeof value === "object") {
        contentType = FormData2.DEFAULT_CONTENT_TYPE;
      }
      return contentType;
    };
    FormData2.prototype._multiPartFooter = function() {
      return function(next) {
        var footer = FormData2.LINE_BREAK;
        var lastPart = this._streams.length === 0;
        if (lastPart) {
          footer += this._lastBoundary();
        }
        next(footer);
      }.bind(this);
    };
    FormData2.prototype._lastBoundary = function() {
      return "--" + this.getBoundary() + "--" + FormData2.LINE_BREAK;
    };
    FormData2.prototype.getHeaders = function(userHeaders) {
      var header;
      var formHeaders = {
        "content-type": "multipart/form-data; boundary=" + this.getBoundary()
      };
      for (header in userHeaders) {
        if (hasOwn(userHeaders, header)) {
          formHeaders[header.toLowerCase()] = userHeaders[header];
        }
      }
      return formHeaders;
    };
    FormData2.prototype.setBoundary = function(boundary) {
      if (typeof boundary !== "string") {
        throw new TypeError("FormData boundary must be a string");
      }
      this._boundary = boundary;
    };
    FormData2.prototype.getBoundary = function() {
      if (!this._boundary) {
        this._generateBoundary();
      }
      return this._boundary;
    };
    FormData2.prototype.getBuffer = function() {
      var dataBuffer = new Buffer.alloc(0);
      var boundary = this.getBoundary();
      for (var i = 0, len = this._streams.length; i < len; i++) {
        if (typeof this._streams[i] !== "function") {
          if (Buffer.isBuffer(this._streams[i])) {
            dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
          } else {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
          }
          if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData2.LINE_BREAK)]);
          }
        }
      }
      return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
    };
    FormData2.prototype._generateBoundary = function() {
      this._boundary = "--------------------------" + crypto6.randomBytes(12).toString("hex");
    };
    FormData2.prototype.getLengthSync = function() {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this.hasKnownLength()) {
        this._error(new Error("Cannot calculate proper length in synchronous way."));
      }
      return knownLength;
    };
    FormData2.prototype.hasKnownLength = function() {
      var hasKnownLength = true;
      if (this._valuesToMeasure.length) {
        hasKnownLength = false;
      }
      return hasKnownLength;
    };
    FormData2.prototype.getLength = function(cb) {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
      }
      asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
        if (err) {
          cb(err);
          return;
        }
        values.forEach(function(length) {
          knownLength += length;
        });
        cb(null, knownLength);
      });
    };
    FormData2.prototype.submit = function(params, cb) {
      var request;
      var options;
      var defaults = { method: "post" };
      if (typeof params === "string") {
        params = parseUrl(params);
        options = populate({
          port: params.port,
          path: params.pathname,
          host: params.hostname,
          protocol: params.protocol
        }, defaults);
      } else {
        options = populate(params, defaults);
        if (!options.port) {
          options.port = options.protocol === "https:" ? 443 : 80;
        }
      }
      options.headers = this.getHeaders(params.headers);
      if (options.protocol === "https:") {
        request = https.request(options);
      } else {
        request = http.request(options);
      }
      this.getLength(function(err, length) {
        if (err && err !== "Unknown stream") {
          this._error(err);
          return;
        }
        if (length) {
          request.setHeader("Content-Length", length);
        }
        this.pipe(request);
        if (cb) {
          var onResponse;
          var callback = function(error, responce) {
            request.removeListener("error", callback);
            request.removeListener("response", onResponse);
            return cb.call(this, error, responce);
          };
          onResponse = callback.bind(this, null);
          request.on("error", callback);
          request.on("response", onResponse);
        }
      }.bind(this));
      return request;
    };
    FormData2.prototype._error = function(err) {
      if (!this.error) {
        this.error = err;
        this.pause();
        this.emit("error", err);
      }
    };
    FormData2.prototype.toString = function() {
      return "[object FormData]";
    };
    setToStringTag(FormData2, "FormData");
    module2.exports = FormData2;
  }
});

// node_modules/proxy-from-env/index.js
var require_proxy_from_env = __commonJS({
  "node_modules/proxy-from-env/index.js"(exports2) {
    "use strict";
    var parseUrl = require("url").parse;
    var DEFAULT_PORTS = {
      ftp: 21,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var stringEndsWith = String.prototype.endsWith || function(s) {
      return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
    };
    function getProxyForUrl(url) {
      var parsedUrl = typeof url === "string" ? parseUrl(url) : url || {};
      var proto = parsedUrl.protocol;
      var hostname = parsedUrl.host;
      var port = parsedUrl.port;
      if (typeof hostname !== "string" || !hostname || typeof proto !== "string") {
        return "";
      }
      proto = proto.split(":", 1)[0];
      hostname = hostname.replace(/:\d*$/, "");
      port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
      if (!shouldProxy(hostname, port)) {
        return "";
      }
      var proxy = getEnv3("npm_config_" + proto + "_proxy") || getEnv3(proto + "_proxy") || getEnv3("npm_config_proxy") || getEnv3("all_proxy");
      if (proxy && proxy.indexOf("://") === -1) {
        proxy = proto + "://" + proxy;
      }
      return proxy;
    }
    function shouldProxy(hostname, port) {
      var NO_PROXY = (getEnv3("npm_config_no_proxy") || getEnv3("no_proxy")).toLowerCase();
      if (!NO_PROXY) {
        return true;
      }
      if (NO_PROXY === "*") {
        return false;
      }
      return NO_PROXY.split(/[,\s]/).every(function(proxy) {
        if (!proxy) {
          return true;
        }
        var parsedProxy = proxy.match(/^(.+):(\d+)$/);
        var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
        var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
        if (parsedProxyPort && parsedProxyPort !== port) {
          return true;
        }
        if (!/^[.*]/.test(parsedProxyHostname)) {
          return hostname !== parsedProxyHostname;
        }
        if (parsedProxyHostname.charAt(0) === "*") {
          parsedProxyHostname = parsedProxyHostname.slice(1);
        }
        return !stringEndsWith.call(hostname, parsedProxyHostname);
      });
    }
    function getEnv3(key) {
      return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
    }
    exports2.getProxyForUrl = getProxyForUrl;
  }
});

// node_modules/debug/src/common.js
var require_common2 = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common2()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/debug/src/node.js
var require_node3 = __commonJS({
  "node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.formatWithOptions(exports2.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common2()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node3();
    }
  }
});

// node_modules/follow-redirects/debug.js
var require_debug = __commonJS({
  "node_modules/follow-redirects/debug.js"(exports2, module2) {
    var debug;
    module2.exports = function() {
      if (!debug) {
        try {
          debug = require_src()("follow-redirects");
        } catch (error) {
        }
        if (typeof debug !== "function") {
          debug = function() {
          };
        }
      }
      debug.apply(null, arguments);
    };
  }
});

// node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS({
  "node_modules/follow-redirects/index.js"(exports2, module2) {
    var url = require("url");
    var URL3 = url.URL;
    var http = require("http");
    var https = require("https");
    var Writable = require("stream").Writable;
    var assert = require("assert");
    var debug = require_debug();
    (function detectUnsupportedEnvironment() {
      var looksLikeNode = typeof process !== "undefined";
      var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";
      var looksLikeV8 = isFunction(Error.captureStackTrace);
      if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
        console.warn("The follow-redirects package should be excluded from browser builds.");
      }
    })();
    var useNativeURL = false;
    try {
      assert(new URL3(""));
    } catch (error) {
      useNativeURL = error.code === "ERR_INVALID_URL";
    }
    var preservedUrlFields = [
      "auth",
      "host",
      "hostname",
      "href",
      "path",
      "pathname",
      "port",
      "protocol",
      "query",
      "search",
      "hash"
    ];
    var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    var eventHandlers = /* @__PURE__ */ Object.create(null);
    events.forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    var InvalidUrlError = createErrorType(
      "ERR_INVALID_URL",
      "Invalid URL",
      TypeError
    );
    var RedirectionError = createErrorType(
      "ERR_FR_REDIRECTION_FAILURE",
      "Redirected request failed"
    );
    var TooManyRedirectsError = createErrorType(
      "ERR_FR_TOO_MANY_REDIRECTS",
      "Maximum number of redirects exceeded",
      RedirectionError
    );
    var MaxBodyLengthExceededError = createErrorType(
      "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
      "Request body larger than maxBodyLength limit"
    );
    var WriteAfterEndError = createErrorType(
      "ERR_STREAM_WRITE_AFTER_END",
      "write after end"
    );
    var destroy = Writable.prototype.destroy || noop;
    function RedirectableRequest(options, responseCallback) {
      Writable.call(this);
      this._sanitizeOptions(options);
      this._options = options;
      this._ended = false;
      this._ending = false;
      this._redirectCount = 0;
      this._redirects = [];
      this._requestBodyLength = 0;
      this._requestBodyBuffers = [];
      if (responseCallback) {
        this.on("response", responseCallback);
      }
      var self2 = this;
      this._onNativeResponse = function(response) {
        try {
          self2._processResponse(response);
        } catch (cause) {
          self2.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({ cause }));
        }
      };
      this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
      destroyRequest(this._currentRequest);
      this._currentRequest.abort();
      this.emit("abort");
    };
    RedirectableRequest.prototype.destroy = function(error) {
      destroyRequest(this._currentRequest, error);
      destroy.call(this, error);
      return this;
    };
    RedirectableRequest.prototype.write = function(data, encoding, callback) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!isString(data) && !isBuffer(data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (isFunction(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (data.length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({ data, encoding });
        this._currentRequest.write(data, encoding, callback);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data, encoding, callback) {
      if (isFunction(data)) {
        callback = data;
        data = encoding = null;
      } else if (isFunction(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
      } else {
        var self2 = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
          self2._ended = true;
          currentRequest.end(null, null, callback);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name, value) {
      this._options.headers[name] = value;
      this._currentRequest.setHeader(name, value);
    };
    RedirectableRequest.prototype.removeHeader = function(name) {
      delete this._options.headers[name];
      this._currentRequest.removeHeader(name);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
      var self2 = this;
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
        }
        self2._timeout = setTimeout(function() {
          self2.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
          self2._timeout = null;
        }
        self2.removeListener("abort", clearTimer);
        self2.removeListener("error", clearTimer);
        self2.removeListener("response", clearTimer);
        self2.removeListener("close", clearTimer);
        if (callback) {
          self2.removeListener("timeout", callback);
        }
        if (!self2.socket) {
          self2._currentRequest.removeListener("socket", startTimer);
        }
      }
      if (callback) {
        this.on("timeout", callback);
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once("socket", startTimer);
      }
      this.on("socket", destroyOnTimeout);
      this.on("abort", clearTimer);
      this.on("error", clearTimer);
      this.on("response", clearTimer);
      this.on("close", clearTimer);
      return this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
          return this._currentRequest[property];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options) {
      if (!options.headers) {
        options.headers = {};
      }
      if (options.host) {
        if (!options.hostname) {
          options.hostname = options.host;
        }
        delete options.host;
      }
      if (!options.pathname && options.path) {
        var searchPos = options.path.indexOf("?");
        if (searchPos < 0) {
          options.pathname = options.path;
        } else {
          options.pathname = options.path.substring(0, searchPos);
          options.search = options.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol];
      if (!nativeProtocol) {
        throw new TypeError("Unsupported protocol " + protocol);
      }
      if (this._options.agents) {
        var scheme = protocol.slice(0, -1);
        this._options.agent = this._options.agents[scheme];
      }
      var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      request._redirectable = this;
      for (var event of events) {
        request.on(event, eventHandlers[event]);
      }
      this._currentUrl = /^\//.test(this._options.path) ? url.format(this._options) : (
        // When making a request to a proxy, []
        // a client MUST send the target URI in absolute-form [].
        this._options.path
      );
      if (this._isRedirect) {
        var i = 0;
        var self2 = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error) {
          if (request === self2._currentRequest) {
            if (error) {
              self2.emit("error", error);
            } else if (i < buffers.length) {
              var buffer = buffers[i++];
              if (!request.finished) {
                request.write(buffer.data, buffer.encoding, writeNext);
              }
            } else if (self2._ended) {
              request.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location = response.headers.location;
      if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
        return;
      }
      destroyRequest(this._currentRequest);
      response.destroy();
      if (++this._redirectCount > this._options.maxRedirects) {
        throw new TooManyRedirectsError();
      }
      var requestHeaders;
      var beforeRedirect = this._options.beforeRedirect;
      if (beforeRedirect) {
        requestHeaders = Object.assign({
          // The Host header was set by nativeProtocol.request
          Host: response.req.getHeader("host")
        }, this._options.headers);
      }
      var method = this._options.method;
      if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC72316.4.4: The 303 (See Other) status code indicates that
      // the server is redirecting the user agent to a different resource []
      // A user agent can perform a retrieval request targeting that URI
      // (a GET or HEAD request if using HTTP) []
      statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET";
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
      }
      var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
      var currentUrlParts = parseUrl(this._currentUrl);
      var currentHost = currentHostHeader || currentUrlParts.host;
      var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }));
      var redirectUrl = resolveUrl(location, currentUrl);
      debug("redirecting to", redirectUrl.href);
      this._isRedirect = true;
      spreadUrlObject(redirectUrl, this._options);
      if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
        removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
      }
      if (isFunction(beforeRedirect)) {
        var responseDetails = {
          headers: response.headers,
          statusCode
        };
        var requestDetails = {
          url: currentUrl,
          method,
          headers: requestHeaders
        };
        beforeRedirect(this._options, responseDetails, requestDetails);
        this._sanitizeOptions(this._options);
      }
      this._performRequest();
    };
    function wrap2(protocols) {
      var exports3 = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
      };
      var nativeProtocols = {};
      Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports3[scheme] = Object.create(nativeProtocol);
        function request(input, options, callback) {
          if (isURL(input)) {
            input = spreadUrlObject(input);
          } else if (isString(input)) {
            input = spreadUrlObject(parseUrl(input));
          } else {
            callback = options;
            options = validateUrl(input);
            input = { protocol };
          }
          if (isFunction(options)) {
            callback = options;
            options = null;
          }
          options = Object.assign({
            maxRedirects: exports3.maxRedirects,
            maxBodyLength: exports3.maxBodyLength
          }, input, options);
          options.nativeProtocols = nativeProtocols;
          if (!isString(options.host) && !isString(options.hostname)) {
            options.hostname = "::1";
          }
          assert.equal(options.protocol, protocol, "protocol mismatch");
          debug("options", options);
          return new RedirectableRequest(options, callback);
        }
        function get(input, options, callback) {
          var wrappedRequest = wrappedProtocol.request(input, options, callback);
          wrappedRequest.end();
          return wrappedRequest;
        }
        Object.defineProperties(wrappedProtocol, {
          request: { value: request, configurable: true, enumerable: true, writable: true },
          get: { value: get, configurable: true, enumerable: true, writable: true }
        });
      });
      return exports3;
    }
    function noop() {
    }
    function parseUrl(input) {
      var parsed;
      if (useNativeURL) {
        parsed = new URL3(input);
      } else {
        parsed = validateUrl(url.parse(input));
        if (!isString(parsed.protocol)) {
          throw new InvalidUrlError({ input });
        }
      }
      return parsed;
    }
    function resolveUrl(relative, base) {
      return useNativeURL ? new URL3(relative, base) : parseUrl(url.resolve(base, relative));
    }
    function validateUrl(input) {
      if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
        throw new InvalidUrlError({ input: input.href || input });
      }
      if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
        throw new InvalidUrlError({ input: input.href || input });
      }
      return input;
    }
    function spreadUrlObject(urlObject, target) {
      var spread = target || {};
      for (var key of preservedUrlFields) {
        spread[key] = urlObject[key];
      }
      if (spread.hostname.startsWith("[")) {
        spread.hostname = spread.hostname.slice(1, -1);
      }
      if (spread.port !== "") {
        spread.port = Number(spread.port);
      }
      spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;
      return spread;
    }
    function removeMatchingHeaders(regex, headers) {
      var lastValue;
      for (var header in headers) {
        if (regex.test(header)) {
          lastValue = headers[header];
          delete headers[header];
        }
      }
      return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
    }
    function createErrorType(code, message, baseClass) {
      function CustomError(properties) {
        if (isFunction(Error.captureStackTrace)) {
          Error.captureStackTrace(this, this.constructor);
        }
        Object.assign(this, properties || {});
        this.code = code;
        this.message = this.cause ? message + ": " + this.cause.message : message;
      }
      CustomError.prototype = new (baseClass || Error)();
      Object.defineProperties(CustomError.prototype, {
        constructor: {
          value: CustomError,
          enumerable: false
        },
        name: {
          value: "Error [" + code + "]",
          enumerable: false
        }
      });
      return CustomError;
    }
    function destroyRequest(request, error) {
      for (var event of events) {
        request.removeListener(event, eventHandlers[event]);
      }
      request.on("error", noop);
      request.destroy(error);
    }
    function isSubdomain(subdomain, domain) {
      assert(isString(subdomain) && isString(domain));
      var dot = subdomain.length - domain.length - 1;
      return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
    }
    function isString(value) {
      return typeof value === "string" || value instanceof String;
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    function isBuffer(value) {
      return typeof value === "object" && "length" in value;
    }
    function isURL(value) {
      return URL3 && value instanceof URL3;
    }
    module2.exports = wrap2({ http, https });
    module2.exports.wrap = wrap2;
  }
});

// node_modules/axios/dist/node/axios.cjs
var require_axios = __commonJS({
  "node_modules/axios/dist/node/axios.cjs"(exports2, module2) {
    "use strict";
    var FormData$1 = require_form_data();
    var crypto6 = require("crypto");
    var url = require("url");
    var proxyFromEnv = require_proxy_from_env();
    var http = require("http");
    var https = require("https");
    var util = require("util");
    var followRedirects = require_follow_redirects();
    var zlib = require("zlib");
    var stream = require("stream");
    var events = require("events");
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var FormData__default = /* @__PURE__ */ _interopDefaultLegacy(FormData$1);
    var crypto__default = /* @__PURE__ */ _interopDefaultLegacy(crypto6);
    var url__default = /* @__PURE__ */ _interopDefaultLegacy(url);
    var proxyFromEnv__default = /* @__PURE__ */ _interopDefaultLegacy(proxyFromEnv);
    var http__default = /* @__PURE__ */ _interopDefaultLegacy(http);
    var https__default = /* @__PURE__ */ _interopDefaultLegacy(https);
    var util__default = /* @__PURE__ */ _interopDefaultLegacy(util);
    var followRedirects__default = /* @__PURE__ */ _interopDefaultLegacy(followRedirects);
    var zlib__default = /* @__PURE__ */ _interopDefaultLegacy(zlib);
    var stream__default = /* @__PURE__ */ _interopDefaultLegacy(stream);
    function bind(fn, thisArg) {
      return function wrap2() {
        return fn.apply(thisArg, arguments);
      };
    }
    var { toString } = Object.prototype;
    var { getPrototypeOf } = Object;
    var { iterator, toStringTag } = Symbol;
    var kindOf = /* @__PURE__ */ ((cache) => (thing) => {
      const str = toString.call(thing);
      return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
    })(/* @__PURE__ */ Object.create(null));
    var kindOfTest = (type) => {
      type = type.toLowerCase();
      return (thing) => kindOf(thing) === type;
    };
    var typeOfTest = (type) => (thing) => typeof thing === type;
    var { isArray } = Array;
    var isUndefined = typeOfTest("undefined");
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
    }
    var isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      let result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    var isString = typeOfTest("string");
    var isFunction = typeOfTest("function");
    var isNumber = typeOfTest("number");
    var isObject = (thing) => thing !== null && typeof thing === "object";
    var isBoolean = (thing) => thing === true || thing === false;
    var isPlainObject = (val) => {
      if (kindOf(val) !== "object") {
        return false;
      }
      const prototype2 = getPrototypeOf(val);
      return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(toStringTag in val) && !(iterator in val);
    };
    var isEmptyObject = (val) => {
      if (!isObject(val) || isBuffer(val)) {
        return false;
      }
      try {
        return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
      } catch (e) {
        return false;
      }
    };
    var isDate = kindOfTest("Date");
    var isFile = kindOfTest("File");
    var isBlob = kindOfTest("Blob");
    var isFileList = kindOfTest("FileList");
    var isStream = (val) => isObject(val) && isFunction(val.pipe);
    var isFormData = (thing) => {
      let kind;
      return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
      kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
    };
    var isURLSearchParams = kindOfTest("URLSearchParams");
    var [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
    var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    function forEach(obj, fn, { allOwnKeys = false } = {}) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      let i;
      let l;
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        if (isBuffer(obj)) {
          return;
        }
        const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        const len = keys.length;
        let key;
        for (i = 0; i < len; i++) {
          key = keys[i];
          fn.call(null, obj[key], key, obj);
        }
      }
    }
    function findKey(obj, key) {
      if (isBuffer(obj)) {
        return null;
      }
      key = key.toLowerCase();
      const keys = Object.keys(obj);
      let i = keys.length;
      let _key;
      while (i-- > 0) {
        _key = keys[i];
        if (key === _key.toLowerCase()) {
          return _key;
        }
      }
      return null;
    }
    var _global = (() => {
      if (typeof globalThis !== "undefined") return globalThis;
      return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
    })();
    var isContextDefined = (context) => !isUndefined(context) && context !== _global;
    function merge() {
      const { caseless } = isContextDefined(this) && this || {};
      const result = {};
      const assignValue = (val, key) => {
        const targetKey = caseless && findKey(result, key) || key;
        if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
          result[targetKey] = merge(result[targetKey], val);
        } else if (isPlainObject(val)) {
          result[targetKey] = merge({}, val);
        } else if (isArray(val)) {
          result[targetKey] = val.slice();
        } else {
          result[targetKey] = val;
        }
      };
      for (let i = 0, l = arguments.length; i < l; i++) {
        arguments[i] && forEach(arguments[i], assignValue);
      }
      return result;
    }
    var extend = (a, b, thisArg, { allOwnKeys } = {}) => {
      forEach(b, (val, key) => {
        if (thisArg && isFunction(val)) {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      }, { allOwnKeys });
      return a;
    };
    var stripBOM = (content) => {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    };
    var inherits = (constructor, superConstructor, props, descriptors2) => {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
      constructor.prototype.constructor = constructor;
      Object.defineProperty(constructor, "super", {
        value: superConstructor.prototype
      });
      props && Object.assign(constructor.prototype, props);
    };
    var toFlatObject = (sourceObj, destObj, filter, propFilter) => {
      let props;
      let i;
      let prop;
      const merged = {};
      destObj = destObj || {};
      if (sourceObj == null) return destObj;
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while (i-- > 0) {
          prop = props[i];
          if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = filter !== false && getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    };
    var endsWith = (str, searchString, position) => {
      str = String(str);
      if (position === void 0 || position > str.length) {
        position = str.length;
      }
      position -= searchString.length;
      const lastIndex = str.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    };
    var toArray2 = (thing) => {
      if (!thing) return null;
      if (isArray(thing)) return thing;
      let i = thing.length;
      if (!isNumber(i)) return null;
      const arr2 = new Array(i);
      while (i-- > 0) {
        arr2[i] = thing[i];
      }
      return arr2;
    };
    var isTypedArray = /* @__PURE__ */ ((TypedArray) => {
      return (thing) => {
        return TypedArray && thing instanceof TypedArray;
      };
    })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
    var forEachEntry = (obj, fn) => {
      const generator = obj && obj[iterator];
      const _iterator = generator.call(obj);
      let result;
      while ((result = _iterator.next()) && !result.done) {
        const pair = result.value;
        fn.call(obj, pair[0], pair[1]);
      }
    };
    var matchAll = (regExp, str) => {
      let matches;
      const arr2 = [];
      while ((matches = regExp.exec(str)) !== null) {
        arr2.push(matches);
      }
      return arr2;
    };
    var isHTMLForm = kindOfTest("HTMLFormElement");
    var toCamelCase = (str) => {
      return str.toLowerCase().replace(
        /[-_\s]([a-z\d])(\w*)/g,
        function replacer(m, p1, p2) {
          return p1.toUpperCase() + p2;
        }
      );
    };
    var hasOwnProperty2 = (({ hasOwnProperty: hasOwnProperty3 }) => (obj, prop) => hasOwnProperty3.call(obj, prop))(Object.prototype);
    var isRegExp = kindOfTest("RegExp");
    var reduceDescriptors = (obj, reducer) => {
      const descriptors2 = Object.getOwnPropertyDescriptors(obj);
      const reducedDescriptors = {};
      forEach(descriptors2, (descriptor, name) => {
        let ret;
        if ((ret = reducer(descriptor, name, obj)) !== false) {
          reducedDescriptors[name] = ret || descriptor;
        }
      });
      Object.defineProperties(obj, reducedDescriptors);
    };
    var freezeMethods = (obj) => {
      reduceDescriptors(obj, (descriptor, name) => {
        if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
          return false;
        }
        const value = obj[name];
        if (!isFunction(value)) return;
        descriptor.enumerable = false;
        if ("writable" in descriptor) {
          descriptor.writable = false;
          return;
        }
        if (!descriptor.set) {
          descriptor.set = () => {
            throw Error("Can not rewrite read-only method '" + name + "'");
          };
        }
      });
    };
    var toObjectSet = (arrayOrString, delimiter) => {
      const obj = {};
      const define2 = (arr2) => {
        arr2.forEach((value) => {
          obj[value] = true;
        });
      };
      isArray(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
      return obj;
    };
    var noop = () => {
    };
    var toFiniteNumber = (value, defaultValue) => {
      return value != null && Number.isFinite(value = +value) ? value : defaultValue;
    };
    function isSpecCompliantForm(thing) {
      return !!(thing && isFunction(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
    }
    var toJSONObject = (obj) => {
      const stack = new Array(10);
      const visit = (source, i) => {
        if (isObject(source)) {
          if (stack.indexOf(source) >= 0) {
            return;
          }
          if (isBuffer(source)) {
            return source;
          }
          if (!("toJSON" in source)) {
            stack[i] = source;
            const target = isArray(source) ? [] : {};
            forEach(source, (value, key) => {
              const reducedValue = visit(value, i + 1);
              !isUndefined(reducedValue) && (target[key] = reducedValue);
            });
            stack[i] = void 0;
            return target;
          }
        }
        return source;
      };
      return visit(obj, 0);
    };
    var isAsyncFn = kindOfTest("AsyncFunction");
    var isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
    var _setImmediate = ((setImmediateSupported, postMessageSupported) => {
      if (setImmediateSupported) {
        return setImmediate;
      }
      return postMessageSupported ? ((token, callbacks) => {
        _global.addEventListener("message", ({ source, data }) => {
          if (source === _global && data === token) {
            callbacks.length && callbacks.shift()();
          }
        }, false);
        return (cb) => {
          callbacks.push(cb);
          _global.postMessage(token, "*");
        };
      })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
    })(
      typeof setImmediate === "function",
      isFunction(_global.postMessage)
    );
    var asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
    var isIterable = (thing) => thing != null && isFunction(thing[iterator]);
    var utils$1 = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isBoolean,
      isObject,
      isPlainObject,
      isEmptyObject,
      isReadableStream,
      isRequest,
      isResponse,
      isHeaders,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isRegExp,
      isFunction,
      isStream,
      isURLSearchParams,
      isTypedArray,
      isFileList,
      forEach,
      merge,
      extend,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray: toArray2,
      forEachEntry,
      matchAll,
      isHTMLForm,
      hasOwnProperty: hasOwnProperty2,
      hasOwnProp: hasOwnProperty2,
      // an alias to avoid ESLint no-prototype-builtins detection
      reduceDescriptors,
      freezeMethods,
      toObjectSet,
      toCamelCase,
      noop,
      toFiniteNumber,
      findKey,
      global: _global,
      isContextDefined,
      isSpecCompliantForm,
      toJSONObject,
      isAsyncFn,
      isThenable,
      setImmediate: _setImmediate,
      asap,
      isIterable
    };
    function AxiosError(message, code, config, request, response) {
      Error.call(this);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack;
      }
      this.message = message;
      this.name = "AxiosError";
      code && (this.code = code);
      config && (this.config = config);
      request && (this.request = request);
      if (response) {
        this.response = response;
        this.status = response.status ? response.status : null;
      }
    }
    utils$1.inherits(AxiosError, Error, {
      toJSON: function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: utils$1.toJSONObject(this.config),
          code: this.code,
          status: this.status
        };
      }
    });
    var prototype$1 = AxiosError.prototype;
    var descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED",
      "ERR_NOT_SUPPORT",
      "ERR_INVALID_URL"
      // eslint-disable-next-line func-names
    ].forEach((code) => {
      descriptors[code] = { value: code };
    });
    Object.defineProperties(AxiosError, descriptors);
    Object.defineProperty(prototype$1, "isAxiosError", { value: true });
    AxiosError.from = (error, code, config, request, response, customProps) => {
      const axiosError = Object.create(prototype$1);
      utils$1.toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
      }, (prop) => {
        return prop !== "isAxiosError";
      });
      AxiosError.call(axiosError, error.message, code, config, request, response);
      axiosError.cause = error;
      axiosError.name = error.name;
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    function isVisitable(thing) {
      return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
    }
    function removeBrackets(key) {
      return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
    }
    function renderKey(path, key, dots) {
      if (!path) return key;
      return path.concat(key).map(function each(token, i) {
        token = removeBrackets(token);
        return !dots && i ? "[" + token + "]" : token;
      }).join(dots ? "." : "");
    }
    function isFlatArray(arr2) {
      return utils$1.isArray(arr2) && !arr2.some(isVisitable);
    }
    var predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
      return /^is[A-Z]/.test(prop);
    });
    function toFormData(obj, formData, options) {
      if (!utils$1.isObject(obj)) {
        throw new TypeError("target must be an object");
      }
      formData = formData || new (FormData__default["default"] || FormData)();
      options = utils$1.toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
      }, false, function defined(option, source) {
        return !utils$1.isUndefined(source[option]);
      });
      const metaTokens = options.metaTokens;
      const visitor = options.visitor || defaultVisitor;
      const dots = options.dots;
      const indexes = options.indexes;
      const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
      const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
      if (!utils$1.isFunction(visitor)) {
        throw new TypeError("visitor must be a function");
      }
      function convertValue(value) {
        if (value === null) return "";
        if (utils$1.isDate(value)) {
          return value.toISOString();
        }
        if (utils$1.isBoolean(value)) {
          return value.toString();
        }
        if (!useBlob && utils$1.isBlob(value)) {
          throw new AxiosError("Blob is not supported. Use a Buffer instead.");
        }
        if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
          return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
        }
        return value;
      }
      function defaultVisitor(value, key, path) {
        let arr2 = value;
        if (value && !path && typeof value === "object") {
          if (utils$1.endsWith(key, "{}")) {
            key = metaTokens ? key : key.slice(0, -2);
            value = JSON.stringify(value);
          } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr2 = utils$1.toArray(value))) {
            key = removeBrackets(key);
            arr2.forEach(function each(el, index) {
              !(utils$1.isUndefined(el) || el === null) && formData.append(
                // eslint-disable-next-line no-nested-ternary
                indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
                convertValue(el)
              );
            });
            return false;
          }
        }
        if (isVisitable(value)) {
          return true;
        }
        formData.append(renderKey(path, key, dots), convertValue(value));
        return false;
      }
      const stack = [];
      const exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
      });
      function build(value, path) {
        if (utils$1.isUndefined(value)) return;
        if (stack.indexOf(value) !== -1) {
          throw Error("Circular reference detected in " + path.join("."));
        }
        stack.push(value);
        utils$1.forEach(value, function each(el, key) {
          const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
            formData,
            el,
            utils$1.isString(key) ? key.trim() : key,
            path,
            exposedHelpers
          );
          if (result === true) {
            build(el, path ? path.concat(key) : [key]);
          }
        });
        stack.pop();
      }
      if (!utils$1.isObject(obj)) {
        throw new TypeError("data must be an object");
      }
      build(obj);
      return formData;
    }
    function encode$1(str) {
      const charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
      };
      return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
        return charMap[match];
      });
    }
    function AxiosURLSearchParams(params, options) {
      this._pairs = [];
      params && toFormData(params, this, options);
    }
    var prototype = AxiosURLSearchParams.prototype;
    prototype.append = function append(name, value) {
      this._pairs.push([name, value]);
    };
    prototype.toString = function toString2(encoder2) {
      const _encode = encoder2 ? function(value) {
        return encoder2.call(this, value, encode$1);
      } : encode$1;
      return this._pairs.map(function each(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
      }, "").join("&");
    };
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    function buildURL(url2, params, options) {
      if (!params) {
        return url2;
      }
      const _encode = options && options.encode || encode;
      if (utils$1.isFunction(options)) {
        options = {
          serialize: options
        };
      }
      const serializeFn = options && options.serialize;
      let serializedParams;
      if (serializeFn) {
        serializedParams = serializeFn(params, options);
      } else {
        serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
      }
      if (serializedParams) {
        const hashmarkIndex = url2.indexOf("#");
        if (hashmarkIndex !== -1) {
          url2 = url2.slice(0, hashmarkIndex);
        }
        url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url2;
    }
    var InterceptorManager = class {
      constructor() {
        this.handlers = [];
      }
      /**
       * Add a new interceptor to the stack
       *
       * @param {Function} fulfilled The function to handle `then` for a `Promise`
       * @param {Function} rejected The function to handle `reject` for a `Promise`
       *
       * @return {Number} An ID used to remove interceptor later
       */
      use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      }
      /**
       * Remove an interceptor from the stack
       *
       * @param {Number} id The ID that was returned by `use`
       *
       * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
       */
      eject(id) {
        if (this.handlers[id]) {
          this.handlers[id] = null;
        }
      }
      /**
       * Clear all interceptors from the stack
       *
       * @returns {void}
       */
      clear() {
        if (this.handlers) {
          this.handlers = [];
        }
      }
      /**
       * Iterate over all the registered interceptors
       *
       * This method is particularly useful for skipping over any
       * interceptors that may have become `null` calling `eject`.
       *
       * @param {Function} fn The function to call for each interceptor
       *
       * @returns {void}
       */
      forEach(fn) {
        utils$1.forEach(this.handlers, function forEachHandler(h) {
          if (h !== null) {
            fn(h);
          }
        });
      }
    };
    var InterceptorManager$1 = InterceptorManager;
    var transitionalDefaults = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
    var URLSearchParams2 = url__default["default"].URLSearchParams;
    var ALPHA = "abcdefghijklmnopqrstuvwxyz";
    var DIGIT = "0123456789";
    var ALPHABET = {
      DIGIT,
      ALPHA,
      ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
    };
    var generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
      let str = "";
      const { length } = alphabet;
      const randomValues = new Uint32Array(size);
      crypto__default["default"].randomFillSync(randomValues);
      for (let i = 0; i < size; i++) {
        str += alphabet[randomValues[i] % length];
      }
      return str;
    };
    var platform$1 = {
      isNode: true,
      classes: {
        URLSearchParams: URLSearchParams2,
        FormData: FormData__default["default"],
        Blob: typeof Blob !== "undefined" && Blob || null
      },
      ALPHABET,
      generateString,
      protocols: ["http", "https", "file", "data"]
    };
    var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
    var _navigator = typeof navigator === "object" && navigator || void 0;
    var hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
    var hasStandardBrowserWebWorkerEnv = (() => {
      return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
      self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
    })();
    var origin = hasBrowserEnv && window.location.href || "http://localhost";
    var utils = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      hasBrowserEnv,
      hasStandardBrowserWebWorkerEnv,
      hasStandardBrowserEnv,
      navigator: _navigator,
      origin
    });
    var platform = {
      ...utils,
      ...platform$1
    };
    function toURLEncodedForm(data, options) {
      return toFormData(data, new platform.classes.URLSearchParams(), {
        visitor: function(value, key, path, helpers) {
          if (platform.isNode && utils$1.isBuffer(value)) {
            this.append(key, value.toString("base64"));
            return false;
          }
          return helpers.defaultVisitor.apply(this, arguments);
        },
        ...options
      });
    }
    function parsePropPath(name) {
      return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
        return match[0] === "[]" ? "" : match[1] || match[0];
      });
    }
    function arrayToObject(arr2) {
      const obj = {};
      const keys = Object.keys(arr2);
      let i;
      const len = keys.length;
      let key;
      for (i = 0; i < len; i++) {
        key = keys[i];
        obj[key] = arr2[key];
      }
      return obj;
    }
    function formDataToJSON(formData) {
      function buildPath(path, value, target, index) {
        let name = path[index++];
        if (name === "__proto__") return true;
        const isNumericKey = Number.isFinite(+name);
        const isLast = index >= path.length;
        name = !name && utils$1.isArray(target) ? target.length : name;
        if (isLast) {
          if (utils$1.hasOwnProp(target, name)) {
            target[name] = [target[name], value];
          } else {
            target[name] = value;
          }
          return !isNumericKey;
        }
        if (!target[name] || !utils$1.isObject(target[name])) {
          target[name] = [];
        }
        const result = buildPath(path, value, target[name], index);
        if (result && utils$1.isArray(target[name])) {
          target[name] = arrayToObject(target[name]);
        }
        return !isNumericKey;
      }
      if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
        const obj = {};
        utils$1.forEachEntry(formData, (name, value) => {
          buildPath(parsePropPath(name), value, obj, 0);
        });
        return obj;
      }
      return null;
    }
    function stringifySafely(rawValue, parser, encoder2) {
      if (utils$1.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils$1.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder2 || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: transitionalDefaults,
      adapter: ["xhr", "http", "fetch"],
      transformRequest: [function transformRequest(data, headers) {
        const contentType = headers.getContentType() || "";
        const hasJSONContentType = contentType.indexOf("application/json") > -1;
        const isObjectPayload = utils$1.isObject(data);
        if (isObjectPayload && utils$1.isHTMLForm(data)) {
          data = new FormData(data);
        }
        const isFormData2 = utils$1.isFormData(data);
        if (isFormData2) {
          return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
        }
        if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data) || utils$1.isReadableStream(data)) {
          return data;
        }
        if (utils$1.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils$1.isURLSearchParams(data)) {
          headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
          return data.toString();
        }
        let isFileList2;
        if (isObjectPayload) {
          if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
            return toURLEncodedForm(data, this.formSerializer).toString();
          }
          if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
            const _FormData = this.env && this.env.FormData;
            return toFormData(
              isFileList2 ? { "files[]": data } : data,
              _FormData && new _FormData(),
              this.formSerializer
            );
          }
        }
        if (isObjectPayload || hasJSONContentType) {
          headers.setContentType("application/json", false);
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        const transitional = this.transitional || defaults.transitional;
        const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        const JSONRequested = this.responseType === "json";
        if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
          return data;
        }
        if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
          const silentJSONParsing = transitional && transitional.silentJSONParsing;
          const strictJSONParsing = !silentJSONParsing && JSONRequested;
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: platform.classes.FormData,
        Blob: platform.classes.Blob
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*",
          "Content-Type": void 0
        }
      }
    };
    utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
      defaults.headers[method] = {};
    });
    var defaults$1 = defaults;
    var ignoreDuplicateOf = utils$1.toObjectSet([
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ]);
    var parseHeaders = (rawHeaders) => {
      const parsed = {};
      let key;
      let val;
      let i;
      rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
        i = line.indexOf(":");
        key = line.substring(0, i).trim().toLowerCase();
        val = line.substring(i + 1).trim();
        if (!key || parsed[key] && ignoreDuplicateOf[key]) {
          return;
        }
        if (key === "set-cookie") {
          if (parsed[key]) {
            parsed[key].push(val);
          } else {
            parsed[key] = [val];
          }
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      });
      return parsed;
    };
    var $internals = Symbol("internals");
    function normalizeHeader(header) {
      return header && String(header).trim().toLowerCase();
    }
    function normalizeValue(value) {
      if (value === false || value == null) {
        return value;
      }
      return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
    }
    function parseTokens(str) {
      const tokens = /* @__PURE__ */ Object.create(null);
      const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
      let match;
      while (match = tokensRE.exec(str)) {
        tokens[match[1]] = match[2];
      }
      return tokens;
    }
    var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
    function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
      if (utils$1.isFunction(filter)) {
        return filter.call(this, value, header);
      }
      if (isHeaderNameFilter) {
        value = header;
      }
      if (!utils$1.isString(value)) return;
      if (utils$1.isString(filter)) {
        return value.indexOf(filter) !== -1;
      }
      if (utils$1.isRegExp(filter)) {
        return filter.test(value);
      }
    }
    function formatHeader(header) {
      return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
        return char.toUpperCase() + str;
      });
    }
    function buildAccessors(obj, header) {
      const accessorName = utils$1.toCamelCase(" " + header);
      ["get", "set", "has"].forEach((methodName) => {
        Object.defineProperty(obj, methodName + accessorName, {
          value: function(arg1, arg2, arg3) {
            return this[methodName].call(this, header, arg1, arg2, arg3);
          },
          configurable: true
        });
      });
    }
    var AxiosHeaders = class {
      constructor(headers) {
        headers && this.set(headers);
      }
      set(header, valueOrRewrite, rewrite) {
        const self2 = this;
        function setHeader(_value, _header, _rewrite) {
          const lHeader = normalizeHeader(_header);
          if (!lHeader) {
            throw new Error("header name must be a non-empty string");
          }
          const key = utils$1.findKey(self2, lHeader);
          if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
            self2[key || _header] = normalizeValue(_value);
          }
        }
        const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
        if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
          setHeaders(header, valueOrRewrite);
        } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
          setHeaders(parseHeaders(header), valueOrRewrite);
        } else if (utils$1.isObject(header) && utils$1.isIterable(header)) {
          let obj = {}, dest, key;
          for (const entry of header) {
            if (!utils$1.isArray(entry)) {
              throw TypeError("Object iterator must return a key-value pair");
            }
            obj[key = entry[0]] = (dest = obj[key]) ? utils$1.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
          }
          setHeaders(obj, valueOrRewrite);
        } else {
          header != null && setHeader(valueOrRewrite, header, rewrite);
        }
        return this;
      }
      get(header, parser) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          if (key) {
            const value = this[key];
            if (!parser) {
              return value;
            }
            if (parser === true) {
              return parseTokens(value);
            }
            if (utils$1.isFunction(parser)) {
              return parser.call(this, value, key);
            }
            if (utils$1.isRegExp(parser)) {
              return parser.exec(value);
            }
            throw new TypeError("parser must be boolean|regexp|function");
          }
        }
      }
      has(header, matcher) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
        }
        return false;
      }
      delete(header, matcher) {
        const self2 = this;
        let deleted = false;
        function deleteHeader(_header) {
          _header = normalizeHeader(_header);
          if (_header) {
            const key = utils$1.findKey(self2, _header);
            if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
              delete self2[key];
              deleted = true;
            }
          }
        }
        if (utils$1.isArray(header)) {
          header.forEach(deleteHeader);
        } else {
          deleteHeader(header);
        }
        return deleted;
      }
      clear(matcher) {
        const keys = Object.keys(this);
        let i = keys.length;
        let deleted = false;
        while (i--) {
          const key = keys[i];
          if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
            delete this[key];
            deleted = true;
          }
        }
        return deleted;
      }
      normalize(format) {
        const self2 = this;
        const headers = {};
        utils$1.forEach(this, (value, header) => {
          const key = utils$1.findKey(headers, header);
          if (key) {
            self2[key] = normalizeValue(value);
            delete self2[header];
            return;
          }
          const normalized = format ? formatHeader(header) : String(header).trim();
          if (normalized !== header) {
            delete self2[header];
          }
          self2[normalized] = normalizeValue(value);
          headers[normalized] = true;
        });
        return this;
      }
      concat(...targets) {
        return this.constructor.concat(this, ...targets);
      }
      toJSON(asStrings) {
        const obj = /* @__PURE__ */ Object.create(null);
        utils$1.forEach(this, (value, header) => {
          value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
        });
        return obj;
      }
      [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
      }
      toString() {
        return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
      }
      getSetCookie() {
        return this.get("set-cookie") || [];
      }
      get [Symbol.toStringTag]() {
        return "AxiosHeaders";
      }
      static from(thing) {
        return thing instanceof this ? thing : new this(thing);
      }
      static concat(first, ...targets) {
        const computed = new this(first);
        targets.forEach((target) => computed.set(target));
        return computed;
      }
      static accessor(header) {
        const internals = this[$internals] = this[$internals] = {
          accessors: {}
        };
        const accessors = internals.accessors;
        const prototype2 = this.prototype;
        function defineAccessor(_header) {
          const lHeader = normalizeHeader(_header);
          if (!accessors[lHeader]) {
            buildAccessors(prototype2, _header);
            accessors[lHeader] = true;
          }
        }
        utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
      }
    };
    AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
    utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
      let mapped = key[0].toUpperCase() + key.slice(1);
      return {
        get: () => value,
        set(headerValue) {
          this[mapped] = headerValue;
        }
      };
    });
    utils$1.freezeMethods(AxiosHeaders);
    var AxiosHeaders$1 = AxiosHeaders;
    function transformData(fns, response) {
      const config = this || defaults$1;
      const context = response || config;
      const headers = AxiosHeaders$1.from(context.headers);
      let data = context.data;
      utils$1.forEach(fns, function transform(fn) {
        data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
      });
      headers.normalize();
      return data;
    }
    function isCancel(value) {
      return !!(value && value.__CANCEL__);
    }
    function CanceledError(message, config, request) {
      AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
      this.name = "CanceledError";
    }
    utils$1.inherits(CanceledError, AxiosError, {
      __CANCEL__: true
    });
    function settle(resolve, reject, response) {
      const validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(new AxiosError(
          "Request failed with status code " + response.status,
          [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    }
    function isAbsoluteURL(url2) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
    }
    function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    }
    function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
      let isRelativeUrl = !isAbsoluteURL(requestedURL);
      if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    }
    var VERSION = "1.11.0";
    function parseProtocol(url2) {
      const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
      return match && match[1] || "";
    }
    var DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
    function fromDataURI(uri, asBlob, options) {
      const _Blob = options && options.Blob || platform.classes.Blob;
      const protocol = parseProtocol(uri);
      if (asBlob === void 0 && _Blob) {
        asBlob = true;
      }
      if (protocol === "data") {
        uri = protocol.length ? uri.slice(protocol.length + 1) : uri;
        const match = DATA_URL_PATTERN.exec(uri);
        if (!match) {
          throw new AxiosError("Invalid URL", AxiosError.ERR_INVALID_URL);
        }
        const mime = match[1];
        const isBase64 = match[2];
        const body = match[3];
        const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? "base64" : "utf8");
        if (asBlob) {
          if (!_Blob) {
            throw new AxiosError("Blob is not supported", AxiosError.ERR_NOT_SUPPORT);
          }
          return new _Blob([buffer], { type: mime });
        }
        return buffer;
      }
      throw new AxiosError("Unsupported protocol " + protocol, AxiosError.ERR_NOT_SUPPORT);
    }
    var kInternals = Symbol("internals");
    var AxiosTransformStream = class extends stream__default["default"].Transform {
      constructor(options) {
        options = utils$1.toFlatObject(options, {
          maxRate: 0,
          chunkSize: 64 * 1024,
          minChunkSize: 100,
          timeWindow: 500,
          ticksRate: 2,
          samplesCount: 15
        }, null, (prop, source) => {
          return !utils$1.isUndefined(source[prop]);
        });
        super({
          readableHighWaterMark: options.chunkSize
        });
        const internals = this[kInternals] = {
          timeWindow: options.timeWindow,
          chunkSize: options.chunkSize,
          maxRate: options.maxRate,
          minChunkSize: options.minChunkSize,
          bytesSeen: 0,
          isCaptured: false,
          notifiedBytesLoaded: 0,
          ts: Date.now(),
          bytes: 0,
          onReadCallback: null
        };
        this.on("newListener", (event) => {
          if (event === "progress") {
            if (!internals.isCaptured) {
              internals.isCaptured = true;
            }
          }
        });
      }
      _read(size) {
        const internals = this[kInternals];
        if (internals.onReadCallback) {
          internals.onReadCallback();
        }
        return super._read(size);
      }
      _transform(chunk, encoding, callback) {
        const internals = this[kInternals];
        const maxRate = internals.maxRate;
        const readableHighWaterMark = this.readableHighWaterMark;
        const timeWindow = internals.timeWindow;
        const divider = 1e3 / timeWindow;
        const bytesThreshold = maxRate / divider;
        const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;
        const pushChunk = (_chunk, _callback) => {
          const bytes = Buffer.byteLength(_chunk);
          internals.bytesSeen += bytes;
          internals.bytes += bytes;
          internals.isCaptured && this.emit("progress", internals.bytesSeen);
          if (this.push(_chunk)) {
            process.nextTick(_callback);
          } else {
            internals.onReadCallback = () => {
              internals.onReadCallback = null;
              process.nextTick(_callback);
            };
          }
        };
        const transformChunk = (_chunk, _callback) => {
          const chunkSize = Buffer.byteLength(_chunk);
          let chunkRemainder = null;
          let maxChunkSize = readableHighWaterMark;
          let bytesLeft;
          let passed = 0;
          if (maxRate) {
            const now = Date.now();
            if (!internals.ts || (passed = now - internals.ts) >= timeWindow) {
              internals.ts = now;
              bytesLeft = bytesThreshold - internals.bytes;
              internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
              passed = 0;
            }
            bytesLeft = bytesThreshold - internals.bytes;
          }
          if (maxRate) {
            if (bytesLeft <= 0) {
              return setTimeout(() => {
                _callback(null, _chunk);
              }, timeWindow - passed);
            }
            if (bytesLeft < maxChunkSize) {
              maxChunkSize = bytesLeft;
            }
          }
          if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {
            chunkRemainder = _chunk.subarray(maxChunkSize);
            _chunk = _chunk.subarray(0, maxChunkSize);
          }
          pushChunk(_chunk, chunkRemainder ? () => {
            process.nextTick(_callback, null, chunkRemainder);
          } : _callback);
        };
        transformChunk(chunk, function transformNextChunk(err, _chunk) {
          if (err) {
            return callback(err);
          }
          if (_chunk) {
            transformChunk(_chunk, transformNextChunk);
          } else {
            callback(null);
          }
        });
      }
    };
    var AxiosTransformStream$1 = AxiosTransformStream;
    var { asyncIterator } = Symbol;
    var readBlob = async function* (blob) {
      if (blob.stream) {
        yield* blob.stream();
      } else if (blob.arrayBuffer) {
        yield await blob.arrayBuffer();
      } else if (blob[asyncIterator]) {
        yield* blob[asyncIterator]();
      } else {
        yield blob;
      }
    };
    var readBlob$1 = readBlob;
    var BOUNDARY_ALPHABET = platform.ALPHABET.ALPHA_DIGIT + "-_";
    var textEncoder = typeof TextEncoder === "function" ? new TextEncoder() : new util__default["default"].TextEncoder();
    var CRLF = "\r\n";
    var CRLF_BYTES = textEncoder.encode(CRLF);
    var CRLF_BYTES_COUNT = 2;
    var FormDataPart = class {
      constructor(name, value) {
        const { escapeName } = this.constructor;
        const isStringValue = utils$1.isString(value);
        let headers = `Content-Disposition: form-data; name="${escapeName(name)}"${!isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ""}${CRLF}`;
        if (isStringValue) {
          value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
        } else {
          headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
        }
        this.headers = textEncoder.encode(headers + CRLF);
        this.contentLength = isStringValue ? value.byteLength : value.size;
        this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;
        this.name = name;
        this.value = value;
      }
      async *encode() {
        yield this.headers;
        const { value } = this;
        if (utils$1.isTypedArray(value)) {
          yield value;
        } else {
          yield* readBlob$1(value);
        }
        yield CRLF_BYTES;
      }
      static escapeName(name) {
        return String(name).replace(/[\r\n"]/g, (match) => ({
          "\r": "%0D",
          "\n": "%0A",
          '"': "%22"
        })[match]);
      }
    };
    var formDataToStream = (form, headersHandler, options) => {
      const {
        tag = "form-data-boundary",
        size = 25,
        boundary = tag + "-" + platform.generateString(size, BOUNDARY_ALPHABET)
      } = options || {};
      if (!utils$1.isFormData(form)) {
        throw TypeError("FormData instance required");
      }
      if (boundary.length < 1 || boundary.length > 70) {
        throw Error("boundary must be 10-70 characters long");
      }
      const boundaryBytes = textEncoder.encode("--" + boundary + CRLF);
      const footerBytes = textEncoder.encode("--" + boundary + "--" + CRLF);
      let contentLength = footerBytes.byteLength;
      const parts = Array.from(form.entries()).map(([name, value]) => {
        const part = new FormDataPart(name, value);
        contentLength += part.size;
        return part;
      });
      contentLength += boundaryBytes.byteLength * parts.length;
      contentLength = utils$1.toFiniteNumber(contentLength);
      const computedHeaders = {
        "Content-Type": `multipart/form-data; boundary=${boundary}`
      };
      if (Number.isFinite(contentLength)) {
        computedHeaders["Content-Length"] = contentLength;
      }
      headersHandler && headersHandler(computedHeaders);
      return stream.Readable.from(async function* () {
        for (const part of parts) {
          yield boundaryBytes;
          yield* part.encode();
        }
        yield footerBytes;
      }());
    };
    var formDataToStream$1 = formDataToStream;
    var ZlibHeaderTransformStream = class extends stream__default["default"].Transform {
      __transform(chunk, encoding, callback) {
        this.push(chunk);
        callback();
      }
      _transform(chunk, encoding, callback) {
        if (chunk.length !== 0) {
          this._transform = this.__transform;
          if (chunk[0] !== 120) {
            const header = Buffer.alloc(2);
            header[0] = 120;
            header[1] = 156;
            this.push(header, encoding);
          }
        }
        this.__transform(chunk, encoding, callback);
      }
    };
    var ZlibHeaderTransformStream$1 = ZlibHeaderTransformStream;
    var callbackify = (fn, reducer) => {
      return utils$1.isAsyncFn(fn) ? function(...args) {
        const cb = args.pop();
        fn.apply(this, args).then((value) => {
          try {
            reducer ? cb(null, ...reducer(value)) : cb(null, value);
          } catch (err) {
            cb(err);
          }
        }, cb);
      } : fn;
    };
    var callbackify$1 = callbackify;
    function speedometer(samplesCount, min) {
      samplesCount = samplesCount || 10;
      const bytes = new Array(samplesCount);
      const timestamps = new Array(samplesCount);
      let head = 0;
      let tail = 0;
      let firstSampleTS;
      min = min !== void 0 ? min : 1e3;
      return function push(chunkLength) {
        const now = Date.now();
        const startedAt = timestamps[tail];
        if (!firstSampleTS) {
          firstSampleTS = now;
        }
        bytes[head] = chunkLength;
        timestamps[head] = now;
        let i = tail;
        let bytesCount = 0;
        while (i !== head) {
          bytesCount += bytes[i++];
          i = i % samplesCount;
        }
        head = (head + 1) % samplesCount;
        if (head === tail) {
          tail = (tail + 1) % samplesCount;
        }
        if (now - firstSampleTS < min) {
          return;
        }
        const passed = startedAt && now - startedAt;
        return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
      };
    }
    function throttle(fn, freq) {
      let timestamp = 0;
      let threshold = 1e3 / freq;
      let lastArgs;
      let timer;
      const invoke = (args, now = Date.now()) => {
        timestamp = now;
        lastArgs = null;
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
        fn(...args);
      };
      const throttled = (...args) => {
        const now = Date.now();
        const passed = now - timestamp;
        if (passed >= threshold) {
          invoke(args, now);
        } else {
          lastArgs = args;
          if (!timer) {
            timer = setTimeout(() => {
              timer = null;
              invoke(lastArgs);
            }, threshold - passed);
          }
        }
      };
      const flush = () => lastArgs && invoke(lastArgs);
      return [throttled, flush];
    }
    var progressEventReducer = (listener, isDownloadStream, freq = 3) => {
      let bytesNotified = 0;
      const _speedometer = speedometer(50, 250);
      return throttle((e) => {
        const loaded = e.loaded;
        const total = e.lengthComputable ? e.total : void 0;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;
        bytesNotified = loaded;
        const data = {
          loaded,
          total,
          progress: total ? loaded / total : void 0,
          bytes: progressBytes,
          rate: rate ? rate : void 0,
          estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
          event: e,
          lengthComputable: total != null,
          [isDownloadStream ? "download" : "upload"]: true
        };
        listener(data);
      }, freq);
    };
    var progressEventDecorator = (total, throttled) => {
      const lengthComputable = total != null;
      return [(loaded) => throttled[0]({
        lengthComputable,
        total,
        loaded
      }), throttled[1]];
    };
    var asyncDecorator = (fn) => (...args) => utils$1.asap(() => fn(...args));
    var zlibOptions = {
      flush: zlib__default["default"].constants.Z_SYNC_FLUSH,
      finishFlush: zlib__default["default"].constants.Z_SYNC_FLUSH
    };
    var brotliOptions = {
      flush: zlib__default["default"].constants.BROTLI_OPERATION_FLUSH,
      finishFlush: zlib__default["default"].constants.BROTLI_OPERATION_FLUSH
    };
    var isBrotliSupported = utils$1.isFunction(zlib__default["default"].createBrotliDecompress);
    var { http: httpFollow, https: httpsFollow } = followRedirects__default["default"];
    var isHttps = /https:?/;
    var supportedProtocols = platform.protocols.map((protocol) => {
      return protocol + ":";
    });
    var flushOnFinish = (stream2, [throttled, flush]) => {
      stream2.on("end", flush).on("error", flush);
      return throttled;
    };
    function dispatchBeforeRedirect(options, responseDetails) {
      if (options.beforeRedirects.proxy) {
        options.beforeRedirects.proxy(options);
      }
      if (options.beforeRedirects.config) {
        options.beforeRedirects.config(options, responseDetails);
      }
    }
    function setProxy(options, configProxy, location) {
      let proxy = configProxy;
      if (!proxy && proxy !== false) {
        const proxyUrl = proxyFromEnv__default["default"].getProxyForUrl(location);
        if (proxyUrl) {
          proxy = new URL(proxyUrl);
        }
      }
      if (proxy) {
        if (proxy.username) {
          proxy.auth = (proxy.username || "") + ":" + (proxy.password || "");
        }
        if (proxy.auth) {
          if (proxy.auth.username || proxy.auth.password) {
            proxy.auth = (proxy.auth.username || "") + ":" + (proxy.auth.password || "");
          }
          const base642 = Buffer.from(proxy.auth, "utf8").toString("base64");
          options.headers["Proxy-Authorization"] = "Basic " + base642;
        }
        options.headers.host = options.hostname + (options.port ? ":" + options.port : "");
        const proxyHost = proxy.hostname || proxy.host;
        options.hostname = proxyHost;
        options.host = proxyHost;
        options.port = proxy.port;
        options.path = location;
        if (proxy.protocol) {
          options.protocol = proxy.protocol.includes(":") ? proxy.protocol : `${proxy.protocol}:`;
        }
      }
      options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
        setProxy(redirectOptions, configProxy, redirectOptions.href);
      };
    }
    var isHttpAdapterSupported = typeof process !== "undefined" && utils$1.kindOf(process) === "process";
    var wrapAsync = (asyncExecutor) => {
      return new Promise((resolve, reject) => {
        let onDone;
        let isDone;
        const done = (value, isRejected) => {
          if (isDone) return;
          isDone = true;
          onDone && onDone(value, isRejected);
        };
        const _resolve = (value) => {
          done(value);
          resolve(value);
        };
        const _reject = (reason) => {
          done(reason, true);
          reject(reason);
        };
        asyncExecutor(_resolve, _reject, (onDoneHandler) => onDone = onDoneHandler).catch(_reject);
      });
    };
    var resolveFamily = ({ address, family }) => {
      if (!utils$1.isString(address)) {
        throw TypeError("address must be a string");
      }
      return {
        address,
        family: family || (address.indexOf(".") < 0 ? 6 : 4)
      };
    };
    var buildAddressEntry = (address, family) => resolveFamily(utils$1.isObject(address) ? address : { address, family });
    var httpAdapter = isHttpAdapterSupported && function httpAdapter2(config) {
      return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {
        let { data, lookup, family } = config;
        const { responseType, responseEncoding } = config;
        const method = config.method.toUpperCase();
        let isDone;
        let rejected = false;
        let req;
        if (lookup) {
          const _lookup = callbackify$1(lookup, (value) => utils$1.isArray(value) ? value : [value]);
          lookup = (hostname, opt, cb) => {
            _lookup(hostname, opt, (err, arg0, arg1) => {
              if (err) {
                return cb(err);
              }
              const addresses = utils$1.isArray(arg0) ? arg0.map((addr) => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];
              opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
            });
          };
        }
        const emitter = new events.EventEmitter();
        const onFinished = () => {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(abort);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", abort);
          }
          emitter.removeAllListeners();
        };
        onDone((value, isRejected) => {
          isDone = true;
          if (isRejected) {
            rejected = true;
            onFinished();
          }
        });
        function abort(reason) {
          emitter.emit("abort", !reason || reason.type ? new CanceledError(null, config, req) : reason);
        }
        emitter.once("abort", reject);
        if (config.cancelToken || config.signal) {
          config.cancelToken && config.cancelToken.subscribe(abort);
          if (config.signal) {
            config.signal.aborted ? abort() : config.signal.addEventListener("abort", abort);
          }
        }
        const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
        const parsed = new URL(fullPath, platform.hasBrowserEnv ? platform.origin : void 0);
        const protocol = parsed.protocol || supportedProtocols[0];
        if (protocol === "data:") {
          let convertedData;
          if (method !== "GET") {
            return settle(resolve, reject, {
              status: 405,
              statusText: "method not allowed",
              headers: {},
              config
            });
          }
          try {
            convertedData = fromDataURI(config.url, responseType === "blob", {
              Blob: config.env && config.env.Blob
            });
          } catch (err) {
            throw AxiosError.from(err, AxiosError.ERR_BAD_REQUEST, config);
          }
          if (responseType === "text") {
            convertedData = convertedData.toString(responseEncoding);
            if (!responseEncoding || responseEncoding === "utf8") {
              convertedData = utils$1.stripBOM(convertedData);
            }
          } else if (responseType === "stream") {
            convertedData = stream__default["default"].Readable.from(convertedData);
          }
          return settle(resolve, reject, {
            data: convertedData,
            status: 200,
            statusText: "OK",
            headers: new AxiosHeaders$1(),
            config
          });
        }
        if (supportedProtocols.indexOf(protocol) === -1) {
          return reject(new AxiosError(
            "Unsupported protocol " + protocol,
            AxiosError.ERR_BAD_REQUEST,
            config
          ));
        }
        const headers = AxiosHeaders$1.from(config.headers).normalize();
        headers.set("User-Agent", "axios/" + VERSION, false);
        const { onUploadProgress, onDownloadProgress } = config;
        const maxRate = config.maxRate;
        let maxUploadRate = void 0;
        let maxDownloadRate = void 0;
        if (utils$1.isSpecCompliantForm(data)) {
          const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);
          data = formDataToStream$1(data, (formHeaders) => {
            headers.set(formHeaders);
          }, {
            tag: `axios-${VERSION}-boundary`,
            boundary: userBoundary && userBoundary[1] || void 0
          });
        } else if (utils$1.isFormData(data) && utils$1.isFunction(data.getHeaders)) {
          headers.set(data.getHeaders());
          if (!headers.hasContentLength()) {
            try {
              const knownLength = await util__default["default"].promisify(data.getLength).call(data);
              Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);
            } catch (e) {
            }
          }
        } else if (utils$1.isBlob(data) || utils$1.isFile(data)) {
          data.size && headers.setContentType(data.type || "application/octet-stream");
          headers.setContentLength(data.size || 0);
          data = stream__default["default"].Readable.from(readBlob$1(data));
        } else if (data && !utils$1.isStream(data)) {
          if (Buffer.isBuffer(data)) ;
          else if (utils$1.isArrayBuffer(data)) {
            data = Buffer.from(new Uint8Array(data));
          } else if (utils$1.isString(data)) {
            data = Buffer.from(data, "utf-8");
          } else {
            return reject(new AxiosError(
              "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
              AxiosError.ERR_BAD_REQUEST,
              config
            ));
          }
          headers.setContentLength(data.length, false);
          if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
            return reject(new AxiosError(
              "Request body larger than maxBodyLength limit",
              AxiosError.ERR_BAD_REQUEST,
              config
            ));
          }
        }
        const contentLength = utils$1.toFiniteNumber(headers.getContentLength());
        if (utils$1.isArray(maxRate)) {
          maxUploadRate = maxRate[0];
          maxDownloadRate = maxRate[1];
        } else {
          maxUploadRate = maxDownloadRate = maxRate;
        }
        if (data && (onUploadProgress || maxUploadRate)) {
          if (!utils$1.isStream(data)) {
            data = stream__default["default"].Readable.from(data, { objectMode: false });
          }
          data = stream__default["default"].pipeline([data, new AxiosTransformStream$1({
            maxRate: utils$1.toFiniteNumber(maxUploadRate)
          })], utils$1.noop);
          onUploadProgress && data.on("progress", flushOnFinish(
            data,
            progressEventDecorator(
              contentLength,
              progressEventReducer(asyncDecorator(onUploadProgress), false, 3)
            )
          ));
        }
        let auth = void 0;
        if (config.auth) {
          const username = config.auth.username || "";
          const password = config.auth.password || "";
          auth = username + ":" + password;
        }
        if (!auth && parsed.username) {
          const urlUsername = parsed.username;
          const urlPassword = parsed.password;
          auth = urlUsername + ":" + urlPassword;
        }
        auth && headers.delete("authorization");
        let path;
        try {
          path = buildURL(
            parsed.pathname + parsed.search,
            config.params,
            config.paramsSerializer
          ).replace(/^\?/, "");
        } catch (err) {
          const customErr = new Error(err.message);
          customErr.config = config;
          customErr.url = config.url;
          customErr.exists = true;
          return reject(customErr);
        }
        headers.set(
          "Accept-Encoding",
          "gzip, compress, deflate" + (isBrotliSupported ? ", br" : ""),
          false
        );
        const options = {
          path,
          method,
          headers: headers.toJSON(),
          agents: { http: config.httpAgent, https: config.httpsAgent },
          auth,
          protocol,
          family,
          beforeRedirect: dispatchBeforeRedirect,
          beforeRedirects: {}
        };
        !utils$1.isUndefined(lookup) && (options.lookup = lookup);
        if (config.socketPath) {
          options.socketPath = config.socketPath;
        } else {
          options.hostname = parsed.hostname.startsWith("[") ? parsed.hostname.slice(1, -1) : parsed.hostname;
          options.port = parsed.port;
          setProxy(options, config.proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
        }
        let transport;
        const isHttpsRequest = isHttps.test(options.protocol);
        options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
        if (config.transport) {
          transport = config.transport;
        } else if (config.maxRedirects === 0) {
          transport = isHttpsRequest ? https__default["default"] : http__default["default"];
        } else {
          if (config.maxRedirects) {
            options.maxRedirects = config.maxRedirects;
          }
          if (config.beforeRedirect) {
            options.beforeRedirects.config = config.beforeRedirect;
          }
          transport = isHttpsRequest ? httpsFollow : httpFollow;
        }
        if (config.maxBodyLength > -1) {
          options.maxBodyLength = config.maxBodyLength;
        } else {
          options.maxBodyLength = Infinity;
        }
        if (config.insecureHTTPParser) {
          options.insecureHTTPParser = config.insecureHTTPParser;
        }
        req = transport.request(options, function handleResponse(res) {
          if (req.destroyed) return;
          const streams = [res];
          const responseLength = +res.headers["content-length"];
          if (onDownloadProgress || maxDownloadRate) {
            const transformStream = new AxiosTransformStream$1({
              maxRate: utils$1.toFiniteNumber(maxDownloadRate)
            });
            onDownloadProgress && transformStream.on("progress", flushOnFinish(
              transformStream,
              progressEventDecorator(
                responseLength,
                progressEventReducer(asyncDecorator(onDownloadProgress), true, 3)
              )
            ));
            streams.push(transformStream);
          }
          let responseStream = res;
          const lastRequest = res.req || req;
          if (config.decompress !== false && res.headers["content-encoding"]) {
            if (method === "HEAD" || res.statusCode === 204) {
              delete res.headers["content-encoding"];
            }
            switch ((res.headers["content-encoding"] || "").toLowerCase()) {
              /*eslint default-case:0*/
              case "gzip":
              case "x-gzip":
              case "compress":
              case "x-compress":
                streams.push(zlib__default["default"].createUnzip(zlibOptions));
                delete res.headers["content-encoding"];
                break;
              case "deflate":
                streams.push(new ZlibHeaderTransformStream$1());
                streams.push(zlib__default["default"].createUnzip(zlibOptions));
                delete res.headers["content-encoding"];
                break;
              case "br":
                if (isBrotliSupported) {
                  streams.push(zlib__default["default"].createBrotliDecompress(brotliOptions));
                  delete res.headers["content-encoding"];
                }
            }
          }
          responseStream = streams.length > 1 ? stream__default["default"].pipeline(streams, utils$1.noop) : streams[0];
          const offListeners = stream__default["default"].finished(responseStream, () => {
            offListeners();
            onFinished();
          });
          const response = {
            status: res.statusCode,
            statusText: res.statusMessage,
            headers: new AxiosHeaders$1(res.headers),
            config,
            request: lastRequest
          };
          if (responseType === "stream") {
            response.data = responseStream;
            settle(resolve, reject, response);
          } else {
            const responseBuffer = [];
            let totalResponseBytes = 0;
            responseStream.on("data", function handleStreamData(chunk) {
              responseBuffer.push(chunk);
              totalResponseBytes += chunk.length;
              if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
                rejected = true;
                responseStream.destroy();
                reject(new AxiosError(
                  "maxContentLength size of " + config.maxContentLength + " exceeded",
                  AxiosError.ERR_BAD_RESPONSE,
                  config,
                  lastRequest
                ));
              }
            });
            responseStream.on("aborted", function handlerStreamAborted() {
              if (rejected) {
                return;
              }
              const err = new AxiosError(
                "stream has been aborted",
                AxiosError.ERR_BAD_RESPONSE,
                config,
                lastRequest
              );
              responseStream.destroy(err);
              reject(err);
            });
            responseStream.on("error", function handleStreamError2(err) {
              if (req.destroyed) return;
              reject(AxiosError.from(err, null, config, lastRequest));
            });
            responseStream.on("end", function handleStreamEnd() {
              try {
                let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
                if (responseType !== "arraybuffer") {
                  responseData = responseData.toString(responseEncoding);
                  if (!responseEncoding || responseEncoding === "utf8") {
                    responseData = utils$1.stripBOM(responseData);
                  }
                }
                response.data = responseData;
              } catch (err) {
                return reject(AxiosError.from(err, null, config, response.request, response));
              }
              settle(resolve, reject, response);
            });
          }
          emitter.once("abort", (err) => {
            if (!responseStream.destroyed) {
              responseStream.emit("error", err);
              responseStream.destroy();
            }
          });
        });
        emitter.once("abort", (err) => {
          reject(err);
          req.destroy(err);
        });
        req.on("error", function handleRequestError(err) {
          reject(AxiosError.from(err, null, config, req));
        });
        req.on("socket", function handleRequestSocket(socket) {
          socket.setKeepAlive(true, 1e3 * 60);
        });
        if (config.timeout) {
          const timeout = parseInt(config.timeout, 10);
          if (Number.isNaN(timeout)) {
            reject(new AxiosError(
              "error trying to parse `config.timeout` to int",
              AxiosError.ERR_BAD_OPTION_VALUE,
              config,
              req
            ));
            return;
          }
          req.setTimeout(timeout, function handleRequestTimeout() {
            if (isDone) return;
            let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
            const transitional = config.transitional || transitionalDefaults;
            if (config.timeoutErrorMessage) {
              timeoutErrorMessage = config.timeoutErrorMessage;
            }
            reject(new AxiosError(
              timeoutErrorMessage,
              transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
              config,
              req
            ));
            abort();
          });
        }
        if (utils$1.isStream(data)) {
          let ended = false;
          let errored = false;
          data.on("end", () => {
            ended = true;
          });
          data.once("error", (err) => {
            errored = true;
            req.destroy(err);
          });
          data.on("close", () => {
            if (!ended && !errored) {
              abort(new CanceledError("Request stream has been aborted", config, req));
            }
          });
          data.pipe(req);
        } else {
          req.end(data);
        }
      });
    };
    var isURLSameOrigin = platform.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url2) => {
      url2 = new URL(url2, platform.origin);
      return origin2.protocol === url2.protocol && origin2.host === url2.host && (isMSIE || origin2.port === url2.port);
    })(
      new URL(platform.origin),
      platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
    ) : () => true;
    var cookies = platform.hasStandardBrowserEnv ? (
      // Standard browser envs support document.cookie
      {
        write(name, value, expires, path, domain, secure) {
          const cookie = [name + "=" + encodeURIComponent(value)];
          utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
          utils$1.isString(path) && cookie.push("path=" + path);
          utils$1.isString(domain) && cookie.push("domain=" + domain);
          secure === true && cookie.push("secure");
          document.cookie = cookie.join("; ");
        },
        read(name) {
          const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match ? decodeURIComponent(match[3]) : null;
        },
        remove(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      }
    ) : (
      // Non-standard browser env (web workers, react-native) lack needed support.
      {
        write() {
        },
        read() {
          return null;
        },
        remove() {
        }
      }
    );
    var headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
    function mergeConfig(config1, config2) {
      config2 = config2 || {};
      const config = {};
      function getMergedValue(target, source, prop, caseless) {
        if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
          return utils$1.merge.call({ caseless }, target, source);
        } else if (utils$1.isPlainObject(source)) {
          return utils$1.merge({}, source);
        } else if (utils$1.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(a, b, prop, caseless) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(a, b, prop, caseless);
        } else if (!utils$1.isUndefined(a)) {
          return getMergedValue(void 0, a, prop, caseless);
        }
      }
      function valueFromConfig2(a, b) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(void 0, b);
        }
      }
      function defaultToConfig2(a, b) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(void 0, b);
        } else if (!utils$1.isUndefined(a)) {
          return getMergedValue(void 0, a);
        }
      }
      function mergeDirectKeys(a, b, prop) {
        if (prop in config2) {
          return getMergedValue(a, b);
        } else if (prop in config1) {
          return getMergedValue(void 0, a);
        }
      }
      const mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        withXSRFToken: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
      };
      utils$1.forEach(Object.keys({ ...config1, ...config2 }), function computeConfigValue(prop) {
        const merge2 = mergeMap[prop] || mergeDeepProperties;
        const configValue = merge2(config1[prop], config2[prop], prop);
        utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    }
    var resolveConfig = (config) => {
      const newConfig = mergeConfig({}, config);
      let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
      newConfig.headers = headers = AxiosHeaders$1.from(headers);
      newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
      if (auth) {
        headers.set(
          "Authorization",
          "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
        );
      }
      let contentType;
      if (utils$1.isFormData(data)) {
        if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
          headers.setContentType(void 0);
        } else if ((contentType = headers.getContentType()) !== false) {
          const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
          headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
        }
      }
      if (platform.hasStandardBrowserEnv) {
        withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
        if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
          const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
          if (xsrfValue) {
            headers.set(xsrfHeaderName, xsrfValue);
          }
        }
      }
      return newConfig;
    };
    var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
    var xhrAdapter = isXHRAdapterSupported && function(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        const _config = resolveConfig(config);
        let requestData = _config.data;
        const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
        let { responseType, onUploadProgress, onDownloadProgress } = _config;
        let onCanceled;
        let uploadThrottled, downloadThrottled;
        let flushUpload, flushDownload;
        function done() {
          flushUpload && flushUpload();
          flushDownload && flushDownload();
          _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
          _config.signal && _config.signal.removeEventListener("abort", onCanceled);
        }
        let request = new XMLHttpRequest();
        request.open(_config.method.toUpperCase(), _config.url, true);
        request.timeout = _config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          const responseHeaders = AxiosHeaders$1.from(
            "getAllResponseHeaders" in request && request.getAllResponseHeaders()
          );
          const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          const response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
          const transitional = _config.transitional || transitionalDefaults;
          if (_config.timeoutErrorMessage) {
            timeoutErrorMessage = _config.timeoutErrorMessage;
          }
          reject(new AxiosError(
            timeoutErrorMessage,
            transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
            config,
            request
          ));
          request = null;
        };
        requestData === void 0 && requestHeaders.setContentType(null);
        if ("setRequestHeader" in request) {
          utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
            request.setRequestHeader(key, val);
          });
        }
        if (!utils$1.isUndefined(_config.withCredentials)) {
          request.withCredentials = !!_config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = _config.responseType;
        }
        if (onDownloadProgress) {
          [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
          request.addEventListener("progress", downloadThrottled);
        }
        if (onUploadProgress && request.upload) {
          [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
          request.upload.addEventListener("progress", uploadThrottled);
          request.upload.addEventListener("loadend", flushUpload);
        }
        if (_config.cancelToken || _config.signal) {
          onCanceled = (cancel) => {
            if (!request) {
              return;
            }
            reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
            request.abort();
            request = null;
          };
          _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
          if (_config.signal) {
            _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
          }
        }
        const protocol = parseProtocol(_config.url);
        if (protocol && platform.protocols.indexOf(protocol) === -1) {
          reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
          return;
        }
        request.send(requestData || null);
      });
    };
    var composeSignals = (signals, timeout) => {
      const { length } = signals = signals ? signals.filter(Boolean) : [];
      if (timeout || length) {
        let controller = new AbortController();
        let aborted;
        const onabort = function(reason) {
          if (!aborted) {
            aborted = true;
            unsubscribe();
            const err = reason instanceof Error ? reason : this.reason;
            controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
          }
        };
        let timer = timeout && setTimeout(() => {
          timer = null;
          onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));
        }, timeout);
        const unsubscribe = () => {
          if (signals) {
            timer && clearTimeout(timer);
            timer = null;
            signals.forEach((signal2) => {
              signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
            });
            signals = null;
          }
        };
        signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
        const { signal } = controller;
        signal.unsubscribe = () => utils$1.asap(unsubscribe);
        return signal;
      }
    };
    var composeSignals$1 = composeSignals;
    var streamChunk = function* (chunk, chunkSize) {
      let len = chunk.byteLength;
      if (!chunkSize || len < chunkSize) {
        yield chunk;
        return;
      }
      let pos = 0;
      let end;
      while (pos < len) {
        end = pos + chunkSize;
        yield chunk.slice(pos, end);
        pos = end;
      }
    };
    var readBytes = async function* (iterable, chunkSize) {
      for await (const chunk of readStream(iterable)) {
        yield* streamChunk(chunk, chunkSize);
      }
    };
    var readStream = async function* (stream2) {
      if (stream2[Symbol.asyncIterator]) {
        yield* stream2;
        return;
      }
      const reader = stream2.getReader();
      try {
        for (; ; ) {
          const { done, value } = await reader.read();
          if (done) {
            break;
          }
          yield value;
        }
      } finally {
        await reader.cancel();
      }
    };
    var trackStream = (stream2, chunkSize, onProgress, onFinish) => {
      const iterator2 = readBytes(stream2, chunkSize);
      let bytes = 0;
      let done;
      let _onFinish = (e) => {
        if (!done) {
          done = true;
          onFinish && onFinish(e);
        }
      };
      return new ReadableStream({
        async pull(controller) {
          try {
            const { done: done2, value } = await iterator2.next();
            if (done2) {
              _onFinish();
              controller.close();
              return;
            }
            let len = value.byteLength;
            if (onProgress) {
              let loadedBytes = bytes += len;
              onProgress(loadedBytes);
            }
            controller.enqueue(new Uint8Array(value));
          } catch (err) {
            _onFinish(err);
            throw err;
          }
        },
        cancel(reason) {
          _onFinish(reason);
          return iterator2.return();
        }
      }, {
        highWaterMark: 2
      });
    };
    var isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
    var isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
    var encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder2) => (str) => encoder2.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
    var test = (fn, ...args) => {
      try {
        return !!fn(...args);
      } catch (e) {
        return false;
      }
    };
    var supportsRequestStream = isReadableStreamSupported && test(() => {
      let duplexAccessed = false;
      const hasContentType = new Request(platform.origin, {
        body: new ReadableStream(),
        method: "POST",
        get duplex() {
          duplexAccessed = true;
          return "half";
        }
      }).headers.has("Content-Type");
      return duplexAccessed && !hasContentType;
    });
    var DEFAULT_CHUNK_SIZE = 64 * 1024;
    var supportsResponseStream = isReadableStreamSupported && test(() => utils$1.isReadableStream(new Response("").body));
    var resolvers = {
      stream: supportsResponseStream && ((res) => res.body)
    };
    isFetchSupported && ((res) => {
      ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
        !resolvers[type] && (resolvers[type] = utils$1.isFunction(res[type]) ? (res2) => res2[type]() : (_, config) => {
          throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);
        });
      });
    })(new Response());
    var getBodyLength = async (body) => {
      if (body == null) {
        return 0;
      }
      if (utils$1.isBlob(body)) {
        return body.size;
      }
      if (utils$1.isSpecCompliantForm(body)) {
        const _request = new Request(platform.origin, {
          method: "POST",
          body
        });
        return (await _request.arrayBuffer()).byteLength;
      }
      if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
        return body.byteLength;
      }
      if (utils$1.isURLSearchParams(body)) {
        body = body + "";
      }
      if (utils$1.isString(body)) {
        return (await encodeText(body)).byteLength;
      }
    };
    var resolveBodyLength = async (headers, body) => {
      const length = utils$1.toFiniteNumber(headers.getContentLength());
      return length == null ? getBodyLength(body) : length;
    };
    var fetchAdapter = isFetchSupported && (async (config) => {
      let {
        url: url2,
        method,
        data,
        signal,
        cancelToken,
        timeout,
        onDownloadProgress,
        onUploadProgress,
        responseType,
        headers,
        withCredentials = "same-origin",
        fetchOptions
      } = resolveConfig(config);
      responseType = responseType ? (responseType + "").toLowerCase() : "text";
      let composedSignal = composeSignals$1([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
      let request;
      const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
        composedSignal.unsubscribe();
      });
      let requestContentLength;
      try {
        if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
          let _request = new Request(url2, {
            method: "POST",
            body: data,
            duplex: "half"
          });
          let contentTypeHeader;
          if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
            headers.setContentType(contentTypeHeader);
          }
          if (_request.body) {
            const [onProgress, flush] = progressEventDecorator(
              requestContentLength,
              progressEventReducer(asyncDecorator(onUploadProgress))
            );
            data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
          }
        }
        if (!utils$1.isString(withCredentials)) {
          withCredentials = withCredentials ? "include" : "omit";
        }
        const isCredentialsSupported = "credentials" in Request.prototype;
        request = new Request(url2, {
          ...fetchOptions,
          signal: composedSignal,
          method: method.toUpperCase(),
          headers: headers.normalize().toJSON(),
          body: data,
          duplex: "half",
          credentials: isCredentialsSupported ? withCredentials : void 0
        });
        let response = await fetch(request, fetchOptions);
        const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
        if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
          const options = {};
          ["status", "statusText", "headers"].forEach((prop) => {
            options[prop] = response[prop];
          });
          const responseContentLength = utils$1.toFiniteNumber(response.headers.get("content-length"));
          const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
            responseContentLength,
            progressEventReducer(asyncDecorator(onDownloadProgress), true)
          ) || [];
          response = new Response(
            trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
              flush && flush();
              unsubscribe && unsubscribe();
            }),
            options
          );
        }
        responseType = responseType || "text";
        let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || "text"](response, config);
        !isStreamResponse && unsubscribe && unsubscribe();
        return await new Promise((resolve, reject) => {
          settle(resolve, reject, {
            data: responseData,
            headers: AxiosHeaders$1.from(response.headers),
            status: response.status,
            statusText: response.statusText,
            config,
            request
          });
        });
      } catch (err) {
        unsubscribe && unsubscribe();
        if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
          throw Object.assign(
            new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request),
            {
              cause: err.cause || err
            }
          );
        }
        throw AxiosError.from(err, err && err.code, config, request);
      }
    });
    var knownAdapters = {
      http: httpAdapter,
      xhr: xhrAdapter,
      fetch: fetchAdapter
    };
    utils$1.forEach(knownAdapters, (fn, value) => {
      if (fn) {
        try {
          Object.defineProperty(fn, "name", { value });
        } catch (e) {
        }
        Object.defineProperty(fn, "adapterName", { value });
      }
    });
    var renderReason = (reason) => `- ${reason}`;
    var isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
    var adapters = {
      getAdapter: (adapters2) => {
        adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
        const { length } = adapters2;
        let nameOrAdapter;
        let adapter;
        const rejectedReasons = {};
        for (let i = 0; i < length; i++) {
          nameOrAdapter = adapters2[i];
          let id;
          adapter = nameOrAdapter;
          if (!isResolvedHandle(nameOrAdapter)) {
            adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
            if (adapter === void 0) {
              throw new AxiosError(`Unknown adapter '${id}'`);
            }
          }
          if (adapter) {
            break;
          }
          rejectedReasons[id || "#" + i] = adapter;
        }
        if (!adapter) {
          const reasons = Object.entries(rejectedReasons).map(
            ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
          );
          let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
          throw new AxiosError(
            `There is no suitable adapter to dispatch the request ` + s,
            "ERR_NOT_SUPPORT"
          );
        }
        return adapter;
      },
      adapters: knownAdapters
    };
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new CanceledError(null, config);
      }
    }
    function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = AxiosHeaders$1.from(config.headers);
      config.data = transformData.call(
        config,
        config.transformRequest
      );
      if (["post", "put", "patch"].indexOf(config.method) !== -1) {
        config.headers.setContentType("application/x-www-form-urlencoded", false);
      }
      const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          config.transformResponse,
          response
        );
        response.headers = AxiosHeaders$1.from(response.headers);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              config.transformResponse,
              reason.response
            );
            reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
          }
        }
        return Promise.reject(reason);
      });
    }
    var validators$1 = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
      validators$1[type] = function validator3(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators$1.transitional = function transitional(validator3, version, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return (value, opt, opts) => {
        if (validator3 === false) {
          throw new AxiosError(
            formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
            AxiosError.ERR_DEPRECATED
          );
        }
        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version + " and will be removed in the near future"
            )
          );
        }
        return validator3 ? validator3(value, opt, opts) : true;
      };
    };
    validators$1.spelling = function spelling(correctSpelling) {
      return (value, opt) => {
        console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
        return true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
      }
      const keys = Object.keys(options);
      let i = keys.length;
      while (i-- > 0) {
        const opt = keys[i];
        const validator3 = schema[opt];
        if (validator3) {
          const value = options[opt];
          const result = value === void 0 || validator3(value, opt, options);
          if (result !== true) {
            throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
        }
      }
    }
    var validator2 = {
      assertOptions,
      validators: validators$1
    };
    var validators = validator2.validators;
    var Axios = class {
      constructor(instanceConfig) {
        this.defaults = instanceConfig || {};
        this.interceptors = {
          request: new InterceptorManager$1(),
          response: new InterceptorManager$1()
        };
      }
      /**
       * Dispatch a request
       *
       * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
       * @param {?Object} config
       *
       * @returns {Promise} The Promise to be fulfilled
       */
      async request(configOrUrl, config) {
        try {
          return await this._request(configOrUrl, config);
        } catch (err) {
          if (err instanceof Error) {
            let dummy = {};
            Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
            const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
            try {
              if (!err.stack) {
                err.stack = stack;
              } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
                err.stack += "\n" + stack;
              }
            } catch (e) {
            }
          }
          throw err;
        }
      }
      _request(configOrUrl, config) {
        if (typeof configOrUrl === "string") {
          config = config || {};
          config.url = configOrUrl;
        } else {
          config = configOrUrl || {};
        }
        config = mergeConfig(this.defaults, config);
        const { transitional, paramsSerializer, headers } = config;
        if (transitional !== void 0) {
          validator2.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
          }, false);
        }
        if (paramsSerializer != null) {
          if (utils$1.isFunction(paramsSerializer)) {
            config.paramsSerializer = {
              serialize: paramsSerializer
            };
          } else {
            validator2.assertOptions(paramsSerializer, {
              encode: validators.function,
              serialize: validators.function
            }, true);
          }
        }
        if (config.allowAbsoluteUrls !== void 0) ;
        else if (this.defaults.allowAbsoluteUrls !== void 0) {
          config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
        } else {
          config.allowAbsoluteUrls = true;
        }
        validator2.assertOptions(config, {
          baseUrl: validators.spelling("baseURL"),
          withXsrfToken: validators.spelling("withXSRFToken")
        }, true);
        config.method = (config.method || this.defaults.method || "get").toLowerCase();
        let contextHeaders = headers && utils$1.merge(
          headers.common,
          headers[config.method]
        );
        headers && utils$1.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          (method) => {
            delete headers[method];
          }
        );
        config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise;
        let i = 0;
        let len;
        if (!synchronousRequestInterceptors) {
          const chain = [dispatchRequest.bind(this), void 0];
          chain.unshift(...requestInterceptorChain);
          chain.push(...responseInterceptorChain);
          len = chain.length;
          promise = Promise.resolve(config);
          while (i < len) {
            promise = promise.then(chain[i++], chain[i++]);
          }
          return promise;
        }
        len = requestInterceptorChain.length;
        let newConfig = config;
        i = 0;
        while (i < len) {
          const onFulfilled = requestInterceptorChain[i++];
          const onRejected = requestInterceptorChain[i++];
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected.call(this, error);
            break;
          }
        }
        try {
          promise = dispatchRequest.call(this, newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        i = 0;
        len = responseInterceptorChain.length;
        while (i < len) {
          promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
        }
        return promise;
      }
      getUri(config) {
        config = mergeConfig(this.defaults, config);
        const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
        return buildURL(fullPath, config.params, config.paramsSerializer);
      }
    };
    utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url2, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url: url2,
          data: (config || {}).data
        }));
      };
    });
    utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url2, data, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url: url2,
            data
          }));
        };
      }
      Axios.prototype[method] = generateHTTPMethod();
      Axios.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    var Axios$1 = Axios;
    var CancelToken = class _CancelToken {
      constructor(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });
        const token = this;
        this.promise.then((cancel) => {
          if (!token._listeners) return;
          let i = token._listeners.length;
          while (i-- > 0) {
            token._listeners[i](cancel);
          }
          token._listeners = null;
        });
        this.promise.then = (onfulfilled) => {
          let _resolve;
          const promise = new Promise((resolve) => {
            token.subscribe(resolve);
            _resolve = resolve;
          }).then(onfulfilled);
          promise.cancel = function reject() {
            token.unsubscribe(_resolve);
          };
          return promise;
        };
        executor(function cancel(message, config, request) {
          if (token.reason) {
            return;
          }
          token.reason = new CanceledError(message, config, request);
          resolvePromise(token.reason);
        });
      }
      /**
       * Throws a `CanceledError` if cancellation has been requested.
       */
      throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      }
      /**
       * Subscribe to the cancel signal
       */
      subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      }
      /**
       * Unsubscribe from the cancel signal
       */
      unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        const index = this._listeners.indexOf(listener);
        if (index !== -1) {
          this._listeners.splice(index, 1);
        }
      }
      toAbortSignal() {
        const controller = new AbortController();
        const abort = (err) => {
          controller.abort(err);
        };
        this.subscribe(abort);
        controller.signal.unsubscribe = () => this.unsubscribe(abort);
        return controller.signal;
      }
      /**
       * Returns an object that contains a new `CancelToken` and a function that, when called,
       * cancels the `CancelToken`.
       */
      static source() {
        let cancel;
        const token = new _CancelToken(function executor(c) {
          cancel = c;
        });
        return {
          token,
          cancel
        };
      }
    };
    var CancelToken$1 = CancelToken;
    function spread(callback) {
      return function wrap2(arr2) {
        return callback.apply(null, arr2);
      };
    }
    function isAxiosError(payload) {
      return utils$1.isObject(payload) && payload.isAxiosError === true;
    }
    var HttpStatusCode = {
      Continue: 100,
      SwitchingProtocols: 101,
      Processing: 102,
      EarlyHints: 103,
      Ok: 200,
      Created: 201,
      Accepted: 202,
      NonAuthoritativeInformation: 203,
      NoContent: 204,
      ResetContent: 205,
      PartialContent: 206,
      MultiStatus: 207,
      AlreadyReported: 208,
      ImUsed: 226,
      MultipleChoices: 300,
      MovedPermanently: 301,
      Found: 302,
      SeeOther: 303,
      NotModified: 304,
      UseProxy: 305,
      Unused: 306,
      TemporaryRedirect: 307,
      PermanentRedirect: 308,
      BadRequest: 400,
      Unauthorized: 401,
      PaymentRequired: 402,
      Forbidden: 403,
      NotFound: 404,
      MethodNotAllowed: 405,
      NotAcceptable: 406,
      ProxyAuthenticationRequired: 407,
      RequestTimeout: 408,
      Conflict: 409,
      Gone: 410,
      LengthRequired: 411,
      PreconditionFailed: 412,
      PayloadTooLarge: 413,
      UriTooLong: 414,
      UnsupportedMediaType: 415,
      RangeNotSatisfiable: 416,
      ExpectationFailed: 417,
      ImATeapot: 418,
      MisdirectedRequest: 421,
      UnprocessableEntity: 422,
      Locked: 423,
      FailedDependency: 424,
      TooEarly: 425,
      UpgradeRequired: 426,
      PreconditionRequired: 428,
      TooManyRequests: 429,
      RequestHeaderFieldsTooLarge: 431,
      UnavailableForLegalReasons: 451,
      InternalServerError: 500,
      NotImplemented: 501,
      BadGateway: 502,
      ServiceUnavailable: 503,
      GatewayTimeout: 504,
      HttpVersionNotSupported: 505,
      VariantAlsoNegotiates: 506,
      InsufficientStorage: 507,
      LoopDetected: 508,
      NotExtended: 510,
      NetworkAuthenticationRequired: 511
    };
    Object.entries(HttpStatusCode).forEach(([key, value]) => {
      HttpStatusCode[value] = key;
    });
    var HttpStatusCode$1 = HttpStatusCode;
    function createInstance(defaultConfig) {
      const context = new Axios$1(defaultConfig);
      const instance = bind(Axios$1.prototype.request, context);
      utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
      utils$1.extend(instance, context, null, { allOwnKeys: true });
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios = createInstance(defaults$1);
    axios.Axios = Axios$1;
    axios.CanceledError = CanceledError;
    axios.CancelToken = CancelToken$1;
    axios.isCancel = isCancel;
    axios.VERSION = VERSION;
    axios.toFormData = toFormData;
    axios.AxiosError = AxiosError;
    axios.Cancel = axios.CanceledError;
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = spread;
    axios.isAxiosError = isAxiosError;
    axios.mergeConfig = mergeConfig;
    axios.AxiosHeaders = AxiosHeaders$1;
    axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
    axios.getAdapter = adapters.getAdapter;
    axios.HttpStatusCode = HttpStatusCode$1;
    axios.default = axios;
    module2.exports = axios;
  }
});

// node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/url.js
var require_url = __commonJS({
  "node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/url.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkUrlExists = checkUrlExists;
    var axios_1 = __importDefault(require_axios());
    async function checkUrlExists(url) {
      return axios_1.default.request({ url, method: "HEAD" }).then((response) => response.status);
    }
  }
});

// node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/index.js
var require_dist = __commonJS({
  "node_modules/@sap-ai-sdk/orchestration/node_modules/@sap-cloud-sdk/util/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_array(), exports2);
    __exportStar(require_code_block(), exports2);
    __exportStar(require_documentation_block(), exports2);
    __exportStar(require_equal(), exports2);
    __exportStar(require_error_with_cause(), exports2);
    __exportStar(require_fs(), exports2);
    __exportStar(require_logger2(), exports2);
    __exportStar(require_nullish(), exports2);
    __exportStar(require_object(), exports2);
    __exportStar(require_pipe(), exports2);
    __exportStar(require_promise(), exports2);
    __exportStar(require_remove_slashes(), exports2);
    __exportStar(require_string(), exports2);
    __exportStar(require_string_formatter(), exports2);
    __exportStar(require_types(), exports2);
    __exportStar(require_unique_name_generator(), exports2);
    __exportStar(require_url(), exports2);
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/array.js
var require_array2 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/array.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.flatten = void 0;
    exports2.flat = flat;
    exports2.unique = unique;
    exports2.last = last;
    exports2.first = first;
    exports2.splitInChunks = splitInChunks;
    exports2.transformVariadicArgumentToArray = transformVariadicArgumentToArray;
    exports2.zip = zip;
    exports2.partition = partition2;
    exports2.filterDuplicates = filterDuplicates;
    exports2.filterDuplicatesRight = filterDuplicatesRight;
    function flat(arr2) {
      return arr2.reduce((flattened, subArr) => [...flattened, ...subArr], []);
    }
    function unique(arr2) {
      return Array.from(new Set(arr2));
    }
    function last(arr2) {
      return arr2.length ? arr2[arr2.length - 1] : void 0;
    }
    function first(arr2) {
      return arr2[0];
    }
    function splitInChunks(arr2, chunkSize) {
      const chunks = [];
      if (arr2) {
        for (let i = 0; i < arr2.length; i += chunkSize) {
          chunks.push(arr2.slice(i, i + chunkSize));
        }
      }
      return chunks;
    }
    function transformVariadicArgumentToArray(firstOrArray, rest) {
      if (Array.isArray(firstOrArray)) {
        return [...firstOrArray, ...rest];
      }
      return firstOrArray ? [firstOrArray, ...rest] : [...rest];
    }
    var flatten = (input) => {
      const flatResult = [];
      const stack = [...input];
      while (stack.length > 0) {
        const current = stack.pop();
        if (!Array.isArray(current)) {
          flatResult.push(current);
        } else {
          stack.push(...current);
        }
      }
      return flatResult.reverse();
    };
    exports2.flatten = flatten;
    function zip(left, right) {
      const longerArr = left.length > right.length ? left : right;
      return longerArr.reduce((zipped, _, i) => {
        const currentZipped = [];
        if (left.length > i) {
          currentZipped.push(left[i]);
        }
        if (right.length > i) {
          currentZipped.push(right[i]);
        }
        return [...zipped, ...currentZipped];
      }, []);
    }
    function partition2(arr2, condition) {
      return arr2.reduce(([conditionTrue, conditionFalse], item) => condition(item) ? [[...conditionTrue, item], conditionFalse] : [conditionTrue, [...conditionFalse, item]], [[], []]);
    }
    function filterDuplicates(arr2, comparator = (left, right) => left === right) {
      return arr2.filter((item, index) => !arr2.slice(0, index).find((filteredItem) => comparator(item, filteredItem)));
    }
    function filterDuplicatesRight(arr2, comparator = (left, right) => left === right) {
      return filterDuplicates(arr2.reverse(), comparator).reverse();
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/string-formatter.js
var require_string_formatter2 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/string-formatter.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.webEOL = exports2.unixEOL = void 0;
    exports2.upperCaseSnakeCase = upperCaseSnakeCase;
    exports2.camelCase = camelCase2;
    exports2.titleFormat = titleFormat;
    exports2.pascalCase = pascalCase;
    exports2.kebabCase = kebabCase;
    exports2.formatJson = formatJson;
    var voca_1 = __importDefault(require_voca());
    exports2.unixEOL = "\n";
    exports2.webEOL = "\r\n";
    function upperCaseSnakeCase(str) {
      return voca_1.default.upperCase(voca_1.default.snakeCase(str));
    }
    function camelCase2(str) {
      return voca_1.default.camelCase(str);
    }
    function titleFormat(str) {
      return voca_1.default.titleCase(voca_1.default.words(str).join(" "));
    }
    function pascalCase(str) {
      return voca_1.default.words(str).map((word) => voca_1.default.capitalize(word)).join("");
    }
    function kebabCase(str) {
      return voca_1.default.kebabCase(str);
    }
    function formatJson(json2) {
      return JSON.stringify(json2, null, 2) + exports2.unixEOL;
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/string.js
var require_string2 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/string.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encodeBase64 = encodeBase64;
    exports2.trimLeft = trimLeft;
    exports2.trimRight = trimRight;
    exports2.trim = trim;
    exports2.removeFileExtension = removeFileExtension;
    var string_formatter_1 = require_string_formatter2();
    function encodeBase64(str) {
      return Buffer.from(str).toString("base64");
    }
    function trimLeft(string) {
      const subStrings = string.split(string_formatter_1.unixEOL);
      const leftTrimmed = subStrings[0].trimStart();
      if (!leftTrimmed) {
        subStrings.shift();
      } else {
        subStrings[0] = leftTrimmed;
      }
      return subStrings.join(string_formatter_1.unixEOL);
    }
    function trimRight(string) {
      const subStrings = string.split(string_formatter_1.unixEOL);
      const rightTrimmed = subStrings[subStrings.length - 1].trimEnd();
      if (!rightTrimmed) {
        subStrings.pop();
      } else {
        subStrings[subStrings.length - 1] = rightTrimmed;
      }
      return subStrings.join(string_formatter_1.unixEOL);
    }
    function trim(string) {
      return trimRight(trimLeft(string));
    }
    function removeFileExtension(fileName) {
      return fileName.includes(".") ? fileName.split(".").slice(0, -1).join(".") : fileName;
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/code-block.js
var require_code_block2 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/code-block.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.codeBlock = codeBlock;
    var string_formatter_1 = require_string_formatter2();
    var array_1 = require_array2();
    var string_1 = require_string2();
    function codeBlock(strings, ...args) {
      const pre = strings.slice(0, -1).map((string) => {
        const trimmed = trimRightNewlines(string);
        return trimmed.length === string.length ? string : trimmed + string_formatter_1.unixEOL;
      });
      pre.push(strings[strings.length - 1]);
      const indents = strings.slice(0, -1).map((s) => {
        const indentation = s.split(string_formatter_1.unixEOL).pop();
        return !indentation.trim() ? indentation : "";
      });
      const post = args.map((arg, i) => ("" + arg).split(string_formatter_1.unixEOL).map((subArg) => indents[i] + subArg).join(string_formatter_1.unixEOL));
      const zipped = (0, array_1.zip)(pre, post);
      return (0, string_1.trim)(zipped.join(""));
    }
    function trimRightNewlines(string) {
      let subStrings = string.split(string_formatter_1.unixEOL);
      if (!subStrings[subStrings.length - 1].trim()) {
        subStrings = subStrings.slice(0, -1);
      }
      return subStrings.join(string_formatter_1.unixEOL);
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/logger/format/local.js
var require_local2 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/logger/format/local.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.local = void 0;
    exports2.getMessageOrStack = getMessageOrStack;
    var chalk_1 = __importDefault(require_source());
    var winston_1 = require_winston();
    var { combine, timestamp, cli, printf, errors } = winston_1.format;
    exports2.local = combine(errors({ stack: true }), timestamp(), (0, winston_1.format)(localTransformer)(), cli(), printf((info) => {
      const messageContext = info.custom_fields && typeof info.custom_fields === "object" && "messageContext" in info.custom_fields ? `${chalk_1.default.blue(`(${info.custom_fields.messageContext})`)}: ` : "";
      const message = typeof info.message === "string" ? info.message : "";
      const trimmedMessage = message.replace(/^\s*/, "");
      const paddingLength = message.length - trimmedMessage.length + messageContext.length;
      if (info.error) {
        info.level = chalk_1.default.inverse(info.level);
      }
      return `${chalk_1.default.gray(`[${info.timestamp}]`)} ${info.level} ${messageContext.padStart(paddingLength, " ")}${trimmedMessage}`;
    }));
    function getMessageOrStack(info) {
      const isString = (value) => typeof value === "string";
      const hasStackTrace = info.stack && info.level === "error";
      if (hasStackTrace && isString(info.stack)) {
        return info.stack;
      }
      if (isString(info.message)) {
        return info.message;
      }
      return "";
    }
    function localTransformer(info) {
      return {
        ...info,
        level: info.level.toUpperCase(),
        message: getMessageOrStack(info)
      };
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/logger/format/kibana.js
var require_kibana2 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/logger/format/kibana.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.kibana = void 0;
    var winston_1 = require_winston();
    var local_1 = require_local2();
    var { combine, timestamp, json: json2, errors } = winston_1.format;
    exports2.kibana = combine(errors({ stack: true }), timestamp(), (0, winston_1.format)(kibanaTransformer)(), json2());
    function kibanaTransformer(info) {
      return {
        ...info,
        msg: (0, local_1.getMessageOrStack)(info),
        written_ts: new Date(info.timestamp).getTime(),
        written_at: info.timestamp
      };
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/logger/format/index.js
var require_format3 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/logger/format/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_kibana2(), exports2);
    __exportStar(require_local2(), exports2);
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/logger/cloud-sdk-logger.js
var require_cloud_sdk_logger2 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/logger/cloud-sdk-logger.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.cloudSdkExceptionLogger = exports2.logFormat = void 0;
    exports2.muteLoggers = muteLoggers;
    exports2.unmuteLoggers = unmuteLoggers;
    exports2.disableExceptionLogger = disableExceptionLogger;
    exports2.enableExceptionLogger = enableExceptionLogger;
    exports2.createLogger = createLogger8;
    exports2.getLogger = getLogger;
    exports2.setLogLevel = setLogLevel;
    exports2.setGlobalLogLevel = setGlobalLogLevel;
    exports2.getGlobalLogLevel = getGlobalLogLevel;
    exports2.setGlobalTransports = setGlobalTransports;
    exports2.setLogFormat = setLogFormat;
    exports2.setGlobalLogFormat = setGlobalLogFormat;
    exports2.getGlobalLogFormat = getGlobalLogFormat;
    exports2.sanitizeRecord = sanitizeRecord;
    exports2.resetCustomLogLevels = resetCustomLogLevels;
    exports2.resetCustomLogFormats = resetCustomLogFormats;
    var winston_1 = require_winston();
    var format_1 = require_format3();
    var loggerReference = "sap-cloud-sdk-logger";
    var exceptionLoggerId = "sap-cloud-sdk-exception-logger";
    var container = new winston_1.Container();
    exports2.logFormat = {
      kibana: format_1.kibana,
      local: format_1.local
    };
    container.options.format = process.env.NODE_ENV === "production" ? exports2.logFormat.kibana : exports2.logFormat.local;
    var exceptionTransport = new winston_1.transports.Console();
    var customLogLevels = {};
    var customLogFormats = {};
    var DEFAULT_LOGGER__MESSAGE_CONTEXT = "__DEFAULT_LOGGER__MESSAGE_CONTEXT";
    var silent = false;
    var moduleLogger = createLogger8({
      package: "util",
      messageContext: "cloud-sdk-logger"
    });
    function toggleMuteLoggers(silence) {
      silent = silence;
      container.loggers.forEach((logger8) => toggleSilenceTransports(logger8, silence));
    }
    function toggleSilenceTransports(logger8, silence) {
      logger8.transports.forEach((transport) => transport.silent = silence);
    }
    function muteLoggers() {
      toggleMuteLoggers(true);
    }
    function unmuteLoggers() {
      toggleMuteLoggers(false);
    }
    exports2.cloudSdkExceptionLogger = container.get(exceptionLoggerId, {
      defaultMeta: { logger: loggerReference, test: "exception" },
      format: container.options.format,
      exceptionHandlers: [exceptionTransport]
    });
    function disableExceptionLogger() {
      exports2.cloudSdkExceptionLogger.exceptions.unhandle();
    }
    function enableExceptionLogger() {
      disableExceptionLogger();
      exports2.cloudSdkExceptionLogger.exceptions.handle(exceptionTransport);
    }
    function createLogger8(messageContext) {
      const customFields = typeof messageContext === "string" ? { messageContext } : { ...messageContext };
      const logger8 = container.get(customFields.messageContext, {
        level: process.env.SAP_CLOUD_SDK_LOG_LEVEL || customLogLevels[customFields.messageContext] || customFields.level || container.options.level || "info",
        defaultMeta: {
          ...Object.entries(customFields).length && {
            custom_fields: customFields
          },
          logger: customFields.logger || loggerReference
        },
        format: customLogFormats[customFields.messageContext] || customFields.format || container.options.format || exports2.logFormat.local,
        transports: [new winston_1.transports.Console()]
      });
      toggleSilenceTransports(logger8, silent);
      return logger8;
    }
    function getLogger(messageContext = DEFAULT_LOGGER__MESSAGE_CONTEXT) {
      if (container.has(messageContext)) {
        return container.get(messageContext);
      }
    }
    function setLogLevel(level, messageContextOrLogger = DEFAULT_LOGGER__MESSAGE_CONTEXT) {
      const messageContext = typeof messageContextOrLogger === "string" ? messageContextOrLogger : getMessageContext(messageContextOrLogger);
      if (messageContext) {
        customLogLevels[messageContext] = level;
        if (container.has(messageContext)) {
          const logger8 = container.get(messageContext);
          logger8.level = level;
        }
      } else if (typeof messageContextOrLogger !== "string") {
        moduleLogger.warn("Setting log level for logger with unknown message context");
        messageContextOrLogger.level = level;
      }
    }
    function setGlobalLogLevel(level) {
      container.options.level = level;
      container.loggers.forEach((logger8) => {
        logger8.level = level;
      });
    }
    function getGlobalLogLevel() {
      return container.options.level;
    }
    function setGlobalTransports(customTransports) {
      container.options.transports = customTransports;
      container.loggers.forEach((logger8) => {
        logger8.clear();
        return Array.isArray(customTransports) ? customTransports.forEach((transport) => logger8.add(transport)) : logger8.add(customTransports);
      });
    }
    function setLogFormat(format, messageContextOrLogger = DEFAULT_LOGGER__MESSAGE_CONTEXT) {
      const messageContext = typeof messageContextOrLogger === "string" ? messageContextOrLogger : getMessageContext(messageContextOrLogger);
      if (messageContext) {
        customLogFormats[messageContext] = format;
        if (container.has(messageContext)) {
          const logger8 = container.get(messageContext);
          logger8.format = format;
        }
      } else if (typeof messageContextOrLogger !== "string") {
        moduleLogger.warn("Setting log format for logger with unknown message context");
        messageContextOrLogger.format = format;
      }
    }
    function setGlobalLogFormat(format) {
      container.options.format = format;
      container.loggers.forEach((logger8) => {
        logger8.format = format;
      });
    }
    function getGlobalLogFormat() {
      return container.options.format;
    }
    var defaultSensitiveKeys = [
      "access_token",
      "authentication",
      "authorization",
      "apiKey",
      "credentials",
      "csrf",
      "xsrf",
      "secret",
      "password",
      "JTENANT",
      "JSESSION"
    ];
    function isSensitive(inputKey, value, sensitiveKeys) {
      const normalizedKeys = sensitiveKeys.map((key) => key.toLowerCase());
      const input = isCookieHeader(inputKey, value) ? value : inputKey;
      return normalizedKeys.some((normalizedKey) => input.toLowerCase().includes(normalizedKey));
    }
    function isCookieHeader(inputKey, value) {
      return inputKey.toLowerCase() === "cookie" && typeof value === "string";
    }
    function sanitizeRecord(input, replacementString = "<DATA NOT LOGGED TO PREVENT LEAKING SENSITIVE DATA>", sensitiveKeys = defaultSensitiveKeys) {
      return Object.fromEntries(Object.entries(input).map(([inputKey, value]) => isSensitive(inputKey, value, sensitiveKeys) ? [inputKey, replacementString] : [inputKey, value]));
    }
    function getMessageContext(logger8) {
      const loggerOptions = logger8;
      if (loggerOptions && loggerOptions.defaultMeta && loggerOptions.defaultMeta.custom_fields) {
        return loggerOptions.defaultMeta.custom_fields.messageContext;
      }
    }
    function resetCustomLogLevels() {
      Object.keys(customLogLevels).forEach((key) => delete customLogLevels[key]);
    }
    function resetCustomLogFormats() {
      Object.keys(customLogFormats).forEach((key) => delete customLogFormats[key]);
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/logger/index.js
var require_logger3 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/logger/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_cloud_sdk_logger2(), exports2);
    __exportStar(require_format3(), exports2);
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/documentation-block.js
var require_documentation_block2 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/documentation-block.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.documentationBlock = documentationBlock;
    var array_1 = require_array2();
    var logger_1 = require_logger3();
    var string_formatter_1 = require_string_formatter2();
    var logger8 = (0, logger_1.createLogger)("documentation-block");
    function documentationBlock(strings, ...args) {
      const firstLineTrimmed = removeLeadingEmptyLines(strings.raw[0]);
      const textIndentation = getIndentation(firstLineTrimmed);
      const argsWithIndentation = addIndentationToArguments(args, textIndentation);
      let content = (0, array_1.zip)([firstLineTrimmed, ...strings.raw.slice(1)], argsWithIndentation).join("");
      if (!content.match(/\w/)) {
        return "";
      }
      content = maskProblematicCharacters(content);
      let lines = content.split(string_formatter_1.unixEOL);
      lines = adjustIndentation(lines, textIndentation);
      content = lines.join(`${string_formatter_1.unixEOL} * `);
      const result = ["/**", ` * ${content}`, " */"].join(string_formatter_1.unixEOL);
      return result;
    }
    function removeLeadingEmptyLines(firstLine) {
      const lines = firstLine.split(string_formatter_1.unixEOL);
      const indexFirstNonEmpty = lines.findIndex((str) => str.match(/\w/)) || 0;
      return lines.splice(indexFirstNonEmpty).join(string_formatter_1.unixEOL);
    }
    function addIndentationToArguments(args, textIndentation) {
      const argsWithIndentation = args.map((arg) => arg.replace(/\n/g, string_formatter_1.unixEOL + " ".repeat(textIndentation)));
      return argsWithIndentation;
    }
    function adjustIndentation(lines, textIndentation) {
      return lines.map((str) => str.slice(textIndentation));
    }
    function getIndentation(firstLine) {
      const removeStarting = firstLine?.replace(/^\n*/g, "");
      const countEmptySpaces = removeStarting?.search(/\S/);
      return countEmptySpaces > 0 ? countEmptySpaces : 0;
    }
    function maskProblematicCharacters(str) {
      if (str.includes("*/")) {
        logger8.warn(`The documentation block ${str}'
      )} contained */ in the text will be masked as \\*\\/.`);
      }
      return str.replace(/\*\//g, "\\*\\/");
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/nullish.js
var require_nullish2 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/nullish.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isNullish = isNullish;
    function isNullish(val) {
      return val === null || val === void 0;
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/equal.js
var require_equal2 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/equal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.equalObjects = equalObjects;
    exports2.equal = equal;
    exports2.equalArrays = equalArrays;
    var nullish_1 = require_nullish2();
    function equalObjects(obj1, obj2) {
      const keys1 = Object.keys(obj1);
      return Object.keys(obj1).length === Object.keys(obj2).length && keys1.every((key) => equal(obj1[key], obj2[key]));
    }
    function equal(item1, item2) {
      if (Array.isArray(item1) && Array.isArray(item2)) {
        return equalArrays(item1, item2);
      }
      if (typeof item1 === "object" && typeof item2 === "object" && !(0, nullish_1.isNullish)(item1) && !(0, nullish_1.isNullish)(item2)) {
        return equalObjects(item1, item2);
      }
      return item1 === item2;
    }
    function equalArrays(arr1, arr2) {
      return arr1.length === arr2.length && arr1.every((item1, i) => equal(item1, arr2[i]));
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/error-with-cause.js
var require_error_with_cause2 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/error-with-cause.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ErrorWithCause = void 0;
    exports2.isErrorWithCause = isErrorWithCause;
    var string_formatter_1 = require_string_formatter2();
    var logger_1 = require_logger3();
    var logger8 = (0, logger_1.createLogger)({
      package: "util",
      messageContext: "error-with-cause"
    });
    var ErrorWithCause3 = class extends Error {
      /**
       * Create an instance of ErrorWithCause.
       * @param message - Error message.
       * @param cause - Original error, causing this error.
       */
      constructor(message, cause) {
        super(message);
        this.cause = cause;
        Object.setPrototypeOf(this, new.target.prototype);
        this.name = "ErrorWithCause";
        this.addStack(cause);
      }
      isAxiosError(err) {
        return err["isAxiosError"] === true;
      }
      addStack(cause) {
        if (this.isAxiosError(cause)) {
          let response = "";
          if (cause.response?.data) {
            try {
              response = `${string_formatter_1.unixEOL}${JSON.stringify(cause.response?.data, null, 2)}`;
            } catch (error) {
              logger8.warn(`Failed to stringify response data: ${error.message}`);
              response = `${string_formatter_1.unixEOL}${cause.response?.data}`;
            }
          }
          this.stack = `${this.stack}${string_formatter_1.unixEOL}Caused by:${string_formatter_1.unixEOL}HTTP Response: ${cause.message}${response}`;
        } else if (this.stack && cause?.stack) {
          this.stack = `${this.stack}${string_formatter_1.unixEOL}Caused by:${string_formatter_1.unixEOL}${cause.stack}`;
        }
      }
      /**
       * Root cause of the error.
       * If there are multiple errors caused one by another, the root cause is the first error that occurred.
       * In case there is no root cause.
       * @returns The root cause.
       */
      get rootCause() {
        return isErrorWithCause(this.cause) ? this.cause.rootCause : this.cause;
      }
    };
    exports2.ErrorWithCause = ErrorWithCause3;
    function isErrorWithCause(err) {
      return err?.name === "ErrorWithCause";
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/fs.js
var require_fs2 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.findProjectRoot = findProjectRoot;
    exports2.readJSON = readJSON;
    var fs_1 = require("fs");
    var path_1 = require("path");
    var logger_1 = require_logger3();
    var logger8 = (0, logger_1.createLogger)({
      package: "util",
      messageContext: "fs"
    });
    function findProjectRoot(path, lastPath = path) {
      if (!path) {
        return lastPath;
      }
      const inProject = (0, fs_1.readdirSync)(path).includes("package.json") || (0, fs_1.readdirSync)(path).includes("node_modules") || path.includes("node_modules");
      if (!inProject) {
        return lastPath;
      }
      return findProjectRoot((0, path_1.resolve)(path, ".."), path);
    }
    function readJSON(path) {
      if ((0, fs_1.existsSync)(path)) {
        return JSON.parse((0, fs_1.readFileSync)(path, "utf8"));
      }
      logger8.warn(`File "${path}" does not exist, return empty object.`);
      return {};
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/object.js
var require_object2 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/object.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.exclude = exports2.pick = exports2.renameKeys = void 0;
    exports2.propertyExists = propertyExists;
    exports2.toSanitizedObject = toSanitizedObject;
    exports2.pickIgnoreCase = pickIgnoreCase;
    exports2.pickValueIgnoreCase = pickValueIgnoreCase;
    exports2.pickNonNullish = pickNonNullish;
    exports2.mergeLeftIgnoreCase = mergeLeftIgnoreCase;
    exports2.mergeIgnoreCase = mergeIgnoreCase2;
    var nullish_1 = require_nullish2();
    function propertyExists(obj, ...properties) {
      if (!properties.length) {
        return true;
      }
      if (obj && obj.hasOwnProperty(properties[0])) {
        return propertyExists(obj[properties[0]], ...properties.slice(1));
      }
      return false;
    }
    var renameKeys = (keyMapping, obj) => {
      const unchangedEntries = Object.keys(obj).filter((k) => !Object.keys(keyMapping).includes(k)).reduce((newObj, key) => ({ ...newObj, [key]: obj[key] }), {});
      return Object.entries(keyMapping).reduce((newObj, [oldKey, newKey]) => ({ ...newObj, [newKey]: obj[oldKey] }), unchangedEntries);
    };
    exports2.renameKeys = renameKeys;
    var pick = (keys, obj) => {
      const result = {};
      keys.forEach((key) => {
        const value = obj[key];
        if (Object.keys(obj).includes(key)) {
          result[key] = value;
        }
      });
      return result;
    };
    exports2.pick = pick;
    var exclude = (keys, obj) => {
      const result = {};
      Object.keys(obj).forEach((key) => {
        const value = obj[key];
        if (!keys.includes(key)) {
          result[key] = value;
        }
      });
      return result;
    };
    exports2.exclude = exclude;
    function toSanitizedObject(key, value) {
      return (0, nullish_1.isNullish)(key) || (0, nullish_1.isNullish)(value) ? {} : { [key]: value };
    }
    function pickIgnoreCase(obj = {}, ...keys) {
      return keys.reduce((filteredHeaders, providedKey) => {
        const originalKey = Object.keys(obj).find((objKey) => objKey.toLowerCase() === providedKey.toLowerCase());
        return {
          ...filteredHeaders,
          ...originalKey && { [originalKey]: obj[originalKey] }
        };
      }, {});
    }
    function pickValueIgnoreCase(obj = {}, key) {
      return Object.values(pickIgnoreCase(obj, key))[0];
    }
    function pickNonNullish(obj = {}) {
      return Object.entries(obj).filter(([key, value]) => !(0, nullish_1.isNullish)(key) && !(0, nullish_1.isNullish)(value)).reduce((filtered, [key, value]) => ({ ...filtered, [key]: value }), {});
    }
    function mergeLeftIgnoreCase(left = {}, right = {}) {
      return Object.entries(left).map(([key, value]) => pickValueIgnoreCase(right, key) ? pickIgnoreCase(right, key) : { [key]: value }).reduce((replaced, obj) => ({ ...replaced, ...obj }), {});
    }
    function mergeIgnoreCase2(left = {}, right = {}) {
      return {
        ...mergeLeftIgnoreCase(left, right),
        ...right
      };
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/pipe.js
var require_pipe2 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/pipe.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.identity = identity;
    function identity(value) {
      return value;
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/promise.js
var require_promise2 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/promise.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.finishAll = finishAll;
    async function finishAll(promises, errorMessage) {
      const settledPromises = await Promise.allSettled(promises);
      const rejectedPromises = settledPromises.filter((promise) => promise.status === "rejected");
      if (rejectedPromises.length) {
        const reasons = rejectedPromises.map((promise) => `	${promise.reason}`).join("\n");
        const message = errorMessage ? `${errorMessage} ` : "";
        throw new Error(`${message}Errors: [
${reasons}
]`);
      }
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/remove-slashes.js
var require_remove_slashes2 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/remove-slashes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.removeSlashes = removeSlashes;
    exports2.removeTrailingSlashes = removeTrailingSlashes2;
    exports2.removeLeadingSlashes = removeLeadingSlashes2;
    function removeSlashes(path) {
      path = removeLeadingSlashes2(path);
      path = removeTrailingSlashes2(path);
      return path;
    }
    function removeTrailingSlashes2(path) {
      return path.endsWith("/") ? path.slice(0, -1) : path;
    }
    function removeLeadingSlashes2(path) {
      return path.startsWith("/") ? path.slice(1) : path;
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/types.js
var require_types2 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.caps = caps;
    function caps(oDataVersion) {
      return oDataVersion ? oDataVersion.toUpperCase() : "V2";
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/unique-name-generator.js
var require_unique_name_generator2 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/unique-name-generator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UniqueNameGenerator = void 0;
    var UniqueNameGenerator = class _UniqueNameGenerator {
      static getNameForComparison(name, caseSensitive) {
        return caseSensitive ? name : name.toLowerCase();
      }
      /**
       * Creates an instance of UniqueNameGenerator.
       * @param indexSeparator - The separator to be used when adding an index.
       * @param usedNames - Sets the already used names considered in the finding process.
       */
      constructor(indexSeparator = "_", usedNames = []) {
        this.indexSeparator = indexSeparator;
        this.usedNames = [];
        this.addToUsedNames(...usedNames);
      }
      /**
       * Adds the name(s) to the already used names.
       * @param names - Names to be added.
       */
      addToUsedNames(...names) {
        this.usedNames.push(...names);
      }
      /**
       * Generate a unique name by appending an index separated by the `indexSeparator` if necessary, e.g. if `MyName` is already taken `MyName_1` will be found by default.
       * If the name is already unique nothing is appended.
       * @param name - The name to get a unique name from.
       * @param caseSensitive - Whether to check the already used names in a case sensitive manner.
       * @returns A unique name.
       */
      generateUniqueName(name, caseSensitive = true) {
        return this.generateUniqueNamesWithSuffixes(name, [], caseSensitive)[0];
      }
      /**
       * Generate a unique name by appending an index separated by the `indexSeparator` if necessary, e.g. if `MyName` is already taken `MyName_1` will be found by default.
       * The generated name is added to the used names.
       * If the name is already unique nothing is appended.
       * @param name - The name to get a unique name from.
       * @param caseSensitive - Whether to check the already used names in a case sensitive manner.
       * @returns A unique name.
       */
      generateAndSaveUniqueName(name, caseSensitive = true) {
        const uniqueName = this.generateUniqueName(name, caseSensitive);
        this.addToUsedNames(uniqueName);
        return uniqueName;
      }
      /**
       * Generate unique names by appending an index separated by the `indexSeparator` if necessary, while respecting the given suffixes.
       * If the name is already unique nothing is appended.
       * Each given suffix is appended to the unique name in the result.
       * The resulting names are also checked for uniqueness.
       * All names in the result have the same number suffix.
       * @example if `MyName` and `MyName_1MySuffix` is already taken, `[MyName_2, MyName_2MySuffix]` will be generated by default.
       * @param name - The name to get a unique name from.
       * @param suffixes - Additional name of suffixes to be considered for the finding process, as well as the output.
       * @param caseSensitive - Whether to check the already used names in a case sensitive manner.
       * @returns A list of unique names. The length of this array is one plus the number of suffixes provided. The first entry corresponds to the given name.
       */
      generateUniqueNamesWithSuffixes(name, suffixes, caseSensitive = true) {
        const relevantUsedNames = this.getUsedNamesStartingWith(name, caseSensitive);
        const namesWithSuffixes = this.generateNamesWithSuffixes(name, suffixes);
        if (!this.areNamesUsed(namesWithSuffixes, relevantUsedNames, caseSensitive)) {
          return [name, ...namesWithSuffixes];
        }
        const index = this.getUniqueIndex(name, relevantUsedNames, suffixes, caseSensitive);
        return this.generateNamesWithIndexAndSuffixes(name, index, suffixes);
      }
      /**
       * Generate unique names by appending an index separated by the `indexSeparator` if necessary, while respecting the given suffixes.
       * If the name is already unique nothing is appended.
       * The generated names are added to the used names.
       * Each given suffix is appended to the unique name in the result.
       * The resulting names are also checked for uniqueness.
       * All names in the result have the same number suffix.
       * @example if `MyName` and `MyName_1MySuffix` is already taken, `[MyName_2, MyName_2MySuffix]` will be generated by default.
       * @param name - The name to get a unique name from.
       * @param suffixes - Additional name of suffixes to be considered for the finding process, as well as the output.
       * @param caseSensitive - Whether to check the already used names in a case sensitive manner.
       * @returns A list of unique names. The length of this array is one plus the number of suffixes provided. The first entry corresponds to the given name.
       */
      generateAndSaveUniqueNamesWithSuffixes(name, suffixes, caseSensitive = true) {
        const uniqueNames = this.generateUniqueNamesWithSuffixes(name, suffixes, caseSensitive);
        this.addToUsedNames(...uniqueNames);
        return uniqueNames;
      }
      getUsedNamesForComparison(caseSensitive) {
        return this.usedNames.map((name) => _UniqueNameGenerator.getNameForComparison(name, caseSensitive));
      }
      areNamesUsed(names, usedNames, caseSensitive) {
        return names.some((name) => usedNames.map((usedName) => _UniqueNameGenerator.getNameForComparison(usedName, caseSensitive)).includes(_UniqueNameGenerator.getNameForComparison(name, caseSensitive)));
      }
      generateNamesWithIndexAndSuffixes(name, index, suffixes) {
        const nameWithoutIndex = this.getNameWithoutIndex(name);
        return this.generateNamesWithSuffixes(`${nameWithoutIndex}${this.indexSeparator}${index}`, suffixes);
      }
      generateNamesWithSuffixes(name, suffixes) {
        return [name, ...suffixes.map((nameSuffix) => `${name}${nameSuffix}`)];
      }
      getUsedNamesStartingWith(name, caseSensitive) {
        const modifiedName = this.getNameWithoutIndex(name);
        return this.getUsedNamesForComparison(caseSensitive).filter((used) => used.startsWith(_UniqueNameGenerator.getNameForComparison(modifiedName, caseSensitive)));
      }
      getUniqueIndex(name, usedNames, suffixes, caseSensitive) {
        let index = 1;
        while (index < _UniqueNameGenerator.MAXIMUM_NUMBER_OF_SUFFIX) {
          const newNames = this.generateNamesWithIndexAndSuffixes(name, index, suffixes);
          if (!this.areNamesUsed(newNames, usedNames, caseSensitive)) {
            return index;
          }
          index++;
        }
        throw new Error(`Unable to find a unique name for ${name} within the range of ${_UniqueNameGenerator.MAXIMUM_NUMBER_OF_SUFFIX} suffixes.`);
      }
      getNameWithoutIndex(name) {
        return name.replace(new RegExp(`${this.indexSeparator}\\d+$`), "");
      }
    };
    exports2.UniqueNameGenerator = UniqueNameGenerator;
    UniqueNameGenerator.MAXIMUM_NUMBER_OF_SUFFIX = 1e3;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/url.js
var require_url2 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/url.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkUrlExists = checkUrlExists;
    var axios_1 = __importDefault(require_axios());
    async function checkUrlExists(url) {
      return axios_1.default.request({ url, method: "HEAD" }).then((response) => response.status);
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/util/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_array2(), exports2);
    __exportStar(require_code_block2(), exports2);
    __exportStar(require_documentation_block2(), exports2);
    __exportStar(require_equal2(), exports2);
    __exportStar(require_error_with_cause2(), exports2);
    __exportStar(require_fs2(), exports2);
    __exportStar(require_logger3(), exports2);
    __exportStar(require_nullish2(), exports2);
    __exportStar(require_object2(), exports2);
    __exportStar(require_pipe2(), exports2);
    __exportStar(require_promise2(), exports2);
    __exportStar(require_remove_slashes2(), exports2);
    __exportStar(require_string2(), exports2);
    __exportStar(require_string_formatter2(), exports2);
    __exportStar(require_types2(), exports2);
    __exportStar(require_unique_name_generator2(), exports2);
    __exportStar(require_url2(), exports2);
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/resilience/dist/timeout.js
var require_timeout = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/resilience/dist/timeout.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.timeout = timeout;
    var util_1 = require_dist2();
    var defaultTimeout = 1e4;
    var logger8 = (0, util_1.createLogger)({
      package: "resilience",
      messageContext: "timeout"
    });
    function timeout(timeoutValue = defaultTimeout) {
      if (timeoutValue <= 0) {
        throw new Error("Timeout must be greater than 0.");
      }
      if (timeoutValue < 10) {
        logger8.warn(`The timeout of ${timeoutValue} ms is too low. Make sure this is not intentional.`);
      }
      return function(options) {
        const message = `Request to URL: ${options.context.uri} ran into a timeout after ${timeoutValue}ms.`;
        return (arg) => wrapInTimeout(options.fn(arg), timeoutValue, message);
      };
    }
    function getTimeoutPromise(timeoutValue, message) {
      let timeoutNode;
      const promise = new Promise((resolve, reject) => {
        timeoutNode = setTimeout(() => reject(new Error(message)), timeoutValue);
      });
      return [promise, timeoutNode];
    }
    async function wrapInTimeout(promise, timeoutValue, message) {
      const [timeoutPromise, timeoutInstance] = getTimeoutPromise(timeoutValue, message);
      const withClearTimeout = promise.finally(() => {
        clearTimeout(timeoutInstance);
      });
      return Promise.race([withClearTimeout, timeoutPromise]);
    }
  }
});

// node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS({
  "node_modules/retry/lib/retry_operation.js"(exports2, module2) {
    function RetryOperation(timeouts, options) {
      if (typeof options === "boolean") {
        options = { forever: options };
      }
      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
      this._timeouts = timeouts;
      this._options = options || {};
      this._maxRetryTime = options && options.maxRetryTime || Infinity;
      this._fn = null;
      this._errors = [];
      this._attempts = 1;
      this._operationTimeout = null;
      this._operationTimeoutCb = null;
      this._timeout = null;
      this._operationStart = null;
      this._timer = null;
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
      }
    }
    module2.exports = RetryOperation;
    RetryOperation.prototype.reset = function() {
      this._attempts = 1;
      this._timeouts = this._originalTimeouts.slice(0);
    };
    RetryOperation.prototype.stop = function() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (this._timer) {
        clearTimeout(this._timer);
      }
      this._timeouts = [];
      this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function(err) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (!err) {
        return false;
      }
      var currentTime = (/* @__PURE__ */ new Date()).getTime();
      if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.push(err);
        this._errors.unshift(new Error("RetryOperation timeout occurred"));
        return false;
      }
      this._errors.push(err);
      var timeout = this._timeouts.shift();
      if (timeout === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(0, this._errors.length - 1);
          timeout = this._cachedTimeouts.slice(-1);
        } else {
          return false;
        }
      }
      var self2 = this;
      this._timer = setTimeout(function() {
        self2._attempts++;
        if (self2._operationTimeoutCb) {
          self2._timeout = setTimeout(function() {
            self2._operationTimeoutCb(self2._attempts);
          }, self2._operationTimeout);
          if (self2._options.unref) {
            self2._timeout.unref();
          }
        }
        self2._fn(self2._attempts);
      }, timeout);
      if (this._options.unref) {
        this._timer.unref();
      }
      return true;
    };
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
      this._fn = fn;
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb;
        }
      }
      var self2 = this;
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
          self2._operationTimeoutCb();
        }, self2._operationTimeout);
      }
      this._operationStart = (/* @__PURE__ */ new Date()).getTime();
      this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function(fn) {
      console.log("Using RetryOperation.try() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = function(fn) {
      console.log("Using RetryOperation.start() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function() {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function() {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function() {
      if (this._errors.length === 0) {
        return null;
      }
      var counts = {};
      var mainError = null;
      var mainErrorCount = 0;
      for (var i = 0; i < this._errors.length; i++) {
        var error = this._errors[i];
        var message = error.message;
        var count = (counts[message] || 0) + 1;
        counts[message] = count;
        if (count >= mainErrorCount) {
          mainError = error;
          mainErrorCount = count;
        }
      }
      return mainError;
    };
  }
});

// node_modules/retry/lib/retry.js
var require_retry = __commonJS({
  "node_modules/retry/lib/retry.js"(exports2) {
    var RetryOperation = require_retry_operation();
    exports2.operation = function(options) {
      var timeouts = exports2.timeouts(options);
      return new RetryOperation(timeouts, {
        forever: options && (options.forever || options.retries === Infinity),
        unref: options && options.unref,
        maxRetryTime: options && options.maxRetryTime
      });
    };
    exports2.timeouts = function(options) {
      if (options instanceof Array) {
        return [].concat(options);
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      };
      for (var key in options) {
        opts[key] = options[key];
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i = 0; i < opts.retries; i++) {
        timeouts.push(this.createTimeout(i, opts));
      }
      if (options && options.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i, opts));
      }
      timeouts.sort(function(a, b) {
        return a - b;
      });
      return timeouts;
    };
    exports2.createTimeout = function(attempt, opts) {
      var random = opts.randomize ? Math.random() + 1 : 1;
      var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
      timeout = Math.min(timeout, opts.maxTimeout);
      return timeout;
    };
    exports2.wrap = function(obj, options, methods) {
      if (options instanceof Array) {
        methods = options;
        options = null;
      }
      if (!methods) {
        methods = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key);
          }
        }
      }
      for (var i = 0; i < methods.length; i++) {
        var method = methods[i];
        var original = obj[method];
        obj[method] = function retryWrapper(original2) {
          var op = exports2.operation(options);
          var args = Array.prototype.slice.call(arguments, 1);
          var callback = args.pop();
          args.push(function(err) {
            if (op.retry(err)) {
              return;
            }
            if (err) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function() {
            original2.apply(obj, args);
          });
        }.bind(obj, original);
        obj[method].options = options;
      }
    };
  }
});

// node_modules/retry/index.js
var require_retry2 = __commonJS({
  "node_modules/retry/index.js"(exports2, module2) {
    module2.exports = require_retry();
  }
});

// node_modules/async-retry/lib/index.js
var require_lib = __commonJS({
  "node_modules/async-retry/lib/index.js"(exports2, module2) {
    var retrier = require_retry2();
    function retry(fn, opts) {
      function run(resolve, reject) {
        var options = opts || {};
        var op;
        if (!("randomize" in options)) {
          options.randomize = true;
        }
        op = retrier.operation(options);
        function bail(err) {
          reject(err || new Error("Aborted"));
        }
        function onError(err, num) {
          if (err.bail) {
            bail(err);
            return;
          }
          if (!op.retry(err)) {
            reject(op.mainError());
          } else if (options.onRetry) {
            options.onRetry(err, num);
          }
        }
        function runAttempt(num) {
          var val;
          try {
            val = fn(bail, num);
          } catch (err) {
            onError(err, num);
            return;
          }
          Promise.resolve(val).then(resolve).catch(function catchIt(err) {
            onError(err, num);
          });
        }
        op.attempt(runAttempt);
      }
      return new Promise(run);
    }
    module2.exports = retry;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/resilience/dist/retry.js
var require_retry3 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/resilience/dist/retry.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.retry = retry;
    var util_1 = require_dist2();
    var asyncRetry = __importStar(require_lib());
    var logger8 = (0, util_1.createLogger)({
      package: "resilience",
      messageContext: "retry"
    });
    var defaultRetries = 3;
    function retry(retries = defaultRetries) {
      if (retries < 0) {
        throw new Error("Number of retries must be greater or equal to 0.");
      }
      return function(options) {
        return (arg) => asyncRetry.default(async (bail) => {
          try {
            return await options.fn(arg);
          } catch (error) {
            const status = error?.response?.status;
            if (!status) {
              logger8.debug("HTTP request failed but error did not contain a response status field as expected. Rethrowing error.");
            } else if (status.toString().startsWith("4")) {
              bail(new util_1.ErrorWithCause(`Request failed with status code ${status}`, error));
              return void 0;
            }
            throw error;
          }
        }, { retries });
      };
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/resilience/dist/middleware.js
var require_middleware = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/resilience/dist/middleware.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.executeWithMiddleware = executeWithMiddleware;
    function executeWithMiddleware(middlewares, { fn, context, fnArgument }) {
      if (!middlewares?.length) {
        return fn(fnArgument);
      }
      const initial = { context, fn };
      const functionWithMiddlewares = addMiddlewaresToInitialFunction(middlewares, initial);
      return functionWithMiddlewares(fnArgument);
    }
    function addMiddlewaresToInitialFunction(middlewares, initial) {
      const { context } = initial;
      const functionWithMiddlewares = middlewares.reduceRight((prev, curr) => ({ fn: curr(prev), context }), initial);
      return functionWithMiddlewares.fn;
    }
  }
});

// node_modules/opossum/lib/status.js
var require_status = __commonJS({
  "node_modules/opossum/lib/status.js"(exports2, module2) {
    "use strict";
    var WINDOW = Symbol("window");
    var BUCKETS = Symbol("buckets");
    var TIMEOUT = Symbol("timeout");
    var PERCENTILES = Symbol("percentiles");
    var BUCKET_INTERVAL = Symbol("bucket-interval");
    var SNAPSHOT_INTERVAL = Symbol("snapshot-interval");
    var ROTATE_EVENT_NAME = Symbol("rotate-event-name");
    var EventEmitter = require("events").EventEmitter;
    var Status = class extends EventEmitter {
      constructor(options) {
        super();
        this[BUCKETS] = options.rollingCountBuckets || 10;
        this[TIMEOUT] = options.rollingCountTimeout || 1e4;
        this[WINDOW] = new Array(this[BUCKETS]);
        this[PERCENTILES] = [0, 0.25, 0.5, 0.75, 0.9, 0.95, 0.99, 0.995, 1];
        this[ROTATE_EVENT_NAME] = "rotate";
        this.rollingPercentilesEnabled = options.rollingPercentilesEnabled !== false;
        this.enableSnapshots = options.enableSnapshots !== false;
        this.rotateBucketController = options.rotateBucketController;
        this.rotateBucket = nextBucket(this[WINDOW]);
        for (let i = 0; i < this[BUCKETS]; i++) this[WINDOW][i] = bucket();
        const bucketInterval = Math.floor(this[TIMEOUT] / this[BUCKETS]);
        if (this.rotateBucketController) {
          this.startListeneningForRotateEvent();
        } else {
          this[BUCKET_INTERVAL] = setInterval(this.rotateBucket, bucketInterval);
          if (typeof this[BUCKET_INTERVAL].unref === "function") {
            this[BUCKET_INTERVAL].unref();
          }
        }
        if (this.enableSnapshots) {
          this[SNAPSHOT_INTERVAL] = setInterval(
            (_) => this.emit("snapshot", this.stats),
            bucketInterval
          );
          if (typeof this[SNAPSHOT_INTERVAL].unref === "function") {
            this[SNAPSHOT_INTERVAL].unref();
          }
        }
        if (options.stats) {
          this[WINDOW][0] = { ...bucket(), ...options.stats };
        }
      }
      /**
       * Get the cumulative stats for the current window
       * @type {Object}
       */
      get stats() {
        const totals = this[WINDOW].reduce((acc, val) => {
          if (!val) {
            return acc;
          }
          Object.keys(acc).forEach((key) => {
            if (key !== "latencyTimes" && key !== "percentiles") {
              acc[key] += val[key] || 0;
            }
          });
          if (this.rollingPercentilesEnabled) {
            if (val.latencyTimes) {
              acc.latencyTimes = acc.latencyTimes.concat(val.latencyTimes);
            }
          }
          return acc;
        }, bucket());
        if (this.rollingPercentilesEnabled) {
          totals.latencyTimes.sort((a, b) => a - b);
          if (totals.latencyTimes.length) {
            totals.latencyMean = totals.latencyTimes.reduce((a, b) => a + b, 0) / totals.latencyTimes.length;
          } else {
            totals.latencyMean = 0;
          }
          this[PERCENTILES].forEach((percentile) => {
            totals.percentiles[percentile] = calculatePercentile(percentile, totals.latencyTimes);
          });
        } else {
          totals.latencyMean = -1;
          this[PERCENTILES].forEach((percentile) => {
            totals.percentiles[percentile] = -1;
          });
        }
        return totals;
      }
      /**
       * Gets the stats window as an array of time-sliced objects.
       * @type {Array}
       */
      get window() {
        return this[WINDOW].slice();
      }
      increment(property, latencyRunTime) {
        this[WINDOW][0][property]++;
        if (property === "successes" || property === "failures" || property === "timeouts") {
          this[WINDOW][0].latencyTimes.push(latencyRunTime || 0);
        }
      }
      open() {
        this[WINDOW][0].isCircuitBreakerOpen = true;
      }
      close() {
        this[WINDOW][0].isCircuitBreakerOpen = false;
      }
      shutdown() {
        this.removeAllListeners();
        if (this.rotateBucketController === void 0) {
          clearInterval(this[BUCKET_INTERVAL]);
        } else {
          this.removeRotateBucketControllerListener();
        }
        if (this.enableSnapshots) {
          clearInterval(this[SNAPSHOT_INTERVAL]);
        }
      }
      removeRotateBucketControllerListener() {
        if (this.rotateBucketController) {
          this.rotateBucketController.removeListener(
            this[ROTATE_EVENT_NAME],
            this.rotateBucket
          );
        }
      }
      startListeneningForRotateEvent() {
        if (this.rotateBucketController && this.rotateBucketController.listenerCount(
          this[ROTATE_EVENT_NAME],
          this.rotateBucket
        ) === 0) {
          this.rotateBucketController.on(
            this[ROTATE_EVENT_NAME],
            this.rotateBucket
          );
        }
      }
    };
    var nextBucket = (window2) => (_) => {
      window2.pop();
      window2.unshift(bucket());
    };
    var bucket = (_) => ({
      failures: 0,
      fallbacks: 0,
      successes: 0,
      rejects: 0,
      fires: 0,
      timeouts: 0,
      cacheHits: 0,
      cacheMisses: 0,
      coalesceCacheHits: 0,
      coalesceCacheMisses: 0,
      semaphoreRejections: 0,
      percentiles: {},
      latencyTimes: []
    });
    function calculatePercentile(percentile, arr2) {
      if (percentile === 0) {
        return arr2[0] || 0;
      }
      const idx = Math.ceil(percentile * arr2.length);
      return arr2[idx - 1] || 0;
    }
    module2.exports = exports2 = Status;
  }
});

// node_modules/opossum/lib/semaphore.js
var require_semaphore = __commonJS({
  "node_modules/opossum/lib/semaphore.js"(exports2, module2) {
    "use strict";
    module2.exports = exports2 = semaphore;
    function semaphore(count) {
      const resolvers = [];
      let counter = count;
      const sem = {
        take,
        release,
        test
      };
      Object.defineProperty(sem, "count", {
        get: (_) => counter,
        enumerable: true
      });
      return sem;
      function take(timeout) {
        if (counter > 0) {
          --counter;
          return Promise.resolve(release);
        }
        return new Promise((resolve, reject) => {
          resolvers.push((_) => {
            --counter;
            resolve(release);
          });
          if (timeout) {
            setTimeout((_) => {
              resolvers.shift();
              const err = new Error(`Timed out after ${timeout}ms`);
              err.code = "ETIMEDOUT";
              reject(err);
            }, timeout);
          }
        });
      }
      function release() {
        counter++;
        if (resolvers.length > 0) {
          resolvers.shift()();
        }
      }
      function test() {
        if (counter < 1) return false;
        return take() && true;
      }
    }
  }
});

// node_modules/opossum/lib/cache.js
var require_cache = __commonJS({
  "node_modules/opossum/lib/cache.js"(exports2, module2) {
    var MemoryCache = class {
      constructor(maxEntries) {
        this.cache = /* @__PURE__ */ new Map();
        this.maxEntries = maxEntries ?? 2 ** 24 - 1;
      }
      /**
       * Get cache value by key
       * @param {string} key Cache key
       * @return {any} Response from cache
       */
      get(key) {
        const cached = this.cache.get(key);
        if (cached) {
          if (cached.expiresAt > Date.now() || cached.expiresAt === 0) {
            return cached.value;
          }
          this.cache.delete(key);
        }
        return void 0;
      }
      /**
       * Set cache key with value and ttl
       * @param {string} key Cache key
       * @param {any} value Value to cache
       * @param {number} ttl Time to live in milliseconds
       * @return {void}
       */
      set(key, value, ttl) {
        if (this.cache.size === this.maxEntries && this.get(key) === void 0) {
          this.cache.delete(this.cache.keys().next().value);
        }
        this.cache.set(key, {
          expiresAt: ttl,
          value
        });
      }
      /**
       * Delete cache key
       * @param {string} key Cache key
       * @return {void}
       */
      delete(key) {
        this.cache.delete(key);
      }
      /**
       * Clear cache
       * @returns {void}
       */
      flush() {
        this.cache.clear();
      }
    };
    module2.exports = exports2 = MemoryCache;
  }
});

// node_modules/opossum/lib/circuit.js
var require_circuit = __commonJS({
  "node_modules/opossum/lib/circuit.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var Status = require_status();
    var Semaphore = require_semaphore();
    var MemoryCache = require_cache();
    var STATE = Symbol("state");
    var OPEN = Symbol("open");
    var CLOSED = Symbol("closed");
    var HALF_OPEN = Symbol("half-open");
    var PENDING_CLOSE = Symbol("pending-close");
    var SHUTDOWN = Symbol("shutdown");
    var FALLBACK_FUNCTION = Symbol("fallback");
    var STATUS = Symbol("status");
    var NAME = Symbol("name");
    var GROUP = Symbol("group");
    var ENABLED = Symbol("Enabled");
    var WARMING_UP = Symbol("warming-up");
    var VOLUME_THRESHOLD = Symbol("volume-threshold");
    var OUR_ERROR = Symbol("our-error");
    var RESET_TIMEOUT = Symbol("reset-timeout");
    var WARMUP_TIMEOUT = Symbol("warmup-timeout");
    var LAST_TIMER_AT = Symbol("last-timer-at");
    var deprecation = `options.maxFailures is deprecated. Please use options.errorThresholdPercentage`;
    var CircuitBreaker = class _CircuitBreaker extends EventEmitter {
      /**
       * Returns true if the provided error was generated here. It will be false
       * if the error came from the action itself.
       * @param {Error} error The Error to check.
       * @returns {Boolean} true if the error was generated here
       */
      static isOurError(error) {
        return !!error[OUR_ERROR];
      }
      /**
      * Create a new Status object,
      * helpful when you need to prime a breaker with stats
      * @param {Object} options -
      * @param {Number} options.rollingCountBuckets number of buckets in the window
      * @param {Number} options.rollingCountTimeout the duration of the window
      * @param {Boolean} options.rollingPercentilesEnabled whether to calculate
      * @param {Object} options.stats user supplied stats
      * @returns {Status} a new {@link Status} object
      */
      static newStatus(options) {
        return new Status(options);
      }
      constructor(action, options = {}) {
        super();
        this.options = options;
        this.options.timeout = options.timeout ?? 1e4;
        this.options.resetTimeout = options.resetTimeout ?? 3e4;
        this.options.errorThresholdPercentage = options.errorThresholdPercentage ?? 50;
        this.options.rollingCountTimeout = options.rollingCountTimeout ?? 1e4;
        this.options.rollingCountBuckets = options.rollingCountBuckets ?? 10;
        this.options.rollingPercentilesEnabled = options.rollingPercentilesEnabled !== false;
        this.options.capacity = Number.isInteger(options.capacity) ? options.capacity : Number.MAX_SAFE_INTEGER;
        this.options.errorFilter = options.errorFilter || ((_) => false);
        this.options.cacheTTL = options.cacheTTL ?? 0;
        this.options.cacheGetKey = options.cacheGetKey ?? ((...args) => JSON.stringify(args));
        this.options.enableSnapshots = options.enableSnapshots !== false;
        this.options.rotateBucketController = options.rotateBucketController;
        this.options.coalesce = !!options.coalesce;
        this.options.coalesceTTL = options.coalesceTTL ?? this.options.timeout;
        this.options.coalesceResetOn = options.coalesceResetOn?.filter((o) => ["error", "success", "timeout"].includes(o)) || [];
        if (this.options.cache) {
          if (this.options.cacheTransport === void 0) {
            this.options.cacheTransport = new MemoryCache(options.cacheSize);
          } else if (typeof this.options.cacheTransport !== "object" || !this.options.cacheTransport.get || !this.options.cacheTransport.set || !this.options.cacheTransport.flush) {
            throw new TypeError(
              "options.cacheTransport should be an object with `get`, `set` and `flush` methods"
            );
          }
        }
        if (this.options.coalesce) {
          this.options.coalesceCache = new MemoryCache(options.coalesceSize);
        }
        this.semaphore = new Semaphore(this.options.capacity);
        if (!action) {
          throw new TypeError(
            "No action provided. Cannot construct a CircuitBreaker without an invocable action."
          );
        }
        if (options.autoRenewAbortController && !options.abortController) {
          options.abortController = new AbortController();
        }
        if (options.abortController && typeof options.abortController.abort !== "function") {
          throw new TypeError(
            "AbortController does not contain `abort()` method"
          );
        }
        this[VOLUME_THRESHOLD] = Number.isInteger(options.volumeThreshold) ? options.volumeThreshold : 0;
        this[WARMING_UP] = options.allowWarmUp === true;
        if (this.options.status) {
          if (this.options.status instanceof Status) {
            this[STATUS] = this.options.status;
          } else {
            this[STATUS] = new Status({ stats: this.options.status });
          }
        } else {
          this[STATUS] = new Status(this.options);
        }
        this[STATE] = CLOSED;
        if (options.state) {
          this[ENABLED] = options.state.enabled !== false;
          this[WARMING_UP] = options.state.warmUp || this[WARMING_UP];
          this[CLOSED] = options.state.closed !== false;
          this[HALF_OPEN] = this[PENDING_CLOSE] = options.state.halfOpen || false;
          this[OPEN] = !this[CLOSED] && !this[HALF_OPEN];
          this[SHUTDOWN] = options.state.shutdown || false;
        } else {
          this[PENDING_CLOSE] = false;
          this[ENABLED] = options.enabled !== false;
        }
        this[FALLBACK_FUNCTION] = null;
        this[NAME] = options.name || action.name || nextName();
        this[GROUP] = options.group || this[NAME];
        if (this[WARMING_UP]) {
          const timer = this[WARMUP_TIMEOUT] = setTimeout(
            (_) => this[WARMING_UP] = false,
            this.options.rollingCountTimeout
          );
          if (typeof timer.unref === "function") {
            timer.unref();
          }
        }
        if (typeof action !== "function") {
          this.action = (_) => Promise.resolve(action);
        } else this.action = action;
        if (options.maxFailures) console.error(deprecation);
        const increment = (property) => (result, runTime) => this[STATUS].increment(property, runTime);
        this.on("success", increment("successes"));
        this.on("failure", increment("failures"));
        this.on("fallback", increment("fallbacks"));
        this.on("timeout", increment("timeouts"));
        this.on("fire", increment("fires"));
        this.on("reject", increment("rejects"));
        this.on("cacheHit", increment("cacheHits"));
        this.on("cacheMiss", increment("cacheMisses"));
        this.on("coalesceCacheHit", increment("coalesceCacheHits"));
        this.on("coalesceCacheMiss", increment("coalesceCacheMisses"));
        this.on("open", (_) => this[STATUS].open());
        this.on("close", (_) => this[STATUS].close());
        this.on("semaphoreLocked", increment("semaphoreRejections"));
        function _startTimer(circuit) {
          circuit[LAST_TIMER_AT] = Date.now();
          return (_) => {
            const timer = circuit[RESET_TIMEOUT] = setTimeout(() => {
              _halfOpen(circuit);
            }, circuit.options.resetTimeout);
            if (typeof timer.unref === "function") {
              timer.unref();
            }
          };
        }
        function _halfOpen(circuit) {
          circuit[STATE] = HALF_OPEN;
          circuit[PENDING_CLOSE] = true;
          circuit._renewAbortControllerIfNeeded();
          circuit.emit("halfOpen", circuit.options.resetTimeout);
        }
        this.on("open", _startTimer(this));
        this.on("success", (_) => {
          if (this.halfOpen) {
            this.close();
          }
        });
        if (this[SHUTDOWN]) {
          this[STATE] = SHUTDOWN;
          this.shutdown();
        } else if (this[CLOSED]) {
          this.close();
        } else if (this[OPEN]) {
          if (this.options.state.lastTimerAt !== void 0 && Date.now() - this.options.state.lastTimerAt > this.options.resetTimeout) {
            _halfOpen(this);
          } else {
            this.open();
          }
        } else if (this[HALF_OPEN]) {
          this[STATE] = HALF_OPEN;
        }
      }
      /**
       * Renews the abort controller if needed
       * @private
       * @returns {void}
       */
      _renewAbortControllerIfNeeded() {
        if (this.options.autoRenewAbortController && this.options.abortController && this.options.abortController.signal.aborted) {
          this.options.abortController = new AbortController();
        }
      }
      /**
       * Closes the breaker, allowing the action to execute again
       * @fires CircuitBreaker#close
       * @returns {void}
       */
      close() {
        if (this[STATE] !== CLOSED) {
          if (this[RESET_TIMEOUT]) {
            clearTimeout(this[RESET_TIMEOUT]);
          }
          this[STATE] = CLOSED;
          this[PENDING_CLOSE] = false;
          this._renewAbortControllerIfNeeded();
          this.emit("close");
        }
      }
      /**
       * Opens the breaker. Each time the breaker is fired while the circuit is
       * opened, a failed Promise is returned, or if any fallback function
       * has been provided, it is invoked.
       *
       * If the breaker is already open this call does nothing.
       * @fires CircuitBreaker#open
       * @returns {void}
       */
      open() {
        if (this[STATE] !== OPEN) {
          this[STATE] = OPEN;
          this[PENDING_CLOSE] = false;
          this.emit("open");
        }
      }
      /**
       * Shuts down this circuit breaker. All subsequent calls to the
       * circuit will fail, returning a rejected promise.
       * @returns {void}
       */
      shutdown() {
        this.emit("shutdown");
        this.disable();
        this.removeAllListeners();
        if (this[RESET_TIMEOUT]) {
          clearTimeout(this[RESET_TIMEOUT]);
        }
        if (this[WARMUP_TIMEOUT]) {
          clearTimeout(this[WARMUP_TIMEOUT]);
        }
        this.status.shutdown();
        this[STATE] = SHUTDOWN;
        this.clearCache();
      }
      /**
       * Determines if the circuit has been shutdown.
       * @type {Boolean}
       */
      get isShutdown() {
        return this[STATE] === SHUTDOWN;
      }
      /**
       * Gets the name of this circuit
       * @type {String}
       */
      get name() {
        return this[NAME];
      }
      /**
       * Gets the name of this circuit group
       * @type {String}
       */
      get group() {
        return this[GROUP];
      }
      /**
       * Gets whether this circuit is in the `pendingClosed` state
       * @type {Boolean}
       */
      get pendingClose() {
        return this[PENDING_CLOSE];
      }
      /**
       * True if the circuit is currently closed. False otherwise.
       * @type {Boolean}
       */
      get closed() {
        return this[STATE] === CLOSED;
      }
      /**
       * True if the circuit is currently opened. False otherwise.
       * @type {Boolean}
       */
      get opened() {
        return this[STATE] === OPEN;
      }
      /**
       * True if the circuit is currently half opened. False otherwise.
       * @type {Boolean}
       */
      get halfOpen() {
        return this[STATE] === HALF_OPEN;
      }
      /**
       * The current {@link Status} of this {@link CircuitBreaker}
       * @type {Status}
       */
      get status() {
        return this[STATUS];
      }
      /**
       * Get the current stats for the circuit.
       * @see Status#stats
       * @type {Object}
       */
      get stats() {
        return this[STATUS].stats;
      }
      toJSON() {
        return {
          state: {
            name: this.name,
            enabled: this.enabled,
            closed: this.closed,
            open: this.opened,
            halfOpen: this.halfOpen,
            warmUp: this.warmUp,
            shutdown: this.isShutdown,
            lastTimerAt: this[LAST_TIMER_AT]
          },
          status: this.status.stats
        };
      }
      /**
       * Gets whether the circuit is enabled or not
       * @type {Boolean}
       */
      get enabled() {
        return this[ENABLED];
      }
      /**
       * Gets whether the circuit is currently in warm up phase
       * @type {Boolean}
       */
      get warmUp() {
        return this[WARMING_UP];
      }
      /**
       * Gets the volume threshold for this circuit
       * @type {Boolean}
       */
      get volumeThreshold() {
        return this[VOLUME_THRESHOLD];
      }
      /**
       * Provide a fallback function for this {@link CircuitBreaker}. This
       * function will be executed when the circuit is `fire`d and fails.
       * It will always be preceded by a `failure` event, and `breaker.fire` returns
       * a rejected Promise.
       * @param {Function | CircuitBreaker} func the fallback function to execute
       * when the breaker has opened or when a timeout or error occurs.
       * @return {CircuitBreaker} this
       */
      fallback(func) {
        let fb = func;
        if (func instanceof _CircuitBreaker) {
          fb = (...args) => func.fire(...args);
        }
        this[FALLBACK_FUNCTION] = fb;
        return this;
      }
      /**
       * Execute the action for this circuit. If the action fails or times out, the
       * returned promise will be rejected. If the action succeeds, the promise will
       * resolve with the resolved value from action. If a fallback function was
       * provided, it will be invoked in the event of any failure or timeout.
       *
       * Any parameters passed to this function will be proxied to the circuit
       * function.
       *
       * @return {Promise<any>} promise resolves with the circuit function's return
       * value on success or is rejected on failure of the action. Use isOurError()
       * to determine if a rejection was a result of the circuit breaker or the
       * action.
       *
       * @fires CircuitBreaker#failure
       * @fires CircuitBreaker#fallback
       * @fires CircuitBreaker#fire
       * @fires CircuitBreaker#reject
       * @fires CircuitBreaker#success
       * @fires CircuitBreaker#timeout
       * @fires CircuitBreaker#semaphoreLocked
       */
      fire(...args) {
        return this.call(this.action, ...args);
      }
      /**
       * Execute the action for this circuit using `context` as `this`.
       * If the action fails or times out, the
       * returned promise will be rejected. If the action succeeds, the promise will
       * resolve with the resolved value from action. If a fallback function was
       * provided, it will be invoked in the event of any failure or timeout.
       *
       * Any parameters in addition to `context will be passed to the
       * circuit function.
       *
       * @param {any} context the `this` context used for function execution
       * @param {any} rest the arguments passed to the action
       *
       * @return {Promise<any>} promise resolves with the circuit function's return
       * value on success or is rejected on failure of the action.
       *
       * @fires CircuitBreaker#failure
       * @fires CircuitBreaker#fallback
       * @fires CircuitBreaker#fire
       * @fires CircuitBreaker#reject
       * @fires CircuitBreaker#success
       * @fires CircuitBreaker#timeout
       * @fires CircuitBreaker#semaphoreLocked
       */
      call(context, ...rest) {
        if (this.isShutdown) {
          const err = buildError("The circuit has been shutdown.", "ESHUTDOWN");
          return Promise.reject(err);
        }
        const args = rest.slice();
        this.emit("fire", args);
        if (!this[ENABLED]) {
          const result = this.action.apply(context, args);
          return typeof result.then === "function" ? result : Promise.resolve(result);
        }
        const cacheKey = this.options.cache || this.options.coalesce ? this.options.cacheGetKey.apply(this, rest) : "";
        if (this.options.cache) {
          const cached = this.options.cacheTransport.get(cacheKey);
          if (cached) {
            this.emit("cacheHit");
            return cached;
          }
          this.emit("cacheMiss");
        }
        if (this.options.coalesce) {
          const cachedCall = this.options.coalesceCache.get(cacheKey);
          if (cachedCall) {
            this.emit("coalesceCacheHit");
            return cachedCall;
          }
          this.emit("coalesceCacheMiss");
        }
        if (!this.closed && !this.pendingClose) {
          const error = buildError("Breaker is open", "EOPENBREAKER");
          this.emit("reject", error);
          return fallback(this, error, args) || Promise.reject(error);
        }
        this[PENDING_CLOSE] = false;
        let timeout;
        let timeoutError = false;
        const call = new Promise((resolve, reject) => {
          const latencyStartTime = Date.now();
          if (this.semaphore.test()) {
            if (this.options.timeout) {
              timeout = setTimeout(
                () => {
                  timeoutError = true;
                  const error = buildError(
                    `Timed out after ${this.options.timeout}ms`,
                    "ETIMEDOUT"
                  );
                  const latency = Date.now() - latencyStartTime;
                  this.semaphore.release();
                  this.emit("timeout", error, latency, args);
                  handleError(error, this, timeout, args, latency, resolve, reject);
                  resetCoalesce(this, cacheKey, "timeout");
                  if (this.options.abortController) {
                    this.options.abortController.abort();
                  }
                },
                this.options.timeout
              );
            }
            try {
              const result = this.action.apply(context, args);
              const promise = typeof result.then === "function" ? result : Promise.resolve(result);
              promise.then((result2) => {
                if (!timeoutError) {
                  clearTimeout(timeout);
                  this.emit("success", result2, Date.now() - latencyStartTime);
                  resetCoalesce(this, cacheKey, "success");
                  this.semaphore.release();
                  resolve(result2);
                  if (this.options.cache) {
                    this.options.cacheTransport.set(
                      cacheKey,
                      promise,
                      this.options.cacheTTL > 0 ? Date.now() + this.options.cacheTTL : 0
                    );
                  }
                }
              }).catch((error) => {
                if (!timeoutError) {
                  this.semaphore.release();
                  const latencyEndTime = Date.now() - latencyStartTime;
                  handleError(
                    error,
                    this,
                    timeout,
                    args,
                    latencyEndTime,
                    resolve,
                    reject
                  );
                  resetCoalesce(this, cacheKey, "error");
                }
              });
            } catch (error) {
              this.semaphore.release();
              const latency = Date.now() - latencyStartTime;
              handleError(error, this, timeout, args, latency, resolve, reject);
              resetCoalesce(this, cacheKey, "error");
            }
          } else {
            const latency = Date.now() - latencyStartTime;
            const err = buildError("Semaphore locked", "ESEMLOCKED");
            this.emit("semaphoreLocked", err, latency);
            handleError(err, this, timeout, args, latency, resolve, reject);
            resetCoalesce(this, cacheKey);
          }
        });
        if (this.options.coalesce) {
          this.options.coalesceCache.set(
            cacheKey,
            call,
            this.options.coalesceTTL > 0 ? Date.now() + this.options.coalesceTTL : 0
          );
        }
        return call;
      }
      /**
       * Clears the cache of this {@link CircuitBreaker}
       * @returns {void}
       */
      clearCache() {
        if (this.options.cache) {
          this.options.cacheTransport.flush();
        }
        if (this.options.coalesceCache) {
          this.options.coalesceCache.flush();
        }
      }
      /**
       * Provide a health check function to be called periodically. The function
       * should return a Promise. If the promise is rejected the circuit will open.
       * This is in addition to the existing circuit behavior as defined by
       * `options.errorThresholdPercentage` in the constructor. For example, if the
       * health check function provided here always returns a resolved promise, the
       * circuit can still trip and open if there are failures exceeding the
       * configured threshold. The health check function is executed within the
       * circuit breaker's execution context, so `this` within the function is the
       * circuit breaker itself.
       *
       * @param {Function} func a health check function which returns a promise.
       * @param {Number} [interval] the amount of time between calls to the health
       * check function. Default: 5000 (5 seconds)
       *
       * @returns {void}
       *
       * @fires CircuitBreaker#healthCheckFailed
       * @throws {TypeError} if `interval` is supplied but not a number
       */
      healthCheck(func, interval) {
        interval = interval || 5e3;
        if (typeof func !== "function") {
          throw new TypeError("Health check function must be a function");
        }
        if (isNaN(interval)) {
          throw new TypeError("Health check interval must be a number");
        }
        const check = (_) => {
          func.apply(this).catch((e) => {
            this.emit("healthCheckFailed", e);
            this.open();
          });
        };
        const timer = setInterval(check, interval);
        if (typeof timer.unref === "function") {
          timer.unref();
        }
        check();
      }
      /**
       * Enables this circuit. If the circuit is the  disabled
       * state, it will be re-enabled. If not, this is essentially
       * a noop.
       * @returns {void}
       */
      enable() {
        this[ENABLED] = true;
        this.status.startListeneningForRotateEvent();
      }
      /**
       * Disables this circuit, causing all calls to the circuit's function
       * to be executed without circuit or fallback protection.
       * @returns {void}
       */
      disable() {
        this[ENABLED] = false;
        this.status.removeRotateBucketControllerListener();
      }
      /**
       * Retrieves the current AbortSignal from the abortController, if available.
       * This signal can be used to monitor ongoing requests.
       * @returns {AbortSignal|undefined} The AbortSignal if present,
       * otherwise undefined.
       */
      getSignal() {
        if (this.options.abortController && this.options.abortController.signal) {
          return this.options.abortController.signal;
        }
        return void 0;
      }
      /**
       * Retrieves the current AbortController instance.
       * This controller can be used to manually abort ongoing requests or create
       * a new signal.
       * @returns {AbortController|undefined} The AbortController if present,
       * otherwise undefined.
       */
      getAbortController() {
        return this.options.abortController;
      }
    };
    function handleError(error, circuit, timeout, args, latency, resolve, reject) {
      clearTimeout(timeout);
      if (circuit.options.errorFilter(error, ...args)) {
        circuit.emit("success", error, latency);
      } else {
        fail(circuit, error, args, latency);
        const fb = fallback(circuit, error, args);
        if (fb) return resolve(fb);
      }
      reject(error);
    }
    function fallback(circuit, err, args) {
      if (circuit[FALLBACK_FUNCTION]) {
        try {
          const result = circuit[FALLBACK_FUNCTION].apply(circuit[FALLBACK_FUNCTION], [...args, err]);
          circuit.emit("fallback", result, err);
          if (result instanceof Promise) return result;
          return Promise.resolve(result);
        } catch (e) {
          return Promise.reject(e);
        }
      }
    }
    function fail(circuit, err, args, latency) {
      circuit.emit("failure", err, latency, args);
      if (circuit.warmUp) return;
      const stats = circuit.stats;
      if (stats.fires < circuit.volumeThreshold && !circuit.halfOpen) return;
      const errorRate = stats.failures / stats.fires * 100;
      if (errorRate > circuit.options.errorThresholdPercentage || circuit.halfOpen) {
        circuit.open();
      }
    }
    function resetCoalesce(circuit, cacheKey, event) {
      if (!event || circuit.options.coalesceResetOn.includes(event)) {
        circuit.options.coalesceCache?.delete(cacheKey);
      }
    }
    function buildError(msg, code) {
      const error = new Error(msg);
      error.code = code;
      error[OUR_ERROR] = true;
      return error;
    }
    var nextName = () => "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
      const r = Math.random() * 16 | 0;
      const v = c === "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
    module2.exports = exports2 = CircuitBreaker;
  }
});

// node_modules/opossum/index.js
var require_opossum = __commonJS({
  "node_modules/opossum/index.js"(exports2, module2) {
    "use strict";
    module2.exports = exports2 = require_circuit();
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/resilience/dist/circuit-breaker.js
var require_circuit_breaker = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/resilience/dist/circuit-breaker.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.circuitBreakerDefaultOptions = exports2.circuitBreakers = void 0;
    exports2.circuitBreaker = circuitBreaker;
    var opossum_1 = __importDefault(require_opossum());
    exports2.circuitBreakers = {};
    exports2.circuitBreakerDefaultOptions = {
      timeout: false,
      errorThresholdPercentage: 50,
      volumeThreshold: 10,
      resetTimeout: 3e4,
      cache: false
    };
    function httpErrorFilter(error) {
      return !!error.response?.status && error.response.status.toString().startsWith("4");
    }
    function circuitBreakerKeyBuilder({ uri, tenantId = "tenant_id" }) {
      return `${uri}::${tenantId}`;
    }
    function circuitBreaker() {
      return circuitBreakerGeneric(circuitBreakerKeyBuilder, httpErrorFilter);
    }
    function circuitBreakerGeneric(keyBuilder, errorFilter) {
      return (options) => (fnArgument) => getCircuitBreaker(keyBuilder(options.context), errorFilter).fire(options.fn, fnArgument);
    }
    function getCircuitBreaker(key, errorFilter) {
      if (!exports2.circuitBreakers[key]) {
        exports2.circuitBreakers[key] = new opossum_1.default(executeFunction, {
          ...exports2.circuitBreakerDefaultOptions,
          errorFilter
        });
      }
      return exports2.circuitBreakers[key];
    }
    function executeFunction(fn, ...parameters) {
      return fn(...parameters);
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/resilience/dist/resilience.js
var require_resilience = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/resilience/dist/resilience.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resilience = resilience;
    var timeout_1 = require_timeout();
    var retry_1 = require_retry3();
    var circuit_breaker_1 = require_circuit_breaker();
    var defaultResilienceOptions = {
      retry: false,
      timeout: true,
      circuitBreaker: true
    };
    function resilience(options) {
      const resilienceOption = { ...defaultResilienceOptions, ...options };
      const middlewares = [];
      if (typeof resilienceOption.retry === "number") {
        middlewares.push((0, retry_1.retry)(resilienceOption.retry));
      } else if (resilienceOption.retry) {
        middlewares.push((0, retry_1.retry)());
      }
      if (resilienceOption.circuitBreaker) {
        middlewares.push((0, circuit_breaker_1.circuitBreaker)());
      }
      if (typeof resilienceOption.timeout === "number") {
        middlewares.push((0, timeout_1.timeout)(resilienceOption.timeout));
      } else if (resilienceOption.timeout) {
        middlewares.push((0, timeout_1.timeout)());
      }
      return middlewares;
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/resilience/dist/internal.js
var require_internal = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/resilience/dist/internal.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_timeout(), exports2);
    __exportStar(require_retry3(), exports2);
    __exportStar(require_middleware(), exports2);
    __exportStar(require_circuit_breaker(), exports2);
    __exportStar(require_resilience(), exports2);
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/resilience/internal.js
var require_internal2 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/resilience/internal.js"(exports2) {
    "use strict";
    function __export2(m) {
      for (const p in m) {
        if (!exports2.hasOwnProperty(p)) {
          exports2[p] = m[p];
        }
      }
    }
    Object.defineProperty(exports2, "__esModule", { value: true });
    __export2(require_internal());
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/http-client/dist/csrf-token-middleware.js
var require_csrf_token_middleware = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/http-client/dist/csrf-token-middleware.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.csrf = csrf;
    exports2.buildCsrfFetchHeaders = buildCsrfFetchHeaders;
    var util_1 = require_dist2();
    var axios_1 = __importDefault(require_axios());
    var internal_1 = require_internal2();
    var logger8 = (0, util_1.createLogger)("csrf-middleware");
    function csrf(options) {
      return (middlewareOptions) => async (requestConfig) => {
        if (!needsCsrfToken(requestConfig)) {
          return middlewareOptions.fn(requestConfig);
        }
        const csrfToken = await makeCsrfRequests(requestConfig, {
          ...options,
          ...middlewareOptions
        });
        if (csrfToken?.cookie) {
          csrfToken.cookie = requestConfig.headers?.cookie ? [requestConfig.headers?.cookie, csrfToken?.cookie].join(";") : csrfToken?.cookie;
        }
        requestConfig.headers = { ...requestConfig.headers, ...csrfToken };
        return middlewareOptions.fn(requestConfig);
      };
    }
    function needsCsrfToken(requestConfig) {
      if (requestConfig.method.toLowerCase() === "get") {
        logger8.debug("Method is GET no CSRF token needed.");
        return false;
      }
      if ((0, util_1.pickValueIgnoreCase)(requestConfig.headers, "x-csrf-token")) {
        logger8.debug("CSRF token header was already provided. Existing token used.");
        return false;
      }
      return true;
    }
    function appendSlash(requestConfig) {
      if (!requestConfig.url) {
        requestConfig.url = "/";
      } else if (!requestConfig.url.endsWith("/")) {
        requestConfig.url = `${requestConfig.url}/`;
      }
      return requestConfig;
    }
    function removeSlash(requestConfig) {
      if (requestConfig.url.endsWith("/")) {
        requestConfig.url = (0, util_1.removeTrailingSlashes)(requestConfig.url);
      }
      return requestConfig;
    }
    function getCsrfToken(headers) {
      return Object.values((0, util_1.pickIgnoreCase)(headers, "x-csrf-token"))[0];
    }
    function getSetCookieHeader(headers) {
      const cookies = Object.values((0, util_1.pickIgnoreCase)(headers, "set-cookie"));
      return (0, util_1.flatten)(cookies).map((cookie) => cookie.split(";")[0]).join(";");
    }
    function buildCsrfFetchHeaders(headers) {
      const contentLengthHeaderKey = (0, util_1.first)(Object.keys((0, util_1.pickIgnoreCase)(headers, "content-length"))) || "content-length";
      return {
        "x-csrf-token": "Fetch",
        ...headers,
        [contentLengthHeaderKey]: 0
      };
    }
    async function makeCsrfRequest(requestConfig, options) {
      try {
        const response = await (0, internal_1.executeWithMiddleware)(options.middleware, {
          fn: axios_1.default.request,
          fnArgument: requestConfig,
          context: options.context
        });
        return findCsrfHeader(response.headers);
      } catch (error) {
        if (findCsrfHeader(error.response?.headers)) {
          return findCsrfHeader(error.response?.headers);
        }
        logger8.warn(new util_1.ErrorWithCause(`Failed to get CSRF token from  URL: ${requestConfig.url}.`, error));
      }
    }
    function findCsrfHeader(headers) {
      if (!headers) {
        return;
      }
      const csrfHeader = getCsrfToken(headers);
      if (!csrfHeader) {
        return;
      }
      const cookieHeader = getSetCookieHeader(headers) ? { cookie: getSetCookieHeader(headers) } : {};
      return { "x-csrf-token": csrfHeader, ...cookieHeader };
    }
    async function makeCsrfRequests(requestConfig, options) {
      const { data, params, parameterEncoder, ...requestConfigWithoutData } = requestConfig;
      const axiosConfig = {
        ...requestConfigWithoutData,
        method: options.method || "head",
        url: options.url || requestConfig.url,
        headers: buildCsrfFetchHeaders(requestConfig.headers)
      };
      if (options.url) {
        return makeCsrfRequest(axiosConfig, options);
      }
      return await makeCsrfRequest(appendSlash(axiosConfig), options) ?? await makeCsrfRequest(removeSlash(axiosConfig), options);
    }
  }
});

// node_modules/jws/lib/data-stream.js
var require_data_stream = __commonJS({
  "node_modules/jws/lib/data-stream.js"(exports2, module2) {
    var Buffer2 = require_safe_buffer().Buffer;
    var Stream = require("stream");
    var util = require("util");
    function DataStream(data) {
      this.buffer = null;
      this.writable = true;
      this.readable = true;
      if (!data) {
        this.buffer = Buffer2.alloc(0);
        return this;
      }
      if (typeof data.pipe === "function") {
        this.buffer = Buffer2.alloc(0);
        data.pipe(this);
        return this;
      }
      if (data.length || typeof data === "object") {
        this.buffer = data;
        this.writable = false;
        process.nextTick(function() {
          this.emit("end", data);
          this.readable = false;
          this.emit("close");
        }.bind(this));
        return this;
      }
      throw new TypeError("Unexpected data type (" + typeof data + ")");
    }
    util.inherits(DataStream, Stream);
    DataStream.prototype.write = function write(data) {
      this.buffer = Buffer2.concat([this.buffer, Buffer2.from(data)]);
      this.emit("data", data);
    };
    DataStream.prototype.end = function end(data) {
      if (data)
        this.write(data);
      this.emit("end", data);
      this.emit("close");
      this.writable = false;
      this.readable = false;
    };
    module2.exports = DataStream;
  }
});

// node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js
var require_param_bytes_for_alg = __commonJS({
  "node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js"(exports2, module2) {
    "use strict";
    function getParamSize(keySize) {
      var result = (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);
      return result;
    }
    var paramBytesForAlg = {
      ES256: getParamSize(256),
      ES384: getParamSize(384),
      ES512: getParamSize(521)
    };
    function getParamBytesForAlg(alg) {
      var paramBytes = paramBytesForAlg[alg];
      if (paramBytes) {
        return paramBytes;
      }
      throw new Error('Unknown algorithm "' + alg + '"');
    }
    module2.exports = getParamBytesForAlg;
  }
});

// node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js
var require_ecdsa_sig_formatter = __commonJS({
  "node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var getParamBytesForAlg = require_param_bytes_for_alg();
    var MAX_OCTET = 128;
    var CLASS_UNIVERSAL = 0;
    var PRIMITIVE_BIT = 32;
    var TAG_SEQ = 16;
    var TAG_INT = 2;
    var ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6;
    var ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
    function base64Url(base642) {
      return base642.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function signatureAsBuffer(signature) {
      if (Buffer2.isBuffer(signature)) {
        return signature;
      } else if ("string" === typeof signature) {
        return Buffer2.from(signature, "base64");
      }
      throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
    }
    function derToJose(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var maxEncodedParamLength = paramBytes + 1;
      var inputLength = signature.length;
      var offset = 0;
      if (signature[offset++] !== ENCODED_TAG_SEQ) {
        throw new Error('Could not find expected "seq"');
      }
      var seqLength = signature[offset++];
      if (seqLength === (MAX_OCTET | 1)) {
        seqLength = signature[offset++];
      }
      if (inputLength - offset < seqLength) {
        throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
      }
      if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "r"');
      }
      var rLength = signature[offset++];
      if (inputLength - offset - 2 < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
      }
      if (maxEncodedParamLength < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
      }
      var rOffset = offset;
      offset += rLength;
      if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "s"');
      }
      var sLength = signature[offset++];
      if (inputLength - offset !== sLength) {
        throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
      }
      if (maxEncodedParamLength < sLength) {
        throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
      }
      var sOffset = offset;
      offset += sLength;
      if (offset !== inputLength) {
        throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
      }
      var rPadding = paramBytes - rLength, sPadding = paramBytes - sLength;
      var dst = Buffer2.allocUnsafe(rPadding + rLength + sPadding + sLength);
      for (offset = 0; offset < rPadding; ++offset) {
        dst[offset] = 0;
      }
      signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);
      offset = paramBytes;
      for (var o = offset; offset < o + sPadding; ++offset) {
        dst[offset] = 0;
      }
      signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);
      dst = dst.toString("base64");
      dst = base64Url(dst);
      return dst;
    }
    function countPadding(buf, start, stop) {
      var padding = 0;
      while (start + padding < stop && buf[start + padding] === 0) {
        ++padding;
      }
      var needsSign = buf[start + padding] >= MAX_OCTET;
      if (needsSign) {
        --padding;
      }
      return padding;
    }
    function joseToDer(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var signatureBytes = signature.length;
      if (signatureBytes !== paramBytes * 2) {
        throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
      }
      var rPadding = countPadding(signature, 0, paramBytes);
      var sPadding = countPadding(signature, paramBytes, signature.length);
      var rLength = paramBytes - rPadding;
      var sLength = paramBytes - sPadding;
      var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
      var shortLength = rsBytes < MAX_OCTET;
      var dst = Buffer2.allocUnsafe((shortLength ? 2 : 3) + rsBytes);
      var offset = 0;
      dst[offset++] = ENCODED_TAG_SEQ;
      if (shortLength) {
        dst[offset++] = rsBytes;
      } else {
        dst[offset++] = MAX_OCTET | 1;
        dst[offset++] = rsBytes & 255;
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = rLength;
      if (rPadding < 0) {
        dst[offset++] = 0;
        offset += signature.copy(dst, offset, 0, paramBytes);
      } else {
        offset += signature.copy(dst, offset, rPadding, paramBytes);
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = sLength;
      if (sPadding < 0) {
        dst[offset++] = 0;
        signature.copy(dst, offset, paramBytes);
      } else {
        signature.copy(dst, offset, paramBytes + sPadding);
      }
      return dst;
    }
    module2.exports = {
      derToJose,
      joseToDer
    };
  }
});

// node_modules/buffer-equal-constant-time/index.js
var require_buffer_equal_constant_time = __commonJS({
  "node_modules/buffer-equal-constant-time/index.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require("buffer").Buffer;
    var SlowBuffer = require("buffer").SlowBuffer;
    module2.exports = bufferEq;
    function bufferEq(a, b) {
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        return false;
      }
      if (a.length !== b.length) {
        return false;
      }
      var c = 0;
      for (var i = 0; i < a.length; i++) {
        c |= a[i] ^ b[i];
      }
      return c === 0;
    }
    bufferEq.install = function() {
      Buffer2.prototype.equal = SlowBuffer.prototype.equal = function equal(that) {
        return bufferEq(this, that);
      };
    };
    var origBufEqual = Buffer2.prototype.equal;
    var origSlowBufEqual = SlowBuffer.prototype.equal;
    bufferEq.restore = function() {
      Buffer2.prototype.equal = origBufEqual;
      SlowBuffer.prototype.equal = origSlowBufEqual;
    };
  }
});

// node_modules/jwa/index.js
var require_jwa = __commonJS({
  "node_modules/jwa/index.js"(exports2, module2) {
    var Buffer2 = require_safe_buffer().Buffer;
    var crypto6 = require("crypto");
    var formatEcdsa = require_ecdsa_sig_formatter();
    var util = require("util");
    var MSG_INVALID_ALGORITHM = '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".';
    var MSG_INVALID_SECRET = "secret must be a string or buffer";
    var MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer";
    var MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object";
    var supportsKeyObjects = typeof crypto6.createPublicKey === "function";
    if (supportsKeyObjects) {
      MSG_INVALID_VERIFIER_KEY += " or a KeyObject";
      MSG_INVALID_SECRET += "or a KeyObject";
    }
    function checkIsPublicKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key !== "object") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.type !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.asymmetricKeyType !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
    }
    function checkIsPrivateKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return;
      }
      if (typeof key === "object") {
        return;
      }
      throw typeError(MSG_INVALID_SIGNER_KEY);
    }
    function checkIsSecretKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return key;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key !== "object") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (key.type !== "secret") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_SECRET);
      }
    }
    function fromBase64(base642) {
      return base642.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function toBase64(base64url) {
      base64url = base64url.toString();
      var padding = 4 - base64url.length % 4;
      if (padding !== 4) {
        for (var i = 0; i < padding; ++i) {
          base64url += "=";
        }
      }
      return base64url.replace(/\-/g, "+").replace(/_/g, "/");
    }
    function typeError(template) {
      var args = [].slice.call(arguments, 1);
      var errMsg = util.format.bind(util, template).apply(null, args);
      return new TypeError(errMsg);
    }
    function bufferOrString(obj) {
      return Buffer2.isBuffer(obj) || typeof obj === "string";
    }
    function normalizeInput(thing) {
      if (!bufferOrString(thing))
        thing = JSON.stringify(thing);
      return thing;
    }
    function createHmacSigner(bits) {
      return function sign(thing, secret) {
        checkIsSecretKey(secret);
        thing = normalizeInput(thing);
        var hmac = crypto6.createHmac("sha" + bits, secret);
        var sig = (hmac.update(thing), hmac.digest("base64"));
        return fromBase64(sig);
      };
    }
    var bufferEqual;
    var timingSafeEqual = "timingSafeEqual" in crypto6 ? function timingSafeEqual2(a, b) {
      if (a.byteLength !== b.byteLength) {
        return false;
      }
      return crypto6.timingSafeEqual(a, b);
    } : function timingSafeEqual2(a, b) {
      if (!bufferEqual) {
        bufferEqual = require_buffer_equal_constant_time();
      }
      return bufferEqual(a, b);
    };
    function createHmacVerifier(bits) {
      return function verify(thing, signature, secret) {
        var computedSig = createHmacSigner(bits)(thing, secret);
        return timingSafeEqual(Buffer2.from(signature), Buffer2.from(computedSig));
      };
    }
    function createKeySigner(bits) {
      return function sign(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto6.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign(privateKey, "base64"));
        return fromBase64(sig);
      };
    }
    function createKeyVerifier(bits) {
      return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto6.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify(publicKey, signature, "base64");
      };
    }
    function createPSSKeySigner(bits) {
      return function sign(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto6.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign({
          key: privateKey,
          padding: crypto6.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto6.constants.RSA_PSS_SALTLEN_DIGEST
        }, "base64"));
        return fromBase64(sig);
      };
    }
    function createPSSKeyVerifier(bits) {
      return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto6.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify({
          key: publicKey,
          padding: crypto6.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto6.constants.RSA_PSS_SALTLEN_DIGEST
        }, signature, "base64");
      };
    }
    function createECDSASigner(bits) {
      var inner = createKeySigner(bits);
      return function sign() {
        var signature = inner.apply(null, arguments);
        signature = formatEcdsa.derToJose(signature, "ES" + bits);
        return signature;
      };
    }
    function createECDSAVerifer(bits) {
      var inner = createKeyVerifier(bits);
      return function verify(thing, signature, publicKey) {
        signature = formatEcdsa.joseToDer(signature, "ES" + bits).toString("base64");
        var result = inner(thing, signature, publicKey);
        return result;
      };
    }
    function createNoneSigner() {
      return function sign() {
        return "";
      };
    }
    function createNoneVerifier() {
      return function verify(thing, signature) {
        return signature === "";
      };
    }
    module2.exports = function jwa(algorithm) {
      var signerFactories = {
        hs: createHmacSigner,
        rs: createKeySigner,
        ps: createPSSKeySigner,
        es: createECDSASigner,
        none: createNoneSigner
      };
      var verifierFactories = {
        hs: createHmacVerifier,
        rs: createKeyVerifier,
        ps: createPSSKeyVerifier,
        es: createECDSAVerifer,
        none: createNoneVerifier
      };
      var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);
      if (!match)
        throw typeError(MSG_INVALID_ALGORITHM, algorithm);
      var algo = (match[1] || match[3]).toLowerCase();
      var bits = match[2];
      return {
        sign: signerFactories[algo](bits),
        verify: verifierFactories[algo](bits)
      };
    };
  }
});

// node_modules/jws/lib/tostring.js
var require_tostring = __commonJS({
  "node_modules/jws/lib/tostring.js"(exports2, module2) {
    var Buffer2 = require("buffer").Buffer;
    module2.exports = function toString(obj) {
      if (typeof obj === "string")
        return obj;
      if (typeof obj === "number" || Buffer2.isBuffer(obj))
        return obj.toString();
      return JSON.stringify(obj);
    };
  }
});

// node_modules/jws/lib/sign-stream.js
var require_sign_stream = __commonJS({
  "node_modules/jws/lib/sign-stream.js"(exports2, module2) {
    var Buffer2 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream = require("stream");
    var toString = require_tostring();
    var util = require("util");
    function base64url(string, encoding) {
      return Buffer2.from(string, encoding).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function jwsSecuredInput(header, payload, encoding) {
      encoding = encoding || "utf8";
      var encodedHeader = base64url(toString(header), "binary");
      var encodedPayload = base64url(toString(payload), encoding);
      return util.format("%s.%s", encodedHeader, encodedPayload);
    }
    function jwsSign(opts) {
      var header = opts.header;
      var payload = opts.payload;
      var secretOrKey = opts.secret || opts.privateKey;
      var encoding = opts.encoding;
      var algo = jwa(header.alg);
      var securedInput = jwsSecuredInput(header, payload, encoding);
      var signature = algo.sign(securedInput, secretOrKey);
      return util.format("%s.%s", securedInput, signature);
    }
    function SignStream(opts) {
      var secret = opts.secret || opts.privateKey || opts.key;
      var secretStream = new DataStream(secret);
      this.readable = true;
      this.header = opts.header;
      this.encoding = opts.encoding;
      this.secret = this.privateKey = this.key = secretStream;
      this.payload = new DataStream(opts.payload);
      this.secret.once("close", function() {
        if (!this.payload.writable && this.readable)
          this.sign();
      }.bind(this));
      this.payload.once("close", function() {
        if (!this.secret.writable && this.readable)
          this.sign();
      }.bind(this));
    }
    util.inherits(SignStream, Stream);
    SignStream.prototype.sign = function sign() {
      try {
        var signature = jwsSign({
          header: this.header,
          payload: this.payload.buffer,
          secret: this.secret.buffer,
          encoding: this.encoding
        });
        this.emit("done", signature);
        this.emit("data", signature);
        this.emit("end");
        this.readable = false;
        return signature;
      } catch (e) {
        this.readable = false;
        this.emit("error", e);
        this.emit("close");
      }
    };
    SignStream.sign = jwsSign;
    module2.exports = SignStream;
  }
});

// node_modules/jws/lib/verify-stream.js
var require_verify_stream = __commonJS({
  "node_modules/jws/lib/verify-stream.js"(exports2, module2) {
    var Buffer2 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream = require("stream");
    var toString = require_tostring();
    var util = require("util");
    var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
    function isObject(thing) {
      return Object.prototype.toString.call(thing) === "[object Object]";
    }
    function safeJsonParse(thing) {
      if (isObject(thing))
        return thing;
      try {
        return JSON.parse(thing);
      } catch (e) {
        return void 0;
      }
    }
    function headerFromJWS(jwsSig) {
      var encodedHeader = jwsSig.split(".", 1)[0];
      return safeJsonParse(Buffer2.from(encodedHeader, "base64").toString("binary"));
    }
    function securedInputFromJWS(jwsSig) {
      return jwsSig.split(".", 2).join(".");
    }
    function signatureFromJWS(jwsSig) {
      return jwsSig.split(".")[2];
    }
    function payloadFromJWS(jwsSig, encoding) {
      encoding = encoding || "utf8";
      var payload = jwsSig.split(".")[1];
      return Buffer2.from(payload, "base64").toString(encoding);
    }
    function isValidJws(string) {
      return JWS_REGEX.test(string) && !!headerFromJWS(string);
    }
    function jwsVerify(jwsSig, algorithm, secretOrKey) {
      if (!algorithm) {
        var err = new Error("Missing algorithm parameter for jws.verify");
        err.code = "MISSING_ALGORITHM";
        throw err;
      }
      jwsSig = toString(jwsSig);
      var signature = signatureFromJWS(jwsSig);
      var securedInput = securedInputFromJWS(jwsSig);
      var algo = jwa(algorithm);
      return algo.verify(securedInput, signature, secretOrKey);
    }
    function jwsDecode(jwsSig, opts) {
      opts = opts || {};
      jwsSig = toString(jwsSig);
      if (!isValidJws(jwsSig))
        return null;
      var header = headerFromJWS(jwsSig);
      if (!header)
        return null;
      var payload = payloadFromJWS(jwsSig);
      if (header.typ === "JWT" || opts.json)
        payload = JSON.parse(payload, opts.encoding);
      return {
        header,
        payload,
        signature: signatureFromJWS(jwsSig)
      };
    }
    function VerifyStream(opts) {
      opts = opts || {};
      var secretOrKey = opts.secret || opts.publicKey || opts.key;
      var secretStream = new DataStream(secretOrKey);
      this.readable = true;
      this.algorithm = opts.algorithm;
      this.encoding = opts.encoding;
      this.secret = this.publicKey = this.key = secretStream;
      this.signature = new DataStream(opts.signature);
      this.secret.once("close", function() {
        if (!this.signature.writable && this.readable)
          this.verify();
      }.bind(this));
      this.signature.once("close", function() {
        if (!this.secret.writable && this.readable)
          this.verify();
      }.bind(this));
    }
    util.inherits(VerifyStream, Stream);
    VerifyStream.prototype.verify = function verify() {
      try {
        var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
        var obj = jwsDecode(this.signature.buffer, this.encoding);
        this.emit("done", valid, obj);
        this.emit("data", valid);
        this.emit("end");
        this.readable = false;
        return valid;
      } catch (e) {
        this.readable = false;
        this.emit("error", e);
        this.emit("close");
      }
    };
    VerifyStream.decode = jwsDecode;
    VerifyStream.isValid = isValidJws;
    VerifyStream.verify = jwsVerify;
    module2.exports = VerifyStream;
  }
});

// node_modules/jws/index.js
var require_jws = __commonJS({
  "node_modules/jws/index.js"(exports2) {
    var SignStream = require_sign_stream();
    var VerifyStream = require_verify_stream();
    var ALGORITHMS = [
      "HS256",
      "HS384",
      "HS512",
      "RS256",
      "RS384",
      "RS512",
      "PS256",
      "PS384",
      "PS512",
      "ES256",
      "ES384",
      "ES512"
    ];
    exports2.ALGORITHMS = ALGORITHMS;
    exports2.sign = SignStream.sign;
    exports2.verify = VerifyStream.verify;
    exports2.decode = VerifyStream.decode;
    exports2.isValid = VerifyStream.isValid;
    exports2.createSign = function createSign(opts) {
      return new SignStream(opts);
    };
    exports2.createVerify = function createVerify(opts) {
      return new VerifyStream(opts);
    };
  }
});

// node_modules/jsonwebtoken/decode.js
var require_decode = __commonJS({
  "node_modules/jsonwebtoken/decode.js"(exports2, module2) {
    var jws = require_jws();
    module2.exports = function(jwt, options) {
      options = options || {};
      var decoded = jws.decode(jwt, options);
      if (!decoded) {
        return null;
      }
      var payload = decoded.payload;
      if (typeof payload === "string") {
        try {
          var obj = JSON.parse(payload);
          if (obj !== null && typeof obj === "object") {
            payload = obj;
          }
        } catch (e) {
        }
      }
      if (options.complete === true) {
        return {
          header: decoded.header,
          payload,
          signature: decoded.signature
        };
      }
      return payload;
    };
  }
});

// node_modules/jsonwebtoken/lib/JsonWebTokenError.js
var require_JsonWebTokenError = __commonJS({
  "node_modules/jsonwebtoken/lib/JsonWebTokenError.js"(exports2, module2) {
    var JsonWebTokenError = function(message, error) {
      Error.call(this, message);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
      this.name = "JsonWebTokenError";
      this.message = message;
      if (error) this.inner = error;
    };
    JsonWebTokenError.prototype = Object.create(Error.prototype);
    JsonWebTokenError.prototype.constructor = JsonWebTokenError;
    module2.exports = JsonWebTokenError;
  }
});

// node_modules/jsonwebtoken/lib/NotBeforeError.js
var require_NotBeforeError = __commonJS({
  "node_modules/jsonwebtoken/lib/NotBeforeError.js"(exports2, module2) {
    var JsonWebTokenError = require_JsonWebTokenError();
    var NotBeforeError = function(message, date) {
      JsonWebTokenError.call(this, message);
      this.name = "NotBeforeError";
      this.date = date;
    };
    NotBeforeError.prototype = Object.create(JsonWebTokenError.prototype);
    NotBeforeError.prototype.constructor = NotBeforeError;
    module2.exports = NotBeforeError;
  }
});

// node_modules/jsonwebtoken/lib/TokenExpiredError.js
var require_TokenExpiredError = __commonJS({
  "node_modules/jsonwebtoken/lib/TokenExpiredError.js"(exports2, module2) {
    var JsonWebTokenError = require_JsonWebTokenError();
    var TokenExpiredError = function(message, expiredAt) {
      JsonWebTokenError.call(this, message);
      this.name = "TokenExpiredError";
      this.expiredAt = expiredAt;
    };
    TokenExpiredError.prototype = Object.create(JsonWebTokenError.prototype);
    TokenExpiredError.prototype.constructor = TokenExpiredError;
    module2.exports = TokenExpiredError;
  }
});

// node_modules/jsonwebtoken/lib/timespan.js
var require_timespan = __commonJS({
  "node_modules/jsonwebtoken/lib/timespan.js"(exports2, module2) {
    var ms = require_ms();
    module2.exports = function(time, iat) {
      var timestamp = iat || Math.floor(Date.now() / 1e3);
      if (typeof time === "string") {
        var milliseconds = ms(time);
        if (typeof milliseconds === "undefined") {
          return;
        }
        return Math.floor(timestamp + milliseconds / 1e3);
      } else if (typeof time === "number") {
        return timestamp + time;
      } else {
        return;
      }
    };
  }
});

// node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/semver/internal/constants.js"(exports2, module2) {
    "use strict";
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module2.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/semver/internal/debug.js
var require_debug2 = __commonJS({
  "node_modules/semver/internal/debug.js"(exports2, module2) {
    "use strict";
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
});

// node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/semver/internal/re.js"(exports2, module2) {
    "use strict";
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug = require_debug2();
    exports2 = module2.exports = {};
    var re = exports2.re = [];
    var safeRe = exports2.safeRe = [];
    var src = exports2.src = [];
    var safeSrc = exports2.safeSrc = [];
    var t = exports2.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug(name, index, value);
      t[name] = index;
      src[index] = value;
      safeSrc[index] = safe;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("COERCERTLFULL", src[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/semver/internal/parse-options.js"(exports2, module2) {
    "use strict";
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module2.exports = parseOptions;
  }
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/semver/internal/identifiers.js"(exports2, module2) {
    "use strict";
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/semver/classes/semver.js"(exports2, module2) {
    "use strict";
    var debug = require_debug2();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { safeRe: re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version, options) {
        options = parseOptions(options);
        if (version instanceof _SemVer) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("build compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        if (release.startsWith("pre")) {
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (identifier) {
            const match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]);
            if (!match || match[1] !== identifier) {
              throw new Error(`invalid identifier: ${identifier}`);
            }
          }
        }
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "release":
            if (this.prerelease.length === 0) {
              throw new Error(`version ${this.raw} is not a prerelease`);
            }
            this.prerelease.length = 0;
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/semver/functions/parse.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var parse2 = (version, options, throwErrors = false) => {
      if (version instanceof SemVer) {
        return version;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module2.exports = parse2;
  }
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/semver/functions/valid.js"(exports2, module2) {
    "use strict";
    var parse2 = require_parse();
    var valid = (version, options) => {
      const v = parse2(version, options);
      return v ? v.version : null;
    };
    module2.exports = valid;
  }
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/semver/functions/clean.js"(exports2, module2) {
    "use strict";
    var parse2 = require_parse();
    var clean = (version, options) => {
      const s = parse2(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module2.exports = clean;
  }
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/semver/functions/inc.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var inc = (version, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version instanceof SemVer ? version.version : version,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/semver/functions/diff.js"(exports2, module2) {
    "use strict";
    var parse2 = require_parse();
    var diff = (version1, version2) => {
      const v1 = parse2(version1, null, true);
      const v2 = parse2(version2, null, true);
      const comparison = v1.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v2;
      const lowVersion = v1Higher ? v2 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (lowVersion.compareMain(highVersion) === 0) {
          if (lowVersion.minor && !lowVersion.patch) {
            return "minor";
          }
          return "patch";
        }
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v2.major) {
        return prefix + "major";
      }
      if (v1.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module2.exports = diff;
  }
});

// node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/semver/functions/major.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module2.exports = major;
  }
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/semver/functions/minor.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module2.exports = minor;
  }
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/semver/functions/patch.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module2.exports = patch;
  }
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/semver/functions/prerelease.js"(exports2, module2) {
    "use strict";
    var parse2 = require_parse();
    var prerelease = (version, options) => {
      const parsed = parse2(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/semver/functions/compare.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare;
  }
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/semver/functions/rcompare.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module2.exports = rcompare;
  }
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/semver/functions/compare-loose.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module2.exports = compareLoose;
  }
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/semver/functions/compare-build.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/semver/functions/sort.js"(exports2, module2) {
    "use strict";
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module2.exports = sort;
  }
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/semver/functions/rsort.js"(exports2, module2) {
    "use strict";
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module2.exports = rsort;
  }
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/semver/functions/gt.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module2.exports = gt;
  }
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/semver/functions/lt.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module2.exports = lt;
  }
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/semver/functions/eq.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module2.exports = eq;
  }
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/semver/functions/neq.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module2.exports = neq;
  }
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/semver/functions/gte.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module2.exports = gte;
  }
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/semver/functions/lte.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module2.exports = lte;
  }
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/semver/functions/cmp.js"(exports2, module2) {
    "use strict";
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/semver/functions/coerce.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var parse2 = require_parse();
    var { safeRe: re, t } = require_re();
    var coerce = (version, options) => {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major = match[2];
      const minor = match[3] || "0";
      const patch = match[4] || "0";
      const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
      const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
      return parse2(`${major}.${minor}.${patch}${prerelease}${build}`, options);
    };
    module2.exports = coerce;
  }
});

// node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  "node_modules/semver/internal/lrucache.js"(exports2, module2) {
    "use strict";
    var LRUCache = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module2.exports = LRUCache;
  }
});

// node_modules/semver/classes/range.js
var require_range2 = __commonJS({
  "node_modules/semver/classes/range.js"(exports2, module2) {
    "use strict";
    var SPACE_CHARACTERS = /\s+/g;
    var Range = class _Range {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i = 0; i < this.set.length; i++) {
            if (i > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i];
            for (let k = 0; k < comps.length; k++) {
              if (k > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version) {
        if (!version) {
          return false;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range;
    var LRU = require_lrucache();
    var cache = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug2();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/semver/classes/comparator.js"(exports2, module2) {
    "use strict";
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version) {
        debug("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
          return true;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug2();
    var SemVer = require_semver();
    var Range = require_range2();
  }
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/semver/functions/satisfies.js"(exports2, module2) {
    "use strict";
    var Range = require_range2();
    var satisfies = (version, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    };
    module2.exports = satisfies;
  }
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/semver/ranges/to-comparators.js"(exports2, module2) {
    "use strict";
    var Range = require_range2();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/semver/ranges/max-satisfying.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range2();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/semver/ranges/min-satisfying.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range2();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/semver/ranges/min-version.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range2();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/semver/ranges/valid.js"(exports2, module2) {
    "use strict";
    var Range = require_range2();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/semver/ranges/outside.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range2();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version, range, hilo, options) => {
      version = new SemVer(version, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/semver/ranges/gtr.js"(exports2, module2) {
    "use strict";
    var outside = require_outside();
    var gtr = (version, range, options) => outside(version, range, ">", options);
    module2.exports = gtr;
  }
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/semver/ranges/ltr.js"(exports2, module2) {
    "use strict";
    var outside = require_outside();
    var ltr = (version, range, options) => outside(version, range, "<", options);
    module2.exports = ltr;
  }
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/semver/ranges/intersects.js"(exports2, module2) {
    "use strict";
    var Range = require_range2();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2, options);
    };
    module2.exports = intersects;
  }
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/semver/ranges/simplify.js"(exports2, module2) {
    "use strict";
    var satisfies = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions, range, options) => {
      const set = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options));
      for (const version of v) {
        const included = satisfies(version, range, options);
        if (included) {
          prev = version;
          if (!first) {
            first = version;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/semver/ranges/subset.js"(exports2, module2) {
    "use strict";
    var Range = require_range2();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER: for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt = higherGT(gt, c, options);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt = lowerLT(lt, c, options);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq, String(c), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module2.exports = subset;
  }
});

// node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/semver/index.js"(exports2, module2) {
    "use strict";
    var internalRe = require_re();
    var constants = require_constants();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse2 = require_parse();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range2();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module2.exports = {
      parse: parse2,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// node_modules/jsonwebtoken/lib/asymmetricKeyDetailsSupported.js
var require_asymmetricKeyDetailsSupported = __commonJS({
  "node_modules/jsonwebtoken/lib/asymmetricKeyDetailsSupported.js"(exports2, module2) {
    var semver = require_semver2();
    module2.exports = semver.satisfies(process.version, ">=15.7.0");
  }
});

// node_modules/jsonwebtoken/lib/rsaPssKeyDetailsSupported.js
var require_rsaPssKeyDetailsSupported = __commonJS({
  "node_modules/jsonwebtoken/lib/rsaPssKeyDetailsSupported.js"(exports2, module2) {
    var semver = require_semver2();
    module2.exports = semver.satisfies(process.version, ">=16.9.0");
  }
});

// node_modules/jsonwebtoken/lib/validateAsymmetricKey.js
var require_validateAsymmetricKey = __commonJS({
  "node_modules/jsonwebtoken/lib/validateAsymmetricKey.js"(exports2, module2) {
    var ASYMMETRIC_KEY_DETAILS_SUPPORTED = require_asymmetricKeyDetailsSupported();
    var RSA_PSS_KEY_DETAILS_SUPPORTED = require_rsaPssKeyDetailsSupported();
    var allowedAlgorithmsForKeys = {
      "ec": ["ES256", "ES384", "ES512"],
      "rsa": ["RS256", "PS256", "RS384", "PS384", "RS512", "PS512"],
      "rsa-pss": ["PS256", "PS384", "PS512"]
    };
    var allowedCurves = {
      ES256: "prime256v1",
      ES384: "secp384r1",
      ES512: "secp521r1"
    };
    module2.exports = function(algorithm, key) {
      if (!algorithm || !key) return;
      const keyType = key.asymmetricKeyType;
      if (!keyType) return;
      const allowedAlgorithms = allowedAlgorithmsForKeys[keyType];
      if (!allowedAlgorithms) {
        throw new Error(`Unknown key type "${keyType}".`);
      }
      if (!allowedAlgorithms.includes(algorithm)) {
        throw new Error(`"alg" parameter for "${keyType}" key type must be one of: ${allowedAlgorithms.join(", ")}.`);
      }
      if (ASYMMETRIC_KEY_DETAILS_SUPPORTED) {
        switch (keyType) {
          case "ec":
            const keyCurve = key.asymmetricKeyDetails.namedCurve;
            const allowedCurve = allowedCurves[algorithm];
            if (keyCurve !== allowedCurve) {
              throw new Error(`"alg" parameter "${algorithm}" requires curve "${allowedCurve}".`);
            }
            break;
          case "rsa-pss":
            if (RSA_PSS_KEY_DETAILS_SUPPORTED) {
              const length = parseInt(algorithm.slice(-3), 10);
              const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = key.asymmetricKeyDetails;
              if (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm) {
                throw new Error(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${algorithm}.`);
              }
              if (saltLength !== void 0 && saltLength > length >> 3) {
                throw new Error(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${algorithm}.`);
              }
            }
            break;
        }
      }
    };
  }
});

// node_modules/jsonwebtoken/lib/psSupported.js
var require_psSupported = __commonJS({
  "node_modules/jsonwebtoken/lib/psSupported.js"(exports2, module2) {
    var semver = require_semver2();
    module2.exports = semver.satisfies(process.version, "^6.12.0 || >=8.0.0");
  }
});

// node_modules/jsonwebtoken/verify.js
var require_verify = __commonJS({
  "node_modules/jsonwebtoken/verify.js"(exports2, module2) {
    var JsonWebTokenError = require_JsonWebTokenError();
    var NotBeforeError = require_NotBeforeError();
    var TokenExpiredError = require_TokenExpiredError();
    var decode = require_decode();
    var timespan = require_timespan();
    var validateAsymmetricKey = require_validateAsymmetricKey();
    var PS_SUPPORTED = require_psSupported();
    var jws = require_jws();
    var { KeyObject, createSecretKey, createPublicKey } = require("crypto");
    var PUB_KEY_ALGS = ["RS256", "RS384", "RS512"];
    var EC_KEY_ALGS = ["ES256", "ES384", "ES512"];
    var RSA_KEY_ALGS = ["RS256", "RS384", "RS512"];
    var HS_ALGS = ["HS256", "HS384", "HS512"];
    if (PS_SUPPORTED) {
      PUB_KEY_ALGS.splice(PUB_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
      RSA_KEY_ALGS.splice(RSA_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
    }
    module2.exports = function(jwtString, secretOrPublicKey, options, callback) {
      if (typeof options === "function" && !callback) {
        callback = options;
        options = {};
      }
      if (!options) {
        options = {};
      }
      options = Object.assign({}, options);
      let done;
      if (callback) {
        done = callback;
      } else {
        done = function(err, data) {
          if (err) throw err;
          return data;
        };
      }
      if (options.clockTimestamp && typeof options.clockTimestamp !== "number") {
        return done(new JsonWebTokenError("clockTimestamp must be a number"));
      }
      if (options.nonce !== void 0 && (typeof options.nonce !== "string" || options.nonce.trim() === "")) {
        return done(new JsonWebTokenError("nonce must be a non-empty string"));
      }
      if (options.allowInvalidAsymmetricKeyTypes !== void 0 && typeof options.allowInvalidAsymmetricKeyTypes !== "boolean") {
        return done(new JsonWebTokenError("allowInvalidAsymmetricKeyTypes must be a boolean"));
      }
      const clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1e3);
      if (!jwtString) {
        return done(new JsonWebTokenError("jwt must be provided"));
      }
      if (typeof jwtString !== "string") {
        return done(new JsonWebTokenError("jwt must be a string"));
      }
      const parts = jwtString.split(".");
      if (parts.length !== 3) {
        return done(new JsonWebTokenError("jwt malformed"));
      }
      let decodedToken;
      try {
        decodedToken = decode(jwtString, { complete: true });
      } catch (err) {
        return done(err);
      }
      if (!decodedToken) {
        return done(new JsonWebTokenError("invalid token"));
      }
      const header = decodedToken.header;
      let getSecret;
      if (typeof secretOrPublicKey === "function") {
        if (!callback) {
          return done(new JsonWebTokenError("verify must be called asynchronous if secret or public key is provided as a callback"));
        }
        getSecret = secretOrPublicKey;
      } else {
        getSecret = function(header2, secretCallback) {
          return secretCallback(null, secretOrPublicKey);
        };
      }
      return getSecret(header, function(err, secretOrPublicKey2) {
        if (err) {
          return done(new JsonWebTokenError("error in secret or public key callback: " + err.message));
        }
        const hasSignature = parts[2].trim() !== "";
        if (!hasSignature && secretOrPublicKey2) {
          return done(new JsonWebTokenError("jwt signature is required"));
        }
        if (hasSignature && !secretOrPublicKey2) {
          return done(new JsonWebTokenError("secret or public key must be provided"));
        }
        if (!hasSignature && !options.algorithms) {
          return done(new JsonWebTokenError('please specify "none" in "algorithms" to verify unsigned tokens'));
        }
        if (secretOrPublicKey2 != null && !(secretOrPublicKey2 instanceof KeyObject)) {
          try {
            secretOrPublicKey2 = createPublicKey(secretOrPublicKey2);
          } catch (_) {
            try {
              secretOrPublicKey2 = createSecretKey(typeof secretOrPublicKey2 === "string" ? Buffer.from(secretOrPublicKey2) : secretOrPublicKey2);
            } catch (_2) {
              return done(new JsonWebTokenError("secretOrPublicKey is not valid key material"));
            }
          }
        }
        if (!options.algorithms) {
          if (secretOrPublicKey2.type === "secret") {
            options.algorithms = HS_ALGS;
          } else if (["rsa", "rsa-pss"].includes(secretOrPublicKey2.asymmetricKeyType)) {
            options.algorithms = RSA_KEY_ALGS;
          } else if (secretOrPublicKey2.asymmetricKeyType === "ec") {
            options.algorithms = EC_KEY_ALGS;
          } else {
            options.algorithms = PUB_KEY_ALGS;
          }
        }
        if (options.algorithms.indexOf(decodedToken.header.alg) === -1) {
          return done(new JsonWebTokenError("invalid algorithm"));
        }
        if (header.alg.startsWith("HS") && secretOrPublicKey2.type !== "secret") {
          return done(new JsonWebTokenError(`secretOrPublicKey must be a symmetric key when using ${header.alg}`));
        } else if (/^(?:RS|PS|ES)/.test(header.alg) && secretOrPublicKey2.type !== "public") {
          return done(new JsonWebTokenError(`secretOrPublicKey must be an asymmetric key when using ${header.alg}`));
        }
        if (!options.allowInvalidAsymmetricKeyTypes) {
          try {
            validateAsymmetricKey(header.alg, secretOrPublicKey2);
          } catch (e) {
            return done(e);
          }
        }
        let valid;
        try {
          valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey2);
        } catch (e) {
          return done(e);
        }
        if (!valid) {
          return done(new JsonWebTokenError("invalid signature"));
        }
        const payload = decodedToken.payload;
        if (typeof payload.nbf !== "undefined" && !options.ignoreNotBefore) {
          if (typeof payload.nbf !== "number") {
            return done(new JsonWebTokenError("invalid nbf value"));
          }
          if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {
            return done(new NotBeforeError("jwt not active", new Date(payload.nbf * 1e3)));
          }
        }
        if (typeof payload.exp !== "undefined" && !options.ignoreExpiration) {
          if (typeof payload.exp !== "number") {
            return done(new JsonWebTokenError("invalid exp value"));
          }
          if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {
            return done(new TokenExpiredError("jwt expired", new Date(payload.exp * 1e3)));
          }
        }
        if (options.audience) {
          const audiences = Array.isArray(options.audience) ? options.audience : [options.audience];
          const target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];
          const match = target.some(function(targetAudience) {
            return audiences.some(function(audience) {
              return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;
            });
          });
          if (!match) {
            return done(new JsonWebTokenError("jwt audience invalid. expected: " + audiences.join(" or ")));
          }
        }
        if (options.issuer) {
          const invalid_issuer = typeof options.issuer === "string" && payload.iss !== options.issuer || Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1;
          if (invalid_issuer) {
            return done(new JsonWebTokenError("jwt issuer invalid. expected: " + options.issuer));
          }
        }
        if (options.subject) {
          if (payload.sub !== options.subject) {
            return done(new JsonWebTokenError("jwt subject invalid. expected: " + options.subject));
          }
        }
        if (options.jwtid) {
          if (payload.jti !== options.jwtid) {
            return done(new JsonWebTokenError("jwt jwtid invalid. expected: " + options.jwtid));
          }
        }
        if (options.nonce) {
          if (payload.nonce !== options.nonce) {
            return done(new JsonWebTokenError("jwt nonce invalid. expected: " + options.nonce));
          }
        }
        if (options.maxAge) {
          if (typeof payload.iat !== "number") {
            return done(new JsonWebTokenError("iat required when maxAge is specified"));
          }
          const maxAgeTimestamp = timespan(options.maxAge, payload.iat);
          if (typeof maxAgeTimestamp === "undefined") {
            return done(new JsonWebTokenError('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
          }
          if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {
            return done(new TokenExpiredError("maxAge exceeded", new Date(maxAgeTimestamp * 1e3)));
          }
        }
        if (options.complete === true) {
          const signature = decodedToken.signature;
          return done(null, {
            header,
            payload,
            signature
          });
        }
        return done(null, payload);
      });
    };
  }
});

// node_modules/lodash.includes/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.includes/index.js"(exports2, module2) {
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var freeParseInt = parseInt;
    function arrayMap(array, iteratee) {
      var index = -1, length = array ? array.length : 0, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeKeys = overArg(Object.keys, Object);
    var nativeMax = Math.max;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty2.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isString(value) {
      return typeof value == "string" || !isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function values(object) {
      return object ? baseValues(object, keys(object)) : [];
    }
    module2.exports = includes;
  }
});

// node_modules/lodash.isboolean/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.isboolean/index.js"(exports2, module2) {
    var boolTag = "[object Boolean]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isBoolean(value) {
      return value === true || value === false || isObjectLike(value) && objectToString.call(value) == boolTag;
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    module2.exports = isBoolean;
  }
});

// node_modules/lodash.isinteger/index.js
var require_lodash3 = __commonJS({
  "node_modules/lodash.isinteger/index.js"(exports2, module2) {
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isInteger2(value) {
      return typeof value == "number" && value == toInteger(value);
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = isInteger2;
  }
});

// node_modules/lodash.isnumber/index.js
var require_lodash4 = __commonJS({
  "node_modules/lodash.isnumber/index.js"(exports2, module2) {
    var numberTag = "[object Number]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isNumber(value) {
      return typeof value == "number" || isObjectLike(value) && objectToString.call(value) == numberTag;
    }
    module2.exports = isNumber;
  }
});

// node_modules/lodash.isplainobject/index.js
var require_lodash5 = __commonJS({
  "node_modules/lodash.isplainobject/index.js"(exports2, module2) {
    var objectTag = "[object Object]";
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    var objectToString = objectProto.toString;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    module2.exports = isPlainObject;
  }
});

// node_modules/lodash.isstring/index.js
var require_lodash6 = __commonJS({
  "node_modules/lodash.isstring/index.js"(exports2, module2) {
    var stringTag = "[object String]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var isArray = Array.isArray;
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isString(value) {
      return typeof value == "string" || !isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
    }
    module2.exports = isString;
  }
});

// node_modules/lodash.once/index.js
var require_lodash7 = __commonJS({
  "node_modules/lodash.once/index.js"(exports2, module2) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function before(n, func) {
      var result;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = void 0;
        }
        return result;
      };
    }
    function once(func) {
      return before(2, func);
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = once;
  }
});

// node_modules/jsonwebtoken/sign.js
var require_sign2 = __commonJS({
  "node_modules/jsonwebtoken/sign.js"(exports2, module2) {
    var timespan = require_timespan();
    var PS_SUPPORTED = require_psSupported();
    var validateAsymmetricKey = require_validateAsymmetricKey();
    var jws = require_jws();
    var includes = require_lodash();
    var isBoolean = require_lodash2();
    var isInteger2 = require_lodash3();
    var isNumber = require_lodash4();
    var isPlainObject = require_lodash5();
    var isString = require_lodash6();
    var once = require_lodash7();
    var { KeyObject, createSecretKey, createPrivateKey } = require("crypto");
    var SUPPORTED_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512", "HS256", "HS384", "HS512", "none"];
    if (PS_SUPPORTED) {
      SUPPORTED_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
    }
    var sign_options_schema = {
      expiresIn: { isValid: function(value) {
        return isInteger2(value) || isString(value) && value;
      }, message: '"expiresIn" should be a number of seconds or string representing a timespan' },
      notBefore: { isValid: function(value) {
        return isInteger2(value) || isString(value) && value;
      }, message: '"notBefore" should be a number of seconds or string representing a timespan' },
      audience: { isValid: function(value) {
        return isString(value) || Array.isArray(value);
      }, message: '"audience" must be a string or array' },
      algorithm: { isValid: includes.bind(null, SUPPORTED_ALGS), message: '"algorithm" must be a valid string enum value' },
      header: { isValid: isPlainObject, message: '"header" must be an object' },
      encoding: { isValid: isString, message: '"encoding" must be a string' },
      issuer: { isValid: isString, message: '"issuer" must be a string' },
      subject: { isValid: isString, message: '"subject" must be a string' },
      jwtid: { isValid: isString, message: '"jwtid" must be a string' },
      noTimestamp: { isValid: isBoolean, message: '"noTimestamp" must be a boolean' },
      keyid: { isValid: isString, message: '"keyid" must be a string' },
      mutatePayload: { isValid: isBoolean, message: '"mutatePayload" must be a boolean' },
      allowInsecureKeySizes: { isValid: isBoolean, message: '"allowInsecureKeySizes" must be a boolean' },
      allowInvalidAsymmetricKeyTypes: { isValid: isBoolean, message: '"allowInvalidAsymmetricKeyTypes" must be a boolean' }
    };
    var registered_claims_schema = {
      iat: { isValid: isNumber, message: '"iat" should be a number of seconds' },
      exp: { isValid: isNumber, message: '"exp" should be a number of seconds' },
      nbf: { isValid: isNumber, message: '"nbf" should be a number of seconds' }
    };
    function validate3(schema, allowUnknown, object, parameterName) {
      if (!isPlainObject(object)) {
        throw new Error('Expected "' + parameterName + '" to be a plain object.');
      }
      Object.keys(object).forEach(function(key) {
        const validator2 = schema[key];
        if (!validator2) {
          if (!allowUnknown) {
            throw new Error('"' + key + '" is not allowed in "' + parameterName + '"');
          }
          return;
        }
        if (!validator2.isValid(object[key])) {
          throw new Error(validator2.message);
        }
      });
    }
    function validateOptions(options) {
      return validate3(sign_options_schema, false, options, "options");
    }
    function validatePayload(payload) {
      return validate3(registered_claims_schema, true, payload, "payload");
    }
    var options_to_payload = {
      "audience": "aud",
      "issuer": "iss",
      "subject": "sub",
      "jwtid": "jti"
    };
    var options_for_objects = [
      "expiresIn",
      "notBefore",
      "noTimestamp",
      "audience",
      "issuer",
      "subject",
      "jwtid"
    ];
    module2.exports = function(payload, secretOrPrivateKey, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      } else {
        options = options || {};
      }
      const isObjectPayload = typeof payload === "object" && !Buffer.isBuffer(payload);
      const header = Object.assign({
        alg: options.algorithm || "HS256",
        typ: isObjectPayload ? "JWT" : void 0,
        kid: options.keyid
      }, options.header);
      function failure(err) {
        if (callback) {
          return callback(err);
        }
        throw err;
      }
      if (!secretOrPrivateKey && options.algorithm !== "none") {
        return failure(new Error("secretOrPrivateKey must have a value"));
      }
      if (secretOrPrivateKey != null && !(secretOrPrivateKey instanceof KeyObject)) {
        try {
          secretOrPrivateKey = createPrivateKey(secretOrPrivateKey);
        } catch (_) {
          try {
            secretOrPrivateKey = createSecretKey(typeof secretOrPrivateKey === "string" ? Buffer.from(secretOrPrivateKey) : secretOrPrivateKey);
          } catch (_2) {
            return failure(new Error("secretOrPrivateKey is not valid key material"));
          }
        }
      }
      if (header.alg.startsWith("HS") && secretOrPrivateKey.type !== "secret") {
        return failure(new Error(`secretOrPrivateKey must be a symmetric key when using ${header.alg}`));
      } else if (/^(?:RS|PS|ES)/.test(header.alg)) {
        if (secretOrPrivateKey.type !== "private") {
          return failure(new Error(`secretOrPrivateKey must be an asymmetric key when using ${header.alg}`));
        }
        if (!options.allowInsecureKeySizes && !header.alg.startsWith("ES") && secretOrPrivateKey.asymmetricKeyDetails !== void 0 && //KeyObject.asymmetricKeyDetails is supported in Node 15+
        secretOrPrivateKey.asymmetricKeyDetails.modulusLength < 2048) {
          return failure(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
        }
      }
      if (typeof payload === "undefined") {
        return failure(new Error("payload is required"));
      } else if (isObjectPayload) {
        try {
          validatePayload(payload);
        } catch (error) {
          return failure(error);
        }
        if (!options.mutatePayload) {
          payload = Object.assign({}, payload);
        }
      } else {
        const invalid_options = options_for_objects.filter(function(opt) {
          return typeof options[opt] !== "undefined";
        });
        if (invalid_options.length > 0) {
          return failure(new Error("invalid " + invalid_options.join(",") + " option for " + typeof payload + " payload"));
        }
      }
      if (typeof payload.exp !== "undefined" && typeof options.expiresIn !== "undefined") {
        return failure(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
      }
      if (typeof payload.nbf !== "undefined" && typeof options.notBefore !== "undefined") {
        return failure(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
      }
      try {
        validateOptions(options);
      } catch (error) {
        return failure(error);
      }
      if (!options.allowInvalidAsymmetricKeyTypes) {
        try {
          validateAsymmetricKey(header.alg, secretOrPrivateKey);
        } catch (error) {
          return failure(error);
        }
      }
      const timestamp = payload.iat || Math.floor(Date.now() / 1e3);
      if (options.noTimestamp) {
        delete payload.iat;
      } else if (isObjectPayload) {
        payload.iat = timestamp;
      }
      if (typeof options.notBefore !== "undefined") {
        try {
          payload.nbf = timespan(options.notBefore, timestamp);
        } catch (err) {
          return failure(err);
        }
        if (typeof payload.nbf === "undefined") {
          return failure(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
      }
      if (typeof options.expiresIn !== "undefined" && typeof payload === "object") {
        try {
          payload.exp = timespan(options.expiresIn, timestamp);
        } catch (err) {
          return failure(err);
        }
        if (typeof payload.exp === "undefined") {
          return failure(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
      }
      Object.keys(options_to_payload).forEach(function(key) {
        const claim = options_to_payload[key];
        if (typeof options[key] !== "undefined") {
          if (typeof payload[claim] !== "undefined") {
            return failure(new Error('Bad "options.' + key + '" option. The payload already has an "' + claim + '" property.'));
          }
          payload[claim] = options[key];
        }
      });
      const encoding = options.encoding || "utf8";
      if (typeof callback === "function") {
        callback = callback && once(callback);
        jws.createSign({
          header,
          privateKey: secretOrPrivateKey,
          payload,
          encoding
        }).once("error", callback).once("done", function(signature) {
          if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
            return callback(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
          }
          callback(null, signature);
        });
      } else {
        let signature = jws.sign({ header, payload, secret: secretOrPrivateKey, encoding });
        if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
          throw new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`);
        }
        return signature;
      }
    };
  }
});

// node_modules/jsonwebtoken/index.js
var require_jsonwebtoken = __commonJS({
  "node_modules/jsonwebtoken/index.js"(exports2, module2) {
    module2.exports = {
      decode: require_decode(),
      verify: require_verify(),
      sign: require_sign2(),
      JsonWebTokenError: require_JsonWebTokenError(),
      NotBeforeError: require_NotBeforeError(),
      TokenExpiredError: require_TokenExpiredError()
    };
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/cache.js
var require_cache2 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/cache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Cache = void 0;
    var Cache2 = class {
      /**
       * Creates an instance of Cache.
       * @param defaultValidityTime - The default validity time in milliseconds. Use 0 for unlimited cache duration.
       */
      constructor(defaultValidityTime) {
        this.defaultValidityTime = defaultValidityTime;
        this.cache = {};
      }
      /**
       * Clear all cached items.
       */
      clear() {
        this.cache = {};
      }
      /**
       * Specifies whether an entry with a given key is defined in cache.
       * @param key - The entry's key.
       * @returns A boolean value that indicates whether the entry exists in cache.
       */
      hasKey(key) {
        return this.cache.hasOwnProperty(key);
      }
      /**
       * Getter of cached entries.
       * @param key - The key of the entry to retrieve.
       * @returns The corresponding entry to the provided key if it is still valid, returns `undefined` otherwise.
       */
      get(key) {
        return key && this.hasKey(key) && !isExpired(this.cache[key]) ? this.cache[key].entry : void 0;
      }
      /**
       * Setter of entries in cache.
       * @param key - The entry's key.
       * @param item - The entry to cache.
       */
      set(key, item) {
        if (key) {
          const expires = item.expires ?? this.inferDefaultExpirationTime();
          this.cache[key] = { entry: item.entry, expires };
        }
      }
      inferDefaultExpirationTime() {
        const now = /* @__PURE__ */ new Date();
        return this.defaultValidityTime ? now.setMilliseconds(now.getMilliseconds() + this.defaultValidityTime).valueOf() : void 0;
      }
    };
    exports2.Cache = Cache2;
    function isExpired(item) {
      if (item.expires === void 0) {
        return false;
      }
      return item.expires < Date.now();
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/subdomain-replacer.js
var require_subdomain_replacer = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/subdomain-replacer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getIssuerSubdomain = getIssuerSubdomain;
    var url_1 = require("url");
    function getIssuerSubdomain(decodedJwt) {
      const iss = decodedJwt?.iss;
      if (iss) {
        if (!isValidUrl(iss)) {
          throw new Error(`Issuer URL in JWT is not a valid URL: "${iss}".`);
        }
        return getHost(new url_1.URL(iss)).split(".")[0];
      }
    }
    function getHost(url) {
      const { host } = url;
      if (!host || host.indexOf(".") === -1) {
        throw new Error(`Failed to determine sub-domain: invalid host in "${url}".`);
      }
      return host;
    }
    function isValidUrl(url) {
      try {
        new url_1.URL(url);
        return true;
      } catch {
        return false;
      }
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/jwt/jwt.js
var require_jwt = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/jwt/jwt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.verificationKeyCache = exports2.defaultTenantId = void 0;
    exports2.userId = userId;
    exports2.getDefaultTenantId = getDefaultTenantId;
    exports2.getTenantId = getTenantId;
    exports2.getSubdomain = getSubdomain;
    exports2.audiences = audiences;
    exports2.decodeJwt = decodeJwt;
    exports2.decodeJwtComplete = decodeJwtComplete;
    exports2.retrieveJwt = retrieveJwt;
    exports2.wrapJwtInHeader = wrapJwtInHeader;
    exports2.isXsuaaToken = isXsuaaToken;
    exports2.getJwtPair = getJwtPair;
    exports2.isUserToken = isUserToken;
    var util_1 = require_dist2();
    var jsonwebtoken_1 = require_jsonwebtoken();
    var cache_1 = require_cache2();
    var subdomain_replacer_1 = require_subdomain_replacer();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "jwt"
    });
    exports2.defaultTenantId = "provider-tenant";
    function makeArray(val) {
      return val ? Array.isArray(val) ? val : [val] : [];
    }
    function userId({ user_id }) {
      logger8.debug(`JWT user_id is: ${user_id}.`);
      return user_id;
    }
    function getDefaultTenantId() {
      logger8.debug("Could not determine tenant from JWT nor XSUAA, identity or destination service binding. Client Credentials token is cached without tenant information.");
      return exports2.defaultTenantId;
    }
    function getTenantId(jwt) {
      const decodedJwt = jwt ? decodeJwt(jwt) : {};
      logger8.debug(`JWT zid is: ${decodedJwt.zid}, app_tid is: ${decodedJwt.app_tid}.`);
      return decodedJwt.zid || decodedJwt.app_tid || void 0;
    }
    function isNotIasToken(decodedJwt) {
      return !decodedJwt.iss?.includes("accounts.ondemand.com") && !decodedJwt.iss?.includes("accounts400.ondemand.com");
    }
    function getSubdomain(jwt) {
      const decodedJwt = jwt ? decodeJwt(jwt) : {};
      return decodedJwt?.ext_attr?.zdn || (isNotIasToken(decodedJwt) ? (0, subdomain_replacer_1.getIssuerSubdomain)(decodedJwt) : void 0);
    }
    function audiences(decodedToken) {
      const parsedAudiences = audiencesFromAud(decodedToken);
      return parsedAudiences.length ? parsedAudiences : audiencesFromScope(decodedToken);
    }
    function audiencesFromAud({ aud }) {
      return makeArray(aud).map((audience) => audience.split(".")[0]);
    }
    function audiencesFromScope({ scope }) {
      return makeArray(scope).reduce((aud, s) => s.includes(".") ? [...aud, s.split(".")[0]] : aud, []);
    }
    function decodeJwt(token) {
      return typeof token === "string" ? decodeJwtComplete(token).payload : token;
    }
    function decodeJwtComplete(token) {
      const decodedToken = (0, jsonwebtoken_1.decode)(token, { complete: true, json: true });
      if (decodedToken !== null && isJwtWithPayloadObject(decodedToken)) {
        return decodedToken;
      }
      throw new Error("JwtError: The given jwt payload does not encode valid JSON.");
    }
    function retrieveJwt(req) {
      const authHeader = getAuthHeader(req);
      if (validateAuthHeader(authHeader)) {
        return authHeader?.split(" ")[1];
      }
    }
    function getAuthHeader(req) {
      const authHeader = (0, util_1.pickValueIgnoreCase)(req.headers, "authorization");
      if (authHeader) {
        return Array.isArray(authHeader) ? authHeader[0] : authHeader;
      }
    }
    function validateAuthHeader(header) {
      if (typeof header === "undefined") {
        logger8.warn("Authorization header not set.");
        return false;
      }
      const [authType, token] = header.split(" ");
      if (typeof token === "undefined") {
        logger8.warn("Token in auth header missing.");
        return false;
      }
      if (authType.toLowerCase() !== "bearer") {
        logger8.warn("Authorization type is not Bearer.");
        return false;
      }
      return true;
    }
    exports2.verificationKeyCache = new cache_1.Cache(9e5);
    function wrapJwtInHeader(token) {
      return { headers: { Authorization: "Bearer " + token } };
    }
    function isXsuaaToken(decodedJwt) {
      return decodedJwt?.ext_attr?.enhancer === "XSUAA";
    }
    function getJwtPair(encodedJwt) {
      return { encoded: encodedJwt, decoded: decodeJwt(encodedJwt) };
    }
    function isUserToken(token) {
      if (!token) {
        return false;
      }
      const keys = Object.keys(token.decoded);
      return !(keys.length === 1 && keys[0] === "iss");
    }
    function isJwtWithPayloadObject(decoded) {
      return typeof decoded.payload !== "string";
    }
  }
});

// node_modules/@sap/xsenv/lib/filter.js
var require_filter = __commonJS({
  "node_modules/@sap/xsenv/lib/filter.js"(exports2, module2) {
    var assert = require("assert");
    module2.exports.apply = apply;
    function apply(services, filter) {
      assert(
        typeof filter === "string" || typeof filter === "object" || typeof filter === "function",
        "bad filter type: " + typeof filter
      );
      if (!services) {
        return [];
      }
      if (typeof filter === "string") {
        return services[filter] ? [services[filter]] : [];
      }
      var result = [];
      for (var key in services) {
        if (applyFilter(services[key], filter)) {
          result.push(services[key]);
        }
      }
      return result;
    }
    function applyFilter(service, filter) {
      if (typeof filter === "function") {
        return filter(service);
      }
      var match = false;
      for (var key in filter) {
        if (service[key] === filter[key] || /tags?/.test(key) && service.tags && service.tags.indexOf(filter[key]) >= 0) {
          match = true;
        } else {
          return false;
        }
      }
      return match;
    }
  }
});

// node_modules/assert-plus/assert.js
var require_assert = __commonJS({
  "node_modules/assert-plus/assert.js"(exports2, module2) {
    var assert = require("assert");
    var Stream = require("stream").Stream;
    var util = require("util");
    var UUID_REGEXP = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;
    function _capitalize(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    }
    function _toss(name, expected, oper, arg, actual) {
      throw new assert.AssertionError({
        message: util.format("%s (%s) is required", name, expected),
        actual: actual === void 0 ? typeof arg : actual(arg),
        expected,
        operator: oper || "===",
        stackStartFunction: _toss.caller
      });
    }
    function _getClass(arg) {
      return Object.prototype.toString.call(arg).slice(8, -1);
    }
    function noop() {
    }
    var types = {
      bool: {
        check: function(arg) {
          return typeof arg === "boolean";
        }
      },
      func: {
        check: function(arg) {
          return typeof arg === "function";
        }
      },
      string: {
        check: function(arg) {
          return typeof arg === "string";
        }
      },
      object: {
        check: function(arg) {
          return typeof arg === "object" && arg !== null;
        }
      },
      number: {
        check: function(arg) {
          return typeof arg === "number" && !isNaN(arg);
        }
      },
      finite: {
        check: function(arg) {
          return typeof arg === "number" && !isNaN(arg) && isFinite(arg);
        }
      },
      buffer: {
        check: function(arg) {
          return Buffer.isBuffer(arg);
        },
        operator: "Buffer.isBuffer"
      },
      array: {
        check: function(arg) {
          return Array.isArray(arg);
        },
        operator: "Array.isArray"
      },
      stream: {
        check: function(arg) {
          return arg instanceof Stream;
        },
        operator: "instanceof",
        actual: _getClass
      },
      date: {
        check: function(arg) {
          return arg instanceof Date;
        },
        operator: "instanceof",
        actual: _getClass
      },
      regexp: {
        check: function(arg) {
          return arg instanceof RegExp;
        },
        operator: "instanceof",
        actual: _getClass
      },
      uuid: {
        check: function(arg) {
          return typeof arg === "string" && UUID_REGEXP.test(arg);
        },
        operator: "isUUID"
      }
    };
    function _setExports(ndebug) {
      var keys = Object.keys(types);
      var out;
      if (process.env.NODE_NDEBUG) {
        out = noop;
      } else {
        out = function(arg, msg) {
          if (!arg) {
            _toss(msg, "true", arg);
          }
        };
      }
      keys.forEach(function(k) {
        if (ndebug) {
          out[k] = noop;
          return;
        }
        var type = types[k];
        out[k] = function(arg, msg) {
          if (!type.check(arg)) {
            _toss(msg, k, type.operator, arg, type.actual);
          }
        };
      });
      keys.forEach(function(k) {
        var name = "optional" + _capitalize(k);
        if (ndebug) {
          out[name] = noop;
          return;
        }
        var type = types[k];
        out[name] = function(arg, msg) {
          if (arg === void 0 || arg === null) {
            return;
          }
          if (!type.check(arg)) {
            _toss(msg, k, type.operator, arg, type.actual);
          }
        };
      });
      keys.forEach(function(k) {
        var name = "arrayOf" + _capitalize(k);
        if (ndebug) {
          out[name] = noop;
          return;
        }
        var type = types[k];
        var expected = "[" + k + "]";
        out[name] = function(arg, msg) {
          if (!Array.isArray(arg)) {
            _toss(msg, expected, type.operator, arg, type.actual);
          }
          var i;
          for (i = 0; i < arg.length; i++) {
            if (!type.check(arg[i])) {
              _toss(msg, expected, type.operator, arg, type.actual);
            }
          }
        };
      });
      keys.forEach(function(k) {
        var name = "optionalArrayOf" + _capitalize(k);
        if (ndebug) {
          out[name] = noop;
          return;
        }
        var type = types[k];
        var expected = "[" + k + "]";
        out[name] = function(arg, msg) {
          if (arg === void 0 || arg === null) {
            return;
          }
          if (!Array.isArray(arg)) {
            _toss(msg, expected, type.operator, arg, type.actual);
          }
          var i;
          for (i = 0; i < arg.length; i++) {
            if (!type.check(arg[i])) {
              _toss(msg, expected, type.operator, arg, type.actual);
            }
          }
        };
      });
      Object.keys(assert).forEach(function(k) {
        if (k === "AssertionError") {
          out[k] = assert[k];
          return;
        }
        if (ndebug) {
          out[k] = noop;
          return;
        }
        out[k] = assert[k];
      });
      out._setExports = _setExports;
      return out;
    }
    module2.exports = _setExports(process.env.NODE_NDEBUG);
  }
});

// node_modules/extsprintf/lib/extsprintf.js
var require_extsprintf = __commonJS({
  "node_modules/extsprintf/lib/extsprintf.js"(exports2) {
    var mod_assert = require("assert");
    var mod_util = require("util");
    exports2.sprintf = jsSprintf;
    exports2.printf = jsPrintf;
    exports2.fprintf = jsFprintf;
    function jsSprintf(ofmt) {
      var regex = [
        "([^%]*)",
        /* normal text */
        "%",
        /* start of format */
        "(['\\-+ #0]*?)",
        /* flags (optional) */
        "([1-9]\\d*)?",
        /* width (optional) */
        "(\\.([1-9]\\d*))?",
        /* precision (optional) */
        "[lhjztL]*?",
        /* length mods (ignored) */
        "([diouxXfFeEgGaAcCsSp%jr])"
        /* conversion */
      ].join("");
      var re = new RegExp(regex);
      var args = Array.prototype.slice.call(arguments, 1);
      var fmt = ofmt;
      var flags, width, precision, conversion;
      var left, pad, sign, arg, match;
      var ret = "";
      var argn = 1;
      var posn = 0;
      var convposn;
      var curconv;
      mod_assert.equal(
        "string",
        typeof fmt,
        "first argument must be a format string"
      );
      while ((match = re.exec(fmt)) !== null) {
        ret += match[1];
        fmt = fmt.substring(match[0].length);
        curconv = match[0].substring(match[1].length);
        convposn = posn + match[1].length + 1;
        posn += match[0].length;
        flags = match[2] || "";
        width = match[3] || 0;
        precision = match[4] || "";
        conversion = match[6];
        left = false;
        sign = false;
        pad = " ";
        if (conversion == "%") {
          ret += "%";
          continue;
        }
        if (args.length === 0) {
          throw jsError(
            ofmt,
            convposn,
            curconv,
            "has no matching argument (too few arguments passed)"
          );
        }
        arg = args.shift();
        argn++;
        if (flags.match(/[\' #]/)) {
          throw jsError(
            ofmt,
            convposn,
            curconv,
            "uses unsupported flags"
          );
        }
        if (precision.length > 0) {
          throw jsError(
            ofmt,
            convposn,
            curconv,
            "uses non-zero precision (not supported)"
          );
        }
        if (flags.match(/-/))
          left = true;
        if (flags.match(/0/))
          pad = "0";
        if (flags.match(/\+/))
          sign = true;
        switch (conversion) {
          case "s":
            if (arg === void 0 || arg === null) {
              throw jsError(
                ofmt,
                convposn,
                curconv,
                "attempted to print undefined or null as a string (argument " + argn + " to sprintf)"
              );
            }
            ret += doPad(pad, width, left, arg.toString());
            break;
          case "d":
            arg = Math.floor(arg);
          /*jsl:fallthru*/
          case "f":
            sign = sign && arg > 0 ? "+" : "";
            ret += sign + doPad(
              pad,
              width,
              left,
              arg.toString()
            );
            break;
          case "x":
            ret += doPad(pad, width, left, arg.toString(16));
            break;
          case "j":
            if (width === 0)
              width = 10;
            ret += mod_util.inspect(arg, false, width);
            break;
          case "r":
            ret += dumpException(arg);
            break;
          default:
            throw jsError(
              ofmt,
              convposn,
              curconv,
              "is not supported"
            );
        }
      }
      ret += fmt;
      return ret;
    }
    function jsError(fmtstr, convposn, curconv, reason) {
      mod_assert.equal(typeof fmtstr, "string");
      mod_assert.equal(typeof curconv, "string");
      mod_assert.equal(typeof convposn, "number");
      mod_assert.equal(typeof reason, "string");
      return new Error('format string "' + fmtstr + '": conversion specifier "' + curconv + '" at character ' + convposn + " " + reason);
    }
    function jsPrintf() {
      var args = Array.prototype.slice.call(arguments);
      args.unshift(process.stdout);
      jsFprintf.apply(null, args);
    }
    function jsFprintf(stream) {
      var args = Array.prototype.slice.call(arguments, 1);
      return stream.write(jsSprintf.apply(this, args));
    }
    function doPad(chr, width, left, str) {
      var ret = str;
      while (ret.length < width) {
        if (left)
          ret += chr;
        else
          ret = chr + ret;
      }
      return ret;
    }
    function dumpException(ex) {
      var ret;
      if (!(ex instanceof Error))
        throw new Error(jsSprintf("invalid type for %%r: %j", ex));
      ret = "EXCEPTION: " + ex.constructor.name + ": " + ex.stack;
      if (ex.cause && typeof ex.cause === "function") {
        var cex = ex.cause();
        if (cex) {
          ret += "\nCaused by: " + dumpException(cex);
        }
      }
      return ret;
    }
  }
});

// node_modules/core-util-is/lib/util.js
var require_util2 = __commonJS({
  "node_modules/core-util-is/lib/util.js"(exports2) {
    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === "[object Array]";
    }
    exports2.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports2.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports2.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports2.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports2.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports2.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports2.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports2.isUndefined = isUndefined;
    function isRegExp(re) {
      return objectToString(re) === "[object RegExp]";
    }
    exports2.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports2.isObject = isObject;
    function isDate(d) {
      return objectToString(d) === "[object Date]";
    }
    exports2.isDate = isDate;
    function isError(e) {
      return objectToString(e) === "[object Error]" || e instanceof Error;
    }
    exports2.isError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports2.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports2.isPrimitive = isPrimitive;
    exports2.isBuffer = Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  }
});

// node_modules/verror/lib/verror.js
var require_verror = __commonJS({
  "node_modules/verror/lib/verror.js"(exports2, module2) {
    var mod_assertplus = require_assert();
    var mod_util = require("util");
    var mod_extsprintf = require_extsprintf();
    var mod_isError = require_util2().isError;
    var sprintf = mod_extsprintf.sprintf;
    module2.exports = VError;
    VError.VError = VError;
    VError.SError = SError;
    VError.WError = WError;
    VError.MultiError = MultiError;
    function parseConstructorArguments(args) {
      var argv, options, sprintf_args, shortmessage, k;
      mod_assertplus.object(args, "args");
      mod_assertplus.bool(args.strict, "args.strict");
      mod_assertplus.array(args.argv, "args.argv");
      argv = args.argv;
      if (argv.length === 0) {
        options = {};
        sprintf_args = [];
      } else if (mod_isError(argv[0])) {
        options = { "cause": argv[0] };
        sprintf_args = argv.slice(1);
      } else if (typeof argv[0] === "object") {
        options = {};
        for (k in argv[0]) {
          options[k] = argv[0][k];
        }
        sprintf_args = argv.slice(1);
      } else {
        mod_assertplus.string(
          argv[0],
          "first argument to VError, SError, or WError constructor must be a string, object, or Error"
        );
        options = {};
        sprintf_args = argv;
      }
      mod_assertplus.object(options);
      if (!options.strict && !args.strict) {
        sprintf_args = sprintf_args.map(function(a) {
          return a === null ? "null" : a === void 0 ? "undefined" : a;
        });
      }
      if (sprintf_args.length === 0) {
        shortmessage = "";
      } else {
        shortmessage = sprintf.apply(null, sprintf_args);
      }
      return {
        "options": options,
        "shortmessage": shortmessage
      };
    }
    function VError() {
      var args, obj, parsed, cause, ctor, message, k;
      args = Array.prototype.slice.call(arguments, 0);
      if (!(this instanceof VError)) {
        obj = Object.create(VError.prototype);
        VError.apply(obj, arguments);
        return obj;
      }
      parsed = parseConstructorArguments({
        "argv": args,
        "strict": false
      });
      if (parsed.options.name) {
        mod_assertplus.string(
          parsed.options.name,
          `error's "name" must be a string`
        );
        this.name = parsed.options.name;
      }
      this.jse_shortmsg = parsed.shortmessage;
      message = parsed.shortmessage;
      cause = parsed.options.cause;
      if (cause) {
        mod_assertplus.ok(mod_isError(cause), "cause is not an Error");
        this.jse_cause = cause;
        if (!parsed.options.skipCauseMessage) {
          message += ": " + cause.message;
        }
      }
      this.jse_info = {};
      if (parsed.options.info) {
        for (k in parsed.options.info) {
          this.jse_info[k] = parsed.options.info[k];
        }
      }
      this.message = message;
      Error.call(this, message);
      if (Error.captureStackTrace) {
        ctor = parsed.options.constructorOpt || this.constructor;
        Error.captureStackTrace(this, ctor);
      }
      return this;
    }
    mod_util.inherits(VError, Error);
    VError.prototype.name = "VError";
    VError.prototype.toString = function ve_toString() {
      var str = this.hasOwnProperty("name") && this.name || this.constructor.name || this.constructor.prototype.name;
      if (this.message)
        str += ": " + this.message;
      return str;
    };
    VError.prototype.cause = function ve_cause() {
      var cause = VError.cause(this);
      return cause === null ? void 0 : cause;
    };
    VError.cause = function(err) {
      mod_assertplus.ok(mod_isError(err), "err must be an Error");
      return mod_isError(err.jse_cause) ? err.jse_cause : null;
    };
    VError.info = function(err) {
      var rv, cause, k;
      mod_assertplus.ok(mod_isError(err), "err must be an Error");
      cause = VError.cause(err);
      if (cause !== null) {
        rv = VError.info(cause);
      } else {
        rv = {};
      }
      if (typeof err.jse_info == "object" && err.jse_info !== null) {
        for (k in err.jse_info) {
          rv[k] = err.jse_info[k];
        }
      }
      return rv;
    };
    VError.findCauseByName = function(err, name) {
      var cause;
      mod_assertplus.ok(mod_isError(err), "err must be an Error");
      mod_assertplus.string(name, "name");
      mod_assertplus.ok(name.length > 0, "name cannot be empty");
      for (cause = err; cause !== null; cause = VError.cause(cause)) {
        mod_assertplus.ok(mod_isError(cause));
        if (cause.name == name) {
          return cause;
        }
      }
      return null;
    };
    VError.hasCauseWithName = function(err, name) {
      return VError.findCauseByName(err, name) !== null;
    };
    VError.fullStack = function(err) {
      mod_assertplus.ok(mod_isError(err), "err must be an Error");
      var cause = VError.cause(err);
      if (cause) {
        return err.stack + "\ncaused by: " + VError.fullStack(cause);
      }
      return err.stack;
    };
    VError.errorFromList = function(errors) {
      mod_assertplus.arrayOfObject(errors, "errors");
      if (errors.length === 0) {
        return null;
      }
      errors.forEach(function(e) {
        mod_assertplus.ok(mod_isError(e));
      });
      if (errors.length == 1) {
        return errors[0];
      }
      return new MultiError(errors);
    };
    VError.errorForEach = function(err, func) {
      mod_assertplus.ok(mod_isError(err), "err must be an Error");
      mod_assertplus.func(func, "func");
      if (err instanceof MultiError) {
        err.errors().forEach(function iterError(e) {
          func(e);
        });
      } else {
        func(err);
      }
    };
    function SError() {
      var args, obj, parsed, options;
      args = Array.prototype.slice.call(arguments, 0);
      if (!(this instanceof SError)) {
        obj = Object.create(SError.prototype);
        SError.apply(obj, arguments);
        return obj;
      }
      parsed = parseConstructorArguments({
        "argv": args,
        "strict": true
      });
      options = parsed.options;
      VError.call(this, options, "%s", parsed.shortmessage);
      return this;
    }
    mod_util.inherits(SError, VError);
    function MultiError(errors) {
      mod_assertplus.array(errors, "list of errors");
      mod_assertplus.ok(errors.length > 0, "must be at least one error");
      this.ase_errors = errors;
      VError.call(this, {
        "cause": errors[0]
      }, "first of %d error%s", errors.length, errors.length == 1 ? "" : "s");
    }
    mod_util.inherits(MultiError, VError);
    MultiError.prototype.name = "MultiError";
    MultiError.prototype.errors = function me_errors() {
      return this.ase_errors.slice(0);
    };
    function WError() {
      var args, obj, parsed, options;
      args = Array.prototype.slice.call(arguments, 0);
      if (!(this instanceof WError)) {
        obj = Object.create(WError.prototype);
        WError.apply(obj, args);
        return obj;
      }
      parsed = parseConstructorArguments({
        "argv": args,
        "strict": false
      });
      options = parsed.options;
      options["skipCauseMessage"] = true;
      VError.call(this, options, "%s", parsed.shortmessage);
      return this;
    }
    mod_util.inherits(WError, VError);
    WError.prototype.name = "WError";
    WError.prototype.toString = function we_toString() {
      var str = this.hasOwnProperty("name") && this.name || this.constructor.name || this.constructor.prototype.name;
      if (this.message)
        str += ": " + this.message;
      if (this.jse_cause && this.jse_cause.message)
        str += "; caused by " + this.jse_cause.toString();
      return str;
    };
    WError.prototype.cause = function we_cause(c) {
      if (mod_isError(c))
        this.jse_cause = c;
      return this.jse_cause;
    };
  }
});

// node_modules/@sap/xsenv/lib/cfservice.js
var require_cfservice = __commonJS({
  "node_modules/@sap/xsenv/lib/cfservice.js"(exports2) {
    var filter = require_filter();
    var VError = require_verror();
    var fs = require("fs");
    var debug = require_src()("cf-services");
    exports2.readCFServices = readCFServices;
    exports2.filterCFServices = filterCFServices;
    function readCFServices() {
      let services;
      const filePath = process.env.VCAP_SERVICES_FILE_PATH;
      if (filePath) {
        try {
          const fileContent = fs.readFileSync(filePath, "utf8");
          services = JSON.parse(fileContent);
          debug(`Successfully read services from file: ${filePath}`);
        } catch (err) {
          throw new VError(err, `Failed to read or parse file specified by VCAP_SERVICES_FILE_PATH: ${filePath}`);
        }
      } else if (process.env.VCAP_SERVICES) {
        try {
          services = JSON.parse(process.env.VCAP_SERVICES);
          debug("Successfully read services from VCAP_SERVICES environment variable");
        } catch (err) {
          throw new VError(err, "Environment variable VCAP_SERVICES is not a valid JSON string.");
        }
      } else {
        debug("Neither VCAP_SERVICES_FILE_PATH nor VCAP_SERVICES is set.");
        return;
      }
      const result = {};
      for (const s in services) {
        for (const si in services[s]) {
          const svc = services[s][si];
          result[svc.name] = svc;
        }
      }
      return result;
    }
    function filterCFServices(filterQuery) {
      return filter.apply(readCFServices(), filterQuery);
    }
  }
});

// node_modules/clone/clone.js
var require_clone = __commonJS({
  "node_modules/clone/clone.js"(exports2, module2) {
    var clone = function() {
      "use strict";
      function _instanceof(obj, type) {
        return type != null && obj instanceof type;
      }
      var nativeMap;
      try {
        nativeMap = Map;
      } catch (_) {
        nativeMap = function() {
        };
      }
      var nativeSet;
      try {
        nativeSet = Set;
      } catch (_) {
        nativeSet = function() {
        };
      }
      var nativePromise;
      try {
        nativePromise = Promise;
      } catch (_) {
        nativePromise = function() {
        };
      }
      function clone2(parent, circular, depth, prototype, includeNonEnumerable) {
        if (typeof circular === "object") {
          depth = circular.depth;
          prototype = circular.prototype;
          includeNonEnumerable = circular.includeNonEnumerable;
          circular = circular.circular;
        }
        var allParents = [];
        var allChildren = [];
        var useBuffer = typeof Buffer != "undefined";
        if (typeof circular == "undefined")
          circular = true;
        if (typeof depth == "undefined")
          depth = Infinity;
        function _clone(parent2, depth2) {
          if (parent2 === null)
            return null;
          if (depth2 === 0)
            return parent2;
          var child;
          var proto;
          if (typeof parent2 != "object") {
            return parent2;
          }
          if (_instanceof(parent2, nativeMap)) {
            child = new nativeMap();
          } else if (_instanceof(parent2, nativeSet)) {
            child = new nativeSet();
          } else if (_instanceof(parent2, nativePromise)) {
            child = new nativePromise(function(resolve, reject) {
              parent2.then(function(value) {
                resolve(_clone(value, depth2 - 1));
              }, function(err) {
                reject(_clone(err, depth2 - 1));
              });
            });
          } else if (clone2.__isArray(parent2)) {
            child = [];
          } else if (clone2.__isRegExp(parent2)) {
            child = new RegExp(parent2.source, __getRegExpFlags(parent2));
            if (parent2.lastIndex) child.lastIndex = parent2.lastIndex;
          } else if (clone2.__isDate(parent2)) {
            child = new Date(parent2.getTime());
          } else if (useBuffer && Buffer.isBuffer(parent2)) {
            if (Buffer.allocUnsafe) {
              child = Buffer.allocUnsafe(parent2.length);
            } else {
              child = new Buffer(parent2.length);
            }
            parent2.copy(child);
            return child;
          } else if (_instanceof(parent2, Error)) {
            child = Object.create(parent2);
          } else {
            if (typeof prototype == "undefined") {
              proto = Object.getPrototypeOf(parent2);
              child = Object.create(proto);
            } else {
              child = Object.create(prototype);
              proto = prototype;
            }
          }
          if (circular) {
            var index = allParents.indexOf(parent2);
            if (index != -1) {
              return allChildren[index];
            }
            allParents.push(parent2);
            allChildren.push(child);
          }
          if (_instanceof(parent2, nativeMap)) {
            parent2.forEach(function(value, key) {
              var keyChild = _clone(key, depth2 - 1);
              var valueChild = _clone(value, depth2 - 1);
              child.set(keyChild, valueChild);
            });
          }
          if (_instanceof(parent2, nativeSet)) {
            parent2.forEach(function(value) {
              var entryChild = _clone(value, depth2 - 1);
              child.add(entryChild);
            });
          }
          for (var i in parent2) {
            var attrs;
            if (proto) {
              attrs = Object.getOwnPropertyDescriptor(proto, i);
            }
            if (attrs && attrs.set == null) {
              continue;
            }
            child[i] = _clone(parent2[i], depth2 - 1);
          }
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(parent2);
            for (var i = 0; i < symbols.length; i++) {
              var symbol = symbols[i];
              var descriptor = Object.getOwnPropertyDescriptor(parent2, symbol);
              if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
                continue;
              }
              child[symbol] = _clone(parent2[symbol], depth2 - 1);
              if (!descriptor.enumerable) {
                Object.defineProperty(child, symbol, {
                  enumerable: false
                });
              }
            }
          }
          if (includeNonEnumerable) {
            var allPropertyNames = Object.getOwnPropertyNames(parent2);
            for (var i = 0; i < allPropertyNames.length; i++) {
              var propertyName = allPropertyNames[i];
              var descriptor = Object.getOwnPropertyDescriptor(parent2, propertyName);
              if (descriptor && descriptor.enumerable) {
                continue;
              }
              child[propertyName] = _clone(parent2[propertyName], depth2 - 1);
              Object.defineProperty(child, propertyName, {
                enumerable: false
              });
            }
          }
          return child;
        }
        return _clone(parent, depth);
      }
      clone2.clonePrototype = function clonePrototype(parent) {
        if (parent === null)
          return null;
        var c = function() {
        };
        c.prototype = parent;
        return new c();
      };
      function __objToStr(o) {
        return Object.prototype.toString.call(o);
      }
      clone2.__objToStr = __objToStr;
      function __isDate(o) {
        return typeof o === "object" && __objToStr(o) === "[object Date]";
      }
      clone2.__isDate = __isDate;
      function __isArray(o) {
        return typeof o === "object" && __objToStr(o) === "[object Array]";
      }
      clone2.__isArray = __isArray;
      function __isRegExp(o) {
        return typeof o === "object" && __objToStr(o) === "[object RegExp]";
      }
      clone2.__isRegExp = __isRegExp;
      function __getRegExpFlags(re) {
        var flags = "";
        if (re.global) flags += "g";
        if (re.ignoreCase) flags += "i";
        if (re.multiline) flags += "m";
        return flags;
      }
      clone2.__getRegExpFlags = __getRegExpFlags;
      return clone2;
    }();
    if (typeof module2 === "object" && module2.exports) {
      module2.exports = clone;
    }
  }
});

// node_modules/node-cache/lib/node_cache.js
var require_node_cache = __commonJS({
  "node_modules/node-cache/lib/node_cache.js"(exports2, module2) {
    (function() {
      var EventEmitter, NodeCache, clone, splice = [].splice, boundMethodCheck = function(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new Error("Bound instance method accessed before binding");
        }
      }, indexOf = [].indexOf;
      clone = require_clone();
      EventEmitter = require("events").EventEmitter;
      module2.exports = NodeCache = function() {
        class NodeCache2 extends EventEmitter {
          constructor(options = {}) {
            super();
            this.get = this.get.bind(this);
            this.mget = this.mget.bind(this);
            this.set = this.set.bind(this);
            this.mset = this.mset.bind(this);
            this.del = this.del.bind(this);
            this.take = this.take.bind(this);
            this.ttl = this.ttl.bind(this);
            this.getTtl = this.getTtl.bind(this);
            this.keys = this.keys.bind(this);
            this.has = this.has.bind(this);
            this.getStats = this.getStats.bind(this);
            this.flushAll = this.flushAll.bind(this);
            this.flushStats = this.flushStats.bind(this);
            this.close = this.close.bind(this);
            this._checkData = this._checkData.bind(this);
            this._check = this._check.bind(this);
            this._isInvalidKey = this._isInvalidKey.bind(this);
            this._wrap = this._wrap.bind(this);
            this._getValLength = this._getValLength.bind(this);
            this._error = this._error.bind(this);
            this._initErrors = this._initErrors.bind(this);
            this.options = options;
            this._initErrors();
            this.data = {};
            this.options = Object.assign({
              // convert all elements to string
              forceString: false,
              // used standard size for calculating value size
              objectValueSize: 80,
              promiseValueSize: 80,
              arrayValueSize: 40,
              // standard time to live in seconds. 0 = infinity;
              stdTTL: 0,
              // time in seconds to check all data and delete expired keys
              checkperiod: 600,
              // en/disable cloning of variables. If `true` you'll get a copy of the cached variable. If `false` you'll save and get just the reference
              useClones: true,
              // whether values should be deleted automatically at expiration
              deleteOnExpire: true,
              // enable legacy callbacks
              enableLegacyCallbacks: false,
              // max amount of keys that are being stored
              maxKeys: -1
            }, this.options);
            if (this.options.enableLegacyCallbacks) {
              console.warn("WARNING! node-cache legacy callback support will drop in v6.x");
              ["get", "mget", "set", "del", "ttl", "getTtl", "keys", "has"].forEach((methodKey) => {
                var oldMethod;
                oldMethod = this[methodKey];
                this[methodKey] = function(...args) {
                  var cb, err, ref, res;
                  ref = args, [...args] = ref, [cb] = splice.call(args, -1);
                  if (typeof cb === "function") {
                    try {
                      res = oldMethod(...args);
                      cb(null, res);
                    } catch (error1) {
                      err = error1;
                      cb(err);
                    }
                  } else {
                    return oldMethod(...args, cb);
                  }
                };
              });
            }
            this.stats = {
              hits: 0,
              misses: 0,
              keys: 0,
              ksize: 0,
              vsize: 0
            };
            this.validKeyTypes = ["string", "number"];
            this._checkData();
            return;
          }
          get(key) {
            var _ret, err;
            boundMethodCheck(this, NodeCache2);
            if ((err = this._isInvalidKey(key)) != null) {
              throw err;
            }
            if (this.data[key] != null && this._check(key, this.data[key])) {
              this.stats.hits++;
              _ret = this._unwrap(this.data[key]);
              return _ret;
            } else {
              this.stats.misses++;
              return void 0;
            }
          }
          mget(keys) {
            var _err, err, i, key, len, oRet;
            boundMethodCheck(this, NodeCache2);
            if (!Array.isArray(keys)) {
              _err = this._error("EKEYSTYPE");
              throw _err;
            }
            oRet = {};
            for (i = 0, len = keys.length; i < len; i++) {
              key = keys[i];
              if ((err = this._isInvalidKey(key)) != null) {
                throw err;
              }
              if (this.data[key] != null && this._check(key, this.data[key])) {
                this.stats.hits++;
                oRet[key] = this._unwrap(this.data[key]);
              } else {
                this.stats.misses++;
              }
            }
            return oRet;
          }
          set(key, value, ttl) {
            var _err, err, existent;
            boundMethodCheck(this, NodeCache2);
            if (this.options.maxKeys > -1 && this.stats.keys >= this.options.maxKeys) {
              _err = this._error("ECACHEFULL");
              throw _err;
            }
            if (this.options.forceString && false) {
              value = JSON.stringify(value);
            }
            if (ttl == null) {
              ttl = this.options.stdTTL;
            }
            if ((err = this._isInvalidKey(key)) != null) {
              throw err;
            }
            existent = false;
            if (this.data[key]) {
              existent = true;
              this.stats.vsize -= this._getValLength(this._unwrap(this.data[key], false));
            }
            this.data[key] = this._wrap(value, ttl);
            this.stats.vsize += this._getValLength(value);
            if (!existent) {
              this.stats.ksize += this._getKeyLength(key);
              this.stats.keys++;
            }
            this.emit("set", key, value);
            return true;
          }
          mset(keyValueSet) {
            var _err, err, i, j, key, keyValuePair, len, len1, ttl, val;
            boundMethodCheck(this, NodeCache2);
            if (this.options.maxKeys > -1 && this.stats.keys + keyValueSet.length >= this.options.maxKeys) {
              _err = this._error("ECACHEFULL");
              throw _err;
            }
            for (i = 0, len = keyValueSet.length; i < len; i++) {
              keyValuePair = keyValueSet[i];
              ({ key, val, ttl } = keyValuePair);
              if (ttl && typeof ttl !== "number") {
                _err = this._error("ETTLTYPE");
                throw _err;
              }
              if ((err = this._isInvalidKey(key)) != null) {
                throw err;
              }
            }
            for (j = 0, len1 = keyValueSet.length; j < len1; j++) {
              keyValuePair = keyValueSet[j];
              ({ key, val, ttl } = keyValuePair);
              this.set(key, val, ttl);
            }
            return true;
          }
          del(keys) {
            var delCount, err, i, key, len, oldVal;
            boundMethodCheck(this, NodeCache2);
            if (!Array.isArray(keys)) {
              keys = [keys];
            }
            delCount = 0;
            for (i = 0, len = keys.length; i < len; i++) {
              key = keys[i];
              if ((err = this._isInvalidKey(key)) != null) {
                throw err;
              }
              if (this.data[key] != null) {
                this.stats.vsize -= this._getValLength(this._unwrap(this.data[key], false));
                this.stats.ksize -= this._getKeyLength(key);
                this.stats.keys--;
                delCount++;
                oldVal = this.data[key];
                delete this.data[key];
                this.emit("del", key, oldVal.v);
              }
            }
            return delCount;
          }
          take(key) {
            var _ret;
            boundMethodCheck(this, NodeCache2);
            _ret = this.get(key);
            if (_ret != null) {
              this.del(key);
            }
            return _ret;
          }
          ttl(key, ttl) {
            var err;
            boundMethodCheck(this, NodeCache2);
            ttl || (ttl = this.options.stdTTL);
            if (!key) {
              return false;
            }
            if ((err = this._isInvalidKey(key)) != null) {
              throw err;
            }
            if (this.data[key] != null && this._check(key, this.data[key])) {
              if (ttl >= 0) {
                this.data[key] = this._wrap(this.data[key].v, ttl, false);
              } else {
                this.del(key);
              }
              return true;
            } else {
              return false;
            }
          }
          getTtl(key) {
            var _ttl, err;
            boundMethodCheck(this, NodeCache2);
            if (!key) {
              return void 0;
            }
            if ((err = this._isInvalidKey(key)) != null) {
              throw err;
            }
            if (this.data[key] != null && this._check(key, this.data[key])) {
              _ttl = this.data[key].t;
              return _ttl;
            } else {
              return void 0;
            }
          }
          keys() {
            var _keys;
            boundMethodCheck(this, NodeCache2);
            _keys = Object.keys(this.data);
            return _keys;
          }
          has(key) {
            var _exists;
            boundMethodCheck(this, NodeCache2);
            _exists = this.data[key] != null && this._check(key, this.data[key]);
            return _exists;
          }
          getStats() {
            boundMethodCheck(this, NodeCache2);
            return this.stats;
          }
          flushAll(_startPeriod = true) {
            boundMethodCheck(this, NodeCache2);
            this.data = {};
            this.stats = {
              hits: 0,
              misses: 0,
              keys: 0,
              ksize: 0,
              vsize: 0
            };
            this._killCheckPeriod();
            this._checkData(_startPeriod);
            this.emit("flush");
          }
          flushStats() {
            boundMethodCheck(this, NodeCache2);
            this.stats = {
              hits: 0,
              misses: 0,
              keys: 0,
              ksize: 0,
              vsize: 0
            };
            this.emit("flush_stats");
          }
          close() {
            boundMethodCheck(this, NodeCache2);
            this._killCheckPeriod();
          }
          _checkData(startPeriod = true) {
            var key, ref, value;
            boundMethodCheck(this, NodeCache2);
            ref = this.data;
            for (key in ref) {
              value = ref[key];
              this._check(key, value);
            }
            if (startPeriod && this.options.checkperiod > 0) {
              this.checkTimeout = setTimeout(this._checkData, this.options.checkperiod * 1e3, startPeriod);
              if (this.checkTimeout != null && this.checkTimeout.unref != null) {
                this.checkTimeout.unref();
              }
            }
          }
          // ## _killCheckPeriod
          // stop the checkdata period. Only needed to abort the script in testing mode.
          _killCheckPeriod() {
            if (this.checkTimeout != null) {
              return clearTimeout(this.checkTimeout);
            }
          }
          _check(key, data) {
            var _retval;
            boundMethodCheck(this, NodeCache2);
            _retval = true;
            if (data.t !== 0 && data.t < Date.now()) {
              if (this.options.deleteOnExpire) {
                _retval = false;
                this.del(key);
              }
              this.emit("expired", key, this._unwrap(data));
            }
            return _retval;
          }
          _isInvalidKey(key) {
            var ref;
            boundMethodCheck(this, NodeCache2);
            if (ref = typeof key, indexOf.call(this.validKeyTypes, ref) < 0) {
              return this._error("EKEYTYPE", {
                type: typeof key
              });
            }
          }
          _wrap(value, ttl, asClone = true) {
            var livetime, now, oReturn, ttlMultiplicator;
            boundMethodCheck(this, NodeCache2);
            if (!this.options.useClones) {
              asClone = false;
            }
            now = Date.now();
            livetime = 0;
            ttlMultiplicator = 1e3;
            if (ttl === 0) {
              livetime = 0;
            } else if (ttl) {
              livetime = now + ttl * ttlMultiplicator;
            } else {
              if (this.options.stdTTL === 0) {
                livetime = this.options.stdTTL;
              } else {
                livetime = now + this.options.stdTTL * ttlMultiplicator;
              }
            }
            return oReturn = {
              t: livetime,
              v: asClone ? clone(value) : value
            };
          }
          // ## _unwrap
          // internal method to extract get the value out of the wrapped value
          _unwrap(value, asClone = true) {
            if (!this.options.useClones) {
              asClone = false;
            }
            if (value.v != null) {
              if (asClone) {
                return clone(value.v);
              } else {
                return value.v;
              }
            }
            return null;
          }
          // ## _getKeyLength
          // internal method the calculate the key length
          _getKeyLength(key) {
            return key.toString().length;
          }
          _getValLength(value) {
            boundMethodCheck(this, NodeCache2);
            if (typeof value === "string") {
              return value.length;
            } else if (this.options.forceString) {
              return JSON.stringify(value).length;
            } else if (Array.isArray(value)) {
              return this.options.arrayValueSize * value.length;
            } else if (typeof value === "number") {
              return 8;
            } else if (typeof (value != null ? value.then : void 0) === "function") {
              return this.options.promiseValueSize;
            } else if (typeof Buffer !== "undefined" && Buffer !== null ? Buffer.isBuffer(value) : void 0) {
              return value.length;
            } else if (value != null && typeof value === "object") {
              return this.options.objectValueSize * Object.keys(value).length;
            } else if (typeof value === "boolean") {
              return 8;
            } else {
              return 0;
            }
          }
          _error(type, data = {}) {
            var error;
            boundMethodCheck(this, NodeCache2);
            error = new Error();
            error.name = type;
            error.errorcode = type;
            error.message = this.ERRORS[type] != null ? this.ERRORS[type](data) : "-";
            error.data = data;
            return error;
          }
          _initErrors() {
            var _errMsg, _errT, ref;
            boundMethodCheck(this, NodeCache2);
            this.ERRORS = {};
            ref = this._ERRORS;
            for (_errT in ref) {
              _errMsg = ref[_errT];
              this.ERRORS[_errT] = this.createErrorMessage(_errMsg);
            }
          }
          createErrorMessage(errMsg) {
            return function(args) {
              return errMsg.replace("__key", args.type);
            };
          }
        }
        ;
        NodeCache2.prototype._ERRORS = {
          "ENOTFOUND": "Key `__key` not found",
          "ECACHEFULL": "Cache max keys amount exceeded",
          "EKEYTYPE": "The key argument has to be of type `string` or `number`. Found: `__key`",
          "EKEYSTYPE": "The keys argument has to be an array.",
          "ETTLTYPE": "The ttl argument has to be a number."
        };
        return NodeCache2;
      }.call(this);
    }).call(exports2);
  }
});

// node_modules/node-cache/index.js
var require_node_cache2 = __commonJS({
  "node_modules/node-cache/index.js"(exports2, module2) {
    (function() {
      var exports3;
      exports3 = module2.exports = require_node_cache();
      exports3.version = "5.1.2";
    }).call(exports2);
  }
});

// node_modules/@sap/xsenv/lib/redactServiceData.js
var require_redactServiceData = __commonJS({
  "node_modules/@sap/xsenv/lib/redactServiceData.js"(exports2, module2) {
    var debug = require_src()("xsenv");
    var secretKeys = ["certificate", "key", "verificationkey", "clientsecret", "password", "usersecret"];
    module2.exports.redactServicesSecretData = redactServicesSecretData;
    function redactServicesSecretData(serviceData) {
      if (!serviceData) {
        return {};
      }
      debug("Redacting Services Secret Data");
      let services = JSON.parse(JSON.stringify(serviceData));
      if (!Object.keys(services) || Object.keys(services).length === 0) {
        debug("Did not find any services keys in service data.");
        return;
      }
      for (let service in services) {
        if (!services[service].credentials) {
          return;
        }
        for (let sk in secretKeys) {
          let skey = secretKeys[sk];
          if (services[service].credentials[skey]) {
            services[service].credentials[skey] = "redacted";
          }
        }
      }
      debug(services);
      return services;
    }
  }
});

// node_modules/@sap/xsenv/lib/k8sservice.js
var require_k8sservice = __commonJS({
  "node_modules/@sap/xsenv/lib/k8sservice.js"(exports2) {
    var fs = require("fs");
    var assert = require("assert");
    var path = require("path");
    var debug = require_src()("xsenv");
    var DEFAULT_SECRETS_PATH = "/etc/secrets/sapcp/";
    var NodeCache = require_node_cache2();
    var k8sSecretsCache = new NodeCache({ stdTTL: 9 * 60 });
    var redactServicesSecretData = require_redactServiceData().redactServicesSecretData;
    exports2.readK8SServices = readK8SServices;
    var isFile = (filePath) => fs.statSync(filePath).isFile();
    var isDirectory = (dirPath) => fs.statSync(dirPath).isDirectory();
    function isJsonObject(str) {
      return /^{(.|\r?\n?)*}(\s)*$/.test(str);
    }
    function readFileContent(filePath) {
      let content = fs.readFileSync(filePath).toString("utf-8");
      const parseAllJson = process.env.XSENV_PARSE_ALL_JSON === "true" || false;
      if (!parseAllJson) {
        if (!isJsonObject(content)) {
          return content;
        }
      }
      try {
        content = JSON.parse(content);
      } catch (err) {
        debug("Content of file %s is not valid JSON object", filePath);
      }
      return content;
    }
    function readFiles(dirPath) {
      const result = {};
      for (let file of fs.readdirSync(dirPath)) {
        const filePath = path.join(dirPath, file);
        if (isFile(filePath)) {
          result[file] = readFileContent(filePath);
        }
      }
      return result;
    }
    function parseTags(tags, serviceName) {
      if (!tags) {
        return [serviceName];
      }
      if (process.env.XSENV_PARSE_ALL_JSON) {
        return [...tags];
      }
      return JSON.parse(tags);
    }
    function readInstance(serviceName, instanceName, instancePath) {
      const credentials = readFiles(instancePath);
      const tags = parseTags(credentials.tags, serviceName);
      if (!tags.includes(serviceName)) {
        tags.push(serviceName);
      }
      return {
        credentials,
        name: instanceName,
        label: credentials.label || serviceName,
        tags
      };
    }
    function readServiceInstances(serviceName, servicePath) {
      const result = {};
      for (let instanceName of fs.readdirSync(servicePath)) {
        const instancePath = path.join(servicePath, instanceName);
        if (isDirectory(instancePath)) {
          result[instanceName] = readInstance(serviceName, instanceName, instancePath);
        }
      }
      return result;
    }
    function readSecrets(secretsPath) {
      assert(isDirectory(secretsPath), "secrets path must be a directory");
      const result = {};
      for (let serviceName of fs.readdirSync(secretsPath)) {
        const servicePath = path.join(secretsPath, serviceName);
        if (isDirectory(servicePath)) {
          Object.assign(result, readServiceInstances(serviceName, servicePath));
        }
      }
      return result;
    }
    function readK8SServices(secretsPath, disableCache) {
      secretsPath = secretsPath || DEFAULT_SECRETS_PATH;
      assert(typeof secretsPath === "string", "secrets directory path must be string");
      let result = void 0;
      let cachedSecrets = k8sSecretsCache.get(`${secretsPath}-services`);
      if (cachedSecrets && !disableCache) {
        debug(`Cached Secrets found: ${secretsPath}-services`);
        let redactedResult = redactServicesSecretData(cachedSecrets);
        debug(redactedResult);
        return cachedSecrets;
      }
      if (fs.existsSync(secretsPath)) {
        result = readSecrets(secretsPath);
        debug(`Caching Secret: ${secretsPath}-services`);
        let redactedResult = redactServicesSecretData(result);
        debug(redactedResult);
        k8sSecretsCache.set(`${secretsPath}-services`, result);
      }
      return result;
    }
  }
});

// node_modules/@sap/xsenv/lib/serviceBindingService.js
var require_serviceBindingService = __commonJS({
  "node_modules/@sap/xsenv/lib/serviceBindingService.js"(exports2) {
    var fs = require("fs");
    var assert = require("assert");
    var path = require("path");
    var debug = require_src()("xsenv");
    exports2.readServiceBindingServices = readServiceBindingServices;
    var isDirectory = (dirPath) => fs.statSync(dirPath).isDirectory();
    function readFiles(dirPath) {
      const result = {};
      for (const dirEntry of fs.readdirSync(dirPath, { withFileTypes: true })) {
        const filePath = path.join(dirPath, dirEntry.name);
        if (isFile(filePath, dirEntry)) {
          result[dirEntry.name] = fs.readFileSync(filePath, "utf8");
        }
      }
      return result;
    }
    function isFile(p, entry) {
      if (entry.isFile()) {
        return true;
      }
      if (entry.isSymbolicLink()) {
        const target = fs.realpathSync(p);
        const targetStat = fs.statSync(target);
        if (targetStat.isFile()) {
          return true;
        }
      }
      return false;
    }
    var DEFAULT_META_DATA_PROPERTIES = { type: true, provider: true };
    function parseJsonSafe(str) {
      try {
        return JSON.parse(str);
      } catch (error) {
        return void 0;
      }
    }
    function buildBindingWithoutMetaData(properties) {
      const binding = { credentials: {} };
      for (const propertyName in properties) {
        if (propertyName in DEFAULT_META_DATA_PROPERTIES) {
          binding[propertyName] = properties[propertyName];
        } else {
          binding.credentials[propertyName] = properties[propertyName];
        }
      }
      return binding;
    }
    function parseProperties(properties, metaData = []) {
      const result = {};
      for (const metaDataProperty of metaData) {
        const { name } = metaDataProperty;
        const text = properties[name];
        if (name && typeof text !== "undefined") {
          switch (metaDataProperty.format) {
            case "text": {
              result[name] = text;
              break;
            }
            case "json": {
              const value = parseJsonSafe(text);
              if (metaDataProperty.container) {
                Object.assign(result, value);
              } else {
                result[name] = value;
              }
              break;
            }
            default: {
              debug("Unexpected format %s", metaDataProperty.format);
            }
          }
        } else {
          debug("Missing property %s", name);
        }
      }
      return result;
    }
    function readBinding(bindingPath, bindingName) {
      const properties = readFiles(bindingPath);
      const metaDataString = properties[".metadata"];
      let metaData;
      if (metaDataString) {
        metaData = parseJsonSafe(metaDataString);
        if (typeof metaData === "undefined") {
          debug("Cannot parse JSON: %s/.metadata", bindingPath);
        }
      }
      let binding;
      if (metaData) {
        binding = parseProperties(properties, metaData.metaDataProperties);
        binding.credentials = parseProperties(properties, metaData.credentialProperties);
      } else {
        binding = buildBindingWithoutMetaData(properties);
      }
      if (!binding.type) {
        return void 0;
      }
      binding.name = bindingName;
      return binding;
    }
    function readServiceBindingsServicesFromPath(serviceBindingRoot) {
      assert(isDirectory(serviceBindingRoot), "secrets path must be a directory");
      const bindings = {};
      for (const bindingEntry of fs.readdirSync(serviceBindingRoot, { withFileTypes: true })) {
        if (bindingEntry.isDirectory()) {
          const bindingPath = path.join(serviceBindingRoot, bindingEntry.name);
          const binding = readBinding(bindingPath, bindingEntry.name);
          if (binding) {
            bindings[binding.name] = binding;
          }
        }
      }
      return bindings;
    }
    function readServiceBindingServices(serviceBindingRoot) {
      serviceBindingRoot = serviceBindingRoot || process.env.SERVICE_BINDING_ROOT;
      if (typeof serviceBindingRoot === "string" && serviceBindingRoot.length > 0) {
        return fs.existsSync(serviceBindingRoot) ? readServiceBindingsServicesFromPath(serviceBindingRoot) : void 0;
      } else {
        return void 0;
      }
    }
  }
});

// node_modules/@sap/xsenv/lib/xsservices.js
var require_xsservices = __commonJS({
  "node_modules/@sap/xsenv/lib/xsservices.js"(exports2) {
    var assert = require("assert");
    var VError = require_verror();
    var debug = require_src()("xsenv");
    var fs = require("fs");
    var serviceFilter = require_filter();
    var readCFServices = require_cfservice().readCFServices;
    var readK8SServices = require_k8sservice().readK8SServices;
    var readServiceBindingServices = require_serviceBindingService().readServiceBindingServices;
    var redactServicesSecretData = require_redactServiceData().redactServicesSecretData;
    exports2.getServices = getServices;
    exports2.filterServices = filterServices;
    exports2.serviceCredentials = serviceCredentials;
    exports2.readServices = readServices;
    function getServices(arg1, arg2, arg3) {
      const path = typeof arg1 === "string" ? arg1 : void 0;
      const query = typeof arg1 === "string" ? arg2 : arg1;
      const servicesFile = typeof arg1 === "string" ? arg3 : arg2;
      assert(query && typeof query === "object", "Missing mandatory query parameter");
      var defaultServices = loadDefaultServices(servicesFile);
      var result = {};
      for (var key in query) {
        var matches = filterServices(path, query[key]);
        if (matches.length === 1) {
          result[key] = matches[0].credentials;
        } else if (matches.length > 1) {
          throw new VError("Found %d services matching %s", matches.length, key);
        } else {
          if (!defaultServices[key]) {
            throw new VError("No service matches %s", key);
          }
          debug("No service in VCAP_SERVICES matches %s. Returning default configuration from %s", key, servicesFile);
          result[key] = defaultServices[key];
        }
      }
      return result;
    }
    function loadDefaultServices(servicesFile) {
      var defaultServices = {};
      if (servicesFile !== null) {
        servicesFile = servicesFile || "default-services.json";
        if (fs.existsSync(servicesFile)) {
          debug("Loading default service configuration from %s", servicesFile);
          try {
            defaultServices = JSON.parse(fs.readFileSync(servicesFile, "utf8"));
          } catch (err) {
            throw new VError(err, "Could not parse %s", servicesFile);
          }
        }
      }
      return defaultServices;
    }
    function filterServices(arg1, arg2) {
      const path = arguments.length === 1 ? void 0 : arg1;
      const filter = arguments.length === 1 ? arg1 : arg2;
      let filterResults = filterCFServices(path, filter);
      if (!hasResults(filterResults)) {
        filterResults = filterServiceBindingServices(path, filter);
      }
      if (!hasResults(filterResults)) {
        filterResults = filterK8SServices(path, filter);
      }
      return filterResults;
    }
    function filterCFServices(path, filter) {
      const results = serviceFilter.apply(readCFServices(), filter);
      logFilterResults("CF", filter, path, results);
      return results;
    }
    function filterServiceBindingServices(path, filter) {
      const results = serviceFilter.apply(readServiceBindingServices(path), filter);
      logFilterResults("Service Binding", filter, path || "default", results);
      return results;
    }
    function filterK8SServices(path, filter) {
      const results = serviceFilter.apply(readK8SServices(path), filter);
      logFilterResults("K8s", filter, path || "default", results);
      return results;
    }
    function hasResults(results) {
      return results && Array.isArray(results) && results.length > 0;
    }
    function logFilterResults(serviceType, filter, path, results) {
      let redactedResult = redactServicesSecretData(results);
      debug("%s Service filter with filter: %s and path: %s, returned: %s.", serviceType, filter, path, redactedResult);
    }
    function serviceCredentials(arg1, arg2) {
      const path = arguments.length === 1 ? void 0 : arg1;
      const filter = arguments.length === 1 ? arg1 : arg2;
      var matches = path ? filterServices(path, filter) : filterServices(filter);
      if (matches.length !== 1) {
        throw new VError("Found %d matching services", matches.length);
      }
      return matches[0].credentials;
    }
    function readServices(path, options) {
      let cfServices = readCFServices();
      if (cfServices && Object.keys(cfServices).length > 0) {
        let redactedServices2 = redactServicesSecretData(cfServices);
        debug("Found services in VCAP_SERVICES_FILE_PATH or VCAP_SERVICES, returning: %s", redactedServices2);
        return cfServices;
      }
      let serviceBindingServices = readServiceBindingServices(path);
      if (serviceBindingServices && Object.keys(serviceBindingServices).length > 0) {
        let redactedServices2 = redactServicesSecretData(serviceBindingServices);
        debug("Found Service Bindings, returning: %s", redactedServices2);
        return serviceBindingServices;
      }
      let k8sServices = readK8SServices(path, options && options.disableCache);
      let redactedServices = redactServicesSecretData(k8sServices);
      debug("Empty VCAP_SERVICES, returning K8s services: %s.", JSON.stringify(redactedServices));
      return k8sServices || {};
    }
  }
});

// node_modules/@sap/xsenv/lib/cacert.js
var require_cacert = __commonJS({
  "node_modules/@sap/xsenv/lib/cacert.js"(exports2) {
    var debug = require_src()("xsenv");
    var path = require("path");
    var fs = require("fs");
    var assert = require("assert");
    var VError = require_verror();
    exports2.loadCertificates = loadCertificates;
    function loadCertificates(certPath) {
      assert(!certPath || typeof certPath === "string", "certPath argument should be a string");
      certPath = certPath || process.env.XS_CACERT_PATH;
      if (certPath) {
        debug("Loading certificate(s) %s", certPath);
        try {
          return certPath.split(path.delimiter).map(function(f) {
            return fs.readFileSync(f);
          });
        } catch (err) {
          throw new VError(err, "Could not load certificate(s) " + certPath);
        }
      }
    }
  }
});

// node_modules/@sap/xsenv/lib/loadEnv.js
var require_loadEnv = __commonJS({
  "node_modules/@sap/xsenv/lib/loadEnv.js"(exports2, module2) {
    var fs = require("fs");
    var debug = require_src()("xsenv");
    var VError = require_verror();
    module2.exports = loadEnv;
    function loadEnv(jsonFile) {
      jsonFile = jsonFile || "default-env.json";
      if (!fs.existsSync(jsonFile)) {
        return;
      }
      debug("Loading environment from %s", jsonFile);
      try {
        var json2 = JSON.parse(fs.readFileSync(jsonFile, "utf8"));
      } catch (err) {
        throw new VError(err, "Could not parse %s", jsonFile);
      }
      for (var key in json2) {
        if (key in process.env) {
          continue;
        }
        var val = json2[key];
        if (typeof val === "object") {
          process.env[key] = JSON.stringify(val);
        } else {
          process.env[key] = val + "";
        }
      }
    }
  }
});

// node_modules/@sap/xsenv/index.js
var require_xsenv = __commonJS({
  "node_modules/@sap/xsenv/index.js"(exports2) {
    var cfservice = require_cfservice();
    var xsservices = require_xsservices();
    var cacert = require_cacert();
    exports2.loadCertificates = cacert.loadCertificates;
    exports2.loadEnv = require_loadEnv();
    exports2.getServices = xsservices.getServices;
    exports2.filterServices = xsservices.filterServices;
    exports2.serviceCredentials = xsservices.serviceCredentials;
    exports2.readServices = xsservices.readServices;
    exports2.readCFServices = cfservice.readCFServices;
    exports2.cfServiceCredentials = xsservices.serviceCredentials;
    exports2.filterCFServices = cfservice.filterCFServices;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/environment-accessor/service-bindings.js
var require_service_bindings = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/environment-accessor/service-bindings.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getServiceBindings = getServiceBindings;
    exports2.getServiceBinding = getServiceBinding2;
    exports2.resolveServiceBinding = resolveServiceBinding;
    exports2.getServiceBindingByInstanceName = getServiceBindingByInstanceName;
    var util_1 = require_dist2();
    var xsenv = __importStar(require_xsenv());
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "environment-accessor"
    });
    function getServiceBindings(service) {
      return xsenv.filterServices({ label: service });
    }
    function getServiceBinding2(service) {
      const services = xsenv.filterServices({ label: service });
      if (!services.length) {
        logger8.warn(`Could not find service binding of type '${service}'. This might cause errors in other parts of the application.`);
      } else if (services.length > 1) {
        logger8.warn(`Found more than one service binding for service type '${service}':${services.map(({ name }) => `
	- ${name}`).join("")}
Selecting the first one.`);
      }
      return services[0];
    }
    function resolveServiceBinding(service) {
      if (typeof service === "string") {
        const serviceInstance = getServiceBinding2(service);
        if (!serviceInstance) {
          throw Error(`Could not find service binding of type '${service}'.`);
        }
        return serviceInstance;
      }
      return service;
    }
    function getServiceBindingByInstanceName(serviceInstanceName) {
      const service = xsenv.filterServices(serviceInstanceName);
      if (!service.length) {
        throw Error(`Could not find service with name: '${serviceInstanceName}'.`);
      }
      if (service.length > 1) {
        throw Error(`Found multiple services with name: '${serviceInstanceName}'.`);
      }
      return service[0];
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/environment-accessor/service-credentials.js
var require_service_credentials = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/environment-accessor/service-credentials.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getServiceCredentials = getServiceCredentials;
    var util_1 = require_dist2();
    var jwt_1 = require_jwt();
    var service_bindings_1 = require_service_bindings();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "environment-accessor"
    });
    function getServiceCredentials(service, token) {
      const credentialsList = getServiceBindingsWithCredentials(service);
      if (!credentialsList.length) {
        logger8.debug(`Could not find binding to service '${service}', that includes credentials.`);
        return;
      }
      if (token) {
        const credentials = getCredentialsWithJwt(service, credentialsList, typeof token === "string" ? (0, jwt_1.decodeJwt)(token) : token);
        return credentials;
      }
      logger8.debug(`No JWT given to select binding to service '${service}'.`);
      return getCredentialsWithoutJwt(service, credentialsList);
    }
    function getServiceBindingsWithCredentials(service) {
      const services = (0, service_bindings_1.getServiceBindings)(service);
      const serviceCredentials = services.map(({ credentials }) => credentials).filter((credentials) => credentials);
      if (serviceCredentials.length < services.length) {
        const difference = services.length - serviceCredentials.length;
        logger8.warn(`Ignoring ${difference} service binding${difference > 1 ? "s" : ""} of service type '${service}' because of missing credentials.`);
      }
      return serviceCredentials;
    }
    function getCredentialsWithJwt(service, credentials, token) {
      const eligibleCredentials = credentials.filter((c) => matchesClientId(c, token) || matchesAudience(c, token));
      logResult(service, eligibleCredentials, true);
      return eligibleCredentials[0];
    }
    function getCredentialsWithoutJwt(service, credentials) {
      logResult(service, credentials, false);
      return credentials[0];
    }
    function logResult(service, credentials, usedToken) {
      if (credentials.length === 1) {
        logger8.debug(`Found one service binding for service '${service}'${usingJwtText(usedToken)}. ${appNames(credentials)}`);
      } else if (credentials.length > 1) {
        logger8.warn(`Found multiple bindings for service '${service}'${usingJwtText(usedToken)}. ${appNames(credentials)}
Choosing first one ('${credentials[0].xsappname}').`);
      } else if (usedToken) {
        logger8.warn(`Found no service binding for service '${service}' matching either the token's client id or audience.`);
      }
    }
    function usingJwtText(usedToken) {
      return usedToken ? " using JWT" : "";
    }
    function appNames(credentials) {
      const names = credentials.map(({ xsappname }) => xsappname);
      if (names.length) {
        return names.length === 1 ? `App name: ${names[0]}.` : `App names:${names.map((name) => `
	- ${name}`).join("")}`;
      }
      return "";
    }
    function matchesClientId(credentials, token) {
      return credentials.clientid === token.client_id;
    }
    function matchesAudience(credentials, token) {
      return (0, jwt_1.audiences)(token).includes(credentials.xsappname);
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/environment-accessor/destination.js
var require_destination = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/environment-accessor/destination.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getDestinationServiceCredentials = getDestinationServiceCredentials;
    var service_credentials_1 = require_service_credentials();
    function getDestinationServiceCredentials() {
      const credentials = (0, service_credentials_1.getServiceCredentials)("destination");
      if (!credentials) {
        throw new Error("Could not find binding to the destination service.");
      }
      return credentials;
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/environment-accessor/environment-accessor-types.js
var require_environment_accessor_types = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/environment-accessor/environment-accessor-types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/jwt-decode/build/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/jwt-decode/build/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.jwtDecode = exports2.InvalidTokenError = void 0;
    var InvalidTokenError = class extends Error {
    };
    exports2.InvalidTokenError = InvalidTokenError;
    InvalidTokenError.prototype.name = "InvalidTokenError";
    function b64DecodeUnicode(str) {
      return decodeURIComponent(atob(str).replace(/(.)/g, (m, p) => {
        let code = p.charCodeAt(0).toString(16).toUpperCase();
        if (code.length < 2) {
          code = "0" + code;
        }
        return "%" + code;
      }));
    }
    function base64UrlDecode(str) {
      let output = str.replace(/-/g, "+").replace(/_/g, "/");
      switch (output.length % 4) {
        case 0:
          break;
        case 2:
          output += "==";
          break;
        case 3:
          output += "=";
          break;
        default:
          throw new Error("base64 string is not of the correct length");
      }
      try {
        return b64DecodeUnicode(output);
      } catch (err) {
        return atob(output);
      }
    }
    function jwtDecode(token, options) {
      if (typeof token !== "string") {
        throw new InvalidTokenError("Invalid token specified: must be a string");
      }
      options || (options = {});
      const pos = options.header === true ? 0 : 1;
      const part = token.split(".")[pos];
      if (typeof part !== "string") {
        throw new InvalidTokenError(`Invalid token specified: missing part #${pos + 1}`);
      }
      let decoded;
      try {
        decoded = base64UrlDecode(part);
      } catch (e) {
        throw new InvalidTokenError(`Invalid token specified: invalid base64 for part #${pos + 1} (${e.message})`);
      }
      try {
        return JSON.parse(decoded);
      } catch (e) {
        throw new InvalidTokenError(`Invalid token specified: invalid json for part #${pos + 1} (${e.message})`);
      }
    }
    exports2.jwtDecode = jwtDecode;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/XssecError.js
var require_XssecError = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/XssecError.js"(exports2, module2) {
    var XssecError = class extends Error {
      /** 
       * @type {number} Suggested HTTP response code for consumer application catching this error
       */
      #statusCode;
      constructor(message) {
        super(message);
        this.name = "XssecError";
        this.statusCode = 500;
      }
      get statusCode() {
        return this.#statusCode;
      }
      /** 
       * @type {number} Lowercased version of {@link #statusCode} for backward-compatibility
       */
      get statuscode() {
        return this.#statusCode;
      }
      /** 
       * Allows overriding suggested response status code in subclasses, e.g. 403 in ValidationError 
       * @internal
       * @param {number} statusCode - Suggested HTTP response code for consumer application catching this error
       */
      set statusCode(statusCode) {
        this.#statusCode = statusCode;
      }
    };
    module2.exports = XssecError;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/validation/ValidationError.js
var require_ValidationError = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/validation/ValidationError.js"(exports2, module2) {
    var XssecError = require_XssecError();
    var ValidationError = class extends XssecError {
      constructor(message) {
        super(message);
        this.name = "ValidationError";
        this.statusCode = 401;
      }
    };
    module2.exports = ValidationError;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/validation/InvalidJwtError.js
var require_InvalidJwtError = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/validation/InvalidJwtError.js"(exports2, module2) {
    var ValidationError = require_ValidationError();
    var InvalidJwtError = class extends ValidationError {
      /** @type {Error} Error encountered during parsing */
      #parseError;
      constructor(jwt, parseError, message = `JWT could not be parsed: ${parseError.message}`) {
        super(jwt, message);
        this.name = "InvalidJwtError";
        this.jwt = jwt;
        this.#parseError = parseError;
      }
      get parseError() {
        return this.#parseError;
      }
      set parseError(value) {
        this.#parseError = value;
      }
    };
    module2.exports = InvalidJwtError;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/util/constants.js
var require_constants2 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/util/constants.js"(exports2, module2) {
    module2.exports = {
      APP_TID_HEADER: "x-app_tid",
      AZP_HEADER: "x-azp",
      CLIENT_CERTIFICATE_HEADER: "x-client_cert",
      CLIENTID_HEADER: "x-client_id",
      CORRELATIONID_HEADER_VCAP: "x-vcap-request-id",
      CORRELATIONID_HEADERS: [
        "x-correlation-id",
        "x-request-id",
        "x-correlationid",
        "x-vcap-request-id"
      ],
      DEFAULT_TIMEOUT: 2e3,
      DEFAULT_JWT_BEARER_FETCH_TIMEOUT: 1e4,
      FORWARDED_CLIENTCERTIFICATE_HEADER: "x-forwarded-client-cert",
      MAX_TIMEOUT: 1e4,
      GRANTTYPE_SAML2BEARER: "urn:ietf:params:oauth:grant-type:saml2-bearer",
      GRANTTYPE_JWTBEARER: "urn:ietf:params:oauth:grant-type:jwt-bearer",
      GRANTTYPE_USERTOKEN: "user_token",
      GRANTTYPE_REFRESHTOKEN: "refresh_token",
      GRANTTYPE_PASSWORD: "password",
      GRANTTYPE_CLIENTCREDENTIALS: "client_credentials",
      GRANTTYPE_AUTHORIZATIONCODE: "authorization_code",
      GRANTTYPE_IMPLICIT: "implicit",
      HTTP_SCHEME: "http://",
      HTTPS_SCHEME: "https://",
      PEM_HEADER: "-----BEGIN CERTIFICATE-----",
      PEM_FOOTER: "-----END CERTIFICATE-----",
      USER_AGENT: "nodejs-xssec-4",
      SERVICE_PLAN_HEADER: "x-osb_plan",
      TOKEN_DATE_LEEWAY: 60,
      // seconds around nbf / exp time in which token is still considered valid
      X5T_CNF_CLAIM: "x5t#S256",
      ZID_HEADER: "x-zid",
      ZID_QUERY_PARAMETER: "zid"
    };
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/cache/LRUCache.js
var require_LRUCache = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/cache/LRUCache.js"(exports2, module2) {
    var LRUCache = class {
      /**
       * Creates an instance of LRUCache.
       * @param {number} size - The maximum number of items the cache can hold.
       */
      constructor(size) {
        this.size = size;
        this.map = /* @__PURE__ */ new Map();
      }
      /**
       * Retrieve a value from the cache.
       * @param {string} key - The key of the item to retrieve.
       * @returns {*} The value associated with the key, or null if the key does not exist.
       */
      get(key) {
        if (!this.map.has(key)) return null;
        const value = this.map.get(key);
        this.map.delete(key);
        this.map.set(key, value);
        return value;
      }
      /**
       * Insert or update a value in the cache.
       * @param {string} key - The key of the item to insert or update.
       * @param {*} value - The value to associate with the key.
       */
      set(key, value) {
        if (this.map.has(key)) {
          this.map.delete(key);
        } else if (this.map.size >= this.size) {
          const oldestKey = this.map.keys().next().value;
          this.map.delete(oldestKey);
        }
        this.map.set(key, value);
      }
    };
    module2.exports = LRUCache;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/token/Token.js
var require_Token = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/token/Token.js"(exports2, module2) {
    var { jwtDecode } = require_cjs();
    var InvalidJwtError = require_InvalidJwtError();
    var { TOKEN_DATE_LEEWAY } = require_constants2();
    var LRUCache = require_LRUCache();
    var Token = class _Token {
      /**
       * A shared jwt->{header, payload} cache that is used to avoid decoding the same token multiple times.
       * @type {import("../util/Types").Cache}
       */
      static decodeCache = null;
      /**
       * Enables the shared decode cache for tokens.
       * @param {DecodeCacheConfig} [config] - Optional configuration for the decode cache.
       */
      static enableDecodeCache(config = {}) {
        if (config.impl) {
          _Token.decodeCache = config.impl;
        } else {
          _Token.decodeCache = new LRUCache(config?.size || 100);
        }
      }
      /**
       * Disables the shared decode cache for tokens.
       */
      static disableDecodeCache() {
        _Token.decodeCache = null;
      }
      #jwt;
      /** @type {JwtHeader} */
      #header;
      // parsed header
      /** @type {JwtPayload} */
      #payload;
      // parsed payload
      /**
       * @param {string|null} jwt 
       * @param {object} [content] - optional decoded content
       * @param {JwtHeader & { [key: string]: any }} [content.header] - Optional parsed header (used instead of decoding jwt parameter if both header/payload are provided)
       * @param {JwtPayload & { [key: string]: any }} [content.payload] - Optional parsed payload (used instead of decoding jwt parameter if both header/payload are provided)
       */
      constructor(jwt, { header, payload } = {}) {
        this.#jwt = jwt;
        if (!header || !payload) {
          const cached = _Token.decodeCache?.get(jwt);
          if (cached != null) {
            header = cached.header;
            payload = cached.payload;
          } else {
            ({ header, payload } = this.#parseJwt(jwt));
            _Token.decodeCache?.set(jwt, { header, payload });
          }
        }
        this.#header = header;
        this.#payload = payload;
      }
      #parseJwt(jwt) {
        try {
          return {
            header: jwtDecode(jwt, { header: true }),
            payload: jwtDecode(jwt)
          };
        } catch (e) {
          throw new InvalidJwtError(jwt, e);
        }
      }
      get audiences() {
        if (this.payload.aud) {
          return Array.isArray(this.payload.aud) ? this.payload.aud : [this.payload.aud];
        } else {
          return null;
        }
      }
      get azp() {
        return this.payload.azp;
      }
      /**
       * @returns {string|null} clientId used to fetch the token
       */
      get clientId() {
        if (this.azp) {
          return this.azp;
        }
        if (this.audiences == null || this.audiences.length != 1) {
          return null;
        }
        return this.audiences[0] || this.payload.cid;
      }
      get email() {
        return this.payload.email;
      }
      /**
       * Returns whether the token is expired based on claim exp (expiration time).
       * There is a 1min leeway after the exp in which the token still counts as valid to account for clock skew.
       * @return {Boolean} false if token has a positive {@link remainingTime}, true otherwise
       */
      get expired() {
        return this.remainingTime <= 0;
      }
      get expirationDate() {
        return this.payload.exp ? new Date(this.payload.exp * 1e3) : null;
      }
      /**
       * @returns {string|null} family name of the user
       */
      get familyName() {
        return this.payload.ext_attr?.family_name || this.payload.family_name;
      }
      /**
       * @returns {string|null} first name of the user
       */
      get givenName() {
        return this.payload.ext_attr?.given_name || this.payload.given_name;
      }
      get grantType() {
        return this.payload.grant_type;
      }
      /** @return {JwtHeader} Token header as parsed object */
      get header() {
        return this.#header;
      }
      get issuer() {
        return this.payload.iss;
      }
      get issueDate() {
        return this.payload.iat ? new Date(this.payload.iat * 1e3) : null;
      }
      /** @return {String} JWT used to construct this Token instance as raw String */
      get jwt() {
        return this.#jwt;
      }
      /**
       * Returns whether the token is not yet valid based on the optional nbf (no use before) claim.
       * There is a 1min leeway before the nbf in which the token already counts as valid to account for clock skew.
       * @return {Boolean} true if token has nbf and nbf date lies in future, false otherwise 
       */
      get notYetValid() {
        return this.payload.nbf != null && Math.floor(Date.now() / 1e3) + TOKEN_DATE_LEEWAY < this.payload.nbf;
      }
      get origin() {
        return this.payload.origin;
      }
      /** @return {JwtPayload} Token payload as parsed object */
      get payload() {
        return this.#payload;
      }
      /**
       * Returns the remaining time until expiration in seconds based on claim exp (expiration time).
       * There is a 1min leeway after the exp in which the token still counts as valid to account for clock skew.
       * @returns seconds until expiration or 0 if expired
       */
      get remainingTime() {
        return Math.max(0, this.payload.exp + TOKEN_DATE_LEEWAY - Math.floor(Date.now() / 1e3));
      }
      get subject() {
        return this.payload.sub;
      }
      get userName() {
        return this.payload.user_name;
      }
      get userId() {
        return this.payload.user_uuid;
      }
      // Methods for backward-compatibility   
      getAudiencesArray() {
        return this.audiences;
      }
      getAzp() {
        return this.azp;
      }
      getClientId() {
        return this.clientId;
      }
      getEmail() {
        return this.email;
      }
      getExpirationDate() {
        return this.expirationDate;
      }
      getFamilyName() {
        return this.familyName;
      }
      getGivenName() {
        return this.givenName;
      }
      getGrantType() {
        return this.grantType;
      }
      getHeader() {
        return this.header;
      }
      getIssuedAt() {
        return this.issueDate;
      }
      getIssuer() {
        if (this.issuer && !this.issuer.startsWith("http")) {
          return `https://${this.issuer}`;
        } else {
          return this.issuer;
        }
      }
      getPayload() {
        return this.payload;
      }
      getSubject() {
        return this.subject;
      }
      getTokenValue() {
        return this.jwt;
      }
      getUserId() {
        return this.userId;
      }
    };
    module2.exports = Token;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/validation/MissingJwtError.js
var require_MissingJwtError = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/validation/MissingJwtError.js"(exports2, module2) {
    var ValidationError = require_ValidationError();
    var MissingJwtError = class extends ValidationError {
      constructor(message = "Request contains no jwt bearer token and neither a jwt nor a decoded Token were contained in contextConfig of createSecurityContext.") {
        super(message);
        this.name = "MissingJwtError";
      }
    };
    module2.exports = MissingJwtError;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/context/SecurityContext.js
var require_SecurityContext = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/context/SecurityContext.js"(exports2, module2) {
    var { CORRELATIONID_HEADERS, FORWARDED_CLIENTCERTIFICATE_HEADER } = require_constants2();
    var SecurityContext = class {
      /** @type {S} */
      #service;
      /** @type {T} */
      #token;
      /** @type {SecurityContextConfig} */
      config;
      /**
       * @param {S} service - The service instance.
       * @param {T} token - The token instance.
       * @param {SecurityContextConfig} contextConfig - The security context configuration.
       */
      constructor(service, token, contextConfig) {
        this.#service = service;
        this.#token = token;
        this.config = contextConfig;
      }
      /**
       * The Service instance on which this SecurityContext has been created.
       * @returns {S} service
       */
      get service() {
        return this.#service;
      }
      /**
       * @param {S} service
       */
      set service(service) {
        this.#service = service;
      }
      /**
       * The Token instance from which this SecurityContext has ben created.
       * @returns {T} token
       */
      get token() {
        return this.#token;
      }
      /**
       * @param {T} token
       */
      set token(token) {
        this.#token = token;
      }
      // Methods for backwards-compatibility   
      getAppToken() {
        return this.token.jwt;
      }
      getEmail() {
        return this.getUserInfo().email;
      }
      getExpirationDate() {
        return this.token.expirationDate;
      }
      getFamilyName() {
        return this.getUserInfo().familyName;
      }
      getGivenName() {
        return this.getUserInfo().givenName;
      }
      getGrantType() {
        return this.token.grantType;
      }
      getLogonName() {
        return this.getUserInfo().logonName;
      }
      getUserInfo() {
        return {
          email: this.token.email,
          familyName: this.token.familyName,
          givenName: this.token.givenName,
          logonName: this.token.payload.user_name
        };
      }
      getTokenInfo() {
        return this.token;
      }
      /**
       * Tries to fill up missing properties of the security context configuration from the req object in the configuration.
       * @param {SecurityContextConfig} contextConfig 
       */
      static buildContextConfig(contextConfig) {
        let { req } = contextConfig;
        for (let i = 0; contextConfig.correlationId == null && i < CORRELATIONID_HEADERS.length; i++) {
          contextConfig.correlationId = req?.headers?.[CORRELATIONID_HEADERS[i]];
        }
        contextConfig.clientCertificatePem ??= req?.headers?.[FORWARDED_CLIENTCERTIFICATE_HEADER];
        contextConfig.jwt ??= req?.headers?.authorization?.split(" ")[1];
        contextConfig.skipValidation ??= false;
        contextConfig.tokenDecodeCache ??= null;
      }
    };
    module2.exports = SecurityContext;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/configuration/ConfigurationError.js
var require_ConfigurationError = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/configuration/ConfigurationError.js"(exports2, module2) {
    var XssecError = require_XssecError();
    var ConfigurationError = class extends XssecError {
      constructor(message) {
        super(message);
        this.name = "ConfigurationError";
        this.statusCode = 500;
      }
    };
    module2.exports = ConfigurationError;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/validation/TokenValidationError.js
var require_TokenValidationError = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/validation/TokenValidationError.js"(exports2, module2) {
    var debug = require_src();
    var debugLog = debug("xssec");
    var ValidationError = require_ValidationError();
    var TokenValidationError = class extends ValidationError {
      /** @type {Token} */
      #token;
      constructor(token, message = "Token is not valid.") {
        super(message);
        this.name = "TokenValidationError";
        this.token = token;
        if (debugLog.enabled) {
          this.jwt = token.jwt;
        }
      }
      get token() {
        return this.#token;
      }
      set token(value) {
        this.#token = value;
      }
    };
    module2.exports = TokenValidationError;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/validation/ExpiredTokenError.js
var require_ExpiredTokenError = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/validation/ExpiredTokenError.js"(exports2, module2) {
    var TokenValidationError = require_TokenValidationError();
    var ExpiredTokenError = class extends TokenValidationError {
      constructor(token, message = "Token is expired.") {
        super(token, message);
        this.name = "ExpiredTokenError";
      }
    };
    module2.exports = ExpiredTokenError;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/validation/InvalidClientCertificateError.js
var require_InvalidClientCertificateError = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/validation/InvalidClientCertificateError.js"(exports2, module2) {
    var ValidationError = require_ValidationError();
    var InvalidClientCertificateError = class extends ValidationError {
      /** @type {Error} Error encountered during parsing */
      #parseError;
      constructor(clientCertificate, parseError, message = `The forwarded client certificate could not be parsed as X509 certificate: ${parseError.message}`) {
        super(message);
        this.name = "InvalidClientCertificateError";
        this.clientCertificate = clientCertificate;
        this.parseError = parseError;
      }
      get parseError() {
        return this.#parseError;
      }
      set parseError(value) {
        this.#parseError = value;
      }
    };
    module2.exports = InvalidClientCertificateError;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/configuration/InvalidCredentialsError.js
var require_InvalidCredentialsError = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/configuration/InvalidCredentialsError.js"(exports2, module2) {
    var ConfigurationError = require_ConfigurationError();
    var InvalidCredentialsError = class extends ConfigurationError {
      constructor(message = "The service credentials are missing mandatory properties.") {
        super(message);
        this.name = "InvalidCredentialsError";
      }
    };
    module2.exports = InvalidCredentialsError;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/validation/InvalidIssuerError.js
var require_InvalidIssuerError = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/validation/InvalidIssuerError.js"(exports2, module2) {
    var TokenValidationError = require_TokenValidationError();
    var InvalidIssuerError = class extends TokenValidationError {
      /** @type {Error} Error encountered during parsing */
      #parseError;
      constructor(token, parseError, message = `Issuer ${token.issuer} was not a valid domain or URL for use with https. Protocol schemes other than https:// are not supported.`) {
        super(token, message);
        this.name = "InvalidIssuerError";
        this.#parseError = parseError;
      }
      get parseError() {
        return this.#parseError;
      }
      set parseError(value) {
        this.#parseError = value;
      }
    };
    module2.exports = InvalidIssuerError;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/validation/InvalidTokenSignatureError.js
var require_InvalidTokenSignatureError = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/validation/InvalidTokenSignatureError.js"(exports2, module2) {
    var TokenValidationError = require_TokenValidationError();
    var InvalidTokenSignatureError = class extends TokenValidationError {
      constructor(token, message = "Token signature is invalid.") {
        super(token, message);
        this.name = "InvalidTokenSignatureError";
      }
    };
    module2.exports = InvalidTokenSignatureError;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/validation/MissingClientCertificateError.js
var require_MissingClientCertificateError = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/validation/MissingClientCertificateError.js"(exports2, module2) {
    var ValidationError = require_ValidationError();
    var MissingClientCertificateError = class extends ValidationError {
      constructor(message = "Request is missing a forwarded client certificate which is required to validate the token.") {
        super(message);
        this.name = "MissingClientCertificateError";
      }
    };
    module2.exports = MissingClientCertificateError;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/validation/MissingIssuerError.js
var require_MissingIssuerError = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/validation/MissingIssuerError.js"(exports2, module2) {
    var TokenValidationError = require_TokenValidationError();
    var MissingIssuerError = class extends TokenValidationError {
      constructor(token, message = "Token is missing an issuer which is required to validate the signature.") {
        super(token, message);
        this.name = "MissingIssuerError";
      }
    };
    module2.exports = MissingIssuerError;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/validation/MissingKidError.js
var require_MissingKidError = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/validation/MissingKidError.js"(exports2, module2) {
    var ValidationError = require_ValidationError();
    var MissingKidError = class extends ValidationError {
      /** @type {string} */
      #kid;
      constructor(kid, message = `JWKS is missing key for kid=${kid} specified in token header.`) {
        super(message);
        this.name = "MissingKidError";
        this.#kid = kid;
      }
      get kid() {
        return this.#kid;
      }
      set kid(value) {
        this.#kid = value;
      }
    };
    module2.exports = MissingKidError;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/validation/MissingVerificationKeyError.js
var require_MissingVerificationKeyError = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/validation/MissingVerificationKeyError.js"(exports2, module2) {
    var ValidationError = require_ValidationError();
    var MissingVerificationKeyError = class extends ValidationError {
      constructor(message = "XSUAA service credentials are missing a verificationkey that would be required as JWKS fallback to validate the given token.") {
        super(message);
        this.name = "MissingVerificationKeyError";
      }
    };
    module2.exports = MissingVerificationKeyError;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/network/NetworkError.js
var require_NetworkError = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/network/NetworkError.js"(exports2, module2) {
    var XssecError = require_XssecError();
    var NetworkError = class extends XssecError {
      /** @type {String} */
      #correlationId;
      constructor(message = "A network error has occured.") {
        super(message);
        this.name = "NetworkError";
        this.statusCode = 500;
      }
      get correlationId() {
        return this.#correlationId;
      }
      set correlationId(value) {
        this.#correlationId = value;
      }
    };
    module2.exports = NetworkError;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/validation/NotYetValidTokenError.js
var require_NotYetValidTokenError = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/validation/NotYetValidTokenError.js"(exports2, module2) {
    var TokenValidationError = require_TokenValidationError();
    var NotYetValidTokenError = class extends TokenValidationError {
      constructor(token, message = "The token is not yet valid because its 'nbf' (no use before) date lies in the future.") {
        super(token, message);
        this.name = "NotYetValidTokenError";
      }
    };
    module2.exports = NotYetValidTokenError;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/network/RequestError.js
var require_RequestError = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/network/RequestError.js"(exports2, module2) {
    var NetworkError = require_NetworkError();
    var RequestError = class extends NetworkError {
      /** @type {import("https").RequestOptions & {name: string}} */
      #request;
      /** @type {Error|Error[]} the original error(s) of the HTTP client for debugging. Do not code against this property as the internal HTTP client implementation may change anytime. */
      #originalError;
      #url;
      constructor(url, request, originalError, message = `HTTP request [${request.name}] to ${url} could not be sent due to: ${originalError.toString()}.`) {
        super(message);
        this.name = "RequestError";
        this.url = url;
        this.request = request;
        this.originalError = originalError;
      }
      get url() {
        return this.#url;
      }
      set url(value) {
        this.#url = value;
      }
      get request() {
        return this.#request;
      }
      set request(value) {
        this.#request = value;
      }
      get originalError() {
        return this.#originalError;
      }
      set originalError(error) {
        this.#originalError = error;
      }
    };
    module2.exports = RequestError;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/network/ResponseError.js
var require_ResponseError = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/network/ResponseError.js"(exports2, module2) {
    var NetworkError = require_NetworkError();
    var ResponseError = class extends NetworkError {
      #url;
      #request;
      #responseCode;
      #responseText;
      constructor(url, request, responseCode, responseText, message = `HTTP response from ${url} was ${responseCode}: ${responseText}.`) {
        super(message);
        this.name = "ResponseError";
        this.url = url;
        this.request = request;
        this.responseCode = responseCode;
        this.responseText = responseText;
      }
      get url() {
        return this.#url;
      }
      set url(value) {
        this.#url = value;
      }
      get request() {
        return this.#request;
      }
      set request(value) {
        this.#request = value;
      }
      get responseCode() {
        return this.#responseCode;
      }
      set responseCode(value) {
        this.#responseCode = value;
      }
      get responseText() {
        return this.#responseText;
      }
      set responseText(value) {
        this.#responseText = value;
      }
    };
    module2.exports = ResponseError;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/network/TimeoutError.js
var require_TimeoutError = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/network/TimeoutError.js"(exports2, module2) {
    var RequestError = require_RequestError();
    var TimeoutError = class extends RequestError {
      constructor(url, request, originalError, message = `HTTP request [${request.name}] to ${url} timed out after ${request.timeout} ms.`) {
        super(url, request, originalError, message);
        this.name = "TimeoutError";
      }
    };
    module2.exports = TimeoutError;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/validation/UnsupportedAlgorithmError.js
var require_UnsupportedAlgorithmError = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/validation/UnsupportedAlgorithmError.js"(exports2, module2) {
    var TokenValidationError = require_TokenValidationError();
    var UnsupportedAlgorithmError = class extends TokenValidationError {
      #alg;
      constructor(token, alg, message = `Algorithm ${alg} specified in token header is not supported.`) {
        super(token, message);
        this.name = "UnsupportedAlgorithmError";
        this.alg = alg;
      }
      get alg() {
        return this.#alg;
      }
      set alg(value) {
        this.#alg = value;
      }
    };
    module2.exports = UnsupportedAlgorithmError;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/validation/UntrustedIssuerError.js
var require_UntrustedIssuerError = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/validation/UntrustedIssuerError.js"(exports2, module2) {
    var TokenValidationError = require_TokenValidationError();
    var UntrustedIssuerError = class extends TokenValidationError {
      constructor(token, message = "Token issuer is not trusted because it is not a (sub)domain contained in the domains property of the service credentials.") {
        super(token, message);
        this.name = "UntrustedIssuerError";
      }
    };
    module2.exports = UntrustedIssuerError;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/validation/WrongAudienceError.js
var require_WrongAudienceError = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/validation/WrongAudienceError.js"(exports2, module2) {
    var TokenValidationError = require_TokenValidationError();
    var WrongAudienceError = class extends TokenValidationError {
      /** @type {string[]} token audiences */
      audiences;
      /** @type {Service|Service[]} service(s) on which context creation was attempted */
      #service;
      constructor(token, service, message = "Token was issued for a different audience than this service.") {
        super(token, message);
        this.name = "WrongAudienceError";
        this.service = service;
        this.audiences = token.audiences;
      }
      get service() {
        return this.#service;
      }
      set service(value) {
        this.#service = value;
      }
    };
    module2.exports = WrongAudienceError;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/validation/X5tError.js
var require_X5tError = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/validation/X5tError.js"(exports2, module2) {
    var TokenValidationError = require_TokenValidationError();
    var X5tError = class extends TokenValidationError {
      /** @type {String} client certificate used for x5t validation */
      clientCertificate;
      constructor(token, clientCertificate, message = "X5t validation of token failed.") {
        super(token, message);
        this.name = "X5tError";
        this.clientCertificate = clientCertificate;
      }
      /** For backward-compatibility because property was renamed. */
      get cert() {
        return this.clientCertificate;
      }
    };
    module2.exports = X5tError;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/index.js
var require_error = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/index.js"(exports2, module2) {
    var ConfigurationError = require_ConfigurationError();
    var ExpiredTokenError = require_ExpiredTokenError();
    var InvalidClientCertificateError = require_InvalidClientCertificateError();
    var InvalidCredentialsError = require_InvalidCredentialsError();
    var InvalidIssuerError = require_InvalidIssuerError();
    var InvalidJwtError = require_InvalidJwtError();
    var InvalidTokenSignatureError = require_InvalidTokenSignatureError();
    var MissingClientCertificateError = require_MissingClientCertificateError();
    var MissingIssuerError = require_MissingIssuerError();
    var MissingJwtError = require_MissingJwtError();
    var MissingKidError = require_MissingKidError();
    var MissingVerificationKeyError = require_MissingVerificationKeyError();
    var NetworkError = require_NetworkError();
    var NotYetValidTokenError = require_NotYetValidTokenError();
    var RequestError = require_RequestError();
    var ResponseError = require_ResponseError();
    var TimeoutError = require_TimeoutError();
    var TokenValidationError = require_TokenValidationError();
    var UnsupportedAlgorithmError = require_UnsupportedAlgorithmError();
    var UntrustedIssuerError = require_UntrustedIssuerError();
    var ValidationError = require_ValidationError();
    var WrongAudienceError = require_WrongAudienceError();
    var X5tError = require_X5tError();
    var XssecError = require_XssecError();
    module2.exports = {
      ConfigurationError,
      ExpiredTokenError,
      InvalidClientCertificateError,
      InvalidCredentialsError,
      InvalidIssuerError,
      InvalidJwtError,
      InvalidTokenSignatureError,
      MissingClientCertificateError,
      MissingIssuerError,
      MissingJwtError,
      MissingKidError,
      MissingVerificationKeyError,
      NetworkError,
      NotYetValidTokenError,
      RequestError,
      ResponseError,
      TimeoutError,
      TokenValidationError,
      UnsupportedAlgorithmError,
      UntrustedIssuerError,
      ValidationError,
      WrongAudienceError,
      X5tError,
      XssecError
    };
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/util/Logger.js
var require_Logger = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/util/Logger.js"(exports2, module2) {
    var Logger = class {
      constructor(loggingConfig, prefix) {
        this.loggingConfig = loggingConfig;
        this.prefix = prefix;
      }
      info(message, args) {
        message = `[${this.prefix}] ${message}`;
        if (args != null) {
          this.loggingConfig.info(message, args);
        } else {
          this.loggingConfig.info(message);
        }
      }
      warn(message, args) {
        message = `[${this.prefix}] ${message}`;
        if (args != null) {
          this.loggingConfig.warn(message, args);
        } else {
          this.loggingConfig.warn(message);
        }
      }
      error(message, args) {
        message = `[${this.prefix}] ${message}`;
        if (args != null) {
          this.loggingConfig.error(message, args);
        } else {
          this.loggingConfig.error(message);
        }
      }
      debug(message, args) {
        message = `[${this.prefix}] ${message}`;
        if (args != null) {
          this.loggingConfig.debug(message, args);
        } else {
          this.loggingConfig.debug(message);
        }
      }
    };
    module2.exports = Logger;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/util/logging.js
var require_logging = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/util/logging.js"(exports2, module2) {
    var debug = require_src();
    var Logger = require_Logger();
    var debugLogger = debug("xssec");
    debugLogger.log = console.log.bind(console);
    var loggingConfig = {
      info: (message, ...args) => debugLogger(message, ...args),
      warn: (message, ...args) => debugLogger(message, ...args),
      error: (message, ...args) => debugLogger(message, ...args),
      debug: (message, ...args) => debugLogger(message, ...args)
    };
    function getLogger(prefix = "") {
      return new Logger(loggingConfig, prefix);
    }
    function setLoggers(loggers) {
      Object.assign(loggingConfig, loggers);
    }
    module2.exports = {
      getLogger,
      setLoggers
    };
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/context/createSecurityContext.js
var require_createSecurityContext = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/context/createSecurityContext.js"(exports2, module2) {
    var Token = require_Token();
    var MissingJwtError = require_MissingJwtError();
    var SecurityContext = require_SecurityContext();
    var { WrongAudienceError } = require_error();
    var { getLogger } = require_logging();
    var LOG = getLogger("createSecurityContext.js");
    module2.exports = createSecurityContext;
    async function createSecurityContext(services, contextConfig) {
      contextConfig = { ...contextConfig };
      SecurityContext.buildContextConfig(contextConfig);
      if (contextConfig.token == null && contextConfig.jwt == null) {
        throw new MissingJwtError();
      }
      const token = contextConfig.token ?? new Token(contextConfig.jwt);
      LOG.debug(`Creating security context from JWT: ${token.jwt}`, { correlationId: contextConfig.correlationId });
      let targetService = null;
      if (Array.isArray(services)) {
        if (services.length === 1) {
          targetService = services[0];
        } else {
          targetService = findServiceForToken(services, token);
          if (targetService != null) {
            LOG.debug(`Selected ${targetService.constructor.name} with clientid ${targetService.credentials.clientid} based on token audience.`, { correlationId: contextConfig.correlationId });
          }
        }
      } else {
        targetService = services;
      }
      if (targetService == null) {
        throw new WrongAudienceError(token, services, `The audiences of the token fit none of the supplied services.`);
      }
      return targetService.createSecurityContext(token, contextConfig);
    }
    function findServiceForToken(services, token) {
      return services.find((s) => s.acceptsTokenAudience(token));
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/context/IdentityServiceSecurityContext.js
var require_IdentityServiceSecurityContext = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/context/IdentityServiceSecurityContext.js"(exports2, module2) {
    var ConfigurationError = require_ConfigurationError();
    var SecurityContext = require_SecurityContext();
    var IdentityServiceSecurityContext = class extends SecurityContext {
      /**
       * @param {IdentityService|null} service
       * @param {IdentityServiceToken} token 
       * @param {SecurityContextConfig} [contextConfig] 
       */
      constructor(service, token, contextConfig) {
        super(service, token, contextConfig);
      }
      /**
       * Returns the service plans of the consumer application.
       * This method is only available if the context was created from an app2service token and a service with proof token validation enabled.
       * @returns {string[]}
       */
      get servicePlans() {
        if (!this.service.hasProofTokenEnabled()) {
          throw new ConfigurationError("This property is only available on IdentityServiceSecurityContexts created on an IdentityService with proofToken validation enabled.");
        }
        return this.config.servicePlans;
      }
      /**
       * Checks whether the token from which this context was created is a token fetched by the OAuth 2.0 client for internal use.
       * This method requires the IdentityService instance to have x5t validation enabled.
       * @returns {boolean} true if the token was fetched via client credentials flow with the credentials of this context's IdentityService instance, false otherwise.
       */
      isInternal() {
        if (!this.service.hasX5tEnabled()) {
          throw new ConfigurationError("This method is only available on IdentityServiceSecurityContexts created on an IdentityService instance with x5t validation enabled.");
        }
        return this.token.azp === this.service.credentials.clientid && this.token.subject === this.service.credentials.clientid && this.token.appTid === this.service.credentials.app_tid;
      }
      // Methods for backward-compatibility
      getUserInfo() {
        return {
          ...super.getUserInfo(),
          logonName: this.token.payload.user_name || this.token.email || this.token.payload.user_uuid || ""
        };
      }
    };
    module2.exports = IdentityServiceSecurityContext;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/context/XsuaaSecurityContext.js
var require_XsuaaSecurityContext = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/context/XsuaaSecurityContext.js"(exports2, module2) {
    var SecurityContext = require_SecurityContext();
    var { getLogger } = require_logging();
    var { GRANTTYPE_CLIENTCREDENTIALS } = require_constants2();
    var LOG = getLogger("XsuaaSecurityContext.js");
    var XsuaaSecurityContext = class extends SecurityContext {
      /**
       * @param {XsuaaService|null} service
       * @param {XsuaaToken} token 
       * @param {SecurityContextConfig} [contextConfig] 
       */
      constructor(service, token, contextConfig) {
        super(service, token, contextConfig);
      }
      /**
       * Checks if the token of this context was issued for the given scope.
       * @param {String} scope 
       * @returns {Boolean}
       */
      checkScope(scope) {
        return this.token.scopes.includes(scope);
      }
      /**
       * Checks if the token of this context was issued for the given scope, ignoring the xsappname prefix of the service that was used to create this context when copmaring with the token's scopes.
       * @param {String} scope 
       * @returns {Boolean}
       */
      checkLocalScope(scope) {
        return this.token.scopes.includes(`${this.service.credentials.xsappname}.${scope}`);
      }
      checkFollowingInstanceScope(scope) {
        const clientId = this.token.payload.client_id;
        if (!clientId?.startsWith("sb-")) {
          return false;
        }
        const appId = clientId.substring(3);
        if (!appId.includes("|")) {
          return false;
        }
        return this.checkScope(`${appId}.${scope}`);
      }
      // Methods for backward-compatibility
      getAttributes() {
        const attributes = this.token.xsUserAttributes ?? {};
        return Object.keys(attributes).length !== 0 ? attributes : null;
      }
      getAttribute(name) {
        return this.token.getXsUserAttribute(name) || null;
      }
      getAdditionalAuthAttribute(name) {
        const additionalAuthAttributes = this.getAdditionalAuthAttributes();
        if (!additionalAuthAttributes) {
          LOG.debug("\nThe access token contains no additional authentication attributes.\n");
          return null;
        }
        if (!name) {
          LOG.debug("\nInvalid attribute name (may not be null, empty, or undefined).");
          return null;
        }
        if (!additionalAuthAttributes[name]) {
          LOG.debug('\nNo attribute "' + name + '" found as additional authentication attribute.');
          return null;
        }
        return additionalAuthAttributes[name];
      }
      getAdditionalAuthAttributes() {
        return this.token.azAttributes || null;
      }
      /**
       * @deprecated Use token.zid instead 
       */
      getAppTID() {
        return this.token.zid;
      }
      getClientId() {
        return this.token.getClientId();
      }
      getCloneServiceInstanceId() {
        return this.token.extAttributes?.serviceinstanceid || null;
      }
      getEmail() {
        return this.#ifNotClientCredentialsToken("XsuaaSecurityContext.getEmail", this.getUserInfo().email);
      }
      getFamilyName() {
        return this.#ifNotClientCredentialsToken("XsuaaSecurityContext.getFamilyName", this.getUserInfo().familyName);
      }
      getGivenName() {
        return this.#ifNotClientCredentialsToken("XsuaaSecurityContext.getGivenName", this.getUserInfo().givenName);
      }
      getLogonName() {
        return this.#ifNotClientCredentialsToken("XsuaaSecurityContext.getLogonName", this.getUserInfo().logonName);
      }
      getOrigin() {
        return this.token.origin;
      }
      getSubaccountId() {
        return this.token.subAccountId;
      }
      getSubdomain() {
        return this.token.extAttributes?.zdn ?? null;
      }
      getUniquePrincipalName(origin, logonName) {
        if (!this.#ifNotClientCredentialsToken("XsuaaSecurityContext.getUniquePrincipalName", true)) {
          return null;
        }
        if (!origin) {
          LOG.debug("Origin claim not set in JWT. Cannot create unique user name. Returning null.");
          return null;
        }
        if (!logonName) {
          LOG.debug("User login name claim not set in JWT. Cannot create unique user name. Returning null.");
          return null;
        }
        if (origin.includes("/")) {
          LOG.debug("Illegal '/' character detected in origin claim of JWT. Cannot create unique user name. Retuning null.");
          return null;
        }
        return `user/${origin}/${logonName}`;
      }
      getUserName() {
        if (this.token.grantType === GRANTTYPE_CLIENTCREDENTIALS) {
          return `client/${this.getClientId()}`;
        } else {
          return this.getUniquePrincipalName(this.token.origin, this.getLogonName());
        }
      }
      /**
       * @deprecated Use token.zid instead 
       */
      getZoneId() {
        return this.token.zid;
      }
      hasAttributes() {
        return this.#ifNotClientCredentialsToken("XsuaaSecurityContext.hasAttributes", this.token.xsUserAttributes != null);
      }
      isInForeignMode() {
        return this.service.credentials.clientid.includes("!b") && this.token.audiences.some((aud) => aud.includes(`|${this.service.credentials.clientid}`));
      }
      #ifNotClientCredentialsToken(functionName, value) {
        if (this.token.grantType === GRANTTYPE_CLIENTCREDENTIALS) {
          LOG.debug(`Call to ${functionName} not allowed with a token of grant type ${GRANTTYPE_CLIENTCREDENTIALS}.`);
          return null;
        }
        return value;
      }
    };
    module2.exports = XsuaaSecurityContext;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/context/XsaSecurityContext.js
var require_XsaSecurityContext = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/context/XsaSecurityContext.js"(exports2, module2) {
    var XsuaaSecurityContext = require_XsuaaSecurityContext();
    var XsaSecurityContext = class extends XsuaaSecurityContext {
      /**
       * 
       * @param {XsaService|null} service 
       * @param {XsaToken} token 
       * @param {SecurityContextConfig} [contextConfig]
       */
      constructor(service, token, contextConfig) {
        super(service, token, contextConfig);
      }
      /**
       * The Service instance on which this SecurityContext has been created.
       * @returns {XsaService} service
       */
      get service() {
        return super.service;
      }
      /**
       * @param {XsaService} service
       */
      set service(service) {
        super.service = service;
      }
      /**
       * The Token instance from which this SecurityContext has ben created.
       * @returns {XsaToken} token
       */
      get token() {
        return super.token;
      }
      /**
       * @param {XsaToken} token
       */
      set token(token) {
        super.token = token;
      }
    };
    module2.exports = XsaSecurityContext;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/context/UaaSecurityContext.js
var require_UaaSecurityContext = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/context/UaaSecurityContext.js"(exports2, module2) {
    var XsuaaSecurityContext = require_XsuaaSecurityContext();
    var UaaSecurityContext = class extends XsuaaSecurityContext {
      /**
       * @param {UaaService|null} service
       * @param {UaaToken} token 
       * @param {SecurityContextConfig} [contextConfig] 
       */
      constructor(service, token, contextConfig) {
        super(service, token, contextConfig);
      }
      /**
       * The Service instance on which this SecurityContext has been created.
       * @returns {UaaService} service
       */
      get service() {
        return super.service;
      }
      /**
       * @param {UaaService} service
       */
      set service(service) {
        super.service = service;
      }
      /**
       * The Token instance from which this SecurityContext has ben created.
       * @returns {UaaToken} token
       */
      get token() {
        return super.token;
      }
      /**
       * @param {UaaToken} token
       */
      set token(token) {
        super.token = token;
      }
    };
    module2.exports = UaaSecurityContext;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/cache/ResponseReplica.js
var require_ResponseReplica = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/cache/ResponseReplica.js"(exports2, module2) {
    var ResponseReplica = class {
      cache;
      // cache containing this replica
      key;
      // cache key of this replica
      request;
      // callback for fetching response data
      data;
      // last response data
      lastRefresh;
      // UNIX timestamp of last refresh
      expirationTime;
      // time in milliseconds that needs to pass after creation for the replica to count as expired
      pendingRequest;
      // promise for ongoing update of response or undefined
      constructor(cache, key, request) {
        Object.assign(this, { cache, key, request });
        this.data = null;
        this.expirationTime = cache.expirationTime;
      }
      /**
       * Returns the remaining time until expiration.
       * @returns time until expiration or 0 if no data available or data expired
       */
      get remainingTime() {
        if (!this.hasData || this.lastRefresh == null) {
          return 0;
        }
        const elapsedTime = Date.now() - this.lastRefresh;
        return Math.max(0, this.expirationTime - elapsedTime);
      }
      /** Returns whether the replica already has response data. **/
      hasData() {
        return this.data != null;
      }
      /** Returns whether the replica is expired. **/
      isExpired() {
        return this.remainingTime <= 0;
      }
      /**
       * Returns if the replica is considered stale given the refresh period. Stale replicas should be refreshed but may still be used before expiration.
       * @param refreshPeriod time period (in ms) before expiration time in which the replica should count as stale (but not yet as expired)
       * @returns true if the replica is already expired or will expire within the given refresh period.
       */
      isStale(refreshPeriod) {
        return this.expired || this.remainingTime <= refreshPeriod;
      }
      /**
       * Triggers a refresh of this replica. Multiple calls will still result in only one refresh at a time.
       * @param {string} correlationId 
       */
      refresh(correlationId) {
        this.pendingRequest ??= this.#fetchResponse(correlationId);
        return this.pendingRequest;
      }
      /** Fetches new data from the request. */
      async #fetchResponse(correlationId) {
        try {
          this.data = await this.request(correlationId);
        } finally {
          this.pendingRequest = null;
        }
        this.lastRefresh = Date.now();
      }
    };
    module2.exports = ResponseReplica;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/cache/ResponseCache.js
var require_ResponseCache = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/cache/ResponseCache.js"(exports2, module2) {
    var ResponseReplica = require_ResponseReplica();
    var ConfigurationError = require_ConfigurationError();
    var { getLogger } = require_logging();
    var LOG = getLogger("ResponseCache.js");
    var ResponseCache = class _ResponseCache {
      static get DEFAULT_EXPIRATION_TIME() {
        return 30 * 60 * 1e3;
      }
      // 30 minutes
      static get DEFAULT_REFRESH_PERIOD() {
        return 15 * 60 * 1e3;
      }
      // 15 minutes
      /** @type {Map<string,ResponseReplica>} */
      cache;
      // map that stores response replicas by their key
      endpointName;
      // name of cached endpoint for logging purposes, e.g. "JWKS", ".well-known" etc.
      expirationTime;
      // expiration time that will be used for new cache entries
      refreshPeriod;
      // time before expiration in which a response is considered stale
      constructor({
        expirationTime = _ResponseCache.DEFAULT_EXPIRATION_TIME,
        refreshPeriod = _ResponseCache.DEFAULT_REFRESH_PERIOD,
        endpointName = "response"
      } = {}) {
        if (expirationTime < 0) {
          throw new ConfigurationError("ResponseCache expirationTime must be >=0.");
        }
        if (refreshPeriod < 0 || refreshPeriod > expirationTime) {
          throw new ConfigurationError("ResponseCache refreshPeriod must be between 0 and <expirationTime>.");
        }
        this.cache = /* @__PURE__ */ new Map();
        this.endpointName = endpointName;
        this.expirationTime = expirationTime;
        this.refreshPeriod = refreshPeriod;
      }
      /**
       * Returns an up-to-date response associated with the given key. If there is no replica yet for the key, caches a new replica under this key that
       * uses the given request callback to fetch its responses.
       * @param key cache key of response
       * @param buildRequest callback that constructs a request function for fetching new responses if no replica exists yet for the key. The request function
       *  has to throw an Error with a statusCode and statusText if it fails to fetch the data.
       */
      async getOrRequest(key, buildRequest, { correlationId }) {
        const replica = this.cache.get(key) || this.#createReplica(key, buildRequest());
        if (!replica.hasData() || replica.isExpired()) {
          LOG.debug(`Awaiting ${this.endpointName} refresh because replica for key=${key} has ${replica.hasData() ? "expired" : "no"} data.)`, { correlationId });
          await replica.refresh(correlationId);
        } else if (replica.isStale(this.refreshPeriod)) {
          LOG.debug(`Asynchronous ${this.endpointName} refresh scheduled because replica for key=${key} is stale (remaining time = ${replica.remainingTime}ms < ${replica.refreshPeriod}ms = refresh period).`);
          replica.refresh(correlationId).catch(() => {
          });
        }
        return replica.data;
      }
      #createReplica(key, request) {
        const replica = new ResponseReplica(this, key, request);
        this.cache.set(key, replica);
        return replica;
      }
    };
    module2.exports = ResponseCache;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/util/fetch.js
var require_fetch = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/util/fetch.js"(exports2, module2) {
    var https = require("https");
    var http = require("http");
    var zlib = require("zlib");
    var url = require("url");
    function selectRequestModule(protocol) {
      switch (protocol) {
        case "https:":
          return https;
        case "http:":
          return http;
        default:
          throw new Error(`Unsupported protocol: ${protocol}`);
      }
    }
    var FetchError = class extends Error {
      constructor(message, error) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.code = this.errno = error?.code;
        this.erroredSysCall = error?.syscall;
      }
      get name() {
        return this.constructor.name;
      }
    };
    var Response2 = class {
      #response;
      #request;
      constructor(response, request) {
        this.#response = response;
        this.#request = request;
      }
      async #getZip() {
        const response = this.#response;
        return new Promise((resolve, reject) => {
          const gunzip = zlib.createGunzip();
          response.pipe(gunzip);
          const data = [];
          gunzip.on("data", function(chunk) {
            data.push(chunk.toString());
          });
          gunzip.on("end", function() {
            resolve(data.join(""));
          });
          gunzip.on("error", (error) => {
            reject(new FetchError(`request to ${this.requestUrl} failed, reason: ${error.message}`, error));
          });
        });
      }
      get requestUrl() {
        const req = this.#request;
        return req.protocol + "//" + req.host + req.path;
      }
      async #getText() {
        const response = this.#response;
        if (response.headers["content-encoding"] === "gzip") {
          return this.#getZip();
        }
        return new Promise((resolve, reject) => {
          const data = [];
          response.setEncoding("utf8");
          response.on("data", function(chunk) {
            data.push(chunk);
          });
          response.on("end", function() {
            resolve(data.join(""));
          });
          response.on("error", (error) => {
            reject(new FetchError(`request to ${this.requestUrl} failed, reason: ${error.message}`, error));
          });
        });
      }
      async json() {
        return JSON.parse(await this.#getText());
      }
      async text() {
        return this.#getText();
      }
      get ok() {
        return this.status >= 200 && this.status < 300;
      }
      get status() {
        return this.#response.statusCode;
      }
      get headers() {
        const headers = /* @__PURE__ */ new Map();
        for (const [key, value] of Object.entries(this.#response.headers)) {
          headers.set(key, value);
        }
        return headers;
      }
    };
    async function xssec_fetch(inputUrl, options = {}) {
      importDefaultOptions(options);
      importDefaultHeaders(options);
      importBodyOptions(options);
      const requestModule = selectRequestModule(new url.URL(inputUrl).protocol);
      return new Promise(function(resolve, reject) {
        const req = requestModule.request(inputUrl, options, (response) => {
          resolve(new Response2(response, req));
        });
        req.on("error", (error) => {
          reject(new FetchError(`request to ${url} failed, reason: ${error.message}`, error));
        });
        req.on("timeout", () => {
          req.destroy();
          reject(new FetchError(`request to ${url} timed out.`, { code: "ETIMEDOUT" }));
        });
        if (options.data) {
          req.write(options.data);
        }
        req.end();
      });
    }
    function importDefaultOptions(options) {
      options.method ??= "GET";
    }
    function importBodyOptions(options) {
      if (options.body) {
        const method = options.method.toUpperCase();
        if (method !== "GET" && method !== "HEAD") {
          if (options.json) {
            options.data = JSON.stringify(options.body);
            options.headers["Content-Type"] = "application/json;charset=UTF-8";
          } else {
            options.data = options.body.toString();
            options.headers["Content-Type"] = "application/x-www-form-urlencoded;charset=UTF-8";
          }
          options.headers["Content-Length"] = Buffer.byteLength(options.data);
          delete options.body;
        } else {
          throw new Error("Request with GET/HEAD method cannot have body");
        }
      }
    }
    function importDefaultHeaders(options) {
      if (options.headers == null) {
        options.headers = {};
      }
      options.headers["Accept-Encoding"] = "gzip,deflate";
      if (!options.headers["Accept"] && !options.headers["accept"]) {
        options.headers["Accept"] = "*/*";
      }
    }
    module2.exports = xssec_fetch;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/network/RetryError.js
var require_RetryError = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/error/network/RetryError.js"(exports2, module2) {
    var RequestError = require_RequestError();
    var RetryError = class extends RequestError {
      constructor(url, request, originalError, message = `HTTP request [${request.name}] to ${url} was not successful after ${originalError.length} attempts.`) {
        super(url, request, originalError, message);
        this.name = "RetryError";
      }
      get retryErrors() {
        return this.originalError;
      }
    };
    module2.exports = RetryError;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/util/util.js
var require_util3 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/util/util.js"(exports2, module2) {
    var { X509Certificate } = require("crypto");
    var InvalidClientCertificateError = require_InvalidClientCertificateError();
    var { PEM_HEADER, PEM_FOOTER, CLIENT_CERTIFICATE_HEADER } = require_constants2();
    module2.exports = {
      /**
       * Escapes Regex special characters in the given string, so that the string can be used for a literal match inside a Regex.
       * Regex.escape is only a proposal at the time of writing.
       * The source of this code is https://github.com/tc39/proposal-regex-escaping/blob/main/polyfill.js 
       */
      escapeStringForRegex(s) {
        return String(s).replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
      },
      /**
       * Creates a string cache key from the given key-value pairs, ignoring keys with null or undefined values.
       * @param {object} parts
       * @returns a cache key in string format, e.g. app_tid:foo:client_id:bar:azp:baz
       */
      createCacheKey(parts = {}) {
        return Object.entries(parts).filter(([value]) => value != null).map(([key, value]) => `${key}=${value}`).join("|");
      },
      parsePemCertificate(pem) {
        pem = pem.replaceAll("\\n", "\n");
        if (!pem.startsWith(PEM_HEADER)) pem = `${PEM_HEADER}
${pem}`;
        if (!pem.endsWith(PEM_FOOTER)) pem = `${pem}
${PEM_FOOTER}`;
        try {
          return new X509Certificate(pem);
        } catch (error) {
          throw new InvalidClientCertificateError(pem, error);
        }
      },
      shrinkRequestOptionsForLog(request) {
        const maskedRequest = { ...request };
        maskedRequest.headers = { ...request.headers };
        if (maskedRequest.agent) {
          maskedRequest.agent = "<agent>";
        }
        if (maskedRequest.headers?.[CLIENT_CERTIFICATE_HEADER]) {
          maskedRequest.headers[CLIENT_CERTIFICATE_HEADER] = "<clientCertificatePem>";
        }
        return maskedRequest;
      }
    };
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/util/jsonRequest.js
var require_jsonRequest = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/util/jsonRequest.js"(exports2, module2) {
    var fetch2 = require_fetch();
    var { getLogger } = require_logging();
    var RequestError = require_RequestError();
    var RetryError = require_RetryError();
    var ResponseError = require_ResponseError();
    var TimeoutError = require_TimeoutError();
    var { CORRELATIONID_HEADER_VCAP, DEFAULT_TIMEOUT, MAX_TIMEOUT, USER_AGENT } = require_constants2();
    var { shrinkRequestOptionsForLog } = require_util3();
    var LOG = getLogger("request.js");
    var sleep = (ms) => new Promise((resolve) => {
      setTimeout(() => {
        resolve();
      }, ms);
    });
    function calculateDelay(attempt, retryConfig) {
      if (retryConfig.strategy === "exponential") {
        const delay = retryConfig.initialDelay * Math.pow(retryConfig.factor, attempt);
        return Math.min(delay, retryConfig.maxDelay);
      }
      return retryConfig.initialDelay;
    }
    function isRetryableError(e) {
      if (e instanceof ResponseError) {
        if (e.responseCode >= 500 && e.responseCode <= 600 || e.responseCode == 429 || e.responseCode == 408) {
          return true;
        }
      } else if (e instanceof RequestError) {
        return true;
      }
      return false;
    }
    async function fetchWithRetry(url, request, options) {
      const { requestName, correlationId } = options;
      const retryConfig = request.retry;
      const retryErrors = [];
      const requestWithName = { ...request, name: requestName };
      for (let attempt = 0; attempt <= retryConfig.retries; attempt++) {
        try {
          if (attempt > 0) {
            LOG.info(`Retry attempt ${attempt}/${retryConfig.retries} for [${requestName}] to ${url}`, { correlationId });
          }
          return await fetchWithoutRetry(url, request, options);
        } catch (e) {
          if (!isRetryableError(e)) {
            throw e;
          }
          retryErrors.push(e);
          if (attempt >= retryConfig.retries) {
            break;
          }
          const delay = calculateDelay(attempt, retryConfig);
          LOG.debug(`Waiting ${delay}ms before next retry`, { correlationId });
          await sleep(delay);
        }
      }
      const error = new RetryError(url, requestWithName, retryErrors);
      LOG.error(error.message, { correlationId });
      throw error;
    }
    async function fetchWithoutRetry(url, request, { requestName, correlationId, extractHeaders }) {
      if (correlationId) {
        request.headers[CORRELATIONID_HEADER_VCAP] = correlationId;
      }
      LOG.debug(`HTTP request [${requestName}] to ${url} with options`, { correlationId, ...shrinkRequestOptionsForLog(request) });
      let response;
      try {
        response = await fetch2(url, request);
      } catch (e) {
        const requestWithName = { ...request, name: requestName };
        const error = e.code === "ETIMEDOUT" ? new TimeoutError(url, requestWithName, e) : new RequestError(url, requestWithName, e);
        LOG.error(error.message, { correlationId });
        throw error;
      }
      if (!response.ok) {
        const responseText = await response.text();
        const error = new ResponseError(url, { ...request, name: requestName }, response.status, responseText);
        LOG.error(error.message, { correlationId });
        throw error;
      }
      const json2 = await response.json();
      LOG.debug(`HTTP response [${requestName}]:`, { correlationId, ...json2 });
      if (extractHeaders != null) {
        json2[extractHeaders] = response.headers;
      }
      return json2;
    }
    async function jsonRequest(url, request, options = {}) {
      Object.assign(request, {
        redirect: "error",
        follow: 0,
        timeout: Math.min(MAX_TIMEOUT, request.timeout ?? DEFAULT_TIMEOUT)
      });
      request.headers ??= {};
      Object.assign(request.headers, {
        Accept: "application/json",
        "User-Agent": USER_AGENT
      });
      if (request.retry) {
        return fetchWithRetry(url, request, options);
      } else {
        return fetchWithoutRetry(url, request, options);
      }
    }
    module2.exports = {
      jsonRequest
    };
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/service/Service.js
var require_Service = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/service/Service.js"(exports2, module2) {
    var { Agent } = require("node:https");
    var ResponseCache = require_ResponseCache();
    var LRUCache = require_LRUCache();
    var { ConfigurationError, ExpiredTokenError, InvalidCredentialsError, MissingKidError, NotYetValidTokenError, WrongAudienceError } = require_error();
    var { jsonRequest } = require_jsonRequest();
    var { createCacheKey } = require_util3();
    var { DEFAULT_JWT_BEARER_FETCH_TIMEOUT, DEFAULT_TIMEOUT, GRANTTYPE_CLIENTCREDENTIALS, GRANTTYPE_JWTBEARER, GRANTTYPE_PASSWORD, MAX_TIMEOUT } = require_constants2();
    var Service = class _Service {
      /** 
       * JWKS cache instances shared by Service subclasses indexed by their constructor name.
       * @type {Object.<string, ResponseCache>} 
       */
      static #sharedJwksCaches = {};
      /** 
       * Signature cache instances shared by Service subclasses indexed by their constructor name.
       * @type {Object.<string, LRUCache>} 
       */
      static #sharedSignatureCaches = {};
      /** @type {ResponseCache} */
      static #oidcCache = null;
      /** @type {import("../util/Types").ExponentialBackoffRetryConfig} */
      static DEFAULT_RETRY_CONFIG = {
        strategy: "exponential",
        retries: 3,
        initialDelay: 500,
        factor: 3,
        maxDelay: 4e3
      };
      /** @type {import("../util/Types").SignatureCacheConfig} */
      static DEFAULT_SIGNATURE_CACHE_CONFIG = {
        size: 100
      };
      /** @type {ServiceCredentials} */
      credentials;
      /** @type {ServiceConfig} */
      config;
      /** @type {Object.<string, string>}  */
      endpoints;
      /** @type {ResponseCache} */
      jwksCache;
      /**
       * A jwt->boolean cache used for signature validation results. Can be either an external cache implementation or one of the {@link #sharedSignatureCaches}.
       * @type {import("../util/Types").Cache}
       */
      signatureCache;
      /**
       *
       * @param {ServiceCredentials} credentials
       * @param {ServiceConfig} [serviceConfiguration={}]
       */
      constructor(credentials, serviceConfiguration = {}) {
        if (credentials == null) {
          throw new ConfigurationError("Service requires service credentials.");
        }
        this.credentials = { ...credentials };
        this.config = _Service.buildServiceConfiguration(serviceConfiguration);
        _Service.#oidcCache ??= new ResponseCache({ endpointName: "OIDC configuration" });
        this.endpoints = { ...this.endpoints, ...serviceConfiguration.endpoints || {} };
        this.jwksCache = this.config.validation.jwks.shared ? this.#getSharedJwksCache(this.config) : new ResponseCache({ ...this.config.validation.jwks, endpointName: "JWKS" });
        if (this.config.validation.signatureCache.impl) {
          this.signatureCache = this.config.validation.signatureCache.impl;
        } else if (this.config.validation.signatureCache.enabled !== false) {
          this.signatureCache = _Service.#getSharedSignatureCache(this.config.validation.signatureCache);
        }
      }
      /**
       * @internal
       * Gets the OIDC cache shared by all Service instances.
       *
       * @returns {import("../cache/ResponseCache")} The OIDC cache.
       */
      get oidcCache() {
        return _Service.#oidcCache;
      }
      /**
       * @internal
       * Sets the OIDC cache shared by all Service instances.
       */
      set oidcCache(cache) {
        _Service.#oidcCache = cache;
      }
      #getSharedJwksCache() {
        _Service.#sharedJwksCaches[this.constructor.name] ??= new ResponseCache({ ...this.config.validation.jwks, endpointName: "JWKS" });
        return _Service.#sharedJwksCaches[this.constructor.name];
      }
      /**
       * Retrieves or creates the signature cache shared by all instances of this Service subclass.
       * @param {import("../util/Types").SignatureCacheConfig} config 
       * @returns {LRUCache} the shared signature cache
       * @throws {ConfigurationError} if a shared signature cache with a different size has already been created by another Service configuration for the same Service subclass.
       */
      static #getSharedSignatureCache(config) {
        const sharedCache = _Service.#sharedSignatureCaches[this.constructor.name];
        if (sharedCache != null && sharedCache.size !== config.size) {
          throw new ConfigurationError(
            `An internal signature cache with size ${sharedCache.size} instead of ${config.size} has already been created by another ${this.constructor.name} configuration. Please use the same size in all ${this.constructor.name} configurations or provide separate, externally managed cache implementations.`
          );
        }
        _Service.#sharedSignatureCaches[this.constructor.name] ??= new LRUCache(config.size);
        return _Service.#sharedSignatureCaches[this.constructor.name];
      }
      /**
       * Checks if this service is the recipient of the given token.
       * @param {Token} token
       * @returns {Boolean}
       */
      acceptsTokenAudience(token) {
        this.validateCredentials("validate token audience", "clientid");
        return token.audiences?.includes(this.credentials.clientid);
      }
      /**
       * Called internally to validate the credentials to have the necessary properties before performing a specific action, e.g. token fetch.
       *
       * @internal
       * @param {string} action description of action for which the credentials are being validated.
       * @param {...string} mandatoryProperties mandatory properties that must be present in the credentials.
       * @throws {InvalidCredentialsError} if any of the mandatory properties are missing in the credentials.
       */
      validateCredentials(action, ...mandatoryProperties) {
        const missingProperties = mandatoryProperties.filter((p) => !this.credentials[p]);
        if (missingProperties.length > 0) {
          throw new InvalidCredentialsError(`${this.constructor.name} is missing the properties ${missingProperties} inside its credentials for: ${action}.`);
        }
      }
      /**
       * Checks if the given token is valid under the given contextConfig.
       * @param {Token} token
       * @param {SecurityContextConfig} contextConfig
       * @throws {ValidationError} if the token is not valid or could not be validated
      */
      async validateToken(token, contextConfig) {
        if (token.expired) {
          throw new ExpiredTokenError(token);
        }
        if (token.notYetValid) {
          throw new NotYetValidTokenError(token);
        }
        if (!this.acceptsTokenAudience(token)) {
          throw new WrongAudienceError(token, this);
        }
        await this.validateTokenSignature(token, contextConfig);
      }
      /**
       * Checks if the given token's signature is valid under the given contextConfig.
       * @param {Token} token
       * @param {SecurityContextConfig} contextConfig
       * @returns {Promise<void>} resolves when token signature is valid, otherwise error is thrown
       * @throws {ValidationError} if the token signature is not valid or could not be validated
       */
      async validateTokenSignature(token, contextConfig) {
        if (!token.header.kid) {
          throw new MissingKidError(token.header.kid, `Token header contained no kid.`);
        }
        const jwks = await this.getJwks(token, contextConfig);
        const jwk = jwks.get(token.header.kid);
        if (this.signatureCache) {
          jwk.validateSignature(token, this.signatureCache);
        } else {
          jwk.validateSignature(token);
        }
      }
      /**
       * @param {object} [requestOptions]
       * @param {string} [requestOptions.correlationId]
       */
      async getOpenIDConfiguration({ correlationId } = {}) {
        this.validateCredentials("fetch OIDC configuration", "url");
        const cacheKey = createCacheKey({ url: this.credentials.url });
        const buildRequest = () => {
          return (correlationId2) => this.fetchOpenIDConfiguration({ correlationId: correlationId2 });
        };
        return this.oidcCache.getOrRequest(cacheKey, buildRequest, { correlationId });
      }
      /**
       * @param {object} [requestOptions]
       * @param {string} [requestOptions.correlationId]
       */
      async fetchOpenIDConfiguration({ correlationId } = {}) {
        this.validateCredentials("fetch OIDC configuration", "url");
        const oidcUrl = new URL(this.endpoints.oidc_info, this.credentials.url);
        const request = this.buildRequest({
          method: "GET"
        });
        return jsonRequest(oidcUrl, request, { requestName: `${this.constructor.name}.fetchOpenIDConfiguration`, correlationId });
      }
      /**
       * Fetches a token from this service with this service's client credentials.
       * @param {TokenFetchOptions} options
       * @returns {Promise<TokenFetchResponse>} response
       */
      async fetchClientCredentialsToken(options = {}) {
        const grant_type = GRANTTYPE_CLIENTCREDENTIALS;
        const tokenUrl = await this.getTokenUrl(grant_type, options);
        const request = this.buildTokenRequest(grant_type, options);
        return jsonRequest(tokenUrl, request, { requestName: `${this.constructor.name}.fetchClientCredentialsToken`, correlationId: options.correlationId });
      }
      /**
       * Fetches a user token from this service with the given username and password.
       * @param {String} username
       * @param {String} password
       * @param {TokenFetchOptions} options
       * @returns {Promise<TokenFetchResponse>} response
       */
      async fetchPasswordToken(username, password, options = {}) {
        const grant_type = GRANTTYPE_PASSWORD;
        const tokenUrl = await this.getTokenUrl(grant_type, options);
        const request = this.buildTokenRequest(grant_type, options);
        request.body.append("username", username);
        request.body.append("password", password);
        return jsonRequest(tokenUrl, request, { requestName: `${this.constructor.name}.fetchPasswordToken`, correlationId: options.correlationId });
      }
      /**
       * Fetches a JWT bearer token from this service with the given user token as assertion.
       * @param {TokenFetchOptions} options - default timeout is 10 seconds as JWT bearer can be slow
       * @returns {Promise<TokenFetchResponse>} response
       */
      async fetchJwtBearerToken(assertion, options = {}) {
        const grant_type = GRANTTYPE_JWTBEARER;
        const tokenUrl = await this.getTokenUrl(grant_type, options);
        options.timeout ??= DEFAULT_JWT_BEARER_FETCH_TIMEOUT;
        const request = this.buildTokenRequest(grant_type, options);
        request.body.append("assertion", assertion);
        return jsonRequest(tokenUrl, request, { requestName: `${this.constructor.name}.fetchJwtBearerToken`, correlationId: options.correlationId });
      }
      /**
       * Builds a request for this service based on the service configuration and the given request options.
       * For example, the request will use the timeout value from the service configuration if not overridden in the request options.
       *
       * @internal
       * @param {import("node:https").RequestOptions} [requestOptions] - options for the request
       */
      buildRequest(requestOptions) {
        return {
          timeout: this.config.requests.timeout,
          retry: this.config.requests.retry,
          ...requestOptions
        };
      }
      /**
       * Builds a token request for this service with the given grant_type and options.
       *
       * @param {String} grant_type
       * @param {TokenFetchOptions} options
       */
      buildTokenRequest(grant_type, options) {
        const request = this.buildRequest({
          method: "POST",
          body: new URLSearchParams({
            grant_type
          })
        });
        this.addClientAuthentication(request, options);
        if (options.timeout) {
          request.timeout = options.timeout;
        }
        if (options.token_format) {
          request.body.append("token_format", options.token_format);
        }
        return request;
      }
      /**
       * Prepares the given request to use this service's client credentials for authentication.
       * Adds clientid and either clientsecret or an mTLS agent based on client certificate, depending on the type of credentials.
       * @param {RequestInit} request
       * @param {URLSearchParams} request.body
       * @param {TokenFetchOptions} options
       */
      addClientAuthentication(request, options = {}) {
        this.validateCredentials("fetch token", "clientid");
        request.body.append("client_id", this.credentials.clientid);
        if (this.credentials.clientsecret) {
          request.body.append("client_secret", this.credentials.clientsecret);
        } else if (this.credentials.key && this.credentials.certificate) {
          request.agent = new Agent({
            key: this.credentials.key,
            cert: this.credentials.certificate
          });
        } else {
          throw new InvalidCredentialsError("Service credentials contain neither a client secret nor certificate based authentication information.");
        }
      }
      /**
       * Updates the certificate and key in the service credentials for authentication of subsequent requests.
       * @param {String} cert PEM-encoded client certificate
       * @param {String} key PEM-encoded client key
       * @returns {void}
       */
      setCertificateAndKey(cert, key) {
        this.credentials.certificate = cert;
        this.credentials.key = key;
      }
      /**
       * Builds the configuration of this service based on the provided configuration and default values.
       * @param {ServiceConfig} config 
       */
      static buildServiceConfiguration(config) {
        config.endpoints ??= {};
        config.endpoints.oidc_info ??= "/.well-known/openid-configuration";
        config.validation ??= {};
        config.validation.jwks ??= {};
        config.validation.jwks.shared ??= false;
        config.validation.jwks.expirationTime ??= ResponseCache.DEFAULT_EXPIRATION_TIME;
        config.validation.jwks.refreshPeriod ??= ResponseCache.DEFAULT_REFRESH_PERIOD;
        config.validation.signatureCache ??= { enabled: false };
        if (config.validation.signatureCache.enabled === false || config.validation.signatureCache.size === 0) {
          config.validation.signatureCache = { enabled: false };
        } else if (config.validation.signatureCache.impl) {
          config.validation.signatureCache = { impl: config.validation.signatureCache.impl, enabled: true };
        } else {
          config.validation.signatureCache = { ..._Service.DEFAULT_SIGNATURE_CACHE_CONFIG, ...config.validation.signatureCache, enabled: true };
        }
        config.requests ??= {};
        config.requests.timeout = Math.min(MAX_TIMEOUT, config.requests.timeout ?? DEFAULT_TIMEOUT);
        if (config.requests.retry) {
          if (config.requests.retry === true) {
            config.requests.retry = { ..._Service.DEFAULT_RETRY_CONFIG };
          } else {
            config.requests.retry = { ..._Service.DEFAULT_RETRY_CONFIG, ...config.requests.retry };
          }
        }
        return config;
      }
      /**
       * Creates a new {@link SecurityContext} from this service with the given token.
       * @abstract
       * @param {String|Token} token as JWT or Token object
       * @param {SecurityContextConfig} contextConfig
       * @returns {Promise<SecurityContext>} securityContext
       */
      async createSecurityContext(token, contextConfig = {}) {
        throw new ConfigurationError("This abstract function MUST be called on a service-specific implementation.");
      }
      /**
       * Retrieves the JWKS (JSON Web Key Set) for the given token and context configuration.
       *
       * @param {string} token the token for which to retrieve the JWKS.
       * @param {SecurityContextConfig} contextConfig the context configuration object.
       * @returns {Promise<Jwks>} A promise that resolves to the JWKS (JSON Web Key Set) object.
       * @throws {Error} If an error occurs while retrieving the JWKS.
       */
      async getJwks(token, contextConfig) {
        throw new ConfigurationError("This abstract function MUST be called on a service-specific implementation.");
      }
      /**
       * Determines the URL that can be used for fetching tokens of given grant_type from this service.
       * @abstract
       * @param {GrantType} grant_type
       * @param {Object} options
       * @param {String} options.correlationId
       * @returns {Promise<URL>} URL of the service's token endpoint
       */
      async getTokenUrl(grant_type, options = {}) {
        throw new ConfigurationError("This abstract function MUST be called on a service-specific implementation.");
      }
    };
    module2.exports = Service;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/token/IdentityServiceToken.js
var require_IdentityServiceToken = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/token/IdentityServiceToken.js"(exports2, module2) {
    var Token = require_Token();
    var IdentityServiceToken = class extends Token {
      /**
       * @param {string|null} jwt 
       * @param {object} [content] - optional parsed header and payload
       * @param {import('../util/Types').JwtHeader & { [key: string]: any }} [content.header] - parsed header
       * @param {import('../util/Types').JwtPayload & import('../util/Types').IdentityServiceJwtPayload & { [key: string]: any }} [content.payload] - parsed payload
       */
      constructor(jwt, { header, payload } = {}) {
        super(jwt, { header, payload });
      }
      /**
       * @returns {string} The ID of the caller's tenant within the SAP Cloud Identity Service application for which the token was fetched.
       */
      get appTid() {
        return this.payload.app_tid ?? this.payload.zone_uuid;
      }
      /**
       * Returns the SAP Cloud Identity Service APIs consumed by the caller (based on the token's 'ias_apis' claim).
       * @returns {string[]} The consumed APIs or [] if the caller does not consume any APIs.
       */
      get consumedApis() {
        return this.payload.ias_apis || [];
      }
      get customIssuer() {
        return this.payload.ias_iss ? this.payload.iss : null;
      }
      /** 
       * @returns {string} The issuer of the token.
       */
      get issuer() {
        return this.payload.ias_iss || this.payload.iss;
      }
      /**
       * Returns the SCIM id of the user.
       * @returns {string} The SCIM id or undefined if the token does not contain a SCIM id, e.g. because it is a technical user token.
       */
      get scimId() {
        return this.payload.scim_id;
      }
      // Methods for backward-compatibility
      getAppTID() {
        return this.appTid;
      }
      getCustomIssuer() {
        return this.customIssuer;
      }
      /**
       * @deprecated Access appTid instead
       */
      getZoneId() {
        return this.appTid;
      }
    };
    module2.exports = IdentityServiceToken;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/jwks/Jwk.js
var require_Jwk = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/jwks/Jwk.js"(exports2, module2) {
    var crypto6 = require("crypto");
    var UnsupportedAlgorithmError = require_UnsupportedAlgorithmError();
    var InvalidTokenSignatureError = require_InvalidTokenSignatureError();
    var availableHashes = crypto6.getHashes();
    var Jwk = class _Jwk {
      key;
      // key information from JWKS response
      pubKey;
      // Node.Js crypto public key
      nodeAlg;
      // alg as Node.Js crypto name, e.g. RSA-SHA256
      /**
       * Creates a JWK based on a jwk-formatted public key
       * @param {Object} key key information in jwk format
       */
      constructor(key) {
        this.key = key;
        this.pubKey = crypto6.createPublicKey({
          key,
          format: "jwk"
        });
      }
      /**
       * Creates a JWK based on a PEM-formatted public key
       * @param {String} pem public key in PEM format
       * @returns Jwk
       */
      static fromPEM(pem) {
        const cleanedUpPem = _Jwk.cleanUpPemKey(pem);
        const pubKey = crypto6.createPublicKey({
          key: cleanedUpPem,
          format: "pem"
        });
        const jwk = pubKey.export({ format: "jwk" });
        return new _Jwk(jwk);
      }
      /**
       * Validates if the token was signed with the private key that belongs to this public key.
       * If available, uses the signature cache to avoid validating the same signature again on subsequent requests.
       * @param {Token} token 
       * @param {import("../util/Types").Cache} [signatureCache] an optional cache for signature validation results
       * @returns void if the signature is valid
       * @throws {InvalidTokenSignatureError} when signature is invalid
       */
      validateSignature(token, signatureCache) {
        let validationResult = signatureCache?.get(token.jwt);
        if (validationResult == null) {
          validationResult = this.validateSignatureWithoutCache(token);
          signatureCache?.set(token.jwt, validationResult);
        }
        if (validationResult !== true) {
          throw new InvalidTokenSignatureError(token);
        }
      }
      /**
       * Validates if the token was signed with the private key that belongs to this public key without using a cache.
       * @param {Token} token 
       * @returns {boolean} true if the signature is valid, false otherwise
       */
      validateSignatureWithoutCache(token) {
        const nodeAlg = _Jwk.mapAlgToNodeAlg(token.header.alg);
        if (!availableHashes.includes(nodeAlg)) {
          throw new UnsupportedAlgorithmError(token, token.header.alg);
        }
        const [header, payload, signature] = token.jwt.split(".");
        const verifier = crypto6.createVerify(nodeAlg);
        verifier.update(`${header}.${payload}`);
        return verifier.verify(this.pubKey, signature, "base64");
      }
      static mapAlgToNodeAlg(alg) {
        switch (alg?.toUpperCase()) {
          case "RS256":
            return "RSA-SHA256";
          case "RS384":
            return "RSA-SHA384";
          case "RS512":
            return "RSA-SHA512";
          default:
            return null;
        }
      }
      /* 
      * Adds missing line breaks to malformed PEM keys.
      * For backward-compatibility, a specific kind of malformed PEM needs to be supported that is lacking line breaks around the header and footer.
      * This kind of PEM input can occur, for example, in old service bindings of XSA and is not always fixable by consumers of this library.
      */
      static cleanUpPemKey(pem = "") {
        if (!pem.includes("KEY-----\n")) {
          pem = pem.replace("KEY-----", "KEY-----\n");
        }
        if (!pem.includes("\n-----END")) {
          pem = pem.replace("-----END", "\n-----END");
        }
        return pem;
      }
    };
    module2.exports = Jwk;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/jwks/Jwks.js
var require_Jwks = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/jwks/Jwks.js"(exports2, module2) {
    var Jwk = require_Jwk();
    var MissingKidError = require_MissingKidError();
    var Jwks = class {
      constructor(keys = []) {
        this.keys = /* @__PURE__ */ Object.create(null);
        for (const k of keys) {
          this.keys[k.kid] = new Jwk(k);
        }
      }
      /**
       * Retrieves the JWK (JSON Web Key) associated with the specified key ID (kid).
       * @param {string} kid - The key ID (kid) of the JWK to retrieve.
       * @returns {Jwk} - The JWK associated with the specified key ID.
       * @throws {MissingKidError} - If the JWKS does not contain a key for the specified key ID.
       */
      get(kid) {
        const jwk = this.keys[kid];
        if (!jwk) throw new MissingKidError(kid, `JWKS does not contain a key for kid=${kid}`);
        return jwk;
      }
    };
    module2.exports = Jwks;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/service/IdentityService.js
var require_IdentityService = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/service/IdentityService.js"(exports2, module2) {
    "use strict";
    var Service = require_Service();
    var SecurityContext = require_SecurityContext();
    var IdentityServiceSecurityContext = require_IdentityServiceSecurityContext();
    var IdentityServiceToken = require_IdentityServiceToken();
    var Jwks = require_Jwks();
    var { MissingClientCertificateError, MissingIssuerError, InvalidIssuerError, UntrustedIssuerError, X5tError, ConfigurationError, ResponseError, WrongAudienceError } = require_error();
    var util = require_util3();
    var { createCacheKey, escapeStringForRegex } = require_util3();
    var { jsonRequest } = require_jsonRequest();
    var { APP_TID_HEADER, AZP_HEADER, CLIENT_CERTIFICATE_HEADER, CLIENTID_HEADER, HTTPS_SCHEME, SERVICE_PLAN_HEADER, X5T_CNF_CLAIM } = require_constants2();
    var Token = require_Token();
    var IdentityService = class _IdentityService extends Service {
      /**
       * @param {ServiceCredentials & IdentityServiceCredentials} credentials 
       * @param {ServiceConfig & IdentityServiceConfig} [serviceConfiguration={}]
       */
      constructor(credentials, serviceConfiguration) {
        super(credentials, serviceConfiguration);
      }
      /**
       * @override
       * @param {String|IdentityServiceToken} token token as JWT or IdentityServiceToken object
       * @param {SecurityContextConfig} contextConfig 
       * @returns {Promise<IdentityServiceSecurityContext>}
       */
      async createSecurityContext(token, contextConfig = {}) {
        if (typeof token === "string") {
          token = new IdentityServiceToken(token);
        } else if (token instanceof Token && !(token instanceof IdentityServiceToken)) {
          token = new IdentityServiceToken(token.jwt, { header: token.header, payload: token.payload });
        }
        SecurityContext.buildContextConfig(contextConfig);
        if (contextConfig.skipValidation !== true) {
          if (this.#proofTokenCheckRequired(token) || this.hasX5tEnabled()) {
            if (contextConfig.clientCertificatePem == null) {
              throw new MissingClientCertificateError();
            } else {
              contextConfig.clientCertificate = util.parsePemCertificate(contextConfig.clientCertificatePem);
            }
          }
          await this.validateToken(token, contextConfig);
        }
        const ctx = new IdentityServiceSecurityContext(this, token, contextConfig);
        for (let extension of this.config.context?.extensions || []) {
          await extension.extendSecurityContext(ctx);
        }
        return ctx;
      }
      /**
       * @override
       * @param {IdentityServiceToken} token 
       * @param {SecurityContextConfig} contextConfig 
       */
      async validateToken(token, contextConfig) {
        if (this.hasX5tEnabled()) {
          _IdentityService.validateTokenOwnership(token, contextConfig.clientCertificate);
        }
        await super.validateToken(token, contextConfig);
      }
      /**
       * Retrieves the JWKS (JSON Web Key Set) for the given token and context configuration.
       * 
       * @param {string} token - The token for which to retrieve the JWKS.
       * @param {SecurityContextConfig} contextConfig - The context configuration object.
       * @returns {Promise<Jwks>} - A promise that resolves to the JWKS (JSON Web Key Set) object.
       * @throws {WrongAudienceError} - if the online validation in the JWKS endpoint of the Identity Service instance responds with a 400 status code, indicating that the token should not be accepted by this service.
       * @throws {Error} - If an error occurs while retrieving the JWKS.
       */
      async getJwks(token, contextConfig) {
        this.validateCredentials("fetch JWKS", "clientid", "url");
        const issuerUrl = _IdentityService.getSafeUrlFromTokenIssuer(token, this.credentials.domains);
        const jwksParams = {
          clientid: this.credentials.clientid,
          app_tid: token.appTid,
          azp: token.azp
        };
        const keyParts = { url: issuerUrl, ...jwksParams };
        const proofTokenCheck = this.#proofTokenCheckRequired(token);
        if (proofTokenCheck) {
          keyParts.certSub = contextConfig.clientCertificate?.subject;
          jwksParams.clientCertificatePem = contextConfig.clientCertificatePem?.replaceAll("\\n", "").replaceAll("\n", "");
        }
        const cacheKey = createCacheKey(keyParts);
        const buildJwksRequest = () => {
          const issuerService = issuerUrl === this.credentials.url ? this : new _IdentityService({ url: issuerUrl, clientid: this.credentials.clientid });
          const extractHeaders = proofTokenCheck ? "headers" : null;
          return async (correlationId) => {
            const jwksResponse = await issuerService.fetchJwks(jwksParams, { correlationId, extractHeaders });
            return {
              jwks: new Jwks(jwksResponse.keys),
              servicePlans: proofTokenCheck ? jwksResponse.headers.get(SERVICE_PLAN_HEADER)?.split(",").map((plan) => plan.replaceAll('"', "")) : null
            };
          };
        };
        let cachedResponse;
        try {
          cachedResponse = await this.jwksCache.getOrRequest(cacheKey, buildJwksRequest, { correlationId: contextConfig.correlationId });
        } catch (error) {
          if (error instanceof ResponseError && error.responseCode === 400 && error.request.name === `${this.constructor.name}.fetchJwks`) {
            throw new WrongAudienceError(token, this, `The online validation in the JWKS endpoint of the Identity Service instance responded with 400: '${error.responseText}'. This indicates that the token should not be accepted by this service.`);
          }
          throw error;
        }
        const { jwks, servicePlans } = cachedResponse;
        if (proofTokenCheck) {
          contextConfig.servicePlans = servicePlans;
        }
        return jwks;
      }
      async fetchJwks({ clientid, app_tid, azp, clientCertificatePem }, { correlationId, extractHeaders }) {
        const openIDConfiguration = await this.getOpenIDConfiguration({ correlationId });
        const jwksUrl = openIDConfiguration.jwks_uri;
        const request = this.buildRequest({
          method: "GET",
          headers: {
            [CLIENTID_HEADER]: clientid
          }
        });
        if (app_tid != null) {
          request.headers[APP_TID_HEADER] = app_tid;
        }
        if (azp != null) {
          request.headers[AZP_HEADER] = azp;
        }
        if (clientCertificatePem != null) {
          request.headers[CLIENT_CERTIFICATE_HEADER] = clientCertificatePem;
        }
        return jsonRequest(jwksUrl, request, { requestName: `${this.constructor.name}.fetchJwks`, correlationId, extractHeaders });
      }
      // Re-declare JSDoc for token fetches with detailed options and return object properties
      /**
       * Fetches a token from this service with this service's client credentials.
       * @param {TokenFetchOptions & IdentityServiceTokenFetchOptions} options
       * @returns {Promise<TokenFetchResponse>}
       */
      async fetchClientCredentialsToken(options = {}) {
        return super.fetchClientCredentialsToken(options);
      }
      /**
       * Fetches a user token from this service with the given username and password.
       * @param {String} username
       * @param {String} password
       * @param {TokenFetchOptions & IdentityServiceTokenFetchOptions} options      
       * @returns {Promise<TokenFetchResponse & IdTokenFetchResponse & RefreshableTokenFetchResponse>}
       */
      async fetchPasswordToken(username, password, options = {}) {
        return super.fetchPasswordToken(username, password, options);
      }
      /**
       * Fetches a JWT bearer token from this service with the given user token as assertion.
       * @param {String} assertion JWT bearer token used as assertion   
       * @param {TokenFetchOptions & IdentityServiceTokenFetchOptions} options      
       * @returns {Promise<TokenFetchResponse & IdTokenFetchResponse & RefreshableTokenFetchResponse>}
       */
      async fetchJwtBearerToken(assertion, options = {}) {
        return super.fetchJwtBearerToken(assertion, options);
      }
      /** @override */
      buildTokenRequest(grant_type, options) {
        const request = super.buildTokenRequest(grant_type, options);
        if (options.resource) {
          [options.resource].flatMap((r) => r).forEach((resource) => request.body.append("resource", resource));
        }
        return request;
      }
      /**
       * Prepares the given formData and fetch options to use this service's client credentials for authentication.
       * Adds clientid, app_tid and either clientsecret or an mTLS agent based on client certificate, depending on the type of credentials.
       * @param {RequestInit} request 
       * @param {URLSearchParams} request.body
       * @param {TokenFetchOptions} options
       * @override
       */
      addClientAuthentication(request, options = {}) {
        super.addClientAuthentication(request, options);
        const app_tid = options.app_tid ?? this.credentials.app_tid;
        if (app_tid != null) {
          request.body.append("app_tid", app_tid);
        }
      }
      /**
       * @override
       * @inheritdoc
       */
      async getTokenUrl(grant_type, options = {}) {
        const { correlationId } = options;
        const openidConfiguration = await this.getOpenIDConfiguration({ correlationId });
        if (!openidConfiguration.grant_types_supported.includes(grant_type)) {
          throw new ConfigurationError(`This Identity Service instance does not support grant type ${grant_type} according to its openid-configuration.`);
        }
        return new URL(openidConfiguration.token_endpoint);
      }
      /** 
       * Returns whether proof token validation has been enabled via the service's configuration.
       * @returns {Boolean}
       */
      hasProofTokenEnabled() {
        return this.config.validation?.proofToken?.enabled;
      }
      /** 
       * Returns whether x5t proof of token ownership validation has been enabled via the service's configuration.
       * @returns {Boolean}
       */
      hasX5tEnabled() {
        return this.config.validation?.x5t?.enabled;
      }
      /**
       * Returns whether a proof token check has to be done for the given token.
       * The decision depends on the type of token.
       * Tokens with claim ias_api are App2App tokens for which a proof token check must not be done, even when enabled via the configuration.
       * @param {IdentityServiceToken} token 
       */
      #proofTokenCheckRequired(token) {
        return this.hasProofTokenEnabled() && token.payload.ias_apis == null;
      }
      /**
       * Returns an issuer URL based on the issuer of the token if it can be succesfully validated against a list of trusted domains.
       * @param {IdentityServiceToken} token token from which issuer is extracted
       * @param {Array<string>} trustedDomains a list of trusted domains
       * @returns {String} URL of issuer if its domain is either a trusted domain or a subdomain of a trusted domain
       * @throws {UntrustedIssuerError} if issuer is empty, not trusted or not a valid URL
       */
      static getSafeUrlFromTokenIssuer = function(token, trustedDomains = []) {
        const issuer = token?.issuer;
        if (!issuer) {
          throw new MissingIssuerError(token);
        }
        const issuerUrl = issuer.startsWith(HTTPS_SCHEME) ? issuer : `${HTTPS_SCHEME}${issuer}`;
        try {
          new URL(issuerUrl);
        } catch (e) {
          throw new InvalidIssuerError(token, e);
        }
        const issuerDomain = issuerUrl.substring(HTTPS_SCHEME.length);
        for (let d of trustedDomains) {
          const validSubdomainPattern = `^[a-zA-Z0-9-]{1,63}\\.${escapeStringForRegex(d)}$`;
          if (issuerDomain === d || issuerDomain.match(new RegExp(validSubdomainPattern))) {
            return issuerUrl;
          }
        }
        throw new UntrustedIssuerError(token);
      };
      /**
       * Validates that the client owning the given certificate is the owner of the token.
       * The validation is based on proof-of-posession via certificate binding of tokens as described in {@link https://datatracker.ietf.org/doc/html/rfc8705 RFC 8705}.
       * The validation is succesful if the token contains an base64url-encoded x5t thumbprint under claim {@link CNF_X5T_CLAIM cnf.x5t#S256} that matches the given certificate.
       * The client certificate against which the validation is performed, is typically extracted from the {@link FWD_CLIENT_CERT_HEADER x-forwarded-client-cert} request header where it is put by BTP after TLS termination.
       * @param {IdentityServiceToken} token 
       * @param {X509Certificate} cert client certificate parsed as X509Certificate
       */
      static validateTokenOwnership(token, cert) {
        const tokenX5t = token.payload.cnf?.[X5T_CNF_CLAIM];
        if (!tokenX5t) {
          throw new X5tError(token, cert, "X5t validation failed because x5t thumbprint could not be found in token.");
        }
        let certificateX5t;
        try {
          certificateX5t = Buffer.from(cert.fingerprint256.replaceAll(":", ""), "hex").toString("base64url");
        } catch (e) {
          throw new X5tError(token, cert, "x5t validation failed because x5t thumbprint could not be calculated from client certificate.");
        }
        if (tokenX5t !== certificateX5t) {
          throw new X5tError(token, cert, "x5t thumbprint did not match the thumbprint of the provided client certificate.");
        }
      }
    };
    module2.exports = IdentityService;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/token/XsuaaToken.js
var require_XsuaaToken = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/token/XsuaaToken.js"(exports2, module2) {
    var Token = require_Token();
    var XsuaaToken = class extends Token {
      /**
       * @param {string|null} jwt 
       * @param {object} [content] - optional parsed header and payload
       * @param {import('../util/Types').JwtHeader & { [key: string]: any }} [content.header] - parsed header
       * @param {import('../util/Types').JwtPayload & import('../util/Types').XsuaaJwtPayload & { [key: string]: any }} [content.payload] - parsed payload
       */
      constructor(jwt, { header, payload } = {}) {
        super(jwt, { header, payload });
      }
      get azAttributes() {
        return this.payload.az_attr;
      }
      get extAttributes() {
        return this.payload.ext_attr;
      }
      get logonName() {
        return this.payload.user_name;
      }
      /**
       * @returns {string[]} the scopes of the token
       */
      get scopes() {
        return this.payload.scope ?? [];
      }
      get serviceInstanceId() {
        return this.payload.ext_attr?.serviceinstanceid;
      }
      get subAccountId() {
        return this.payload.ext_attr?.subaccountid || this.zid;
      }
      get userId() {
        return super.userId || this.payload.sub;
      }
      get xsUserAttributes() {
        return this.payload.ext_cxt?.["xs.user.attributes"] ?? this.payload["xs.user.attributes"];
      }
      get xsSystemAttributes() {
        return this.payload.ext_cxt?.["xs.system.attributes"] ?? this.payload["xs.system.attributes"];
      }
      /**
       * @returns {string} The zone id of the token.
       */
      get zid() {
        return this.payload.zid;
      }
      getXsUserAttribute(name) {
        return this.xsUserAttributes?.[name];
      }
      // Methods for backward-compatibility
      getAppTID() {
        return this.zid;
      }
      getCustomIssuer() {
        return this.issuer;
      }
      getZoneId() {
        return this.zid;
      }
    };
    module2.exports = XsuaaToken;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/service/XsuaaService.js
var require_XsuaaService = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/service/XsuaaService.js"(exports2, module2) {
    "use strict";
    var Service = require_Service();
    var SecurityContext = require_SecurityContext();
    var XsuaaSecurityContext = require_XsuaaSecurityContext();
    var XsuaaToken = require_XsuaaToken();
    var Jwks = require_Jwks();
    var { jsonRequest } = require_jsonRequest();
    var { HTTPS_SCHEME, ZID_QUERY_PARAMETER, ZID_HEADER } = require_constants2();
    var { createCacheKey } = require_util3();
    var { ResponseError, WrongAudienceError } = require_error();
    var Token = require_Token();
    var XsuaaService = class extends Service {
      #jwksBaseUrl;
      // base URL from which the JWKS is fetched
      /**
       * @param {ServiceCredentials & XsuaaServiceCredentials} credentials 
       * @param {ServiceConfig} [serviceConfig={}] 
       */
      constructor(credentials, serviceConfig) {
        serviceConfig ??= {};
        serviceConfig.endpoints ??= {};
        serviceConfig.endpoints.oidc_info ??= "/.well-known/openid-configuration";
        serviceConfig.endpoints.jwks ??= "/token_keys";
        serviceConfig.endpoints.token ??= "/oauth/token";
        super(credentials, serviceConfig);
      }
      /**
       * @overrides
       * @inheritdoc
       */
      acceptsTokenAudience(token) {
        this.validateCredentials("validate token audience", "clientid", "xsappname");
        if (!(token instanceof XsuaaToken)) {
          token = new XsuaaToken(null, { header: token.header, payload: token.payload });
        }
        let audiencesToConsider;
        if (token.audiences?.length > 0) {
          audiencesToConsider = [...token.audiences];
        } else if (token.scopes) {
          audiencesToConsider = [...token.scopes];
        } else {
          audiencesToConsider = [];
        }
        if (token.payload.cid) {
          audiencesToConsider.push(token.payload.cid);
        }
        return audiencesToConsider.some((a) => a === this.credentials.clientid || a.startsWith(`${this.credentials.clientid}.`)) || audiencesToConsider.some((a) => a === this.credentials.xsappname || a.startsWith(`${this.credentials.xsappname}.`)) || this.credentials.clientid.includes("!b") && audiencesToConsider.some((a) => a.endsWith(`|${this.credentials.xsappname}`));
      }
      /**
       * @override
       * @param {String|XsuaaToken} token as JWT or XsuaaToken object
       * @param {SecurityContextConfig} contextConfig 
       * @returns {Promise<XsuaaSecurityContext}
       */
      async createSecurityContext(token, contextConfig = {}) {
        if (typeof token === "string") {
          token = new XsuaaToken(token);
        } else if (token instanceof Token && !(token instanceof XsuaaToken)) {
          token = new XsuaaToken(token.jwt, { header: token.header, payload: token.payload });
        }
        SecurityContext.buildContextConfig(contextConfig);
        if (contextConfig.skipValidation !== true) {
          await this.validateToken(token, contextConfig);
        }
        const ctx = new XsuaaSecurityContext(this, token, contextConfig);
        for (let extension of this.config.context?.extensions || []) {
          await extension.extendSecurityContext(ctx);
        }
        return ctx;
      }
      async getJwks(token, contextConfig) {
        const jwksParams = {
          zid: token.zid
        };
        const keyParts = { url: this.jwksBaseUrl, ...jwksParams };
        const cacheKey = createCacheKey(keyParts);
        const buildJwksRequest = () => {
          return async (correlationId) => {
            const jwksResponse = await this.fetchJwks({ ...jwksParams, correlationId });
            return new Jwks(jwksResponse.keys);
          };
        };
        let jwks;
        try {
          jwks = await this.jwksCache.getOrRequest(cacheKey, buildJwksRequest, { correlationId: contextConfig.correlationId });
        } catch (error) {
          if (error instanceof ResponseError && error.responseCode === 400) {
            throw new WrongAudienceError(token, this, `The online validation in the JWKS endpoint of the XSUAA server responded with 400: '${error.responseText}'. This indicates that the token should not be accepted by this service.`);
          }
          throw error;
        }
        return jwks;
      }
      /**
       * @internal
       * Returns the base URL (https protocol + uaadomain from the credentials) that can be used for JWKS fetches.
       * @returns {String} base URL for JWKS fetches
       */
      get jwksBaseUrl() {
        if (!this.#jwksBaseUrl) {
          this.validateCredentials("fetch JWKS", "uaadomain");
          const { uaadomain } = this.credentials;
          if (uaadomain.startsWith(HTTPS_SCHEME)) {
            this.#jwksBaseUrl = uaadomain;
          } else {
            this.#jwksBaseUrl = `${HTTPS_SCHEME}${uaadomain}`;
          }
        }
        return this.#jwksBaseUrl;
      }
      async fetchJwks(jwksParams, correlationId) {
        const jwksUrl = new URL(this.jwksBaseUrl + this.endpoints.jwks);
        if (jwksParams.zid) {
          jwksUrl.searchParams.append(ZID_QUERY_PARAMETER, jwksParams.zid);
        }
        const request = this.buildRequest({
          method: "GET"
        });
        return jsonRequest(jwksUrl, request, { requestName: `${this.constructor.name}.fetchJwks`, correlationId });
      }
      // Re-declare JSDoc for token fetches with detailed options and return object properties
      /**
       * Fetches a token from this service with this service's client credentials.
       * @param {TokenFetchOptions & XsuaaTokenFetchOptions} options
       * @returns {Promise<TokenFetchResponse>} response
       */
      async fetchClientCredentialsToken(options = {}) {
        return super.fetchClientCredentialsToken(options);
      }
      /**
       * Fetches a user token from this service with the given username and password.
       * @param {String} username
       * @param {String} password
       * @param {TokenFetchOptions & XsuaaTokenFetchOptions} options
       * @returns {Promise<TokenFetchResponse & RefreshableTokenFetchResponse>} response
       */
      async fetchPasswordToken(username, password, options = {}) {
        return super.fetchPasswordToken(username, password, options);
      }
      /**
       * Fetches a JWT bearer token from this service with the given user token as assertion.
       * @param {String} assertion JWT bearer token used as assertion   
       * @param {TokenFetchOptions & XsuaaTokenFetchOptions} options
       * @returns {Promise<TokenFetchResponse & RefreshableTokenFetchResponse>} response
       */
      async fetchJwtBearerToken(assertion, options = {}) {
        return super.fetchJwtBearerToken(assertion, options);
      }
      /** @override */
      buildTokenRequest(grant_type, options) {
        const request = super.buildTokenRequest(grant_type, options);
        if (options.scope) {
          request.body.append("scope", options.scope);
        }
        if (options.authorities) {
          request.body.append("authorities", JSON.stringify({ az_attr: options.authorities }));
        }
        if (options.zid) {
          request.headers ??= {};
          request.headers[ZID_HEADER] = options.zid;
        }
        return request;
      }
      /**
       * Determines the URL that can be used for fetching tokens from this service, optionally adjusted for a tenant in the same subaccount.
       * @override
       * @inheritdoc
       * @param {GrantType} grant_type
       * @param {String} options.tenant
       */
      async getTokenUrl(grant_type, options = {}) {
        const { tenant } = options;
        let baseUrl;
        if (tenant) {
          this.validateCredentials("build token fetch URL for custom tenant subdomain", "uaadomain");
          const uaaDomain = this.credentials.certificate ? this.credentials.uaadomain.replace("authentication.", "authentication.cert.") : this.credentials.uaadomain;
          baseUrl = `${HTTPS_SCHEME}${tenant}.${uaaDomain}`;
        } else {
          if (this.credentials.certificate) {
            this.validateCredentials("fetch token via certificate authentication", "certurl");
            baseUrl = this.credentials.certurl;
          } else {
            this.validateCredentials("fetch token via client secret authentication", "url");
            baseUrl = this.credentials.url;
          }
        }
        return new URL(this.endpoints.token, baseUrl);
      }
    };
    module2.exports = XsuaaService;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/token/XsaToken.js
var require_XsaToken = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/token/XsaToken.js"(exports2, module2) {
    var XsuaaToken = require_XsuaaToken();
    var XsaToken = class extends XsuaaToken {
    };
    module2.exports = XsaToken;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/service/XsaService.js
var require_XsaService = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/service/XsaService.js"(exports2, module2) {
    "use strict";
    var SecurityContext = require_SecurityContext();
    var XsaSecurityContext = require_XsaSecurityContext();
    var XsaToken = require_XsaToken();
    var Jwk = require_Jwk();
    var MissingKidError = require_MissingKidError();
    var MissingVerificationKeyError = require_MissingVerificationKeyError();
    var { getLogger } = require_logging();
    var XsuaaService = require_XsuaaService();
    var Token = require_Token();
    var LOG = getLogger("XsaService.js");
    var XsaService = class extends XsuaaService {
      /**
       * @param {ServiceCredentials & XsaServiceCredentials} credentials 
       * @param {ServiceConfig} [serviceConfig={}]
       */
      constructor(credentials, serviceConfig) {
        super(credentials, serviceConfig);
      }
      /**
       * @override
       * @param {String|XsaToken} token token as JWT or XsaToken object
       * @param {SecurityContextConfig} contextConfig 
       * @returns {Promise<XsaSecurityContext>}
       */
      async createSecurityContext(token, contextConfig = {}) {
        if (typeof token === "string") {
          token = new XsaToken(token);
        } else if (token instanceof Token && !(token instanceof XsaToken)) {
          token = new XsaToken(token.jwt, { header: token.header, payload: token.payload });
        }
        SecurityContext.buildContextConfig(contextConfig);
        if (contextConfig.skipValidation !== true) {
          await this.validateToken(token, contextConfig);
        }
        const ctx = new XsaSecurityContext(this, token, contextConfig);
        for (let extension of this.config.context?.extensions || []) {
          await extension.extendSecurityContext(ctx);
        }
        return ctx;
      }
      async validateTokenSignature(token, contextConfig) {
        const pemKeyFromConfig = this.credentials.verificationkey;
        if (!token.header.jku || !token.header.kid || token.header.kid == "legacy-token-key") {
          LOG.info("Token header contained no JKU or KID or the KID was 'legacy-token-key'");
          return this.#validateTokenSignatureWithFallback(token, pemKeyFromConfig);
        }
        try {
          await super.validateTokenSignature(token, contextConfig);
        } catch (error) {
          if (error instanceof MissingKidError) {
            LOG.info("JWKS did not contain kid.");
            return this.#validateTokenSignatureWithFallback(token, pemKeyFromConfig);
          } else {
            throw error;
          }
        }
      }
      #validateTokenSignatureWithFallback(token, pemKeyFromConfig) {
        if (!pemKeyFromConfig) {
          throw new MissingVerificationKeyError();
        } else {
          LOG.info("Validating token signature with verificationkey from service configuration.");
          return Jwk.fromPEM(pemKeyFromConfig).validateSignature(token);
        }
      }
      /**
       * Fetches a token from this service with this service's client credentials.
       * @param {TokenFetchOptions} options
       * @returns {Promise<TokenFetchResponse>} response
       */
      async fetchClientCredentialsToken(options = {}) {
        return super.fetchClientCredentialsToken(options);
      }
      /**
       * Fetches a user token from this service with the given username and password.
       * @param {String} username
       * @param {String} password
       * @param {TokenFetchOptions} options
       * @returns {Promise<TokenFetchResponse & RefreshableTokenFetchResponse>} response
       */
      async fetchPasswordToken(username, password, options = {}) {
        return super.fetchPasswordToken(username, password, options);
      }
      /**
       * Fetches a JWT bearer token from this service with the given user token as assertion.
       * @param {String} assertion JWT bearer token used as assertion   
       * @param {TokenFetchOptions} options
       * @returns {Promise<TokenFetchResponse & RefreshableTokenFetchResponse>} response
       */
      async fetchJwtBearerToken(assertion, options = {}) {
        return super.fetchJwtBearerToken(assertion, options);
      }
      /**
       * Determines the URL that can be used for fetching tokens from this service.
       * @param {GrantType} grant_type
       */
      async getTokenUrl(grant_type) {
        let baseUrl;
        if (this.credentials.certificate) {
          this.validateCredentials("fetch token via certificate authentication", "certurl");
          baseUrl = this.credentials.certurl;
        } else {
          this.validateCredentials("fetch token via client secret authentication", "url");
          baseUrl = this.credentials.url;
        }
        return new URL(this.endpoints.token, baseUrl);
      }
      /**
       * @override
       * @inheritdoc
       */
      get jwksBaseUrl() {
        this.validateCredentials("fetch JWKS", "url");
        return this.credentials.url;
      }
    };
    module2.exports = XsaService;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/token/UaaToken.js
var require_UaaToken = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/token/UaaToken.js"(exports2, module2) {
    var XsuaaToken = require_XsuaaToken();
    var UaaToken = class extends XsuaaToken {
    };
    module2.exports = UaaToken;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/service/UaaService.js
var require_UaaService = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/service/UaaService.js"(exports2, module2) {
    "use strict";
    var SecurityContext = require_SecurityContext();
    var UaaSecurityContext = require_UaaSecurityContext();
    var Token = require_Token();
    var UaaToken = require_UaaToken();
    var XsuaaService = require_XsuaaService();
    var UaaService = class extends XsuaaService {
      /**
       * @param {ServiceCredentials | UaaServiceCredentials} credentials 
       * @param {ServiceConfig} [serviceConfig={}]
       */
      constructor(credentials, serviceConfig) {
        super(credentials, serviceConfig);
      }
      /**
       * @override
       * @param {String|UaaToken} token token as JWT or UaaToken object
       * @param {SecurityContextConfig} contextConfig 
       * @returns {Promise<UaaSecurityContext>}
       */
      async createSecurityContext(token, contextConfig = {}) {
        if (typeof token === "string") {
          token = new UaaToken(token);
        } else if (token instanceof Token && !(token instanceof UaaToken)) {
          token = new UaaToken(token.jwt, { header: token.header, payload: token.payload });
        }
        SecurityContext.buildContextConfig(contextConfig);
        if (contextConfig.skipValidation !== true) {
          await this.validateToken(token, contextConfig);
        }
        const ctx = new UaaSecurityContext(this, token, contextConfig);
        for (let extension of this.config.context?.extensions || []) {
          await extension.extendSecurityContext(ctx);
        }
        return ctx;
      }
      /**
      * @overrides
      * @inheritdoc
      */
      acceptsTokenAudience(token) {
        this.validateCredentials("validate token audience", "clientid");
        if (!(token instanceof UaaToken)) {
          token = new UaaToken(null, { header: token.header, payload: token.payload });
        }
        const tokenAudiences = token.audiences?.length > 0 ? token.audiences : token.scopes ?? [];
        if (token.payload.cid) {
          tokenAudiences.push(token.payload.cid);
        }
        return tokenAudiences.some((a) => a === this.credentials.clientid || a.startsWith(`${this.credentials.clientid}.`));
      }
    };
    module2.exports = UaaService;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/passport/XssecPassportStrategy.js
var require_XssecPassportStrategy = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/passport/XssecPassportStrategy.js"(exports2, module2) {
    var createSecurityContext = require_createSecurityContext();
    var ConfigurationError = require_ConfigurationError();
    var ValidationError = require_ValidationError();
    var { getLogger } = require_logging();
    var LOG = getLogger("XssecPassportStrategy.js");
    var XssecPassportStrategy = class _XssecPassportStrategy {
      /** @type {Service|Service[]} service(s) against which incoming JWTs are authenticated */
      services;
      /** @type {string|Symbol} the property on the req object where the SecurityContext is placed after authentication. */
      reqProperty;
      /**
       * Creates a new XssecPassportStrategy that uses the provided service(s) to create security contexts for incoming requests.
       * @param {Service|Service[]} services 
       * @param {string|Symbol} [reqProperty="securityContext"] the property (Default: "securityContext") on the req object where the SecurityContext is placed after authentication.
       */
      constructor(services, reqProperty = "securityContext") {
        this.name = "JWT";
        this.services = services;
        this.reqProperty = reqProperty;
      }
      async authenticate(req, passportOptions = {}) {
        try {
          const securityContext = await createSecurityContext(this.services, { req });
          if (passportOptions.scope) {
            if (!(typeof securityContext.checkScope === "function")) {
              return this.error(new ConfigurationError("XssecPassportStrategy was configured with scope but the authentication was performed via a Service whose SecurityContext does not support checkLocalScope."));
            }
            const hasScope = [passportOptions.scope].flatMap((s) => s).some((s) => securityContext.checkLocalScope(s));
            if (!hasScope) {
              return this.fail("Token is missing required scope.", 403);
            }
          }
          const passportUser = _XssecPassportStrategy.#buildPassportUser(securityContext.token);
          req[this.reqProperty] = securityContext;
          req.tokenInfo = securityContext.token;
          return this.success(passportUser, securityContext);
        } catch (error) {
          req.xssecError = error;
          if (error instanceof ValidationError) {
            LOG.debug("ValidationError:", error);
            return this.fail(401);
          } else {
            return this.error(error);
          }
        }
      }
      /**
       * @param {Token} token 
       */
      static #buildPassportUser(token) {
        return {
          id: token.logonName || token.userName,
          name: {
            givenName: token.givenName,
            familyName: token.familyName
          },
          emails: [
            {
              value: token.email
            }
          ]
        };
      }
    };
    module2.exports = XssecPassportStrategy;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/v3/createService.js
var require_createService = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/v3/createService.js"(exports2, module2) {
    var IdentityService = require_IdentityService();
    var XsuaaService = require_XsuaaService();
    var XsaService = require_XsaService();
    var UaaService = require_UaaService();
    module2.exports = createServiceFromCredentials;
    function createServiceFromCredentials(credentials, serviceConfiguration) {
      if (credentials.xsappname && credentials.uaadomain) {
        return new XsuaaService(credentials, serviceConfiguration);
      } else if (credentials.xsappname && credentials.uaadomain == null) {
        return new XsaService(credentials, serviceConfiguration);
      } else if (credentials.xsappname == null && credentials.uaadomain) {
        return new UaaService(credentials, serviceConfiguration);
      } else {
        return new IdentityService(credentials, serviceConfiguration);
      }
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/v3/createSecurityContextV3.js
var require_createSecurityContextV3 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/v3/createSecurityContextV3.js"(exports2, module2) {
    var createSecurityContext = require_createSecurityContext();
    var ConfigurationError = require_ConfigurationError();
    var { getLogger } = require_logging();
    var XsuaaService = require_XsuaaService();
    var IdentityService = require_IdentityService();
    var UaaService = require_IdentityService();
    var createServiceFromCredentials = require_createService();
    var ValidationError = require_ValidationError();
    var XsaService = require_XsaService();
    var LOG = getLogger("createSecurityContextV3.js");
    async function createSecurityContextV3(jwt, configParameter, forceType, cb) {
      if (typeof forceType === "function") {
        cb = forceType;
        forceType = null;
      }
      if (cb == null || typeof cb !== "function") {
        throw new ConfigurationError("The callback parameter must be a function.");
      }
      let securityContext;
      try {
        if (configParameter == null) {
          throw new ConfigurationError("The configParameter parameter must not be null or undefined.");
        } else if (jwt == null) {
          throw new ConfigurationError("The jwt parameter must not be null or undefined.");
        }
        const contextConfig = buildContextConfig(configParameter, jwt);
        const serviceConfig = buildServiceConfig(configParameter);
        const services = buildServices(contextConfig.credentials, forceType, serviceConfig);
        securityContext = await createSecurityContext(services, contextConfig);
      } catch (error) {
        if (error instanceof ValidationError) {
          return cb(error, null, { isValid: () => false, getErrorObject: () => error });
        }
        return cb(error);
      }
      return cb(null, securityContext, securityContext.token);
    }
    function buildContextConfig(configParameter, jwt) {
      const contextConfig = configParameter.credentials ? configParameter : { credentials: configParameter };
      contextConfig.jwt = jwt;
      contextConfig.correlationId ??= contextConfig.credentials.correlationId;
      contextConfig.clientCertificatePem ??= contextConfig.x509Certificate ?? contextConfig.credentials.x509Certificate;
      return contextConfig;
    }
    function buildServiceConfig(configParameter) {
      const serviceConfig = {};
      serviceConfig.endpoints ??= configParameter.endpoints || {};
      serviceConfig.validation ??= configParameter.validation || {};
      serviceConfig.validation.x5t ??= {};
      serviceConfig.validation.x5t.enabled ??= configParameter.x5tValidation;
      serviceConfig.validation.jwks ??= configParameter.jwksCache || {};
      serviceConfig.validation.jwks.shared = true;
      if (configParameter.disableCache) {
        LOG.warn(`The 'disableCache' option to disable the JWKS cache is not supported by the v3 compatibility package. The cache is always enabled.`);
      }
      return serviceConfig;
    }
    function buildServices(credentials, forceType, serviceConfig) {
      const credentialsArray = Array.isArray(credentials) ? credentials : [credentials];
      insertXsAppnameFromEnv(credentialsArray);
      if (forceType) {
        LOG.info(`forceType === ${forceType}. Creating ${forceType} service(s) from credentials.`);
      }
      switch (forceType) {
        case "XSUAA":
          return credentialsArray.map((c) => new XsuaaService(c, serviceConfig));
        case "XSA":
          return credentialsArray.map((c) => new XsaService(c, serviceConfig));
        case "IAS":
          return credentialsArray.map((c) => new IdentityService(c, serviceConfig));
        case "UAA":
          return credentialsArray.map((c) => new UaaService(c, serviceConfig));
        case null:
        case void 0:
        default:
          return credentialsArray.map((c) => createServiceFromCredentials(c, serviceConfig));
      }
    }
    function insertXsAppnameFromEnv(credentials) {
      if (process.env.XSAPPNAME) {
        for (const c of credentials) {
          c.xsappname = process.env.XSAPPNAME;
        }
      }
    }
    module2.exports = createSecurityContextV3;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/v3/requestsV3.js
var require_requestsV3 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/v3/requestsV3.js"(exports2, module2) {
    var IdentityService = require_IdentityService();
    var XsuaaService = require_XsuaaService();
    async function requestClientCredentialsToken(subdomain, config, additionalAttributes, zoneId, cb) {
      if (typeof zoneId === "function") {
        cb = zoneId;
        zoneId = null;
      }
      const credentials = config.credentials ?? config;
      const service = config.type?.toUpperCase() === "IAS" ? new IdentityService(credentials) : new XsuaaService(credentials);
      const options = {
        authorities: additionalAttributes,
        correlationId: config.correlationId,
        resource: config.resource,
        scope: config.scopes,
        tenant: subdomain,
        timeout: config.timeout,
        app_tid: zoneId
      };
      try {
        const response = await service.fetchClientCredentialsToken(options);
        return cb(null, response.access_token, response);
      } catch (e) {
        return cb(e);
      }
    }
    async function requestPasswordUserToken(subdomain, config, additionalAttributes, cb) {
      const credentials = config.credentials ?? config;
      const service = config.type?.toUpperCase() === "IAS" ? new IdentityService(credentials) : new XsuaaService(credentials);
      const options = {
        authorities: additionalAttributes,
        correlationId: config.correlationId,
        resource: config.resource,
        scope: config.scopes,
        tenant: subdomain,
        timeout: config.timeout
      };
      try {
        const response = await service.fetchPasswordToken(config.username, config.password, options);
        return cb(null, config.type?.toUpperCase() === "IAS" ? response.id_token : response.access_token, response);
      } catch (e) {
        return cb(e);
      }
    }
    async function requestUserToken(appToken, config, additionalAttributes, scopes, subdomain, zoneId, cb) {
      if (typeof zoneId === "function") {
        cb = zoneId;
        zoneId = null;
      }
      const credentials = config.credentials ?? config;
      const service = config.type?.toUpperCase() === "IAS" ? new IdentityService(credentials) : new XsuaaService(credentials);
      const options = {
        authorities: additionalAttributes,
        correlationId: config.correlationId,
        resource: config.resource,
        scope: scopes ?? config.scopes,
        tenant: subdomain,
        timeout: config.timeout,
        app_tid: zoneId,
        zid: zoneId
      };
      try {
        const response = await service.fetchJwtBearerToken(appToken, options);
        return cb(null, config.type?.toUpperCase() === "IAS" ? response.id_token : response.access_token, response);
      } catch (e) {
        return cb(e);
      }
    }
    module2.exports = {
      requestClientCredentialsToken,
      requestPasswordUserToken,
      requestUserToken
    };
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/v3/constantsV3.js
var require_constantsV3 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/v3/constantsV3.js"(exports2) {
    Object.defineProperty(exports2, "XSAPPNAMEPREFIX", {
      value: "$XSAPPNAME.",
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "SYSTEM", {
      value: "System",
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "JOBSCHEDULER", {
      value: "JobScheduler",
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "HDB", {
      value: "HDB",
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "GRANTTYPE_AUTHCODE", {
      value: "authorization_code",
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "GRANTTYPE_PASSWORD", {
      value: "password",
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "GRANTTYPE_CLIENTCREDENTIAL", {
      value: "client_credentials",
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "GRANTTYPE_USERTOKEN", {
      value: "user_token",
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "GRANTTYPE_SAML2BEARER", {
      value: "urn:ietf:params:oauth:grant-type:saml2-bearer",
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "TYPE_USER_TOKEN", {
      value: 0,
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "TYPE_CLIENT_CREDENTIALS_TOKEN", {
      value: 1,
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "USER_AGENT", {
      value: "nodejs-xssec-3",
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "FWD_CLIENT_CERT_HEADER", {
      value: "x-forwarded-client-cert",
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "CNF_X5T_CLAIM", {
      value: "x5t#S256",
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "PEM_HEADER", {
      value: "-----BEGIN CERTIFICATE-----",
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "PEM_FOOTER", {
      value: "-----END CERTIFICATE-----",
      enumerable: true,
      writable: false,
      configurable: false
    });
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/v3/XssecPassportStrategyV3.js
var require_XssecPassportStrategyV3 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/v3/XssecPassportStrategyV3.js"(exports2, module2) {
    "use strict";
    var createSecurityContext = require_createSecurityContextV3();
    var { getLogger } = require_logging();
    var { FWD_CLIENT_CERT_HEADER } = require_constantsV3();
    var LOG = getLogger("XssecPassportStrategyV3.js");
    function JWTStrategy(options, forceType) {
      this.options = options;
      this.name = "JWT";
      this._forceType = forceType;
    }
    function SimpleError(errorStr) {
      const errobj = new Error(errorStr);
      this.getErrorObject = function() {
        return errobj;
      };
    }
    JWTStrategy.prototype.authenticate = function(req, passportOptions) {
      var authorization = req.headers.authorization;
      const authParams = passportOptions;
      if (!authorization) {
        LOG.debug("Missing Authorization header");
        req.tokenInfo = new SimpleError("Missing Authorization header");
        return this.fail(401);
      }
      var parts = authorization.split(" ");
      if (parts.length < 2) {
        LOG.debug("Invalid Authorization header format");
        req.tokenInfo = new SimpleError("Invalid Authorization header format");
        return this.fail(400);
      }
      var scheme = parts[0];
      var token = parts[1];
      if (scheme.toLowerCase() !== "bearer") {
        LOG.debug("Authorization header is not a Bearer token");
        req.tokenInfo = new SimpleError("Authorization header is not a Bearer token");
        return this.fail(401);
      }
      const correlationId = req.headers["x-correlationid"] || req.headers["x-vcap-request-id"];
      const x509Certificate = req.headers[FWD_CLIENT_CERT_HEADER];
      try {
        let callback = function(err, ctx, tokenInfo) {
          req.tokenInfo = tokenInfo;
          if (err) {
            if (!req.tokenInfo) {
              req.tokenInfo = new SimpleError(err.toString());
            }
            return err.statuscode ? self2.fail(err.statuscode, err) : self2.error(err);
          }
          if (authParams && authParams.scope) {
            var scopes = Array.isArray(authParams.scope) ? authParams.scope : [authParams.scope];
            for (var scope of scopes) {
              if (!ctx.checkScope(self2.options.xsappname + "." + scope)) {
                return self2.fail(403);
              }
            }
          }
          var jwtLogonName = ctx.getLogonName();
          var jwtGivenName = ctx.getGivenName();
          var jwtFamilyName = ctx.getFamilyName();
          var jwtEmail = ctx.getEmail();
          var user = !jwtLogonName ? {} : {
            id: jwtLogonName,
            name: {
              givenName: jwtGivenName,
              familyName: jwtFamilyName
            },
            emails: [{ value: jwtEmail }]
          };
          self2.success(user, ctx);
        };
        var self2 = this;
        var paramA = this._forceType ? this._forceType : callback;
        var paramB = this._forceType ? callback : void 0;
        const config = { ...passportOptions, credentials: this.options, correlationId };
        if (x509Certificate) {
          config.x509Certificate = x509Certificate;
        }
        createSecurityContext(token, config, paramA, paramB);
      } catch (err) {
        LOG.error("JWT verification error: ", err);
        this.error(err);
      }
    };
    JWTStrategy.JWTStrategy = JWTStrategy;
    module2.exports = JWTStrategy;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/v3/index.js
var require_v3 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/v3/index.js"(exports2, module2) {
    var createSecurityContext = require_createSecurityContextV3();
    var requests = require_requestsV3();
    var constants = require_constantsV3();
    var TokenInfo = require_Token();
    var JWTStrategy = require_XssecPassportStrategyV3();
    module2.exports = {
      createSecurityContext,
      requests,
      constants,
      TokenInfo,
      JWTStrategy
    };
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/util/Types.js
var require_Types = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/util/Types.js"(exports2, module2) {
    module2.exports = {};
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/context/SecurityContextSymbol.js
var require_SecurityContextSymbol = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/context/SecurityContextSymbol.js"(exports2, module2) {
    var SECURITY_CONTEXT = Symbol("XSSEC_SECURITY_CONTEXT");
    module2.exports = SECURITY_CONTEXT;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/index.js
var require_src2 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap/xssec/src/index.js"(exports2, module2) {
    var createSecurityContext = require_createSecurityContext();
    var SecurityContext = require_SecurityContext();
    var IdentityServiceSecurityContext = require_IdentityServiceSecurityContext();
    var XsuaaSecurityContext = require_XsuaaSecurityContext();
    var XsaSecurityContext = require_XsaSecurityContext();
    var UaaSecurityContext = require_UaaSecurityContext();
    var Service = require_Service();
    var IdentityService = require_IdentityService();
    var XsuaaService = require_XsuaaService();
    var XsaService = require_XsaService();
    var UaaService = require_UaaService();
    var XssecPassportStrategy = require_XssecPassportStrategy();
    var Token = require_Token();
    var IdentityServiceToken = require_IdentityServiceToken();
    var XsuaaToken = require_XsuaaToken();
    var XsaToken = require_XsaToken();
    var UaaToken = require_UaaToken();
    var errors = require_error();
    var constants = require_constants2();
    var v3 = require_v3();
    var Types = require_Types();
    var SECURITY_CONTEXT = require_SecurityContextSymbol();
    module2.exports = {
      createSecurityContext,
      SecurityContext,
      IdentityServiceSecurityContext,
      XsuaaSecurityContext,
      XsaSecurityContext,
      UaaSecurityContext,
      Service,
      IdentityService,
      XsuaaService,
      XsaService,
      UaaService,
      XssecPassportStrategy,
      Token,
      IdentityServiceToken,
      XsuaaToken,
      XsaToken,
      UaaToken,
      errors,
      constants,
      v3,
      Types,
      SECURITY_CONTEXT
    };
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/environment-accessor/xsuaa.js
var require_xsuaa = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/environment-accessor/xsuaa.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getXsuaaServiceCredentials = getXsuaaServiceCredentials;
    exports2.clearXsuaaServices = clearXsuaaServices;
    exports2.getXsuaaService = getXsuaaService;
    var xssec_1 = require_src2();
    var service_credentials_1 = require_service_credentials();
    function getXsuaaServiceCredentials(token) {
      const credentials = (0, service_credentials_1.getServiceCredentials)("xsuaa", token);
      if (!credentials) {
        throw new Error(token ? "Could not find XSUAA service binding matching the token." : "Could not find XSUAA service binding.");
      }
      return credentials;
    }
    var xsuaaServices = {};
    function clearXsuaaServices() {
      Object.keys(xsuaaServices).forEach((key) => delete xsuaaServices[key]);
    }
    function getXsuaaService(options) {
      const credentials = options?.credentials || getXsuaaServiceCredentials(options?.jwt);
      const disableCache = !!options?.disableCache;
      const serviceConfig = disableCache ? {
        validation: {
          jwks: {
            expirationTime: 0,
            refreshPeriod: 0
          }
        }
      } : void 0;
      const cacheKey = `${credentials.clientid}:${disableCache}`;
      if (!xsuaaServices[cacheKey]) {
        xsuaaServices[cacheKey] = new xssec_1.XsuaaService(credentials, serviceConfig);
      }
      return xsuaaServices[cacheKey];
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/environment-accessor/index.js
var require_environment_accessor = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/environment-accessor/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_destination(), exports2);
    __exportStar(require_service_bindings(), exports2);
    __exportStar(require_environment_accessor_types(), exports2);
    __exportStar(require_service_credentials(), exports2);
    __exportStar(require_xsuaa(), exports2);
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/jwt/binding.js
var require_binding = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/jwt/binding.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeOrMakeJwt = decodeOrMakeJwt;
    exports2.getTenantIdFromBinding = getTenantIdFromBinding;
    var environment_accessor_1 = require_environment_accessor();
    var jwt_1 = require_jwt();
    function decodeOrMakeJwt(jwt) {
      if (jwt) {
        const decodedJwt = typeof jwt === "string" ? (0, jwt_1.decodeJwt)(jwt) : jwt;
        if ((0, jwt_1.getTenantId)(decodedJwt)) {
          return decodedJwt;
        }
      }
      const providerTenantId = getTenantIdFromBinding();
      if (providerTenantId) {
        return { zid: providerTenantId };
      }
    }
    function getTenantIdFromBinding() {
      return (0, environment_accessor_1.getServiceCredentials)("xsuaa")?.tenantid || (0, environment_accessor_1.getServiceCredentials)("identity")?.app_tid || (0, environment_accessor_1.getServiceCredentials)("destination")?.tenantid;
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/jwt/verify.js
var require_verify2 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/jwt/verify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.verifyJwt = verifyJwt;
    var xssec_1 = require_src2();
    var util_1 = require_dist2();
    var environment_accessor_1 = require_environment_accessor();
    async function verifyJwt(jwt, options) {
      const disableCache = !{ ...defaultVerifyJwtOptions, ...options }.cacheVerificationKeys;
      const xsuaaService = (0, environment_accessor_1.getXsuaaService)({ disableCache, jwt });
      const { token } = await (0, xssec_1.createSecurityContext)(xsuaaService, {
        jwt
      }).catch((e) => {
        throw new util_1.ErrorWithCause("Failed to verify JWT.", e);
      });
      return token.payload;
    }
    var defaultVerifyJwtOptions = {
      cacheVerificationKeys: true
    };
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/jwt/index.js
var require_jwt2 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/jwt/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_binding(), exports2);
    __exportStar(require_jwt(), exports2);
    __exportStar(require_verify2(), exports2);
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/client-credentials-token-cache.js
var require_client_credentials_token_cache = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/client-credentials-token-cache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.clientCredentialsTokenCache = void 0;
    exports2.getCacheKey = getCacheKey2;
    var util_1 = require_dist2();
    var cache_1 = require_cache2();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "client-credentials-token-cache"
    });
    var ClientCredentialsTokenCache = (cache) => ({
      getToken: (tenantId, clientId) => cache.get(getCacheKey2(tenantId, clientId)),
      cacheToken: (tenantId, clientId, token) => {
        cache.set(getCacheKey2(tenantId, clientId), {
          entry: token,
          expires: token.expires_in ? Date.now() + token.expires_in * 1e3 : void 0
        });
      },
      clear: () => {
        cache.clear();
      },
      getCacheInstance: () => cache
    });
    function getCacheKey2(tenantId, clientId) {
      if (!tenantId) {
        logger8.warn("Cannot create cache key for client credentials token cache. The given tenant ID is undefined.");
        return;
      }
      if (!clientId) {
        logger8.warn("Cannot create cache key for client credentials token cache. The given client ID is undefined.");
        return;
      }
      return [tenantId, clientId].join(":");
    }
    exports2.clientCredentialsTokenCache = ClientCredentialsTokenCache(new cache_1.Cache(
      5 * 60 * 1e3
      /* 5 minutes in ms */
    ));
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/resilience/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/resilience/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resilience = exports2.circuitBreaker = exports2.retry = exports2.timeout = void 0;
    var timeout_1 = require_timeout();
    Object.defineProperty(exports2, "timeout", { enumerable: true, get: function() {
      return timeout_1.timeout;
    } });
    var retry_1 = require_retry3();
    Object.defineProperty(exports2, "retry", { enumerable: true, get: function() {
      return retry_1.retry;
    } });
    var circuit_breaker_1 = require_circuit_breaker();
    Object.defineProperty(exports2, "circuitBreaker", { enumerable: true, get: function() {
      return circuit_breaker_1.circuitBreaker;
    } });
    var resilience_1 = require_resilience();
    Object.defineProperty(exports2, "resilience", { enumerable: true, get: function() {
      return resilience_1.resilience;
    } });
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/xsuaa-service.js
var require_xsuaa_service = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/xsuaa-service.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getClientCredentialsToken = getClientCredentialsToken;
    exports2.getUserToken = getUserToken;
    var internal_1 = require_internal2();
    var resilience_1 = require_dist3();
    var environment_accessor_1 = require_environment_accessor();
    var jwt_1 = require_jwt2();
    async function getClientCredentialsToken(service, jwt) {
      const decodedJwt = jwt ? (0, jwt_1.decodeJwt)(jwt) : {};
      const fnArgument = {
        subdomain: (0, jwt_1.getSubdomain)(decodedJwt),
        zoneId: (0, jwt_1.getTenantId)(decodedJwt),
        serviceCredentials: (0, environment_accessor_1.resolveServiceBinding)(service).credentials
      };
      const xssecPromise = function(arg) {
        const xsuaaService = (0, environment_accessor_1.getXsuaaService)({
          credentials: arg.serviceCredentials
        });
        return xsuaaService.fetchClientCredentialsToken({
          // tenant is the subdomain, not tenant ID
          tenant: arg.zoneId ? void 0 : arg.subdomain,
          zid: arg.zoneId
        });
      };
      return (0, internal_1.executeWithMiddleware)((0, resilience_1.resilience)(), {
        fn: xssecPromise,
        fnArgument,
        context: {
          uri: fnArgument.serviceCredentials.url,
          tenantId: fnArgument.zoneId ?? fnArgument.serviceCredentials.tenantid
        }
      }).catch((err) => {
        throw new Error(`Could not fetch client credentials token for service of type ${(0, environment_accessor_1.resolveServiceBinding)(service).label}: ${err.message}`);
      });
    }
    function getUserToken(service, userJwt) {
      const decodedUserJwt = (0, jwt_1.decodeJwt)(userJwt);
      const fnArgument = {
        subdomain: (0, jwt_1.getSubdomain)(decodedUserJwt),
        zoneId: (0, jwt_1.getTenantId)(decodedUserJwt),
        serviceCredentials: service.credentials,
        userJwt
      };
      const xssecPromise = function(arg) {
        const xsuaaService = (0, environment_accessor_1.getXsuaaService)({
          credentials: arg.serviceCredentials
        });
        return xsuaaService.fetchJwtBearerToken(arg.userJwt, {
          // tenant is the subdomain, not tenant ID
          tenant: arg.zoneId ? void 0 : arg.subdomain,
          zid: arg.zoneId
        }).then((token) => token.access_token);
      };
      return (0, internal_1.executeWithMiddleware)((0, resilience_1.resilience)(), {
        fn: xssecPromise,
        fnArgument,
        context: {
          uri: service.credentials.url,
          tenantId: fnArgument.zoneId ?? service.credentials.tenantid
        }
      }).catch((err) => {
        throw new Error(`Could not fetch JWT bearer token for service of type ${service.label}: ${err.message}`);
      });
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/token-accessor.js
var require_token_accessor = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/token-accessor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.serviceToken = serviceToken;
    exports2.jwtBearerToken = jwtBearerToken;
    var util_1 = require_dist2();
    var jwt_1 = require_jwt2();
    var client_credentials_token_cache_1 = require_client_credentials_token_cache();
    var environment_accessor_1 = require_environment_accessor();
    var xsuaa_service_1 = require_xsuaa_service();
    async function serviceToken(service, options) {
      const opts = {
        useCache: true,
        enableCircuitBreaker: true,
        ...options
      };
      const serviceBinding = (0, environment_accessor_1.resolveServiceBinding)(service);
      const serviceCredentials = serviceBinding.credentials;
      const tenantForCaching = options?.jwt ? (0, jwt_1.getTenantId)(options.jwt) || (0, jwt_1.getSubdomain)(options.jwt) : (0, jwt_1.getTenantIdFromBinding)() || (0, jwt_1.getDefaultTenantId)();
      if (opts.useCache) {
        const cachedToken = client_credentials_token_cache_1.clientCredentialsTokenCache.getToken(tenantForCaching, serviceCredentials.clientid);
        if (cachedToken) {
          return cachedToken.access_token;
        }
      }
      try {
        const token = await (0, xsuaa_service_1.getClientCredentialsToken)(serviceBinding, options?.jwt);
        if (opts.useCache) {
          client_credentials_token_cache_1.clientCredentialsTokenCache.cacheToken(tenantForCaching, serviceCredentials.clientid, token);
        }
        return token.access_token;
      } catch (err) {
        throw new util_1.ErrorWithCause(`Could not fetch client credentials token for service of type "${serviceBinding.label}".`, err);
      }
    }
    async function jwtBearerToken(jwt, service) {
      const resolvedService = (0, environment_accessor_1.resolveServiceBinding)(service);
      return (0, xsuaa_service_1.getUserToken)(resolvedService, jwt);
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/identity-service.js
var require_identity_service = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/identity-service.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.exchangeToken = exchangeToken;
    exports2.shouldExchangeToken = shouldExchangeToken;
    var jwt_1 = require_jwt2();
    var token_accessor_1 = require_token_accessor();
    async function exchangeToken(jwt) {
      return (0, token_accessor_1.jwtBearerToken)(jwt, "xsuaa");
    }
    function shouldExchangeToken(options) {
      return options.iasToXsuaaTokenExchange === true && !!options.jwt && !(0, jwt_1.isXsuaaToken)((0, jwt_1.decodeJwt)(options.jwt));
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-accessor-types.js
var require_destination_accessor_types = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-accessor-types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isDestinationFetchOptions = isDestinationFetchOptions;
    function isDestinationFetchOptions(destination) {
      return destination.destinationName !== void 0;
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination.js
var require_destination2 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sanitizeDestination = sanitizeDestination;
    exports2.parseDestination = parseDestination;
    exports2.getAdditionalHeadersAndQueryParameters = getAdditionalHeadersAndQueryParameters;
    exports2.getAdditionalHeaders = getAdditionalHeaders;
    exports2.getAdditionalQueryParameters = getAdditionalQueryParameters;
    exports2.getDestinationConfig = getDestinationConfig;
    exports2.toDestinationNameUrl = toDestinationNameUrl;
    exports2.parseCertificate = parseCertificate;
    exports2.isDestinationConfiguration = isDestinationConfiguration;
    exports2.isDestinationJson = isDestinationJson;
    exports2.noDestinationErrorMessage = noDestinationErrorMessage;
    var destination_accessor_types_1 = require_destination_accessor_types();
    function sanitizeDestination(destination) {
      let parsedDestination = parseAuthTokens(destination);
      parsedDestination = parseCertificates(parsedDestination);
      parsedDestination = setDefaultAuthenticationFallback(parsedDestination);
      parsedDestination = setTrustAll(parsedDestination);
      parsedDestination = setForwardAuthToken(parsedDestination);
      parsedDestination = setOriginalProperties(parsedDestination);
      return parsedDestination;
    }
    function parseDestination(destinationJson) {
      const destinationConfig = getDestinationConfig(destinationJson);
      const destination = Object.entries(destinationConfig).reduce((dest, [originalKey, value]) => {
        if (originalKey in configMapping) {
          dest[configMapping[originalKey]] = value;
        }
        return dest;
      }, {
        originalProperties: destinationJson,
        authTokens: destinationJson["authTokens"] || [],
        certificates: destinationJson["certificates"] || []
      });
      const additionalHeadersAndQueryParameters = getAdditionalHeadersAndQueryParameters(destinationConfig);
      return sanitizeDestination({
        ...destination,
        ...additionalHeadersAndQueryParameters
      });
    }
    function getAdditionalProperties(destinationConfig, originalKeyPrefix) {
      const relevantConfigEntries = Object.entries(destinationConfig).filter(([key]) => key.startsWith(originalKeyPrefix));
      return relevantConfigEntries.reduce((additionalProperties, [originalKey, value]) => {
        const headerKey = originalKey.replace(originalKeyPrefix, "");
        additionalProperties[headerKey] = value;
        return additionalProperties;
      }, {});
    }
    function getAdditionalHeadersAndQueryParameters(destinationConfig) {
      const additionalProperties = {};
      const additionalHeaders = getAdditionalHeaders(destinationConfig).headers;
      if (additionalHeaders && Object.keys(additionalHeaders).length) {
        additionalProperties["headers"] = additionalHeaders;
      }
      const additionalQueryParameters = getAdditionalQueryParameters(destinationConfig).queryParameters;
      if (additionalQueryParameters && Object.keys(additionalQueryParameters).length) {
        additionalProperties["queryParameters"] = additionalQueryParameters;
      }
      return additionalProperties;
    }
    function getAdditionalHeaders(destinationConfig) {
      const additionalHeaders = getAdditionalProperties(destinationConfig, "URL.headers.");
      const additionalProperties = {};
      if (Object.keys(additionalHeaders).length) {
        additionalProperties["headers"] = additionalHeaders;
      }
      return additionalProperties;
    }
    function getAdditionalQueryParameters(destinationConfig) {
      const additionalQueryParameters = getAdditionalProperties(destinationConfig, "URL.queries.");
      const additionalProperties = {};
      if (Object.keys(additionalQueryParameters).length) {
        additionalProperties["queryParameters"] = additionalQueryParameters;
      }
      return additionalProperties;
    }
    function getDestinationConfig(destinationJson) {
      return isDestinationJson(destinationJson) ? destinationJson.destinationConfiguration : destinationJson;
    }
    function toDestinationNameUrl(destination) {
      if ((0, destination_accessor_types_1.isDestinationFetchOptions)(destination)) {
        return `name: ${destination.destinationName}`;
      }
      const text = ["name", "url"].filter((key) => destination[key]).map((key) => `${key}: ${destination[key]}`);
      return text.length > 0 ? text.join(",") : "Destination does not have a 'name' or 'url' property.";
    }
    function setOriginalProperties(destination) {
      const originalProperties = destination.originalProperties ? destination.originalProperties : destination;
      return {
        ...destination,
        originalProperties
      };
    }
    function setDefaultAuthenticationFallback(destination) {
      return destination.authentication ? destination : {
        ...destination,
        authentication: getAuthenticationType(destination)
      };
    }
    function parseCertificate(certificate) {
      return {
        name: certificate.Name || certificate.name,
        content: certificate.Content || certificate.content,
        type: certificate.Type || certificate.type
      };
    }
    function parseCertificates(destination) {
      return {
        ...destination,
        certificates: (destination.certificates || []).map((certificate) => parseCertificate(certificate))
      };
    }
    function parseAuthToken(authToken) {
      return {
        type: authToken.type,
        value: authToken.value,
        expiresIn: authToken.expires_in,
        error: "error" in authToken ? authToken.error : null,
        http_header: authToken.http_header
      };
    }
    function parseAuthTokens(destination) {
      return {
        ...destination,
        authTokens: (destination.authTokens || []).map((token) => parseAuthToken(token))
      };
    }
    function setTrustAll(destination) {
      return {
        ...destination,
        isTrustingAllCertificates: parseTrustAll(destination.isTrustingAllCertificates)
      };
    }
    function parseTrustAll(isTrustingAllCertificates) {
      if (typeof isTrustingAllCertificates === "string") {
        return isTrustingAllCertificates.toLowerCase() === "true";
      }
      return !!isTrustingAllCertificates;
    }
    function getAuthenticationType(destination) {
      return destination.authentication || destination.username && destination.password ? "BasicAuthentication" : "NoAuthentication";
    }
    function setForwardAuthToken(destination) {
      const forwardAuthToken = destination.originalProperties?.forwardAuthToken ?? destination.originalProperties?.["HTML5.ForwardAuthToken"] ?? destination.forwardAuthToken;
      return {
        ...destination,
        forwardAuthToken: forwardAuthToken === "true" || forwardAuthToken === true
      };
    }
    function isDestinationConfiguration(destination) {
      return destination.URL !== void 0;
    }
    function isDestinationJson(destination) {
      return Object.keys(destination).includes("destinationConfiguration");
    }
    var configMapping = {
      URL: "url",
      Name: "name",
      User: "username",
      Password: "password",
      ProxyType: "proxyType",
      "sap-client": "sapClient",
      Authentication: "authentication",
      TrustAll: "isTrustingAllCertificates",
      Type: "type",
      tokenServiceURL: "tokenServiceUrl",
      clientId: "clientId",
      clientSecret: "clientSecret",
      tokenServiceUser: "tokenServiceUser",
      tokenServicePassword: "tokenServicePassword",
      CloudConnectorLocationId: "cloudConnectorLocationId",
      certificates: "certificates",
      KeyStoreLocation: "keyStoreName",
      KeyStorePassword: "keyStorePassword",
      SystemUser: "systemUser",
      /**
       * Base64-encoded JSON web key set, containing the signing keys which are used to validate the JWT provided in the X-User-Token header.
       */
      "x_user_token.jwks": "jwks",
      /**
       * URI of the JSON web key set, containing the signing keys which are used to validate the JWT provided in the X-User-Token header.
       */
      "x_user_token.jwks_uri": "jwksUri",
      "HTML5.ForwardAuthToken": "forwardAuthToken",
      /**
       * This overwrites `HTML5.ForwardAuthToken`, if both exist (during sanitize).
       */
      forwardAuthToken: "forwardAuthToken"
    };
    function noDestinationErrorMessage(destination) {
      return (0, destination_accessor_types_1.isDestinationFetchOptions)(destination) ? `Could not find a destination with name "${destination.destinationName}"! Unable to execute request.` : "Could not find a destination to execute request against and no destination name has been provided (this should never happen)!";
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/protocol.js
var require_protocol = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/protocol.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getProtocol = getProtocol;
    var protocols = {
      http: "http",
      https: "https",
      socks: "socks"
    };
    function getProtocol(protocol) {
      return protocol.endsWith(":") ? getProtocol(protocol.slice(0, -1)) : protocols[protocol];
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/authorization-header.js
var require_authorization_header = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/authorization-header.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getAuthHeader = getAuthHeader;
    exports2.basicHeader = basicHeader;
    exports2.buildAuthorizationHeaders = buildAuthorizationHeaders;
    var util_1 = require_dist2();
    var destination_1 = require_destination2();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "authorization-header"
    });
    function getAuthHeader(authenticationType, customHeaders) {
      if (authenticationType === "PrincipalPropagation") {
        const principalPropagationHeader = (0, util_1.pickValueIgnoreCase)(customHeaders, "SAP-Connectivity-Authentication");
        if (principalPropagationHeader) {
          return { "SAP-Connectivity-Authentication": principalPropagationHeader };
        }
      }
      const authorizationHeader = (0, util_1.pickValueIgnoreCase)(customHeaders, "authorization");
      if (authorizationHeader) {
        return { authorization: authorizationHeader };
      }
    }
    function headerFromTokens(authenticationType, authTokens) {
      if (!authTokens || !authTokens.length) {
        throw Error(`\`AuthenticationType\` is "${authenticationType}", but no auth tokens could be fetched from the destination service.`);
      }
      const usableTokens = authTokens.filter((token) => !token.error);
      if (!usableTokens.length) {
        throw Error([
          "The destination tried to provide authorization tokens but failed in all cases. This is most likely due to misconfiguration.",
          "Original error messages:",
          ...authTokens.map((token) => token.error)
        ].join(util_1.unixEOL));
      }
      const authToken = usableTokens[0];
      return { authorization: authToken.http_header.value };
    }
    function headerFromBasicAuthDestination(destination) {
      if ((0, util_1.isNullish)(destination.username) || (0, util_1.isNullish)(destination.password)) {
        throw Error('AuthenticationType is "BasicAuthentication", but "username" and / or "password" are missing!');
      }
      return {
        authorization: basicHeader(destination.username, destination.password)
      };
    }
    function basicHeader(username, password) {
      return "Basic " + (0, util_1.encodeBase64)(`${username}:${password}`);
    }
    function headerForPrincipalPropagation(destination) {
      const principalPropagationHeader = destination?.proxyConfiguration?.headers?.["SAP-Connectivity-Authentication"];
      if (!principalPropagationHeader) {
        throw Error("Principal propagation was selected in destination, but no SAP-Connectivity-Authentication bearer header was added by connectivity service.");
      }
      return {
        "SAP-Connectivity-Authentication": principalPropagationHeader
      };
    }
    function getProxyRelatedAuthHeaders(destination) {
      const authHeader = destination?.proxyConfiguration?.headers?.["Proxy-Authorization"];
      if (authHeader) {
        return { "Proxy-Authorization": authHeader };
      }
    }
    async function getAuthenticationRelatedHeaders(destination) {
      const destinationAuthHeaders = getAuthHeader(destination.authentication, destination.headers);
      logger8.debug(`Getting authentication related headers for authentication type: ${destination.authentication}`);
      if (destinationAuthHeaders) {
        logger8.debug("Authentication header from 'destination.headers' used.");
        return destinationAuthHeaders;
      }
      switch (destination.authentication) {
        case null:
        case void 0:
          logger8.warn('No authentication type is specified on the destination. Assuming "NoAuthentication".');
          return;
        case "NoAuthentication":
          return;
        case "ClientCertificateAuthentication":
          return;
        case "SAMLAssertion":
        case "OAuth2SAMLBearerAssertion":
        case "OAuth2UserTokenExchange":
        case "OAuth2JWTBearer":
        case "OAuth2ClientCredentials":
        case "OAuth2Password":
        case "OAuth2RefreshToken": {
          const header = headerFromTokens(destination.authentication, destination.authTokens);
          if (destination.authentication === "SAMLAssertion") {
            logger8.warn("Destination authentication flow is 'SamlAssertion' and the auth header contains the SAML assertion. In most cases you want to translate the assertion to a Bearer token using the 'OAuth2SAMLBearerAssertion' flow.");
            return {
              ...header,
              "x-sap-security-session": "create"
            };
          }
          return header;
        }
        case "BasicAuthentication":
          return headerFromBasicAuthDestination(destination);
        case "PrincipalPropagation":
          return headerForPrincipalPropagation(destination);
        default:
          throw Error(`The destination used "${destination.authentication}" as authentication type which is not supported by the SAP Cloud SDK.`);
      }
    }
    async function buildAuthorizationHeaders(destination) {
      const sanitizedDestination = (0, destination_1.sanitizeDestination)(destination);
      return {
        ...await getAuthenticationRelatedHeaders(sanitizedDestination),
        ...getProxyRelatedAuthHeaders(sanitizedDestination)
      };
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/get-protocol.js
var require_get_protocol = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/get-protocol.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getProtocolOrDefault = getProtocolOrDefault;
    var util_1 = require_dist2();
    var protocol_1 = require_protocol();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "get-protocol"
    });
    function getProtocolOrDefault(destination) {
      const urlParts = destination.url.toLowerCase()?.split("://");
      if (!urlParts || urlParts.length === 1) {
        logger8.warn(`URL of the provided destination (${destination.url}) has no protocol specified! Assuming HTTPS.`);
        return "https";
      }
      const protocol = (0, protocol_1.getProtocol)(urlParts[0]);
      if (!protocol) {
        throw new Error(`Protocol of the provided destination (${destination.url}) is not supported! Currently only HTTP and HTTPS are supported.`);
      }
      return protocol;
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-service-types.js
var require_destination_service_types = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-service-types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assertHttpDestination = assertHttpDestination2;
    exports2.isHttpDestination = isHttpDestination;
    function assertHttpDestination2(destination) {
      if (!isHttpDestination(destination)) {
        throw new Error(destination.url ? `The 'type' property is  ${destination.type} instead of  HTTP for destination '${destination.name}' which is mandatory if you use it as an 'HTTP destination` : `The 'url' property is not set for destination ${destination.name} which is mandatory if you use it as an 'HTTP destination`);
      }
    }
    function isHttpDestination(destination) {
      return !!destination && !!destination.url && (!destination.type || destination.type === "HTTP");
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/http-proxy-util.js
var require_http_proxy_util = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/http-proxy-util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.proxyStrategy = proxyStrategy;
    exports2.parseProxyEnv = parseProxyEnv;
    exports2.addProxyConfigurationInternet = addProxyConfigurationInternet;
    exports2.getProxyConfig = getProxyConfig;
    var node_url_1 = require("node:url");
    var util_1 = require_dist2();
    var protocol_1 = require_protocol();
    var authorization_header_1 = require_authorization_header();
    var get_protocol_1 = require_get_protocol();
    var destination_service_types_1 = require_destination_service_types();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "proxy-util"
    });
    function proxyStrategy(destination) {
      if (destination.proxyType === "OnPremise") {
        logger8.debug("OnPrem destination proxy settings from connectivity service will be used.");
        return "on-premise";
      }
      if (destination.proxyType === "PrivateLink") {
        logger8.debug("PrivateLink destination proxy settings will be used. This is not supported in local/CI/CD environments.");
        return "private-link";
      }
      if ((0, destination_service_types_1.isHttpDestination)(destination)) {
        const destinationProtocol = (0, get_protocol_1.getProtocolOrDefault)(destination);
        return getProxyStrategyFromProxyEnvValue(destinationProtocol, destination.url);
      }
      return "no-proxy";
    }
    function getProxyStrategyFromProxyEnvValue(protocol, destinationUrl) {
      if (!getProxyEnvValue(protocol)) {
        logger8.debug(`Could not find proxy settings for ${protocol} in the environment variables - no proxy used.`);
        return "no-proxy";
      }
      if (getNoProxyEnvValue().includes(destinationUrl)) {
        logger8.debug(`Destination URL ${destinationUrl} is in no_proxy list: ${getNoProxyEnvValue()} - no proxy used.`);
        return "no-proxy";
      }
      if (getProxyEnvValue(protocol)) {
        logger8.debug(`Proxy settings for ${protocol} are found in environment variables.`);
        return "internet";
      }
      return "no-proxy";
    }
    function getProxyEnvValue(protocol) {
      const proxyEnvKey = protocol + "_proxy";
      const proxyEnvValue = process.env[proxyEnvKey.toLowerCase()] || process.env[proxyEnvKey.toUpperCase()];
      logger8.debug(`Tried to read ${proxyEnvKey.toLowerCase()} or ${proxyEnvKey.toUpperCase()} from the environment variables. Value is ${proxyEnvValue}.`);
      return proxyEnvValue || void 0;
    }
    function getNoProxyEnvValue() {
      const noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
      if (!noProxyEnv) {
        return [];
      }
      const split = noProxyEnv.split(",").map((s) => s.trim());
      if (split.find((s) => s.includes("*"))) {
        logger8.warn(`The no_proxy env contains a wildcard ${noProxyEnv}, which is currently not supported`);
      }
      return split;
    }
    function getPort(url) {
      if (url.port) {
        return parseInt(url.port);
      }
      return url.protocol === "https:" ? 443 : 80;
    }
    function getOriginalProtocol(href) {
      const test = href.match(/^[\w.-]+:\/\//);
      return test ? test[0].slice(0, -2) : void 0;
    }
    function sanitizeUrl(href) {
      const protocol = getOriginalProtocol(href);
      if (!protocol) {
        logger8.debug('No protocol specified, using "http:".');
        return `http://${href}`;
      }
      return href;
    }
    function validateUrl(url) {
      if (url.protocol !== "http:" && url.protocol !== "https:") {
        throw new Error(`Unsupported protocol "${url.protocol}".`);
      }
      if (url.protocol === "https:") {
        logger8.debug('Using protocol "https:" to connect to a proxy. This is unusual but possible.');
      }
      if (url.username && !url.password) {
        throw new Error("Password missing.");
      }
    }
    function parseProxyEnv(proxyEnvValue) {
      const href = sanitizeUrl(proxyEnvValue);
      try {
        const url = new node_url_1.URL(href);
        validateUrl(url);
        const proxyConfig = {
          host: url.hostname,
          protocol: (0, protocol_1.getProtocol)(url.protocol),
          port: getPort(url)
        };
        if (url.username && url.password) {
          proxyConfig.headers = {
            "Proxy-Authorization": (0, authorization_header_1.basicHeader)(decodeURIComponent(url.username), decodeURIComponent(url.password))
          };
        }
        if (proxyConfig) {
          const loggableConfig = {
            ...proxyConfig,
            headers: (0, util_1.sanitizeRecord)(proxyConfig.headers || {}, "Authorization header present. Not logged for security reasons.")
          };
          logger8.debug(`Used Proxy Configuration: ${JSON.stringify(loggableConfig, null, 2)}.`);
        }
        return proxyConfig;
      } catch (err) {
        logger8.warn(`Could not parse proxy configuration from environment variable. Reason: ${err.message}`);
        return void 0;
      }
    }
    function addProxyConfigurationInternet(destination) {
      const proxyEnvValue = getProxyEnvValue((0, get_protocol_1.getProtocolOrDefault)(destination));
      if (proxyEnvValue) {
        return {
          ...destination,
          proxyConfiguration: parseProxyEnv(proxyEnvValue) || destination.proxyConfiguration
        };
      }
      logger8.warn("Attempt to get proxy config from environment variables failed. At this point this should not happen - no proxy used.");
      return { ...destination };
    }
    function getProxyConfig(destination) {
      if (destination.proxyConfiguration) {
        const { host, protocol, port } = destination.proxyConfiguration;
        return { host, protocol, port };
      }
      return false;
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/forward-auth-token.js
var require_forward_auth_token = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/forward-auth-token.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setForwardedAuthTokenIfNeeded = setForwardedAuthTokenIfNeeded;
    var util_1 = require_dist2();
    var jwt_1 = require_jwt2();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "forward-auth-token"
    });
    function buildDestinationAuthToken(token) {
      const decodedJwt = (0, jwt_1.decodeJwt)(token);
      return [
        {
          value: token,
          expiresIn: decodedJwt.exp?.toString(),
          error: null,
          http_header: { key: "Authorization", value: `Bearer ${token}` },
          type: "Bearer"
        }
      ];
    }
    function validateToken(token) {
      if (!token) {
        logger8.warn("Option 'forwardAuthToken' was set on destination but no token was provided to forward. This is most likely unintended and will lead to an authorization error on request execution.");
      }
      return !!token;
    }
    function setForwardedAuthTokenIfNeeded(destination, token) {
      if (destination.forwardAuthToken) {
        if (validateToken(token)) {
          logger8.debug("Option 'forwardAuthToken' enabled on destination. Using the given token for the destination.");
          destination.authTokens = buildDestinationAuthToken(token);
        }
      }
      return destination;
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-from-env.js
var require_destination_from_env = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-from-env.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getDestinationsFromEnv = getDestinationsFromEnv;
    exports2.getDestinationFromEnvByName = getDestinationFromEnvByName;
    exports2.getDestinationsEnvVariable = getDestinationsEnvVariable;
    exports2.searchEnvVariablesForDestination = searchEnvVariablesForDestination;
    exports2.validateNameAvailable = validateNameAvailable;
    exports2.setDestinationsInEnv = setDestinationsInEnv;
    var util_1 = require_dist2();
    var destination_1 = require_destination2();
    var http_proxy_util_1 = require_http_proxy_util();
    var destination_service_types_1 = require_destination_service_types();
    var forward_auth_token_1 = require_forward_auth_token();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "env-destination-accessor"
    });
    function getDestinationsFromEnv() {
      const destinationsEnv = getDestinationsEnvVariable();
      logger8.debug(`The value for the destination environment variable is: ${destinationsEnv}`);
      if (destinationsEnv) {
        let destinations;
        try {
          destinations = JSON.parse(destinationsEnv);
        } catch (err) {
          throw new util_1.ErrorWithCause("Error in parsing the destinations from the environment variable.", err);
        }
        validateDestinations(destinations);
        return destinations.map((destination) => (0, destination_1.isDestinationConfiguration)(destination) ? (0, destination_1.parseDestination)(destination) : (0, destination_1.sanitizeDestination)(destination));
      }
      return [];
    }
    function getDestinationFromEnvByName(name) {
      const matchingDestinations = getDestinationsFromEnv().filter((dest) => dest.name === name);
      if (!matchingDestinations.length) {
        return null;
      }
      if (matchingDestinations.length > 1) {
        logger8.warn(`The 'destinations' env variable contains multiple destinations with the name '${name}'. Only the first entry will be considered.`);
      }
      return matchingDestinations[0];
    }
    function getDestinationsEnvVariable() {
      return process.env["destinations"];
    }
    function validateDestinations(destinations) {
      destinations.forEach((destination) => {
        if (typeof destination.name === "undefined" && typeof destination.Name === "undefined") {
          logger8.warn("Destination from 'destinations' env variable is missing 'name' or 'Name' property.");
        }
      });
    }
    function searchEnvVariablesForDestination(options) {
      logger8.debug("Attempting to retrieve destination from environment variable.");
      if (getDestinationsEnvVariable()) {
        try {
          const destination = getDestinationFromEnvByName(options.destinationName);
          if (destination) {
            logger8.info(`Successfully retrieved destination '${options.destinationName}' from environment variable.`);
            (0, forward_auth_token_1.setForwardedAuthTokenIfNeeded)(destination, options.jwt);
            return (0, destination_service_types_1.isHttpDestination)(destination) && ["internet", "private-link"].includes((0, http_proxy_util_1.proxyStrategy)(destination)) ? (0, http_proxy_util_1.addProxyConfigurationInternet)(destination) : destination;
          }
        } catch (error) {
          logger8.error(`Error in reading the given destinations from the environment variable ${error.message}.`);
        }
      }
      logger8.debug("No environment variable set.");
      return null;
    }
    function validateNameAvailable(destinationName, existingNames) {
      if (existingNames.has(destinationName)) {
        throw new Error(`Parsing destinations failed, destination with name "${destinationName}" already exists in the "destinations" environment variables.`);
      }
    }
    function setDestinationsInEnv(destinations) {
      process.env.destinations = JSON.stringify(destinations);
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/service-binding-to-destination.js
var require_service_binding_to_destination = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/service-binding-to-destination.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.serviceToDestinationTransformers = void 0;
    exports2.transformServiceBindingToDestination = transformServiceBindingToDestination2;
    exports2.transformServiceBindingToClientCredentialsDestination = transformServiceBindingToClientCredentialsDestination;
    var token_accessor_1 = require_token_accessor();
    var jwt_1 = require_jwt2();
    exports2.serviceToDestinationTransformers = {
      "business-logging": businessLoggingBindingToDestination,
      "s4-hana-cloud": xfS4hanaCloudBindingToDestination,
      destination: destinationBindingToDestination,
      "saas-registry": saasRegistryBindingToDestination,
      workflow: workflowBindingToDestination,
      "service-manager": serviceManagerBindingToDestination,
      xsuaa: xsuaaToDestination,
      aicore: aicoreToDestination
    };
    async function transformServiceBindingToDestination2(serviceBinding, options) {
      if (exports2.serviceToDestinationTransformers[serviceBinding.label]) {
        return exports2.serviceToDestinationTransformers[serviceBinding.label](serviceBinding, options);
      }
      throw new Error(`The provided service binding of type ${serviceBinding.label} is not supported out of the box for destination transformation.`);
    }
    async function transformServiceBindingToClientCredentialsDestination(service, options) {
      const token = await (0, token_accessor_1.serviceToken)(service, options);
      return buildClientCredentialsDestination(token, options?.url ?? service.url, service.name);
    }
    async function aicoreToDestination(service, options) {
      const token = await (0, token_accessor_1.serviceToken)(service, options);
      return buildClientCredentialsDestination(token, service.credentials.serviceurls.AI_API_URL, service.name);
    }
    async function xsuaaToDestination(service, options) {
      const token = await (0, token_accessor_1.serviceToken)(service, options);
      return buildClientCredentialsDestination(token, service.credentials.apiurl, service.name);
    }
    async function serviceManagerBindingToDestination(service, options) {
      const token = await (0, token_accessor_1.serviceToken)(service, options);
      return buildClientCredentialsDestination(token, service.credentials.sm_url, service.name);
    }
    async function destinationBindingToDestination(service, options) {
      const token = await (0, token_accessor_1.serviceToken)(service, options);
      return buildClientCredentialsDestination(token, service.credentials.uri, service.name);
    }
    async function saasRegistryBindingToDestination(service, options) {
      const token = await (0, token_accessor_1.serviceToken)(service, options);
      return buildClientCredentialsDestination(token, service.credentials["saas_registry_url"], service.name);
    }
    async function businessLoggingBindingToDestination(service, options) {
      const transformedService = {
        ...service,
        credentials: { ...service.credentials.uaa }
      };
      const token = await (0, token_accessor_1.serviceToken)(transformedService, options);
      return buildClientCredentialsDestination(token, service.credentials.writeUrl, service.name);
    }
    async function workflowBindingToDestination(service, options) {
      const transformedService = {
        ...service,
        credentials: { ...service.credentials.uaa }
      };
      const token = await (0, token_accessor_1.serviceToken)(transformedService, options);
      return buildClientCredentialsDestination(token, service.credentials.endpoints.workflow_odata_url, service.name);
    }
    async function xfS4hanaCloudBindingToDestination(service) {
      return {
        url: service.credentials.URL,
        authentication: "BasicAuthentication",
        username: service.credentials.User,
        password: service.credentials.Password
      };
    }
    function buildClientCredentialsDestination(token, url, name) {
      const expirationTime = (0, jwt_1.decodeJwt)(token).exp;
      const expiresIn = expirationTime ? Math.floor((expirationTime * 1e3 - Date.now()) / 1e3).toString(10) : void 0;
      return {
        url,
        name,
        authentication: "OAuth2ClientCredentials",
        authTokens: [
          {
            value: token,
            type: "bearer",
            expiresIn,
            http_header: { key: "Authorization", value: `Bearer ${token}` },
            error: null
          }
        ]
      };
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-from-vcap.js
var require_destination_from_vcap = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-from-vcap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getDestinationFromServiceBinding = getDestinationFromServiceBinding;
    exports2.searchServiceBindingForDestination = searchServiceBindingForDestination;
    var util_1 = require_dist2();
    var jwt_1 = require_jwt2();
    var environment_accessor_1 = require_environment_accessor();
    var http_proxy_util_1 = require_http_proxy_util();
    var destination_service_types_1 = require_destination_service_types();
    var service_binding_to_destination_1 = require_service_binding_to_destination();
    var forward_auth_token_1 = require_forward_auth_token();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "destination-accessor-vcap"
    });
    async function getDestinationFromServiceBinding(options) {
      const decodedJwt = options.iss ? { iss: options.iss } : options.jwt ? (0, jwt_1.decodeJwt)(options.jwt) : void 0;
      const retrievalOptions = { ...options, jwt: decodedJwt };
      const destination = await retrieveDestination(retrievalOptions);
      const destWithProxy = destination && (0, destination_service_types_1.isHttpDestination)(destination) && ["internet", "private-link"].includes((0, http_proxy_util_1.proxyStrategy)(destination)) ? (0, http_proxy_util_1.addProxyConfigurationInternet)(destination) : destination;
      if (destWithProxy) {
        (0, forward_auth_token_1.setForwardedAuthTokenIfNeeded)(destWithProxy, options.jwt);
      }
      return destWithProxy;
    }
    async function retrieveDestination({ useCache, jwt, destinationName, serviceBindingTransformFn }) {
      const service = (0, environment_accessor_1.getServiceBindingByInstanceName)(destinationName);
      const destination = await (serviceBindingTransformFn || transform)(service, {
        useCache,
        jwt
      });
      return { name: destinationName, ...destination };
    }
    async function transform(service, options) {
      if (!service_binding_to_destination_1.serviceToDestinationTransformers[service.label]) {
        throw serviceTypeNotSupportedError(service);
      }
      return service_binding_to_destination_1.serviceToDestinationTransformers[service.label](service, options);
    }
    function serviceTypeNotSupportedError(service) {
      return Error(`The service "${service.name}" is of type "${service.label}" which is not supported! Consider providing your own transformation function when calling \`getDestinationFromServiceBinding()\`, like this:
  destinationServiceForBinding(yourServiceName, { serviceBindingToDestination: yourTransformationFunction });`);
    }
    async function searchServiceBindingForDestination(options) {
      logger8.debug("Attempting to retrieve destination from service binding.");
      try {
        const destination = await getDestinationFromServiceBinding(options);
        logger8.info("Successfully retrieved destination from service binding.");
        return destination;
      } catch (error) {
        logger8.debug(`Could not retrieve destination from service binding. If you are not using SAP Extension Factory, this information probably does not concern you. ${error.message}`);
      }
      return null;
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/connectivity-service.js
var require_connectivity_service = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/connectivity-service.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addProxyConfigurationOnPrem = addProxyConfigurationOnPrem;
    exports2.httpProxyHostAndPort = httpProxyHostAndPort;
    exports2.socksProxyHostAndPort = socksProxyHostAndPort;
    var util_1 = require_dist2();
    var environment_accessor_1 = require_environment_accessor();
    var token_accessor_1 = require_token_accessor();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "connectivity-service"
    });
    async function addProxyConfigurationOnPrem(destination, subscriberToken) {
      if (destination.type === "MAIL") {
        return {
          ...destination,
          proxyConfiguration: await socksProxyHostAndPort(subscriberToken?.userJwt.decoded)
        };
      }
      const proxyConfiguration = {
        ...httpProxyHostAndPort(),
        headers: {
          ...await proxyHeaders(destination.authentication, subscriberToken)
        }
      };
      return { ...destination, proxyConfiguration };
    }
    function httpProxyHostAndPort() {
      const service = readConnectivityServiceBinding();
      return {
        host: service.credentials.onpremise_proxy_host,
        port: service.credentials.onpremise_proxy_http_port || service.credentials.onpremise_proxy_port,
        protocol: "http"
      };
    }
    async function socksProxyHostAndPort(userJwt) {
      const service = readConnectivityServiceBinding();
      const connectivityServiceToken = await (0, token_accessor_1.serviceToken)(service, {
        jwt: userJwt
      });
      return {
        host: service.credentials.onpremise_proxy_host,
        port: parseInt(service.credentials.onpremise_socks5_proxy_port),
        protocol: "socks",
        "proxy-authorization": connectivityServiceToken
      };
    }
    function readConnectivityServiceBinding() {
      const serviceBindings = (0, environment_accessor_1.getServiceBindings)("connectivity");
      if (!serviceBindings.length) {
        throw new Error("No binding to a connectivity service found! Please make sure to bind an instance of the connectivity service to your app if you want to connect to on-premise destinations.");
      }
      return serviceBindings[0];
    }
    async function proxyHeaders(authenticationType, subscriberToken) {
      const proxyAuthHeader = await proxyAuthorizationHeader(subscriberToken?.serviceJwt.encoded);
      const sapConnectivityHeader = sapConnectivityAuthenticationHeader(authenticationType, subscriberToken?.userJwt.encoded);
      return {
        ...proxyAuthHeader,
        ...sapConnectivityHeader
      };
    }
    async function proxyAuthorizationHeader(jwt) {
      try {
        const connServiceBinding = readConnectivityServiceBinding();
        const token = await (0, token_accessor_1.serviceToken)(connServiceBinding, { jwt });
        return { "Proxy-Authorization": `Bearer ${token}` };
      } catch (error) {
        throw new util_1.ErrorWithCause("Failed to add proxy authorization header - client credentials grant failed!", error);
      }
    }
    function sapConnectivityAuthenticationHeader(authenticationType, jwt) {
      if (authenticationType === "PrincipalPropagation") {
        if (jwt) {
          return {
            "SAP-Connectivity-Authentication": `Bearer ${jwt}`
          };
        }
        throw new Error(`Unable to create "SAP-Connectivity-Authentication" header: no JWT found on the current request.
     Connecting to on-premise systems via principle propagation is not possible.`);
      }
      if (authenticationType === "BasicAuthentication") {
        logger8.warn("You are connecting to an On-Premise system using basic authentication. For productive usage Principal propagation is recommended.");
      }
      return {};
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/tenant.js
var require_tenant = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/tenant.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isIdenticalTenant = isIdenticalTenant;
    var jwt_1 = require_jwt2();
    function isIdenticalTenant(userTokenPayload, providerTokenPayload) {
      return (0, jwt_1.getTenantId)(userTokenPayload) === (0, jwt_1.getTenantId)(providerTokenPayload);
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/async-cache.js
var require_async_cache = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/async-cache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AsyncCache = void 0;
    var cache_1 = require_cache2();
    var AsyncCache = class {
      constructor(defaultValidityTime = 0) {
        this.cache = new cache_1.Cache(defaultValidityTime);
      }
      /**
       * Specifies whether an entry with a given key is defined in cache.
       * @param key - The entry's key.
       * @returns A boolean value that indicates whether the entry exists in cache.
       */
      async hasKey(key) {
        return this.cache.hasKey(key);
      }
      /**
       * Getter of cached entries.
       * @param key - The key of the entry to retrieve.
       * @returns The corresponding entry to the provided key if it is still valid, returns `undefined` otherwise.
       */
      async get(key) {
        return this.cache.get(key);
      }
      /**
       * Setter of entries in cache.
       * @param key - The entry's key.
       * @param item - The entry to cache.
       * @returns A promise to oid.
       */
      async set(key, item) {
        return this.cache.set(key, item);
      }
      /**
       * Clear all cached items.
       * @returns A promise to void.
       */
      async clear() {
        return this.cache.clear();
      }
    };
    exports2.AsyncCache = AsyncCache;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-cache.js
var require_destination_cache = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-cache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.destinationCache = exports2.DestinationCache = exports2.DefaultDestinationCache = void 0;
    exports2.getDestinationCacheKey = getDestinationCacheKey;
    exports2.setDestinationCache = setDestinationCache;
    exports2.getDefaultIsolationStrategy = getDefaultIsolationStrategy;
    var util_1 = require_dist2();
    var jwt_1 = require_jwt2();
    var async_cache_1 = require_async_cache();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "destination-cache"
    });
    var DefaultDestinationCache = class extends async_cache_1.AsyncCache {
      constructor(defaultValidityTime = 0) {
        super(defaultValidityTime);
      }
    };
    exports2.DefaultDestinationCache = DefaultDestinationCache;
    var DestinationCache = (cache = new DefaultDestinationCache(3e5)) => ({
      retrieveDestinationFromCache: async (token, name, isolation) => cache.get(getDestinationCacheKey(token, name, isolation)),
      cacheRetrievedDestination: async (token, destination, isolation) => {
        cacheRetrievedDestination(token, destination, isolation, cache);
      },
      cacheRetrievedDestinations: async (token, retrievedDestinations, isolation) => {
        retrievedDestinations.subaccount.forEach((dest) => cacheRetrievedDestination(token, dest, isolation, cache));
        retrievedDestinations.instance.forEach((dest) => cacheRetrievedDestination(token, dest, isolation, cache));
      },
      clear: async () => {
        cache.clear();
      },
      getCacheInstance: () => cache
    });
    exports2.DestinationCache = DestinationCache;
    function getJwtForTenant(token) {
      return token?.serviceJwt?.decoded || token;
    }
    function getJwtForUser(token) {
      return token?.userJwt?.decoded || token;
    }
    function getDestinationCacheKey(token, destinationName, isolationStrategy = "tenant-user") {
      if (isolationStrategy === "tenant") {
        return getTenantCacheKey(destinationName, (0, jwt_1.getTenantId)(getJwtForTenant(token)));
      }
      if (isolationStrategy === "tenant-user") {
        return getTenantUserCacheKey(destinationName, (0, jwt_1.getTenantId)(getJwtForTenant(token)), (0, jwt_1.userId)(getJwtForUser(token)));
      }
      logger8.warn(`Could not build destination cache key. Isolation strategy '${isolationStrategy}' is not supported.`);
    }
    function getTenantCacheKey(destinationName, tenant) {
      if (tenant) {
        return `${tenant}::${destinationName}`;
      }
      logger8.warn("Could not build destination cache key. Isolation strategy 'tenant' is used, but tenant ID is undefined in JWT.");
    }
    function getTenantUserCacheKey(destinationName, tenant, user) {
      if (tenant && user) {
        return `${user}:${tenant}:${destinationName}`;
      }
      logger8.warn("Could not build destination cache key. Isolation strategy 'tenant-user' is used, but tenant id or user id is undefined in JWT.");
    }
    async function cacheRetrievedDestination(token, destination, isolation, cache) {
      if (!destination.name) {
        throw new Error("The destination name is undefined.");
      }
      const key = getDestinationCacheKey(token, destination.name, isolation);
      const expiresIn = (0, util_1.first)(destination.authTokens || [])?.expiresIn;
      const expirationTime = expiresIn ? Date.now() + parseInt(expiresIn) * 1e3 : void 0;
      cache.set(key, { entry: destination, expires: expirationTime });
    }
    function setDestinationCache(cache) {
      exports2.destinationCache = (0, exports2.DestinationCache)(cache);
    }
    exports2.destinationCache = (0, exports2.DestinationCache)();
    function getDefaultIsolationStrategy(jwt) {
      return jwt && (0, jwt_1.userId)(jwt) ? "tenant-user" : "tenant";
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-selection-strategies.js
var require_destination_selection_strategies = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-selection-strategies.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DestinationSelectionStrategies = void 0;
    exports2.alwaysProvider = alwaysProvider;
    exports2.alwaysSubscriber = alwaysSubscriber;
    exports2.subscriberFirst = subscriberFirst;
    var util_1 = require_dist2();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "destination-selection-strategies"
    });
    function alwaysProvider(allDestinations, destinationName) {
      return findDestination(allDestinations.provider, destinationName) || null;
    }
    function alwaysSubscriber(allDestinations, destinationName) {
      return findDestination(allDestinations.subscriber, destinationName) || null;
    }
    function subscriberFirst(allDestinations, destinationName) {
      return findDestination(allDestinations.subscriber, destinationName) || findDestination(allDestinations.provider, destinationName) || null;
    }
    exports2.DestinationSelectionStrategies = {
      alwaysProvider,
      alwaysSubscriber,
      subscriberFirst
    };
    function findDestination(destinations, destinationName) {
      const isRequestedDestination = (destination) => destination.name === destinationName;
      const instanceDest = destinations.instance.find(isRequestedDestination);
      const subAccountDest = destinations.subaccount.find(isRequestedDestination);
      if (instanceDest && subAccountDest) {
        logger8.warn(`Found destinations named '${destinationName}' for both, the destination service instance and subaccount. Using instance destination.`);
      }
      return instanceDest || subAccountDest;
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/http-agent/agent-config.js
var require_agent_config = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/http-agent/agent-config.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/register-destination-cache.js
var require_register_destination_cache = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/register-destination-cache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.registerDestinationCache = exports2.RegisterDestinationCache = void 0;
    var promises_1 = require("fs/promises");
    var crypto_1 = require("crypto");
    var util_1 = require_dist2();
    var async_cache_1 = require_async_cache();
    var destination_cache_1 = require_destination_cache();
    var logger8 = (0, util_1.createLogger)("register-destination-cache");
    var DefaultMtlsCache = class extends async_cache_1.AsyncCache {
      constructor(defaultValidityTime = 3e5) {
        super(defaultValidityTime);
      }
    };
    var MtlsCache = (mtlsCache = new DefaultMtlsCache()) => {
      const that = {
        useMtlsCache: false,
        retrieveMtlsOptionsFromCache: async () => mtlsCache.get("mtlsOptions"),
        cacheMtlsOptions: async () => {
          const getCert = (0, promises_1.readFile)(process.env.CF_INSTANCE_CERT, "utf8");
          const getKey = (0, promises_1.readFile)(process.env.CF_INSTANCE_KEY, "utf8");
          const [cert, key] = await Promise.all([getCert, getKey]);
          mtlsCache.set("mtlsOptions", {
            entry: { cert, key },
            expires: getCertExpirationDate(cert)
          });
        },
        getMtlsOptions: async () => {
          let mtlsOptions = await that.retrieveMtlsOptionsFromCache();
          if (!mtlsOptions) {
            await that.cacheMtlsOptions();
            mtlsOptions = await that.retrieveMtlsOptionsFromCache();
            if (!mtlsOptions) {
              logger8.warn("Neither the previous nor the current mtls certificate is valid anymore.");
            }
          }
          return mtlsOptions || {};
        },
        clear: async () => mtlsCache.clear(),
        getCacheInstance: () => mtlsCache
      };
      return that;
    };
    function getCertExpirationDate(cert) {
      return Number(new crypto_1.X509Certificate(cert).validTo);
    }
    var RegisterDestinationCache = () => ({
      destination: (0, destination_cache_1.DestinationCache)(new destination_cache_1.DefaultDestinationCache(0)),
      mtls: MtlsCache()
    });
    exports2.RegisterDestinationCache = RegisterDestinationCache;
    exports2.registerDestinationCache = (0, exports2.RegisterDestinationCache)();
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/http-agent/http-agent.js
var require_http_agent = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/http-agent/http-agent.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getAgentConfig = getAgentConfig;
    exports2.urlAndAgent = urlAndAgent;
    var promises_1 = require("fs/promises");
    var http_1 = __importDefault(require("http"));
    var https_1 = __importDefault(require("https"));
    var util_1 = require_dist2();
    var get_protocol_1 = require_get_protocol();
    var http_proxy_util_1 = require_http_proxy_util();
    var register_destination_cache_1 = require_register_destination_cache();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "http-agent"
    });
    async function getAgentConfig(destination) {
      const certificateOptions = {
        ...getTrustStoreOptions(destination),
        ...getKeyStoreOptions(destination),
        ...await getMtlsOptions(destination)
      };
      return createAgent(destination, certificateOptions);
    }
    function getTrustStoreOptions(destination) {
      if ((0, get_protocol_1.getProtocolOrDefault)(destination) === "http") {
        if (destination.isTrustingAllCertificates) {
          logger8.warn('"isTrustingAllCertificates" is not available for HTTP.');
        }
        if (destination.trustStoreCertificate) {
          logger8.warn('"trustStore" is not available for HTTP.');
        }
        return {};
      }
      if (destination.isTrustingAllCertificates && destination.trustStoreCertificate) {
        logger8.warn(`Destination ${destination.name} contains the 'trustAll' and 'trustStoreLocation' property which is a redundant setup.`);
      }
      if (destination.isTrustingAllCertificates) {
        logger8.warn('"isTrustingAllCertificates" property in the provided destination is set to "true". This is highly discouraged in production.');
        return { rejectUnauthorized: !destination.isTrustingAllCertificates };
      }
      if (destination.trustStoreCertificate) {
        const decoded = Buffer.from(destination.trustStoreCertificate.content, "base64").toString("utf8");
        return {
          rejectUnauthorized: true,
          ca: [decoded]
        };
      }
      return { rejectUnauthorized: true };
    }
    function getKeyStoreOptions(destination) {
      if (
        // Only add certificates, when using ClientCertificateAuthentication (https://github.com/SAP/cloud-sdk-js/issues/3544)
        destination.authentication === "ClientCertificateAuthentication" && !mtlsIsEnabled(destination) && destination.keyStoreName
      ) {
        const certificate = selectCertificate(destination);
        validateFormat(certificate);
        logger8.debug(`Certificate with name "${certificate.name}" selected.`);
        if (!destination.keyStorePassword) {
          logger8.debug(`Destination '${destination.name}' does not have a keystore password.`);
        }
        const certBuffer = Buffer.from(certificate.content, "base64");
        if (getFormat(certificate) === "pem") {
          return {
            cert: certBuffer,
            key: certBuffer,
            passphrase: destination.keyStorePassword
          };
        }
        return {
          pfx: certBuffer,
          passphrase: destination.keyStorePassword
        };
      }
      return {};
    }
    async function getMtlsOptions(destination) {
      if (destination.mtls && !(process.env.CF_INSTANCE_CERT && process.env.CF_INSTANCE_KEY)) {
        logger8.warn(`Destination ${destination.name ? destination.name : ""} has mTLS enabled, but the required Cloud Foundry environment variables (CF_INSTANCE_CERT and CF_INSTANCE_KEY) are not defined. Note that 'inferMtls' only works on Cloud Foundry.`);
      }
      if (mtlsIsEnabled(destination)) {
        if (register_destination_cache_1.registerDestinationCache.mtls.useMtlsCache) {
          return register_destination_cache_1.registerDestinationCache.mtls.getMtlsOptions();
        }
        const getCert = (0, promises_1.readFile)(process.env.CF_INSTANCE_CERT, "utf8");
        const getKey = (0, promises_1.readFile)(process.env.CF_INSTANCE_KEY, "utf8");
        const [cert, key] = await Promise.all([getCert, getKey]);
        return {
          cert,
          key
        };
      }
      return {};
    }
    function mtlsIsEnabled(destination) {
      return destination.mtls && process.env.CF_INSTANCE_CERT && process.env.CF_INSTANCE_KEY;
    }
    var supportedCertificateFormats = ["p12", "pfx", "pem"];
    function isSupportedFormat(format) {
      return !!format && supportedCertificateFormats.includes(format);
    }
    function selectCertificate(destination) {
      const certificate = destination.certificates.find((c) => c.name === destination.keyStoreName);
      if (!certificate) {
        throw Error(`No certificate with name ${destination.keyStoreName} could be found on the destination!`);
      }
      return certificate;
    }
    function getFormat(certificate) {
      return (0, util_1.last)(certificate.name.split("."));
    }
    function validateFormat(certificate) {
      const format = getFormat(certificate);
      if (!isSupportedFormat(format)) {
        throw Error(`The format of the provided certificate '${certificate.name}' is not supported. Supported formats are: ${supportedCertificateFormats.join(", ")}. ${format && ["jks", "keystore"].includes(format) ? "You can convert Java Keystores (.jks, .keystore) into PKCS#12 keystores using the JVM's keytool CLI: keytool -importkeystore -srckeystore your-keystore.jks -destkeystore your-keystore.p12 -deststoretype pkcs12" : ""}`);
      }
    }
    function createAgent(destination, options) {
      return (0, get_protocol_1.getProtocolOrDefault)(destination) === "https" ? { httpsAgent: new https_1.default.Agent(options) } : { httpAgent: new http_1.default.Agent(options) };
    }
    async function urlAndAgent(targetUri) {
      let destination = { url: targetUri, proxyType: "Internet" };
      if ((0, http_proxy_util_1.proxyStrategy)(destination) === "internet") {
        destination = (0, http_proxy_util_1.addProxyConfigurationInternet)(destination);
      }
      return {
        baseURL: destination.url,
        ...await getAgentConfig(destination),
        proxy: (0, http_proxy_util_1.getProxyConfig)(destination)
      };
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/http-agent/index.js
var require_http_agent2 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/http-agent/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_agent_config(), exports2);
    __exportStar(require_http_agent(), exports2);
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-service-cache.js
var require_destination_service_cache = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-service-cache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.destinationServiceCache = void 0;
    var cache_1 = require_cache2();
    var destination_cache_1 = require_destination_cache();
    var DestinationServiceCache = (cache) => ({
      retrieveDestinationsFromCache: (targetUrl, decodedJwt) => cache.get((0, destination_cache_1.getDestinationCacheKey)(decodedJwt, targetUrl, "tenant")),
      cacheRetrievedDestinations: (destinationServiceUri, decodedJwt, destinations) => {
        const key = (0, destination_cache_1.getDestinationCacheKey)(decodedJwt, destinationServiceUri, "tenant");
        cache.set(key, { entry: destinations });
      },
      clear: () => {
        cache.clear();
      },
      getCacheInstance: () => cache
    });
    exports2.destinationServiceCache = DestinationServiceCache(new cache_1.Cache(3e5));
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-service.js
var require_destination_service = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-service.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fetchDestinations = fetchDestinations;
    exports2.fetchDestinationWithoutTokenRetrieval = fetchDestinationWithoutTokenRetrieval;
    exports2.fetchCertificate = fetchCertificate;
    exports2.fetchDestinationWithTokenRetrieval = fetchDestinationWithTokenRetrieval;
    var util_1 = require_dist2();
    var axios_1 = __importDefault(require_axios());
    var internal_1 = require_internal2();
    var resilience_1 = require_dist3();
    var async_retry_1 = __importDefault(require_lib());
    var jwt_1 = require_jwt2();
    var http_agent_1 = require_http_agent2();
    var authorization_header_1 = require_authorization_header();
    var destination_1 = require_destination2();
    var destination_service_cache_1 = require_destination_service_cache();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "destination-service"
    });
    async function fetchDestinations(destinationServiceUri, serviceToken, type, options) {
      const targetUri = `${(0, util_1.removeTrailingSlashes)(destinationServiceUri)}/destination-configuration/v1/${type}Destinations`;
      if (options?.useCache) {
        const destinationsFromCache = destination_service_cache_1.destinationServiceCache.retrieveDestinationsFromCache(targetUri, (0, jwt_1.decodeJwt)(serviceToken));
        if (destinationsFromCache) {
          logger8.debug(`Destinations retrieved from cache. There were ${destinationsFromCache.length} destinations returned from the cache.`);
          return destinationsFromCache;
        }
      }
      const headers = (0, jwt_1.wrapJwtInHeader)(serviceToken).headers;
      return callDestinationEndpoint({ uri: targetUri, tenantId: getTenantIdFromTokens(serviceToken) }, headers).then((response) => {
        const destinations = response.data.map((destination) => (0, destination_1.parseDestination)(destination));
        if (options?.useCache) {
          destination_service_cache_1.destinationServiceCache.cacheRetrievedDestinations(targetUri, (0, jwt_1.decodeJwt)(serviceToken), destinations);
        }
        return destinations;
      }).catch((error) => {
        throw new util_1.ErrorWithCause(`Failed to fetch ${type} destinations.${errorMessageFromResponse(error)}`, error);
      });
    }
    async function fetchDestinationWithoutTokenRetrieval(destinationName, destinationServiceUri, serviceToken) {
      const targetUri = `${(0, util_1.removeTrailingSlashes)(destinationServiceUri)}/destination-configuration/v1/destinations/${destinationName}?$skipTokenRetrieval=true`;
      try {
        const response = await callDestinationEndpoint({ uri: targetUri, tenantId: getTenantIdFromTokens(serviceToken) }, { Authorization: `Bearer ${serviceToken}` });
        const destination = (0, destination_1.parseDestination)(response.data.destinationConfiguration);
        return {
          instance: response.data.owner?.InstanceId ? [destination] : [],
          subaccount: !response.data.owner?.InstanceId && response.data.owner?.SubaccountId ? [destination] : []
        };
      } catch (err) {
        if (err.response?.status === 404 && err.response?.data?.ErrorMessage === "Configuration with the specified name was not found") {
          return {
            instance: [],
            subaccount: []
          };
        }
        throw new util_1.ErrorWithCause(`Failed to fetch destination.${errorMessageFromResponse(err)}`, err);
      }
    }
    async function fetchCertificate(destinationServiceUri, token, certificateName) {
      const filetype = certificateName.split(".")[1];
      if (filetype.toLowerCase() !== "pem") {
        logger8.warn(`The provided truststore ${certificateName} is not in 'pem' format which is currently the only supported format. Truststore is ignored.`);
        return;
      }
      const accountUri = `${(0, util_1.removeTrailingSlashes)(destinationServiceUri)}/destination-configuration/v1/subaccountCertificates/${certificateName}`;
      const instanceUri = `${(0, util_1.removeTrailingSlashes)(destinationServiceUri)}/destination-configuration/v1/instanceCertificates/${certificateName}`;
      const header = (0, jwt_1.wrapJwtInHeader)(token).headers;
      try {
        const response = await callCertificateEndpoint({ uri: accountUri, tenantId: getTenantIdFromTokens(token) }, header).catch(() => callCertificateEndpoint({
          uri: instanceUri,
          tenantId: getTenantIdFromTokens(token)
        }, header));
        return (0, destination_1.parseCertificate)(response.data);
      } catch (err) {
        logger8.warn(`Failed to fetch truststore certificate ${certificateName} - Continuing without certificate. This may cause failing requests`, err);
      }
    }
    function getTenantIdFromTokens(token) {
      let tenant;
      if (typeof token === "string") {
        tenant = (0, jwt_1.getTenantId)(token);
      } else {
        tenant = // represents the tenant as string already see https://api.sap.com/api/SAP_CP_CF_Connectivity_Destination/resource
        token.exchangeTenant || (0, jwt_1.getTenantId)(token.exchangeHeaderJwt) || (0, jwt_1.getTenantId)(token.authHeaderJwt);
      }
      if (!tenant) {
        throw new Error("Could not obtain tenant identifier from JWT.");
      }
      return tenant;
    }
    async function fetchDestinationWithTokenRetrieval(destinationServiceUri, token, options) {
      const targetUri = `${(0, util_1.removeTrailingSlashes)(destinationServiceUri)}/destination-configuration/v1/destinations/${options.destinationName}`;
      token = typeof token === "string" ? { authHeaderJwt: token } : token;
      let authHeader = (0, jwt_1.wrapJwtInHeader)(token.authHeaderJwt).headers;
      authHeader = token.exchangeHeaderJwt ? { ...authHeader, "X-user-token": token.exchangeHeaderJwt } : authHeader;
      authHeader = token.exchangeTenant ? { ...authHeader, "X-tenant": token.exchangeTenant } : authHeader;
      authHeader = token.refreshToken ? { ...authHeader, "X-refresh-token": token.refreshToken } : authHeader;
      return callDestinationEndpoint({ uri: targetUri, tenantId: getTenantIdFromTokens(token) }, authHeader, options).then((response) => {
        const destination = (0, destination_1.parseDestination)(response.data);
        return destination;
      }).catch((error) => {
        {
          throw new util_1.ErrorWithCause(`Failed to fetch destination ${options.destinationName}.${errorMessageFromResponse(error)}`, error);
        }
      });
    }
    function errorMessageFromResponse(error) {
      return (0, util_1.propertyExists)(error, "response", "data", "ErrorMessage") ? ` ${error.response.data.ErrorMessage}` : "";
    }
    function retryDestination(destinationName) {
      return (options) => (arg) => {
        let retryCount = 1;
        return (0, async_retry_1.default)(async (bail) => {
          try {
            const destination = await options.fn(arg);
            if (retryCount < 3) {
              retryCount++;
              await (0, authorization_header_1.buildAuthorizationHeaders)((0, destination_1.parseDestination)(destination.data));
            }
            return destination;
          } catch (error) {
            const status = error?.response?.status;
            if (status.toString().startsWith("4")) {
              bail(new util_1.ErrorWithCause(`Request failed with status code ${status}`, error));
              return void 0;
            }
            throw error;
          }
        }, {
          retries: 3,
          onRetry: (err) => logger8.warn(`Failed to retrieve destination ${destinationName} - doing a retry. Original Error ${err.message}`)
        });
      };
    }
    async function callCertificateEndpoint(context, headers) {
      if (!context.uri.includes("Certificates")) {
        throw new Error(`callCertificateEndpoint was called with illegal argument: ${context.uri}. URL must be certificate endpoint of destination service.`);
      }
      return callDestinationService(context, headers);
    }
    async function callDestinationEndpoint(context, headers, options) {
      if (!context.uri.match(/[instance|subaccount]Destinations|v1\/destinations/)) {
        throw new Error(`callDestinationEndpoint was called with illegal argument: ${context.uri}. URL must be destination(s) endpoint of destination service.`);
      }
      return callDestinationService(context, headers, options);
    }
    async function callDestinationService(context, headers, options) {
      const { destinationName, retry } = options || {};
      const requestConfig = {
        ...await (0, http_agent_1.urlAndAgent)(context.uri),
        method: "get",
        headers
      };
      const resilienceMiddleware = (0, resilience_1.resilience)();
      if (destinationName && retry) {
        resilienceMiddleware.unshift(retryDestination(destinationName));
      }
      return (0, internal_1.executeWithMiddleware)(resilienceMiddleware, {
        context,
        fnArgument: requestConfig,
        fn: (config) => axios_1.default.request(config)
      });
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/get-provider-token.js
var require_get_provider_token = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/get-provider-token.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getProviderServiceToken = getProviderServiceToken;
    var jwt_1 = require_jwt2();
    var token_accessor_1 = require_token_accessor();
    async function getProviderServiceToken(options) {
      const { jwt, ...optionsWithoutJwt } = options;
      const encoded = await (0, token_accessor_1.serviceToken)("destination", optionsWithoutJwt);
      return { encoded, decoded: (0, jwt_1.decodeJwt)(encoded) };
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/get-subscriber-token.js
var require_get_subscriber_token = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/get-subscriber-token.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isSubscriberToken = isSubscriberToken;
    exports2.getSubscriberToken = getSubscriberToken;
    exports2.getRequiredSubscriberToken = getRequiredSubscriberToken;
    exports2.hasTokens = hasTokens;
    exports2.getJwtForTenant = getJwtForTenant;
    exports2.getJwtForUser = getJwtForUser;
    var util_1 = require_dist2();
    var jwt_1 = require_jwt2();
    var token_accessor_1 = require_token_accessor();
    var subdomain_replacer_1 = require_subdomain_replacer();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "destination-accessor-service"
    });
    function isSubscriberToken(token) {
      return token.userJwt || token.serviceJwt;
    }
    async function getSubscriberToken(options) {
      const isXsuaaJwt = !!options.jwt && (0, jwt_1.isXsuaaToken)((0, jwt_1.decodeJwt)(options.jwt));
      const userJwt = await retrieveUserToken(options, isXsuaaJwt);
      const serviceJwt = await retrieveServiceToken(options, userJwt?.decoded);
      return { userJwt, serviceJwt };
    }
    async function retrieveUserToken(options, isXsuaaJwt) {
      if (options.jwt) {
        if (!options.iss && isXsuaaJwt) {
          await (0, jwt_1.verifyJwt)(options.jwt, options);
        }
        return (0, jwt_1.getJwtPair)(options.jwt);
      }
    }
    async function retrieveServiceToken(options, decodedUserJwt) {
      const jwt = getJwtForServiceToken(options.iss, decodedUserJwt);
      if (jwt) {
        try {
          return (0, jwt_1.getJwtPair)(await (0, token_accessor_1.serviceToken)("destination", {
            ...options,
            jwt
          }));
        } catch (err) {
          logger8.warn(`Failed to fetch subscriber service token for destination. This is only relevant if you are using subscriber destinations. Failure caused by: ${err.message}`);
        }
      }
    }
    function getJwtForServiceToken(iss, decodedUserJwt) {
      if (iss) {
        logger8.debug("Using `iss` option instead of a full JWT to fetch a destination. No validation is performed.");
        return { ext_attr: { zdn: (0, subdomain_replacer_1.getIssuerSubdomain)({ iss }) } };
      }
      if (decodedUserJwt?.zid || decodedUserJwt?.app_tid) {
        return decodedUserJwt;
      }
    }
    function getRequiredSubscriberToken(token) {
      if (token) {
        const { userJwt, serviceJwt } = token;
        const requiredToken = {
          userJwt: userJwt || serviceJwt,
          serviceJwt: serviceJwt || userJwt
        };
        if (isRequired(requiredToken)) {
          return requiredToken;
        }
      }
      throw new Error("Could not get subscriber token: Token value is undefined.");
    }
    function isRequired(token) {
      return !!(token?.userJwt && token.serviceJwt);
    }
    function hasTokens(token) {
      return !!token?.userJwt || !!token?.serviceJwt;
    }
    function getJwtForTenant(token) {
      return token.serviceJwt;
    }
    function getJwtForUser(token) {
      return token.userJwt;
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-from-service.js
var require_destination_from_service = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-from-service.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DestinationFromServiceRetriever = void 0;
    exports2.getDestinationFromDestinationService = getDestinationFromDestinationService;
    var util_1 = require_dist2();
    var connectivity_service_1 = require_connectivity_service();
    var environment_accessor_1 = require_environment_accessor();
    var identity_service_1 = require_identity_service();
    var jwt_1 = require_jwt2();
    var tenant_1 = require_tenant();
    var token_accessor_1 = require_token_accessor();
    var destination_cache_1 = require_destination_cache();
    var destination_selection_strategies_1 = require_destination_selection_strategies();
    var destination_service_1 = require_destination_service();
    var destination_service_types_1 = require_destination_service_types();
    var get_provider_token_1 = require_get_provider_token();
    var get_subscriber_token_1 = require_get_subscriber_token();
    var http_proxy_util_1 = require_http_proxy_util();
    var forward_auth_token_1 = require_forward_auth_token();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "destination-accessor-service"
    });
    var emptyDestinationByType = {
      instance: [],
      subaccount: []
    };
    async function getDestinationFromDestinationService(options) {
      logger8.debug("Attempting to retrieve destination from destination service.");
      return DestinationFromServiceRetriever.getDestinationFromDestinationService(options);
    }
    var DestinationFromServiceRetriever = class _DestinationFromServiceRetriever {
      static async getDestinationFromDestinationService(options) {
        if ((0, identity_service_1.shouldExchangeToken)(options) && options.jwt) {
          options.jwt = await (0, identity_service_1.exchangeToken)(options.jwt);
        }
        const subscriberToken = await (0, get_subscriber_token_1.getSubscriberToken)(options);
        const providerToken = await (0, get_provider_token_1.getProviderServiceToken)(options);
        const da = new _DestinationFromServiceRetriever(options, subscriberToken, providerToken);
        const destinationResult = await da.searchDestinationWithSelectionStrategyAndCache();
        if (!destinationResult) {
          return null;
        }
        let { destination } = destinationResult;
        (0, forward_auth_token_1.setForwardedAuthTokenIfNeeded)(destination, options.jwt);
        if (destinationResult.fromCache) {
          return da.addProxyConfiguration(destination);
        }
        if (!destination.forwardAuthToken) {
          if (destination.authentication === "OAuth2UserTokenExchange" || destination.authentication === "OAuth2JWTBearer" || destination.authentication === "SAMLAssertion" || destination.authentication === "OAuth2SAMLBearerAssertion" && !da.usesSystemUser(destination)) {
            destination = await da.fetchDestinationWithUserExchangeFlows(destinationResult);
          }
          if (destination.authentication === "PrincipalPropagation") {
            if (!this.isUserJwt(da.subscriberToken)) {
              _DestinationFromServiceRetriever.throwUserTokenMissing(destination);
            }
          }
          if (destination.authentication === "OAuth2Password" || destination.authentication === "ClientCertificateAuthentication" || destination.authentication === "OAuth2ClientCredentials" || da.usesSystemUser(destination)) {
            destination = await da.fetchDestinationWithNonUserExchangeFlows(destinationResult);
          }
          if (destination.authentication === "OAuth2RefreshToken") {
            destination = await da.fetchDestinationWithRefreshTokenFlow(destinationResult);
          }
        }
        const withTrustStore = await da.addTrustStoreConfiguration(destination, destinationResult.origin);
        await da.updateDestinationCache(withTrustStore, destinationResult.origin);
        return da.addProxyConfiguration(withTrustStore);
      }
      static throwUserTokenMissing(destination) {
        throw Error(`No user token (JWT) has been provided. This is strictly necessary for '${destination.authentication}'.`);
      }
      static checkDestinationForCustomJwt(destination) {
        if (!destination.jwks && !destination.jwksUri) {
          throw new Error("Failed to verify the JWT with no JKU! Destination must have `x_user_token.jwks` or `x_user_token.jwks_uri` property.");
        }
      }
      static isUserJwt(token) {
        return !!token?.userJwt;
      }
      constructor(options, subscriberToken, providerServiceToken) {
        this.subscriberToken = subscriberToken;
        this.providerServiceToken = providerServiceToken;
        const defaultOptions2 = {
          isolationStrategy: (0, destination_cache_1.getDefaultIsolationStrategy)(subscriberToken?.userJwt?.decoded),
          selectionStrategy: destination_selection_strategies_1.subscriberFirst,
          useCache: true
        };
        this.options = { ...defaultOptions2, ...options };
      }
      async searchDestinationWithSelectionStrategyAndCache() {
        let destinationSearchResult;
        if (this.isSubscriberNeeded()) {
          destinationSearchResult = await this.searchSubscriberAccountForDestination();
        }
        if (this.isProviderNeeded(destinationSearchResult)) {
          destinationSearchResult = await this.searchProviderAccountForDestination();
        }
        if (destinationSearchResult) {
          if (destinationSearchResult.fromCache) {
            logger8.debug(`Successfully retrieved destination from destination service cache for ${destinationSearchResult.origin} destinations.`);
          } else {
            logger8.debug("Successfully retrieved destination from destination service.");
          }
        } else {
          logger8.debug("Could not retrieve destination from destination service.");
        }
        return destinationSearchResult;
      }
      getExchangeTenant(destination) {
        if (destination.authentication !== "OAuth2ClientCredentials") {
          return void 0;
        }
        if (destination.originalProperties?.["tokenServiceURLType"] !== "Common") {
          return void 0;
        }
        const subdomainSubscriber = (0, jwt_1.getSubdomain)(this.subscriberToken?.serviceJwt?.decoded) || (0, jwt_1.getSubdomain)(this.subscriberToken?.userJwt?.decoded);
        const subdomainProvider = (0, jwt_1.getSubdomain)(this.providerServiceToken?.decoded);
        return subdomainSubscriber || subdomainProvider || void 0;
      }
      async getAuthTokenForOAuth2ClientCredentials(destinationResult) {
        const { destination, origin } = destinationResult;
        const exchangeTenant = this.getExchangeTenant(destination);
        const authHeaderJwt = origin === "provider" ? this.providerServiceToken.encoded : this.subscriberToken?.serviceJwt?.encoded;
        if (!authHeaderJwt) {
          throw Error("Could not retrieve service token for the destination service.");
        }
        return { authHeaderJwt, exchangeTenant };
      }
      // This covers the two technical user propagation https://help.sap.com/viewer/cca91383641e40ffbe03bdc78f00f681/Cloud/en-US/3cb7b81115c44cf594e0e3631291af94.html
      usesSystemUser(destination) {
        if (destination.systemUser && destination.authentication === "OAuth2SAMLBearerAssertion") {
          logger8.debug(`System user found on destination: "${destination.name}". 
The property SystemUser has been deprecated. 
It is highly recommended that you stop using it.
Possible alternatives for such technical user authentication are BasicAuthentication, OAuth2ClientCredentials, or ClientCertificateAuthentication`);
          return true;
        }
        return false;
      }
      async getAuthTokenForOAuth2UserBasedTokenExchanges(destinationResult) {
        const { destination, origin } = destinationResult;
        const { destinationName } = this.options;
        if (!_DestinationFromServiceRetriever.isUserJwt(this.subscriberToken)) {
          throw _DestinationFromServiceRetriever.throwUserTokenMissing(destination);
        }
        const isXsuaaUserJwt = (0, jwt_1.isXsuaaToken)(this.subscriberToken.userJwt.decoded);
        if (!isXsuaaUserJwt) {
          _DestinationFromServiceRetriever.checkDestinationForCustomJwt(destination);
        }
        if (isXsuaaUserJwt && (0, tenant_1.isIdenticalTenant)(this.subscriberToken.userJwt.decoded, this.providerServiceToken.decoded)) {
          logger8.debug(`UserExchange flow started without user exchange token for destination ${destinationName} of the provider account.`);
          return {
            authHeaderJwt: await (0, token_accessor_1.jwtBearerToken)(this.subscriberToken.userJwt.encoded, getDestinationService())
          };
        }
        const serviceJwt = origin === "provider" ? this.providerServiceToken : (
          // on type level this could be undefined, but logically if the origin is subscriber, it must be defined.
          this.subscriberToken.serviceJwt
        );
        logger8.debug(`UserExchange flow started for destination ${destinationName} of the ${origin} account.`);
        return {
          authHeaderJwt: serviceJwt.encoded,
          // token to get destination from service
          exchangeHeaderJwt: this.subscriberToken.userJwt.encoded
          // token considered for user and tenant
        };
      }
      async getAuthTokenForOAuth2RefreshToken(destinationResult) {
        const { destination, origin } = destinationResult;
        const { refreshToken } = this.options;
        if (!refreshToken) {
          throw Error(`No refresh token has been provided. This is strictly necessary for '${destination.authentication}'.`);
        }
        const clientGrant = origin === "provider" ? this.providerServiceToken.encoded : this.subscriberToken.serviceJwt.encoded;
        return { authHeaderJwt: clientGrant, refreshToken };
      }
      /**
       * @internal
       * This method calls the 'find destination by name' endpoint of the destination service using a client credentials grant.
       * For the find by name endpoint, the destination service will take care of OAuth flows and include the token in the destination.
       * @param destinationResult - Result of the getDestinations call for which the exchange flow is triggered.
       * @returns Destination containing the auth token.
       */
      async fetchDestinationWithNonUserExchangeFlows(destinationResult) {
        const token = await this.getAuthTokenForOAuth2ClientCredentials(destinationResult);
        return (0, destination_service_1.fetchDestinationWithTokenRetrieval)((0, environment_accessor_1.getDestinationServiceCredentials)().uri, token, this.options);
      }
      async fetchDestinationWithUserExchangeFlows(destinationResult) {
        const token = await this.getAuthTokenForOAuth2UserBasedTokenExchanges(destinationResult);
        return (0, destination_service_1.fetchDestinationWithTokenRetrieval)((0, environment_accessor_1.getDestinationServiceCredentials)().uri, token, this.options);
      }
      async fetchDestinationWithRefreshTokenFlow(destinationResult) {
        const token = await this.getAuthTokenForOAuth2RefreshToken(destinationResult);
        return (0, destination_service_1.fetchDestinationWithTokenRetrieval)((0, environment_accessor_1.getDestinationServiceCredentials)().uri, token, this.options);
      }
      async addProxyConfiguration(destination) {
        switch ((0, http_proxy_util_1.proxyStrategy)(destination)) {
          case "on-premise":
            return (0, connectivity_service_1.addProxyConfigurationOnPrem)(destination, (0, get_subscriber_token_1.hasTokens)(this.subscriberToken) ? (0, get_subscriber_token_1.getRequiredSubscriberToken)(this.subscriberToken) : void 0);
          case "internet":
          case "private-link":
            (0, destination_service_types_1.assertHttpDestination)(destination);
            return (0, http_proxy_util_1.addProxyConfigurationInternet)(destination);
          case "no-proxy":
            return destination;
          default:
            throw new Error("Illegal argument: No valid proxy configuration found in the destination input to be added.");
        }
      }
      async updateDestinationCache(destination, destinationOrigin) {
        if (!this.options.useCache) {
          return destination;
        }
        await destination_cache_1.destinationCache.cacheRetrievedDestination(destinationOrigin === "subscriber" ? (0, get_subscriber_token_1.getRequiredSubscriberToken)(this.subscriberToken) : this.providerServiceToken.decoded, destination, this.options.isolationStrategy);
      }
      async getProviderDestinationService() {
        const providerDestination = await (0, destination_service_1.fetchDestinationWithoutTokenRetrieval)(this.options.destinationName, (0, environment_accessor_1.getDestinationServiceCredentials)().uri, this.providerServiceToken.encoded);
        const destination = this.options.selectionStrategy({
          subscriber: emptyDestinationByType,
          provider: providerDestination
        }, this.options.destinationName);
        if (destination) {
          return { destination, fromCache: false, origin: "provider" };
        }
      }
      async getProviderDestinationCache() {
        const destination = await destination_cache_1.destinationCache.retrieveDestinationFromCache(this.providerServiceToken.decoded, this.options.destinationName, this.options.isolationStrategy);
        if (destination) {
          return { destination, fromCache: true, origin: "provider" };
        }
      }
      async getSubscriberDestinationService() {
        if (!this.subscriberToken?.serviceJwt) {
          throw new Error("Try to get destinations from subscriber account but service JWT was not set.");
        }
        const subscriberDestination = await (0, destination_service_1.fetchDestinationWithoutTokenRetrieval)(this.options.destinationName, (0, environment_accessor_1.getDestinationServiceCredentials)().uri, this.subscriberToken.serviceJwt.encoded);
        const destination = this.options.selectionStrategy({
          subscriber: subscriberDestination,
          provider: emptyDestinationByType
        }, this.options.destinationName);
        if (destination) {
          return { destination, fromCache: false, origin: "subscriber" };
        }
      }
      async getSubscriberDestinationCache() {
        const destination = await destination_cache_1.destinationCache.retrieveDestinationFromCache((0, get_subscriber_token_1.getRequiredSubscriberToken)(this.subscriberToken), this.options.destinationName, this.options.isolationStrategy);
        if (destination) {
          return { destination, fromCache: true, origin: "subscriber" };
        }
      }
      isProviderNeeded(resultFromSubscriber) {
        if (this.options.selectionStrategy.toString() === destination_selection_strategies_1.alwaysSubscriber.toString()) {
          return false;
        }
        if (this.options.selectionStrategy.toString() === destination_selection_strategies_1.subscriberFirst.toString() && resultFromSubscriber) {
          return false;
        }
        return true;
      }
      isSubscriberNeeded() {
        if (!this.subscriberToken?.serviceJwt) {
          return false;
        }
        return this.options.selectionStrategy.toString() !== destination_selection_strategies_1.alwaysProvider.toString();
      }
      async searchProviderAccountForDestination() {
        return this.options.useCache && await this.getProviderDestinationCache() || this.getProviderDestinationService();
      }
      async searchSubscriberAccountForDestination() {
        return this.options.useCache && await this.getSubscriberDestinationCache() || this.getSubscriberDestinationService();
      }
      async addTrustStoreConfiguration(destination, origin) {
        if (destination.originalProperties?.TrustStoreLocation) {
          const trustStoreCertificate = await (0, destination_service_1.fetchCertificate)((0, environment_accessor_1.getDestinationServiceCredentials)().uri, origin === "provider" ? this.providerServiceToken.encoded : this.subscriberToken.serviceJwt.encoded, destination.originalProperties.TrustStoreLocation);
          destination.trustStoreCertificate = trustStoreCertificate;
        }
        return destination;
      }
    };
    exports2.DestinationFromServiceRetriever = DestinationFromServiceRetriever;
    function getDestinationService() {
      const destinationService = (0, environment_accessor_1.getServiceBinding)("destination");
      if (!destinationService) {
        throw Error("No binding to a destination service found.");
      }
      return destinationService;
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-from-registration.js
var require_destination_from_registration = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-from-registration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.registerDestination = registerDestination;
    exports2.searchRegisteredDestination = searchRegisteredDestination;
    var util_1 = require_dist2();
    var jwt_1 = require_jwt2();
    var destination_cache_1 = require_destination_cache();
    var destination_service_types_1 = require_destination_service_types();
    var http_proxy_util_1 = require_http_proxy_util();
    var register_destination_cache_1 = require_register_destination_cache();
    var forward_auth_token_1 = require_forward_auth_token();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "register-destination"
    });
    async function registerDestination(destination, options) {
      if (!destination.name) {
        throw Error("Registering destinations requires a destination name.");
      }
      destination.mtls = !!options?.inferMtls;
      if (options?.useMtlsCache) {
        register_destination_cache_1.registerDestinationCache.mtls.useMtlsCache = true;
        await register_destination_cache_1.registerDestinationCache.mtls.cacheMtlsOptions();
      }
      await register_destination_cache_1.registerDestinationCache.destination.cacheRetrievedDestination(getJwtForCaching(options), destination, isolationStrategy(options));
    }
    function getJwtForCaching(options) {
      const jwt = (0, jwt_1.decodeOrMakeJwt)(options?.jwt);
      if (!(0, jwt_1.getTenantId)(jwt)) {
        if (options?.jwt) {
          throw Error("Could not determine tenant from JWT nor XSUAA, identity or destination service binding. Destination is registered without tenant information.");
        } else {
          logger8.debug("Could not determine tenant from XSUAA, identity or destination service binding. Destination is registered without tenant information.");
        }
        return { zid: jwt_1.defaultTenantId };
      }
      return jwt;
    }
    async function searchRegisteredDestination(options) {
      const destination = await register_destination_cache_1.registerDestinationCache.destination.retrieveDestinationFromCache(getJwtForCaching(options), options.destinationName, isolationStrategy(options));
      if (!destination) {
        logger8.debug(`Could not retrieve '${options.destinationName}' from registered destinations.`);
        return null;
      }
      logger8.info(`Successfully retrieved destination '${options.destinationName}' from registered destinations.`);
      (0, forward_auth_token_1.setForwardedAuthTokenIfNeeded)(destination, options.jwt);
      return (0, destination_service_types_1.isHttpDestination)(destination) && ["internet", "private-link"].includes((0, http_proxy_util_1.proxyStrategy)(destination)) ? (0, http_proxy_util_1.addProxyConfigurationInternet)(destination) : destination;
    }
    function isolationStrategy(options) {
      if (options?.isolationStrategy) {
        return options.isolationStrategy;
      }
      const decoded = options?.jwt ? (0, jwt_1.decodeJwt)(options.jwt) : void 0;
      return (0, destination_cache_1.getDefaultIsolationStrategy)(decoded);
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-accessor.js
var require_destination_accessor = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-accessor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.useOrFetchDestination = useOrFetchDestination2;
    exports2.resolveDestination = resolveDestination;
    exports2.getDestination = getDestination;
    exports2.getAllDestinationsFromDestinationService = getAllDestinationsFromDestinationService;
    var util_1 = require_dist2();
    var identity_service_1 = require_identity_service();
    var environment_accessor_1 = require_environment_accessor();
    var jwt_1 = require_jwt2();
    var destination_1 = require_destination2();
    var destination_from_env_1 = require_destination_from_env();
    var destination_from_vcap_1 = require_destination_from_vcap();
    var destination_from_service_1 = require_destination_from_service();
    var destination_accessor_types_1 = require_destination_accessor_types();
    var destination_from_registration_1 = require_destination_from_registration();
    var get_subscriber_token_1 = require_get_subscriber_token();
    var get_provider_token_1 = require_get_provider_token();
    var destination_service_1 = require_destination_service();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "destination-accessor"
    });
    async function useOrFetchDestination2(destination) {
      return (0, destination_accessor_types_1.isDestinationFetchOptions)(destination) ? getDestination(destination) : (0, destination_1.sanitizeDestination)(destination);
    }
    async function resolveDestination(destination) {
      const resolvedDestination = await useOrFetchDestination2(destination).catch((error) => {
        throw new util_1.ErrorWithCause("Failed to load destination.", error);
      });
      if (!resolvedDestination) {
        throw Error(`Failed to resolve the destination '${(0, destination_1.toDestinationNameUrl)(destination)}'.`);
      }
      return resolvedDestination;
    }
    async function getDestination(options) {
      const destination = (0, destination_from_env_1.searchEnvVariablesForDestination)(options) || await (0, destination_from_registration_1.searchRegisteredDestination)(options) || await (0, destination_from_vcap_1.searchServiceBindingForDestination)(options) || await (0, destination_from_service_1.getDestinationFromDestinationService)(options);
      return destination;
    }
    function createDestinationFetchLogs(origin, destinations) {
      return destinations.reduce((prevLogMessages, currentDestination) => prevLogMessages + `Retrieving ${origin} destination: ${currentDestination.name}.
`, "");
    }
    async function getAllDestinationsFromDestinationService(options = {}) {
      options = {
        ...options,
        // Enable caching by default
        useCache: options.useCache ?? true
      };
      logger8.debug("Attempting to retrieve all destinations from destination service.");
      if ((0, identity_service_1.shouldExchangeToken)(options) && options.jwt) {
        options.jwt = await (0, identity_service_1.exchangeToken)(options.jwt);
      }
      const token = (await (0, get_subscriber_token_1.getSubscriberToken)(options))?.serviceJwt || await (0, get_provider_token_1.getProviderServiceToken)(options);
      const destinationServiceUri = (0, environment_accessor_1.getDestinationServiceCredentials)().uri;
      const subdomain = (0, jwt_1.getSubdomain)(token.decoded);
      logger8.debug(`Retrieving all destinations for account: "${subdomain}" from destination service.`);
      const [instance, subaccount] = await Promise.all([
        (0, destination_service_1.fetchDestinations)(destinationServiceUri, token.encoded, "instance", options),
        (0, destination_service_1.fetchDestinations)(destinationServiceUri, token.encoded, "subaccount", options)
      ]);
      const loggerMessage = createDestinationFetchLogs("instance", instance) + createDestinationFetchLogs("subaccount", subaccount);
      logger8.debug(loggerMessage);
      const allDestinations = [...instance, ...subaccount];
      if (allDestinations?.length) {
        logger8.debug(`Successfully retrieved all destinations for account: "${subdomain}" from destination service.`);
      } else {
        logger8.debug("Didn't receive any destinations from destination service.");
        return [];
      }
      const allDestinationsWithoutToken = allDestinations.map((destination) => {
        delete destination.authTokens;
        return destination;
      });
      return allDestinationsWithoutToken;
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/index.js
var require_destination3 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_destination_accessor(), exports2);
    __exportStar(require_destination_accessor_types(), exports2);
    __exportStar(require_destination_cache(), exports2);
    __exportStar(require_destination_from_env(), exports2);
    __exportStar(require_destination_from_service(), exports2);
    __exportStar(require_destination_from_registration(), exports2);
    __exportStar(require_destination_from_vcap(), exports2);
    __exportStar(require_destination_selection_strategies(), exports2);
    __exportStar(require_destination_service_cache(), exports2);
    __exportStar(require_destination_service_types(), exports2);
    __exportStar(require_destination_service(), exports2);
    __exportStar(require_destination2(), exports2);
    __exportStar(require_forward_auth_token(), exports2);
    __exportStar(require_get_subscriber_token(), exports2);
    __exportStar(require_get_provider_token(), exports2);
    __exportStar(require_http_proxy_util(), exports2);
    __exportStar(require_service_binding_to_destination(), exports2);
    __exportStar(require_register_destination_cache(), exports2);
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/connectivity-service-types.js
var require_connectivity_service_types = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/connectivity-service-types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/header-builder-for-destination.js
var require_header_builder_for_destination = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/header-builder-for-destination.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildHeadersForDestination = buildHeadersForDestination;
    var util_1 = require_dist2();
    var authorization_header_1 = require_authorization_header();
    async function buildHeadersForDestination(destination) {
      const authHeaders = await (0, authorization_header_1.buildAuthorizationHeaders)(destination);
      const sapHeaders = getSapHeaders(destination);
      return (0, util_1.mergeIgnoreCase)(destination.headers, {
        ...authHeaders,
        ...sapHeaders
      });
    }
    function getSapHeaders(destination) {
      const defaultHeaders = (0, util_1.pickNonNullish)({
        "sap-client": destination.sapClient,
        "SAP-Connectivity-SCC-Location_ID": destination.cloudConnectorLocationId
      });
      return (0, util_1.mergeLeftIgnoreCase)(defaultHeaders, destination.headers);
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/jsonwebtoken-type.js
var require_jsonwebtoken_type = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/jsonwebtoken-type.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/xsuaa-service-types.js
var require_xsuaa_service_types = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/xsuaa-service-types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/index.js
var require_scp_cf = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_destination3(), exports2);
    __exportStar(require_authorization_header(), exports2);
    __exportStar(require_cache2(), exports2);
    __exportStar(require_client_credentials_token_cache(), exports2);
    __exportStar(require_connectivity_service(), exports2);
    __exportStar(require_connectivity_service_types(), exports2);
    __exportStar(require_environment_accessor(), exports2);
    __exportStar(require_get_protocol(), exports2);
    __exportStar(require_header_builder_for_destination(), exports2);
    __exportStar(require_identity_service(), exports2);
    __exportStar(require_jsonwebtoken_type(), exports2);
    __exportStar(require_jwt2(), exports2);
    __exportStar(require_protocol(), exports2);
    __exportStar(require_subdomain_replacer(), exports2);
    __exportStar(require_tenant(), exports2);
    __exportStar(require_token_accessor(), exports2);
    __exportStar(require_xsuaa_service_types(), exports2);
    __exportStar(require_xsuaa_service(), exports2);
    __exportStar(require_async_cache(), exports2);
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getAgentConfig = exports2.transformServiceBindingToClientCredentialsDestination = exports2.getTenantId = exports2.getAllDestinationsFromDestinationService = exports2.transformServiceBindingToDestination = exports2.getDestinationFromServiceBinding = exports2.getServiceBinding = exports2.setDestinationCache = exports2.registerDestination = exports2.getUserToken = exports2.getClientCredentialsToken = exports2.buildHeadersForDestination = exports2.DestinationSelectionStrategies = exports2.assertHttpDestination = exports2.isHttpDestination = exports2.serviceToken = exports2.jwtBearerToken = exports2.retrieveJwt = exports2.decodeJwt = exports2.parseProxyEnv = exports2.subscriberFirst = exports2.alwaysSubscriber = exports2.alwaysProvider = exports2.getDestinationFromDestinationService = exports2.useOrFetchDestination = exports2.getDestination = exports2.sanitizeDestination = exports2.toDestinationNameUrl = void 0;
    var scp_cf_1 = require_scp_cf();
    Object.defineProperty(exports2, "toDestinationNameUrl", { enumerable: true, get: function() {
      return scp_cf_1.toDestinationNameUrl;
    } });
    Object.defineProperty(exports2, "sanitizeDestination", { enumerable: true, get: function() {
      return scp_cf_1.sanitizeDestination;
    } });
    Object.defineProperty(exports2, "getDestination", { enumerable: true, get: function() {
      return scp_cf_1.getDestination;
    } });
    Object.defineProperty(exports2, "useOrFetchDestination", { enumerable: true, get: function() {
      return scp_cf_1.useOrFetchDestination;
    } });
    Object.defineProperty(exports2, "getDestinationFromDestinationService", { enumerable: true, get: function() {
      return scp_cf_1.getDestinationFromDestinationService;
    } });
    Object.defineProperty(exports2, "alwaysProvider", { enumerable: true, get: function() {
      return scp_cf_1.alwaysProvider;
    } });
    Object.defineProperty(exports2, "alwaysSubscriber", { enumerable: true, get: function() {
      return scp_cf_1.alwaysSubscriber;
    } });
    Object.defineProperty(exports2, "subscriberFirst", { enumerable: true, get: function() {
      return scp_cf_1.subscriberFirst;
    } });
    Object.defineProperty(exports2, "parseProxyEnv", { enumerable: true, get: function() {
      return scp_cf_1.parseProxyEnv;
    } });
    Object.defineProperty(exports2, "decodeJwt", { enumerable: true, get: function() {
      return scp_cf_1.decodeJwt;
    } });
    Object.defineProperty(exports2, "retrieveJwt", { enumerable: true, get: function() {
      return scp_cf_1.retrieveJwt;
    } });
    Object.defineProperty(exports2, "jwtBearerToken", { enumerable: true, get: function() {
      return scp_cf_1.jwtBearerToken;
    } });
    Object.defineProperty(exports2, "serviceToken", { enumerable: true, get: function() {
      return scp_cf_1.serviceToken;
    } });
    Object.defineProperty(exports2, "isHttpDestination", { enumerable: true, get: function() {
      return scp_cf_1.isHttpDestination;
    } });
    Object.defineProperty(exports2, "assertHttpDestination", { enumerable: true, get: function() {
      return scp_cf_1.assertHttpDestination;
    } });
    Object.defineProperty(exports2, "DestinationSelectionStrategies", { enumerable: true, get: function() {
      return scp_cf_1.DestinationSelectionStrategies;
    } });
    Object.defineProperty(exports2, "buildHeadersForDestination", { enumerable: true, get: function() {
      return scp_cf_1.buildHeadersForDestination;
    } });
    Object.defineProperty(exports2, "getClientCredentialsToken", { enumerable: true, get: function() {
      return scp_cf_1.getClientCredentialsToken;
    } });
    Object.defineProperty(exports2, "getUserToken", { enumerable: true, get: function() {
      return scp_cf_1.getUserToken;
    } });
    Object.defineProperty(exports2, "registerDestination", { enumerable: true, get: function() {
      return scp_cf_1.registerDestination;
    } });
    Object.defineProperty(exports2, "setDestinationCache", { enumerable: true, get: function() {
      return scp_cf_1.setDestinationCache;
    } });
    Object.defineProperty(exports2, "getServiceBinding", { enumerable: true, get: function() {
      return scp_cf_1.getServiceBinding;
    } });
    Object.defineProperty(exports2, "getDestinationFromServiceBinding", { enumerable: true, get: function() {
      return scp_cf_1.getDestinationFromServiceBinding;
    } });
    Object.defineProperty(exports2, "transformServiceBindingToDestination", { enumerable: true, get: function() {
      return scp_cf_1.transformServiceBindingToDestination;
    } });
    Object.defineProperty(exports2, "getAllDestinationsFromDestinationService", { enumerable: true, get: function() {
      return scp_cf_1.getAllDestinationsFromDestinationService;
    } });
    Object.defineProperty(exports2, "getTenantId", { enumerable: true, get: function() {
      return scp_cf_1.getTenantId;
    } });
    Object.defineProperty(exports2, "transformServiceBindingToClientCredentialsDestination", { enumerable: true, get: function() {
      return scp_cf_1.transformServiceBindingToClientCredentialsDestination;
    } });
    var http_agent_1 = require_http_agent2();
    Object.defineProperty(exports2, "getAgentConfig", { enumerable: true, get: function() {
      return http_agent_1.getAgentConfig;
    } });
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/internal.js
var require_internal3 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/dist/internal.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_http_agent2(), exports2);
    __exportStar(require_scp_cf(), exports2);
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/internal.js
var require_internal4 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/connectivity/internal.js"(exports2) {
    "use strict";
    function __export2(m) {
      for (const p in m) {
        if (!exports2.hasOwnProperty(p)) {
          exports2[p] = m[p];
        }
      }
    }
    Object.defineProperty(exports2, "__esModule", { value: true });
    __export2(require_internal3());
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/http-client/dist/http-client-types.js
var require_http_client_types = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/http-client/dist/http-client-types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isOriginOptions = isOriginOptions;
    exports2.isHttpRequestConfigWithOrigin = isHttpRequestConfigWithOrigin;
    function isOriginOptions(obj) {
      return !!obj && (typeof obj["requestConfig"] === "object" || typeof obj["custom"] === "object");
    }
    function isHttpRequestConfigWithOrigin(requestConfig) {
      return isOriginOptions(requestConfig.headers) || isOriginOptions(requestConfig.params);
    }
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/http-client/dist/http-request-config.js
var require_http_request_config = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/http-client/dist/http-request-config.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.origins = exports2.defaultDisallowedKeys = void 0;
    exports2.filterCustomRequestConfig = filterCustomRequestConfig;
    exports2.mergeOptionsWithPriority = mergeOptionsWithPriority;
    var util_1 = require_dist2();
    var logger8 = (0, util_1.createLogger)({
      package: "http-client",
      messageContext: "http-request-config"
    });
    function filterCustomRequestConfig(customRequestConfig, disallowedKeys = exports2.defaultDisallowedKeys) {
      const removedKeys = Object.keys(customRequestConfig).filter((key) => disallowedKeys.includes(key));
      if (removedKeys.length) {
        logger8.warn(`The following keys are found in the custom request config that will be removed: ${removedKeys.join(", ")}`);
      }
      return (0, util_1.exclude)(disallowedKeys, customRequestConfig);
    }
    exports2.defaultDisallowedKeys = [
      "url",
      "baseURL",
      "data",
      "headers",
      "params"
    ];
    function mergeOptionsWithPriority(headersOrParams) {
      if (headersOrParams) {
        return exports2.origins.reduce((mergedHeadersOrParams, origin) => (0, util_1.mergeIgnoreCase)(mergedHeadersOrParams, headersOrParams[origin]), {});
      }
    }
    exports2.origins = [
      "requestConfig",
      "destination",
      "destinationProperty",
      "custom"
    ];
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/http-client/dist/http-client.js
var require_http_client = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/http-client/dist/http-client.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encodeAllParameters = exports2.oDataTypedClientParameterEncoder = void 0;
    exports2.buildHttpRequest = buildHttpRequest;
    exports2.execute = execute;
    exports2.buildHttpRequestConfigWithOrigin = buildHttpRequestConfigWithOrigin;
    exports2.buildRequestWithMergedHeadersAndQueryParameters = buildRequestWithMergedHeadersAndQueryParameters;
    exports2.executeHttpRequest = executeHttpRequest2;
    exports2.executeHttpRequestWithOrigin = executeHttpRequestWithOrigin;
    exports2.getAxiosConfigWithDefaults = getAxiosConfigWithDefaults;
    exports2.getAxiosConfigWithDefaultsWithoutMethod = getAxiosConfigWithDefaultsWithoutMethod;
    exports2.getDefaultHttpRequestConfigOptions = getDefaultHttpRequestConfigOptions;
    exports2.getDefaultHttpRequestOptions = getDefaultHttpRequestOptions;
    var http = __importStar(require("http"));
    var https = __importStar(require("https"));
    var connectivity_1 = require_dist4();
    var internal_1 = require_internal4();
    var internal_2 = require_internal2();
    var util_1 = require_dist2();
    var axios_1 = __importDefault(require_axios());
    var http_client_types_1 = require_http_client_types();
    var http_request_config_1 = require_http_request_config();
    var csrf_token_middleware_1 = require_csrf_token_middleware();
    var logger8 = (0, util_1.createLogger)({
      package: "http-client",
      messageContext: "http-client"
    });
    async function buildHttpRequest(destination) {
      const resolvedDestination = await (0, internal_1.resolveDestination)(destination);
      (0, internal_1.assertHttpDestination)(resolvedDestination);
      const headers = await buildHeaders(resolvedDestination);
      return buildDestinationHttpRequestConfig(resolvedDestination, headers);
    }
    function execute(executeFn) {
      return async function(destination, requestConfig, options) {
        const resolvedDestination = await (0, internal_1.resolveDestination)(destination);
        (0, internal_1.assertHttpDestination)(resolvedDestination);
        const destinationRequestConfig = await buildHttpRequest(resolvedDestination);
        logCustomHeadersWarning(requestConfig.headers);
        const request = await buildRequestWithMergedHeadersAndQueryParameters(requestConfig, resolvedDestination, destinationRequestConfig, destination.jwt);
        if (options?.fetchCsrfToken) {
          requestConfig.middleware = [...requestConfig.middleware || [], (0, csrf_token_middleware_1.csrf)()];
        }
        return (0, internal_2.executeWithMiddleware)(requestConfig.middleware, {
          fnArgument: request,
          fn: (req) => {
            logRequestInformation(request);
            return executeFn(req);
          },
          context: {
            jwt: destination.jwt,
            uri: resolvedDestination.url,
            destinationName: resolvedDestination.name ?? void 0,
            tenantId: (0, connectivity_1.getTenantId)(destination.jwt)
          }
        });
      };
    }
    function buildHttpRequestConfigWithOrigin(requestConfig) {
      if (!requestConfig) {
        return getDefaultHttpRequestConfigOptions();
      }
      if ((0, http_client_types_1.isHttpRequestConfigWithOrigin)(requestConfig)) {
        return requestConfig;
      }
      return {
        ...requestConfig,
        headers: {
          requestConfig: {},
          ...requestConfig.headers && { custom: requestConfig.headers }
        },
        params: {
          requestConfig: {},
          ...requestConfig.params && { custom: requestConfig.params }
        }
      };
    }
    var oDataTypedClientParameterEncoder = (params) => params;
    exports2.oDataTypedClientParameterEncoder = oDataTypedClientParameterEncoder;
    function encodeQueryParameters(options) {
      const { parameterEncoder, parameters, exclude } = options;
      return Object.fromEntries(Object.entries(parameters).map(([key, value]) => exclude.includes(key) ? [key, value] : [key, value ? parameterEncoder(value) : value]));
    }
    function isOdataTypedClientParameterEncoder(parameterEncoder) {
      return parameterEncoder.name === exports2.oDataTypedClientParameterEncoder.name;
    }
    function getEncodedParameters(parameters, requestConfig) {
      const { parameterEncoder } = requestConfig;
      if ((0, util_1.isNullish)(parameterEncoder)) {
        return encodeQueryParameters({
          parameters,
          parameterEncoder: exports2.encodeAllParameters,
          exclude: ["custom"]
        });
      }
      if (isOdataTypedClientParameterEncoder(parameterEncoder)) {
        return encodeQueryParameters({
          parameters,
          parameterEncoder: exports2.encodeAllParameters,
          exclude: ["custom", "requestConfig"]
        });
      }
      return encodeQueryParameters({ parameters, parameterEncoder, exclude: [] });
    }
    async function buildRequestWithMergedHeadersAndQueryParameters(requestConfig, destination, destinationRequestConfig, jwt) {
      const { paramsOriginOptions, headersOriginOptions, requestConfigBase } = splitRequestConfig(requestConfig);
      const parameters = collectParametersFromAllOrigins(destination, paramsOriginOptions);
      const encodedParameters = getEncodedParameters(parameters, requestConfig);
      const mergedQueryParameter = (0, http_request_config_1.mergeOptionsWithPriority)(encodedParameters);
      const mergedHeaders = await getMergedHeaders(destination, destinationRequestConfig.headers, headersOriginOptions, jwt);
      const request = merge(destinationRequestConfig, requestConfigBase);
      request.headers = mergedHeaders || {};
      request.params = mergedQueryParameter || {};
      return request;
    }
    async function getMergedHeaders(destination, headersDestination, headersOriginOptions, jwt) {
      const queryParametersDestinationProperty = (0, internal_1.getAdditionalHeaders)(destination.originalProperties || {}).headers;
      headersDestination = destination.forwardAuthToken ? addForwardAuthTokenHeader(headersDestination, jwt) : headersDestination;
      return (0, http_request_config_1.mergeOptionsWithPriority)({
        requestConfig: headersOriginOptions?.requestConfig,
        custom: { ...headersOriginOptions?.custom },
        destinationProperty: queryParametersDestinationProperty,
        destination: headersDestination
      });
    }
    function addForwardAuthTokenHeader(headersDestination, jwt) {
      if (jwt) {
        return { ...headersDestination, authorization: `Bearer ${jwt}` };
      }
      logger8.debug("The `forwardAuthToken` is set, but the JWT is missing. Please provide a valid JWT to enable token forwarding.");
      return headersDestination;
    }
    function collectParametersFromAllOrigins(destination, paramsOriginOptions) {
      const queryParametersDestinationProperty = (0, internal_1.getAdditionalQueryParameters)(destination.originalProperties || {}).queryParameters;
      return {
        ...paramsOriginOptions,
        destinationProperty: queryParametersDestinationProperty,
        destination: destination.queryParameters
      };
    }
    function splitRequestConfig(requestConfig) {
      const paramsOriginOptions = requestConfig.params;
      const headersOriginOptions = requestConfig.headers;
      return {
        paramsOriginOptions,
        headersOriginOptions,
        requestConfigBase: requestConfig
      };
    }
    function logCustomHeadersWarning(headers) {
      if (!headers) {
        return;
      }
      const customHeaders = headers.custom;
      const requestConfigHeaders = headers.requestConfig;
      if (customHeaders && requestConfigHeaders) {
        const headerKeysToBeOverwritten = Object.keys(customHeaders).filter((customHeaderKey) => Object.keys(requestConfigHeaders).includes(customHeaderKey));
        if (headerKeysToBeOverwritten.length) {
          logger8.debug(`The following custom headers will overwrite headers created by the SDK, if they use the same key:
${headerKeysToBeOverwritten.map((key) => `  - "${key}"`).join("\n")}
If the parameters from multiple origins use the same key, the priority is 1. Custom, 2. Destination, 3. Internal.`);
        }
      }
    }
    function logRequestInformation(request) {
      const basicRequestInfo = `Execute '${request.method}' request with target: ${request.url}.`;
      if (request.headers) {
        const headerText = Object.entries((0, util_1.sanitizeRecord)(request.headers)).map(([key, value]) => `${key}:${value}`).join(util_1.unixEOL);
        logger8.debug(`${basicRequestInfo}${util_1.unixEOL}The headers of the request are:${util_1.unixEOL}${headerText}`);
      } else {
        logger8.debug(basicRequestInfo);
      }
    }
    function executeHttpRequest2(destination, requestConfig, options) {
      const requestConfigWithOrigin = buildHttpRequestConfigWithOrigin(requestConfig);
      return execute(executeWithAxios)(destination, requestConfigWithOrigin, {
        ...getDefaultHttpRequestOptions(),
        ...options
      });
    }
    function executeHttpRequestWithOrigin(destination, requestConfig, options) {
      const requestConfigWithDefaults = requestConfig ?? getDefaultHttpRequestConfigOptions();
      return execute(executeWithAxios)(destination, requestConfigWithDefaults, {
        ...getDefaultHttpRequestOptions(),
        ...options
      });
    }
    async function buildDestinationHttpRequestConfig(destination, headers) {
      return {
        baseURL: destination.url,
        headers,
        params: destination.queryParameters,
        proxy: (0, internal_1.getProxyConfig)(destination),
        ...await (0, connectivity_1.getAgentConfig)(destination)
      };
    }
    async function buildHeaders(destination) {
      try {
        return await (0, connectivity_1.buildHeadersForDestination)(destination);
      } catch (error) {
        throw new util_1.ErrorWithCause("Failed to build headers.", error);
      }
    }
    function merge(destinationRequestConfig, customRequestConfig) {
      return {
        ...destinationRequestConfig,
        ...customRequestConfig,
        headers: {
          ...destinationRequestConfig.headers,
          ...customRequestConfig.headers
        }
      };
    }
    function mergeRequestWithAxiosDefaults(request) {
      return { ...getAxiosConfigWithDefaults(), ...request };
    }
    function executeWithAxios(request) {
      return axios_1.default.request(mergeRequestWithAxiosDefaults(request));
    }
    function getAxiosConfigWithDefaults() {
      return {
        ...getAxiosConfigWithDefaultsWithoutMethod(),
        method: "get"
      };
    }
    function getAxiosConfigWithDefaultsWithoutMethod() {
      return {
        httpAgent: new http.Agent(),
        httpsAgent: new https.Agent(),
        timeout: 0,
        // zero means no timeout https://github.com/axios/axios/blob/main/README.md#request-config
        paramsSerializer: {
          serialize: (params = {}) => Object.entries(params).map(([key, value]) => `${key}=${value}`).join("&")
        }
      };
    }
    function getDefaultHttpRequestConfigOptions() {
      return {
        method: "get"
      };
    }
    function getDefaultHttpRequestOptions() {
      return {
        fetchCsrfToken: true
      };
    }
    var encodeAllParameters = function(parameter) {
      return Object.fromEntries(Object.entries(parameter).map(([key, value]) => [
        encodeURIComponent(key),
        encodeURIComponent(value)
      ]));
    };
    exports2.encodeAllParameters = encodeAllParameters;
  }
});

// node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/http-client/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/@sap-ai-sdk/core/node_modules/@sap-cloud-sdk/http-client/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultDisallowedKeys = exports2.executeHttpRequestWithOrigin = exports2.executeHttpRequest = exports2.encodeAllParameters = exports2.buildHttpRequest = exports2.csrf = void 0;
    var csrf_token_middleware_1 = require_csrf_token_middleware();
    Object.defineProperty(exports2, "csrf", { enumerable: true, get: function() {
      return csrf_token_middleware_1.csrf;
    } });
    var http_client_1 = require_http_client();
    Object.defineProperty(exports2, "buildHttpRequest", { enumerable: true, get: function() {
      return http_client_1.buildHttpRequest;
    } });
    Object.defineProperty(exports2, "encodeAllParameters", { enumerable: true, get: function() {
      return http_client_1.encodeAllParameters;
    } });
    Object.defineProperty(exports2, "executeHttpRequest", { enumerable: true, get: function() {
      return http_client_1.executeHttpRequest;
    } });
    Object.defineProperty(exports2, "executeHttpRequestWithOrigin", { enumerable: true, get: function() {
      return http_client_1.executeHttpRequestWithOrigin;
    } });
    var http_request_config_1 = require_http_request_config();
    Object.defineProperty(exports2, "defaultDisallowedKeys", { enumerable: true, get: function() {
      return http_request_config_1.defaultDisallowedKeys;
    } });
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/array.js
var require_array3 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/array.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.flatten = void 0;
    exports2.flat = flat;
    exports2.unique = unique;
    exports2.last = last;
    exports2.first = first;
    exports2.splitInChunks = splitInChunks;
    exports2.transformVariadicArgumentToArray = transformVariadicArgumentToArray;
    exports2.zip = zip;
    exports2.partition = partition2;
    exports2.filterDuplicates = filterDuplicates;
    exports2.filterDuplicatesRight = filterDuplicatesRight;
    function flat(arr2) {
      return arr2.reduce((flattened, subArr) => [...flattened, ...subArr], []);
    }
    function unique(arr2) {
      return Array.from(new Set(arr2));
    }
    function last(arr2) {
      return arr2.length ? arr2[arr2.length - 1] : void 0;
    }
    function first(arr2) {
      return arr2[0];
    }
    function splitInChunks(arr2, chunkSize) {
      const chunks = [];
      if (arr2) {
        for (let i = 0; i < arr2.length; i += chunkSize) {
          chunks.push(arr2.slice(i, i + chunkSize));
        }
      }
      return chunks;
    }
    function transformVariadicArgumentToArray(firstOrArray, rest) {
      if (Array.isArray(firstOrArray)) {
        return [...firstOrArray, ...rest];
      }
      return firstOrArray ? [firstOrArray, ...rest] : [...rest];
    }
    var flatten = (input) => {
      const flatResult = [];
      const stack = [...input];
      while (stack.length > 0) {
        const current = stack.pop();
        if (!Array.isArray(current)) {
          flatResult.push(current);
        } else {
          stack.push(...current);
        }
      }
      return flatResult.reverse();
    };
    exports2.flatten = flatten;
    function zip(left, right) {
      const longerArr = left.length > right.length ? left : right;
      return longerArr.reduce((zipped, _, i) => {
        const currentZipped = [];
        if (left.length > i) {
          currentZipped.push(left[i]);
        }
        if (right.length > i) {
          currentZipped.push(right[i]);
        }
        return [...zipped, ...currentZipped];
      }, []);
    }
    function partition2(arr2, condition) {
      return arr2.reduce(([conditionTrue, conditionFalse], item) => condition(item) ? [[...conditionTrue, item], conditionFalse] : [conditionTrue, [...conditionFalse, item]], [[], []]);
    }
    function filterDuplicates(arr2, comparator = (left, right) => left === right) {
      return arr2.filter((item, index) => !arr2.slice(0, index).find((filteredItem) => comparator(item, filteredItem)));
    }
    function filterDuplicatesRight(arr2, comparator = (left, right) => left === right) {
      return filterDuplicates(arr2.reverse(), comparator).reverse();
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/string-formatter.js
var require_string_formatter3 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/string-formatter.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.webEOL = exports2.unixEOL = void 0;
    exports2.upperCaseSnakeCase = upperCaseSnakeCase;
    exports2.camelCase = camelCase2;
    exports2.titleFormat = titleFormat;
    exports2.pascalCase = pascalCase;
    exports2.kebabCase = kebabCase;
    exports2.formatJson = formatJson;
    var voca_1 = __importDefault(require_voca());
    exports2.unixEOL = "\n";
    exports2.webEOL = "\r\n";
    function upperCaseSnakeCase(str) {
      return voca_1.default.upperCase(voca_1.default.snakeCase(str));
    }
    function camelCase2(str) {
      return voca_1.default.camelCase(str);
    }
    function titleFormat(str) {
      return voca_1.default.titleCase(voca_1.default.words(str).join(" "));
    }
    function pascalCase(str) {
      return voca_1.default.words(str).map((word) => voca_1.default.capitalize(word)).join("");
    }
    function kebabCase(str) {
      return voca_1.default.kebabCase(str);
    }
    function formatJson(json2) {
      return JSON.stringify(json2, null, 2) + exports2.unixEOL;
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/string.js
var require_string3 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/string.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encodeBase64 = encodeBase64;
    exports2.trimLeft = trimLeft;
    exports2.trimRight = trimRight;
    exports2.trim = trim;
    exports2.removeFileExtension = removeFileExtension;
    var string_formatter_1 = require_string_formatter3();
    function encodeBase64(str) {
      return Buffer.from(str).toString("base64");
    }
    function trimLeft(string) {
      const subStrings = string.split(string_formatter_1.unixEOL);
      const leftTrimmed = subStrings[0].trimStart();
      if (!leftTrimmed) {
        subStrings.shift();
      } else {
        subStrings[0] = leftTrimmed;
      }
      return subStrings.join(string_formatter_1.unixEOL);
    }
    function trimRight(string) {
      const subStrings = string.split(string_formatter_1.unixEOL);
      const rightTrimmed = subStrings[subStrings.length - 1].trimEnd();
      if (!rightTrimmed) {
        subStrings.pop();
      } else {
        subStrings[subStrings.length - 1] = rightTrimmed;
      }
      return subStrings.join(string_formatter_1.unixEOL);
    }
    function trim(string) {
      return trimRight(trimLeft(string));
    }
    function removeFileExtension(fileName) {
      return fileName.includes(".") ? fileName.split(".").slice(0, -1).join(".") : fileName;
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/code-block.js
var require_code_block3 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/code-block.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.codeBlock = codeBlock;
    var string_formatter_1 = require_string_formatter3();
    var array_1 = require_array3();
    var string_1 = require_string3();
    function codeBlock(strings, ...args) {
      const pre = strings.slice(0, -1).map((string) => {
        const trimmed = trimRightNewlines(string);
        return trimmed.length === string.length ? string : trimmed + string_formatter_1.unixEOL;
      });
      pre.push(strings[strings.length - 1]);
      const indents = strings.slice(0, -1).map((s) => {
        const indentation = s.split(string_formatter_1.unixEOL).pop();
        return !indentation.trim() ? indentation : "";
      });
      const post = args.map((arg, i) => ("" + arg).split(string_formatter_1.unixEOL).map((subArg) => indents[i] + subArg).join(string_formatter_1.unixEOL));
      const zipped = (0, array_1.zip)(pre, post);
      return (0, string_1.trim)(zipped.join(""));
    }
    function trimRightNewlines(string) {
      let subStrings = string.split(string_formatter_1.unixEOL);
      if (!subStrings[subStrings.length - 1].trim()) {
        subStrings = subStrings.slice(0, -1);
      }
      return subStrings.join(string_formatter_1.unixEOL);
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/logger/format/local.js
var require_local3 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/logger/format/local.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.local = void 0;
    exports2.getMessageOrStack = getMessageOrStack;
    var chalk_1 = __importDefault(require_source());
    var winston_1 = require_winston();
    var { combine, timestamp, cli, printf, errors } = winston_1.format;
    exports2.local = combine(errors({ stack: true }), timestamp(), (0, winston_1.format)(localTransformer)(), cli(), printf((info) => {
      const messageContext = info.custom_fields && typeof info.custom_fields === "object" && "messageContext" in info.custom_fields ? `${chalk_1.default.blue(`(${info.custom_fields.messageContext})`)}: ` : "";
      const message = typeof info.message === "string" ? info.message : "";
      const trimmedMessage = message.replace(/^\s*/, "");
      const paddingLength = message.length - trimmedMessage.length + messageContext.length;
      if (info.error) {
        info.level = chalk_1.default.inverse(info.level);
      }
      return `${chalk_1.default.gray(`[${info.timestamp}]`)} ${info.level} ${messageContext.padStart(paddingLength, " ")}${trimmedMessage}`;
    }));
    function getMessageOrStack(info) {
      const isString = (value) => typeof value === "string";
      const hasStackTrace = info.stack && info.level === "error";
      if (hasStackTrace && isString(info.stack)) {
        return info.stack;
      }
      if (isString(info.message)) {
        return info.message;
      }
      return "";
    }
    function localTransformer(info) {
      return {
        ...info,
        level: info.level.toUpperCase(),
        message: getMessageOrStack(info)
      };
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/logger/format/kibana.js
var require_kibana3 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/logger/format/kibana.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.kibana = void 0;
    var winston_1 = require_winston();
    var local_1 = require_local3();
    var { combine, timestamp, json: json2, errors } = winston_1.format;
    exports2.kibana = combine(errors({ stack: true }), timestamp(), (0, winston_1.format)(kibanaTransformer)(), json2());
    function kibanaTransformer(info) {
      return {
        ...info,
        msg: (0, local_1.getMessageOrStack)(info),
        written_ts: new Date(info.timestamp).getTime(),
        written_at: info.timestamp
      };
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/logger/format/index.js
var require_format4 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/logger/format/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_kibana3(), exports2);
    __exportStar(require_local3(), exports2);
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/logger/cloud-sdk-logger.js
var require_cloud_sdk_logger3 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/logger/cloud-sdk-logger.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.cloudSdkExceptionLogger = exports2.logFormat = void 0;
    exports2.muteLoggers = muteLoggers;
    exports2.unmuteLoggers = unmuteLoggers;
    exports2.disableExceptionLogger = disableExceptionLogger;
    exports2.enableExceptionLogger = enableExceptionLogger;
    exports2.createLogger = createLogger8;
    exports2.getLogger = getLogger;
    exports2.setLogLevel = setLogLevel;
    exports2.setGlobalLogLevel = setGlobalLogLevel;
    exports2.getGlobalLogLevel = getGlobalLogLevel;
    exports2.setGlobalTransports = setGlobalTransports;
    exports2.setLogFormat = setLogFormat;
    exports2.setGlobalLogFormat = setGlobalLogFormat;
    exports2.getGlobalLogFormat = getGlobalLogFormat;
    exports2.sanitizeRecord = sanitizeRecord;
    exports2.resetCustomLogLevels = resetCustomLogLevels;
    exports2.resetCustomLogFormats = resetCustomLogFormats;
    var winston_1 = require_winston();
    var format_1 = require_format4();
    var loggerReference = "sap-cloud-sdk-logger";
    var exceptionLoggerId = "sap-cloud-sdk-exception-logger";
    var container = new winston_1.Container();
    exports2.logFormat = {
      kibana: format_1.kibana,
      local: format_1.local
    };
    container.options.format = process.env.NODE_ENV === "production" ? exports2.logFormat.kibana : exports2.logFormat.local;
    var exceptionTransport = new winston_1.transports.Console();
    var customLogLevels = {};
    var customLogFormats = {};
    var DEFAULT_LOGGER__MESSAGE_CONTEXT = "__DEFAULT_LOGGER__MESSAGE_CONTEXT";
    var silent = false;
    var moduleLogger = createLogger8({
      package: "util",
      messageContext: "cloud-sdk-logger"
    });
    function toggleMuteLoggers(silence) {
      silent = silence;
      container.loggers.forEach((logger8) => toggleSilenceTransports(logger8, silence));
    }
    function toggleSilenceTransports(logger8, silence) {
      logger8.transports.forEach((transport) => transport.silent = silence);
    }
    function muteLoggers() {
      toggleMuteLoggers(true);
    }
    function unmuteLoggers() {
      toggleMuteLoggers(false);
    }
    exports2.cloudSdkExceptionLogger = container.get(exceptionLoggerId, {
      defaultMeta: { logger: loggerReference, test: "exception" },
      format: container.options.format,
      exceptionHandlers: [exceptionTransport]
    });
    function disableExceptionLogger() {
      exports2.cloudSdkExceptionLogger.exceptions.unhandle();
    }
    function enableExceptionLogger() {
      disableExceptionLogger();
      exports2.cloudSdkExceptionLogger.exceptions.handle(exceptionTransport);
    }
    function createLogger8(messageContext) {
      const customFields = typeof messageContext === "string" ? { messageContext } : { ...messageContext };
      const logger8 = container.get(customFields.messageContext, {
        level: process.env.SAP_CLOUD_SDK_LOG_LEVEL || customLogLevels[customFields.messageContext] || customFields.level || container.options.level || "info",
        defaultMeta: {
          ...Object.entries(customFields).length && {
            custom_fields: customFields
          },
          logger: customFields.logger || loggerReference
        },
        format: customLogFormats[customFields.messageContext] || customFields.format || container.options.format || exports2.logFormat.local,
        transports: [new winston_1.transports.Console()]
      });
      toggleSilenceTransports(logger8, silent);
      return logger8;
    }
    function getLogger(messageContext = DEFAULT_LOGGER__MESSAGE_CONTEXT) {
      if (container.has(messageContext)) {
        return container.get(messageContext);
      }
    }
    function setLogLevel(level, messageContextOrLogger = DEFAULT_LOGGER__MESSAGE_CONTEXT) {
      const messageContext = typeof messageContextOrLogger === "string" ? messageContextOrLogger : getMessageContext(messageContextOrLogger);
      if (messageContext) {
        customLogLevels[messageContext] = level;
        if (container.has(messageContext)) {
          const logger8 = container.get(messageContext);
          logger8.level = level;
        }
      } else if (typeof messageContextOrLogger !== "string") {
        moduleLogger.warn("Setting log level for logger with unknown message context");
        messageContextOrLogger.level = level;
      }
    }
    function setGlobalLogLevel(level) {
      container.options.level = level;
      container.loggers.forEach((logger8) => {
        logger8.level = level;
      });
    }
    function getGlobalLogLevel() {
      return container.options.level;
    }
    function setGlobalTransports(customTransports) {
      container.options.transports = customTransports;
      container.loggers.forEach((logger8) => {
        logger8.clear();
        return Array.isArray(customTransports) ? customTransports.forEach((transport) => logger8.add(transport)) : logger8.add(customTransports);
      });
    }
    function setLogFormat(format, messageContextOrLogger = DEFAULT_LOGGER__MESSAGE_CONTEXT) {
      const messageContext = typeof messageContextOrLogger === "string" ? messageContextOrLogger : getMessageContext(messageContextOrLogger);
      if (messageContext) {
        customLogFormats[messageContext] = format;
        if (container.has(messageContext)) {
          const logger8 = container.get(messageContext);
          logger8.format = format;
        }
      } else if (typeof messageContextOrLogger !== "string") {
        moduleLogger.warn("Setting log format for logger with unknown message context");
        messageContextOrLogger.format = format;
      }
    }
    function setGlobalLogFormat(format) {
      container.options.format = format;
      container.loggers.forEach((logger8) => {
        logger8.format = format;
      });
    }
    function getGlobalLogFormat() {
      return container.options.format;
    }
    var defaultSensitiveKeys = [
      "access_token",
      "authentication",
      "authorization",
      "apiKey",
      "credentials",
      "csrf",
      "xsrf",
      "secret",
      "password",
      "JTENANT",
      "JSESSION"
    ];
    function isSensitive(inputKey, value, sensitiveKeys) {
      const normalizedKeys = sensitiveKeys.map((key) => key.toLowerCase());
      const input = isCookieHeader(inputKey, value) ? value : inputKey;
      return normalizedKeys.some((normalizedKey) => input.toLowerCase().includes(normalizedKey));
    }
    function isCookieHeader(inputKey, value) {
      return inputKey.toLowerCase() === "cookie" && typeof value === "string";
    }
    function sanitizeRecord(input, replacementString = "<DATA NOT LOGGED TO PREVENT LEAKING SENSITIVE DATA>", sensitiveKeys = defaultSensitiveKeys) {
      return Object.fromEntries(Object.entries(input).map(([inputKey, value]) => isSensitive(inputKey, value, sensitiveKeys) ? [inputKey, replacementString] : [inputKey, value]));
    }
    function getMessageContext(logger8) {
      const loggerOptions = logger8;
      if (loggerOptions && loggerOptions.defaultMeta && loggerOptions.defaultMeta.custom_fields) {
        return loggerOptions.defaultMeta.custom_fields.messageContext;
      }
    }
    function resetCustomLogLevels() {
      Object.keys(customLogLevels).forEach((key) => delete customLogLevels[key]);
    }
    function resetCustomLogFormats() {
      Object.keys(customLogFormats).forEach((key) => delete customLogFormats[key]);
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/logger/index.js
var require_logger4 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/logger/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_cloud_sdk_logger3(), exports2);
    __exportStar(require_format4(), exports2);
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/documentation-block.js
var require_documentation_block3 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/documentation-block.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.documentationBlock = documentationBlock;
    var array_1 = require_array3();
    var logger_1 = require_logger4();
    var string_formatter_1 = require_string_formatter3();
    var logger8 = (0, logger_1.createLogger)("documentation-block");
    function documentationBlock(strings, ...args) {
      const firstLineTrimmed = removeLeadingEmptyLines(strings.raw[0]);
      const textIndentation = getIndentation(firstLineTrimmed);
      const argsWithIndentation = addIndentationToArguments(args, textIndentation);
      let content = (0, array_1.zip)([firstLineTrimmed, ...strings.raw.slice(1)], argsWithIndentation).join("");
      if (!content.match(/\w/)) {
        return "";
      }
      content = maskProblematicCharacters(content);
      let lines = content.split(string_formatter_1.unixEOL);
      lines = adjustIndentation(lines, textIndentation);
      content = lines.join(`${string_formatter_1.unixEOL} * `);
      const result = ["/**", ` * ${content}`, " */"].join(string_formatter_1.unixEOL);
      return result;
    }
    function removeLeadingEmptyLines(firstLine) {
      const lines = firstLine.split(string_formatter_1.unixEOL);
      const indexFirstNonEmpty = lines.findIndex((str) => str.match(/\w/)) || 0;
      return lines.splice(indexFirstNonEmpty).join(string_formatter_1.unixEOL);
    }
    function addIndentationToArguments(args, textIndentation) {
      const argsWithIndentation = args.map((arg) => arg.replace(/\n/g, string_formatter_1.unixEOL + " ".repeat(textIndentation)));
      return argsWithIndentation;
    }
    function adjustIndentation(lines, textIndentation) {
      return lines.map((str) => str.slice(textIndentation));
    }
    function getIndentation(firstLine) {
      const removeStarting = firstLine?.replace(/^\n*/g, "");
      const countEmptySpaces = removeStarting?.search(/\S/);
      return countEmptySpaces > 0 ? countEmptySpaces : 0;
    }
    function maskProblematicCharacters(str) {
      if (str.includes("*/")) {
        logger8.warn(`The documentation block ${str}'
      )} contained */ in the text will be masked as \\*\\/.`);
      }
      return str.replace(/\*\//g, "\\*\\/");
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/nullish.js
var require_nullish3 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/nullish.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isNullish = isNullish;
    function isNullish(val) {
      return val === null || val === void 0;
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/equal.js
var require_equal3 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/equal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.equalObjects = equalObjects;
    exports2.equal = equal;
    exports2.equalArrays = equalArrays;
    var nullish_1 = require_nullish3();
    function equalObjects(obj1, obj2) {
      const keys1 = Object.keys(obj1);
      return Object.keys(obj1).length === Object.keys(obj2).length && keys1.every((key) => equal(obj1[key], obj2[key]));
    }
    function equal(item1, item2) {
      if (Array.isArray(item1) && Array.isArray(item2)) {
        return equalArrays(item1, item2);
      }
      if (typeof item1 === "object" && typeof item2 === "object" && !(0, nullish_1.isNullish)(item1) && !(0, nullish_1.isNullish)(item2)) {
        return equalObjects(item1, item2);
      }
      return item1 === item2;
    }
    function equalArrays(arr1, arr2) {
      return arr1.length === arr2.length && arr1.every((item1, i) => equal(item1, arr2[i]));
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/error-with-cause.js
var require_error_with_cause3 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/error-with-cause.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ErrorWithCause = void 0;
    exports2.isErrorWithCause = isErrorWithCause;
    var string_formatter_1 = require_string_formatter3();
    var logger_1 = require_logger4();
    var logger8 = (0, logger_1.createLogger)({
      package: "util",
      messageContext: "error-with-cause"
    });
    var ErrorWithCause3 = class extends Error {
      /**
       * Create an instance of ErrorWithCause.
       * @param message - Error message.
       * @param cause - Original error, causing this error.
       */
      constructor(message, cause) {
        super(message);
        this.cause = cause;
        Object.setPrototypeOf(this, new.target.prototype);
        this.name = "ErrorWithCause";
        this.addStack(cause);
      }
      isAxiosError(err) {
        return err["isAxiosError"] === true;
      }
      addStack(cause) {
        if (this.isAxiosError(cause)) {
          let response = "";
          if (cause.response?.data) {
            try {
              response = `${string_formatter_1.unixEOL}${JSON.stringify(cause.response?.data, null, 2)}`;
            } catch (error) {
              logger8.warn(`Failed to stringify response data: ${error.message}`);
              response = `${string_formatter_1.unixEOL}${cause.response?.data}`;
            }
          }
          this.stack = `${this.stack}${string_formatter_1.unixEOL}Caused by:${string_formatter_1.unixEOL}HTTP Response: ${cause.message}${response}`;
        } else if (this.stack && cause?.stack) {
          this.stack = `${this.stack}${string_formatter_1.unixEOL}Caused by:${string_formatter_1.unixEOL}${cause.stack}`;
        }
      }
      /**
       * Root cause of the error.
       * If there are multiple errors caused one by another, the root cause is the first error that occurred.
       * In case there is no root cause.
       * @returns The root cause.
       */
      get rootCause() {
        return isErrorWithCause(this.cause) ? this.cause.rootCause : this.cause;
      }
    };
    exports2.ErrorWithCause = ErrorWithCause3;
    function isErrorWithCause(err) {
      return err?.name === "ErrorWithCause";
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/fs.js
var require_fs3 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.findProjectRoot = findProjectRoot;
    exports2.readJSON = readJSON;
    var fs_1 = require("fs");
    var path_1 = require("path");
    var logger_1 = require_logger4();
    var logger8 = (0, logger_1.createLogger)({
      package: "util",
      messageContext: "fs"
    });
    function findProjectRoot(path, lastPath = path) {
      if (!path) {
        return lastPath;
      }
      const inProject = (0, fs_1.readdirSync)(path).includes("package.json") || (0, fs_1.readdirSync)(path).includes("node_modules") || path.includes("node_modules");
      if (!inProject) {
        return lastPath;
      }
      return findProjectRoot((0, path_1.resolve)(path, ".."), path);
    }
    function readJSON(path) {
      if ((0, fs_1.existsSync)(path)) {
        return JSON.parse((0, fs_1.readFileSync)(path, "utf8"));
      }
      logger8.warn(`File "${path}" does not exist, return empty object.`);
      return {};
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/object.js
var require_object3 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/object.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.exclude = exports2.pick = exports2.renameKeys = void 0;
    exports2.propertyExists = propertyExists;
    exports2.toSanitizedObject = toSanitizedObject;
    exports2.pickIgnoreCase = pickIgnoreCase;
    exports2.pickValueIgnoreCase = pickValueIgnoreCase;
    exports2.pickNonNullish = pickNonNullish;
    exports2.mergeLeftIgnoreCase = mergeLeftIgnoreCase;
    exports2.mergeIgnoreCase = mergeIgnoreCase2;
    var nullish_1 = require_nullish3();
    function propertyExists(obj, ...properties) {
      if (!properties.length) {
        return true;
      }
      if (obj && obj.hasOwnProperty(properties[0])) {
        return propertyExists(obj[properties[0]], ...properties.slice(1));
      }
      return false;
    }
    var renameKeys = (keyMapping, obj) => {
      const unchangedEntries = Object.keys(obj).filter((k) => !Object.keys(keyMapping).includes(k)).reduce((newObj, key) => ({ ...newObj, [key]: obj[key] }), {});
      return Object.entries(keyMapping).reduce((newObj, [oldKey, newKey]) => ({ ...newObj, [newKey]: obj[oldKey] }), unchangedEntries);
    };
    exports2.renameKeys = renameKeys;
    var pick = (keys, obj) => {
      const result = {};
      keys.forEach((key) => {
        const value = obj[key];
        if (Object.keys(obj).includes(key)) {
          result[key] = value;
        }
      });
      return result;
    };
    exports2.pick = pick;
    var exclude = (keys, obj) => {
      const result = {};
      Object.keys(obj).forEach((key) => {
        const value = obj[key];
        if (!keys.includes(key)) {
          result[key] = value;
        }
      });
      return result;
    };
    exports2.exclude = exclude;
    function toSanitizedObject(key, value) {
      return (0, nullish_1.isNullish)(key) || (0, nullish_1.isNullish)(value) ? {} : { [key]: value };
    }
    function pickIgnoreCase(obj = {}, ...keys) {
      return keys.reduce((filteredHeaders, providedKey) => {
        const originalKey = Object.keys(obj).find((objKey) => objKey.toLowerCase() === providedKey.toLowerCase());
        return {
          ...filteredHeaders,
          ...originalKey && { [originalKey]: obj[originalKey] }
        };
      }, {});
    }
    function pickValueIgnoreCase(obj = {}, key) {
      return Object.values(pickIgnoreCase(obj, key))[0];
    }
    function pickNonNullish(obj = {}) {
      return Object.entries(obj).filter(([key, value]) => !(0, nullish_1.isNullish)(key) && !(0, nullish_1.isNullish)(value)).reduce((filtered, [key, value]) => ({ ...filtered, [key]: value }), {});
    }
    function mergeLeftIgnoreCase(left = {}, right = {}) {
      return Object.entries(left).map(([key, value]) => pickValueIgnoreCase(right, key) ? pickIgnoreCase(right, key) : { [key]: value }).reduce((replaced, obj) => ({ ...replaced, ...obj }), {});
    }
    function mergeIgnoreCase2(left = {}, right = {}) {
      return {
        ...mergeLeftIgnoreCase(left, right),
        ...right
      };
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/pipe.js
var require_pipe3 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/pipe.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.identity = identity;
    function identity(value) {
      return value;
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/promise.js
var require_promise3 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/promise.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.finishAll = finishAll;
    async function finishAll(promises, errorMessage) {
      const settledPromises = await Promise.allSettled(promises);
      const rejectedPromises = settledPromises.filter((promise) => promise.status === "rejected");
      if (rejectedPromises.length) {
        const reasons = rejectedPromises.map((promise) => `	${promise.reason}`).join("\n");
        const message = errorMessage ? `${errorMessage} ` : "";
        throw new Error(`${message}Errors: [
${reasons}
]`);
      }
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/remove-slashes.js
var require_remove_slashes3 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/remove-slashes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.removeSlashes = removeSlashes;
    exports2.removeTrailingSlashes = removeTrailingSlashes2;
    exports2.removeLeadingSlashes = removeLeadingSlashes2;
    function removeSlashes(path) {
      path = removeLeadingSlashes2(path);
      path = removeTrailingSlashes2(path);
      return path;
    }
    function removeTrailingSlashes2(path) {
      return path.endsWith("/") ? path.slice(0, -1) : path;
    }
    function removeLeadingSlashes2(path) {
      return path.startsWith("/") ? path.slice(1) : path;
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/types.js
var require_types3 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.caps = caps;
    function caps(oDataVersion) {
      return oDataVersion ? oDataVersion.toUpperCase() : "V2";
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/unique-name-generator.js
var require_unique_name_generator3 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/unique-name-generator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UniqueNameGenerator = void 0;
    var UniqueNameGenerator = class _UniqueNameGenerator {
      static getNameForComparison(name, caseSensitive) {
        return caseSensitive ? name : name.toLowerCase();
      }
      /**
       * Creates an instance of UniqueNameGenerator.
       * @param indexSeparator - The separator to be used when adding an index.
       * @param usedNames - Sets the already used names considered in the finding process.
       */
      constructor(indexSeparator = "_", usedNames = []) {
        this.indexSeparator = indexSeparator;
        this.usedNames = [];
        this.addToUsedNames(...usedNames);
      }
      /**
       * Adds the name(s) to the already used names.
       * @param names - Names to be added.
       */
      addToUsedNames(...names) {
        this.usedNames.push(...names);
      }
      /**
       * Generate a unique name by appending an index separated by the `indexSeparator` if necessary, e.g. if `MyName` is already taken `MyName_1` will be found by default.
       * If the name is already unique nothing is appended.
       * @param name - The name to get a unique name from.
       * @param caseSensitive - Whether to check the already used names in a case sensitive manner.
       * @returns A unique name.
       */
      generateUniqueName(name, caseSensitive = true) {
        return this.generateUniqueNamesWithSuffixes(name, [], caseSensitive)[0];
      }
      /**
       * Generate a unique name by appending an index separated by the `indexSeparator` if necessary, e.g. if `MyName` is already taken `MyName_1` will be found by default.
       * The generated name is added to the used names.
       * If the name is already unique nothing is appended.
       * @param name - The name to get a unique name from.
       * @param caseSensitive - Whether to check the already used names in a case sensitive manner.
       * @returns A unique name.
       */
      generateAndSaveUniqueName(name, caseSensitive = true) {
        const uniqueName = this.generateUniqueName(name, caseSensitive);
        this.addToUsedNames(uniqueName);
        return uniqueName;
      }
      /**
       * Generate unique names by appending an index separated by the `indexSeparator` if necessary, while respecting the given suffixes.
       * If the name is already unique nothing is appended.
       * Each given suffix is appended to the unique name in the result.
       * The resulting names are also checked for uniqueness.
       * All names in the result have the same number suffix.
       * @example if `MyName` and `MyName_1MySuffix` is already taken, `[MyName_2, MyName_2MySuffix]` will be generated by default.
       * @param name - The name to get a unique name from.
       * @param suffixes - Additional name of suffixes to be considered for the finding process, as well as the output.
       * @param caseSensitive - Whether to check the already used names in a case sensitive manner.
       * @returns A list of unique names. The length of this array is one plus the number of suffixes provided. The first entry corresponds to the given name.
       */
      generateUniqueNamesWithSuffixes(name, suffixes, caseSensitive = true) {
        const relevantUsedNames = this.getUsedNamesStartingWith(name, caseSensitive);
        const namesWithSuffixes = this.generateNamesWithSuffixes(name, suffixes);
        if (!this.areNamesUsed(namesWithSuffixes, relevantUsedNames, caseSensitive)) {
          return [name, ...namesWithSuffixes];
        }
        const index = this.getUniqueIndex(name, relevantUsedNames, suffixes, caseSensitive);
        return this.generateNamesWithIndexAndSuffixes(name, index, suffixes);
      }
      /**
       * Generate unique names by appending an index separated by the `indexSeparator` if necessary, while respecting the given suffixes.
       * If the name is already unique nothing is appended.
       * The generated names are added to the used names.
       * Each given suffix is appended to the unique name in the result.
       * The resulting names are also checked for uniqueness.
       * All names in the result have the same number suffix.
       * @example if `MyName` and `MyName_1MySuffix` is already taken, `[MyName_2, MyName_2MySuffix]` will be generated by default.
       * @param name - The name to get a unique name from.
       * @param suffixes - Additional name of suffixes to be considered for the finding process, as well as the output.
       * @param caseSensitive - Whether to check the already used names in a case sensitive manner.
       * @returns A list of unique names. The length of this array is one plus the number of suffixes provided. The first entry corresponds to the given name.
       */
      generateAndSaveUniqueNamesWithSuffixes(name, suffixes, caseSensitive = true) {
        const uniqueNames = this.generateUniqueNamesWithSuffixes(name, suffixes, caseSensitive);
        this.addToUsedNames(...uniqueNames);
        return uniqueNames;
      }
      getUsedNamesForComparison(caseSensitive) {
        return this.usedNames.map((name) => _UniqueNameGenerator.getNameForComparison(name, caseSensitive));
      }
      areNamesUsed(names, usedNames, caseSensitive) {
        return names.some((name) => usedNames.map((usedName) => _UniqueNameGenerator.getNameForComparison(usedName, caseSensitive)).includes(_UniqueNameGenerator.getNameForComparison(name, caseSensitive)));
      }
      generateNamesWithIndexAndSuffixes(name, index, suffixes) {
        const nameWithoutIndex = this.getNameWithoutIndex(name);
        return this.generateNamesWithSuffixes(`${nameWithoutIndex}${this.indexSeparator}${index}`, suffixes);
      }
      generateNamesWithSuffixes(name, suffixes) {
        return [name, ...suffixes.map((nameSuffix) => `${name}${nameSuffix}`)];
      }
      getUsedNamesStartingWith(name, caseSensitive) {
        const modifiedName = this.getNameWithoutIndex(name);
        return this.getUsedNamesForComparison(caseSensitive).filter((used) => used.startsWith(_UniqueNameGenerator.getNameForComparison(modifiedName, caseSensitive)));
      }
      getUniqueIndex(name, usedNames, suffixes, caseSensitive) {
        let index = 1;
        while (index < _UniqueNameGenerator.MAXIMUM_NUMBER_OF_SUFFIX) {
          const newNames = this.generateNamesWithIndexAndSuffixes(name, index, suffixes);
          if (!this.areNamesUsed(newNames, usedNames, caseSensitive)) {
            return index;
          }
          index++;
        }
        throw new Error(`Unable to find a unique name for ${name} within the range of ${_UniqueNameGenerator.MAXIMUM_NUMBER_OF_SUFFIX} suffixes.`);
      }
      getNameWithoutIndex(name) {
        return name.replace(new RegExp(`${this.indexSeparator}\\d+$`), "");
      }
    };
    exports2.UniqueNameGenerator = UniqueNameGenerator;
    UniqueNameGenerator.MAXIMUM_NUMBER_OF_SUFFIX = 1e3;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/url.js
var require_url3 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/url.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkUrlExists = checkUrlExists;
    var axios_1 = __importDefault(require_axios());
    async function checkUrlExists(url) {
      return axios_1.default.request({ url, method: "HEAD" }).then((response) => response.status);
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/index.js
var require_dist6 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/util/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_array3(), exports2);
    __exportStar(require_code_block3(), exports2);
    __exportStar(require_documentation_block3(), exports2);
    __exportStar(require_equal3(), exports2);
    __exportStar(require_error_with_cause3(), exports2);
    __exportStar(require_fs3(), exports2);
    __exportStar(require_logger4(), exports2);
    __exportStar(require_nullish3(), exports2);
    __exportStar(require_object3(), exports2);
    __exportStar(require_pipe3(), exports2);
    __exportStar(require_promise3(), exports2);
    __exportStar(require_remove_slashes3(), exports2);
    __exportStar(require_string3(), exports2);
    __exportStar(require_string_formatter3(), exports2);
    __exportStar(require_types3(), exports2);
    __exportStar(require_unique_name_generator3(), exports2);
    __exportStar(require_url3(), exports2);
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/cache.js
var require_cache3 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/cache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Cache = void 0;
    var Cache2 = class {
      /**
       * Creates an instance of Cache.
       * @param defaultValidityTime - The default validity time in milliseconds. Use 0 for unlimited cache duration.
       */
      constructor(defaultValidityTime) {
        this.defaultValidityTime = defaultValidityTime;
        this.cache = {};
      }
      /**
       * Clear all cached items.
       */
      clear() {
        this.cache = {};
      }
      /**
       * Specifies whether an entry with a given key is defined in cache.
       * @param key - The entry's key.
       * @returns A boolean value that indicates whether the entry exists in cache.
       */
      hasKey(key) {
        return this.cache.hasOwnProperty(key);
      }
      /**
       * Getter of cached entries.
       * @param key - The key of the entry to retrieve.
       * @returns The corresponding entry to the provided key if it is still valid, returns `undefined` otherwise.
       */
      get(key) {
        return key && this.hasKey(key) && !isExpired(this.cache[key]) ? this.cache[key].entry : void 0;
      }
      /**
       * Setter of entries in cache.
       * @param key - The entry's key.
       * @param item - The entry to cache.
       */
      set(key, item) {
        if (key) {
          const expires = item.expires ?? this.inferDefaultExpirationTime();
          this.cache[key] = { entry: item.entry, expires };
        }
      }
      inferDefaultExpirationTime() {
        const now = /* @__PURE__ */ new Date();
        return this.defaultValidityTime ? now.setMilliseconds(now.getMilliseconds() + this.defaultValidityTime).valueOf() : void 0;
      }
    };
    exports2.Cache = Cache2;
    function isExpired(item) {
      if (item.expires === void 0) {
        return false;
      }
      return item.expires < Date.now();
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/subdomain-replacer.js
var require_subdomain_replacer2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/subdomain-replacer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getIssuerSubdomain = getIssuerSubdomain;
    var url_1 = require("url");
    function getIssuerSubdomain(decodedJwt) {
      const iss = decodedJwt?.iss;
      if (iss) {
        if (!isValidUrl(iss)) {
          throw new Error(`Issuer URL in JWT is not a valid URL: "${iss}".`);
        }
        return getHost(new url_1.URL(iss)).split(".")[0];
      }
    }
    function getHost(url) {
      const { host } = url;
      if (!host || host.indexOf(".") === -1) {
        throw new Error(`Failed to determine sub-domain: invalid host in "${url}".`);
      }
      return host;
    }
    function isValidUrl(url) {
      try {
        new url_1.URL(url);
        return true;
      } catch {
        return false;
      }
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/jwt/jwt.js
var require_jwt3 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/jwt/jwt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.verificationKeyCache = exports2.defaultTenantId = void 0;
    exports2.userId = userId;
    exports2.getDefaultTenantId = getDefaultTenantId;
    exports2.getTenantId = getTenantId;
    exports2.getSubdomain = getSubdomain;
    exports2.audiences = audiences;
    exports2.decodeJwt = decodeJwt;
    exports2.decodeJwtComplete = decodeJwtComplete;
    exports2.retrieveJwt = retrieveJwt;
    exports2.wrapJwtInHeader = wrapJwtInHeader;
    exports2.isXsuaaToken = isXsuaaToken;
    exports2.getJwtPair = getJwtPair;
    exports2.isUserToken = isUserToken;
    var util_1 = require_dist6();
    var jsonwebtoken_1 = require_jsonwebtoken();
    var cache_1 = require_cache3();
    var subdomain_replacer_1 = require_subdomain_replacer2();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "jwt"
    });
    exports2.defaultTenantId = "provider-tenant";
    function makeArray(val) {
      return val ? Array.isArray(val) ? val : [val] : [];
    }
    function userId({ user_id }) {
      logger8.debug(`JWT user_id is: ${user_id}.`);
      return user_id;
    }
    function getDefaultTenantId() {
      logger8.debug("Could not determine tenant from JWT nor XSUAA, identity or destination service binding. Client Credentials token is cached without tenant information.");
      return exports2.defaultTenantId;
    }
    function getTenantId(jwt) {
      const decodedJwt = jwt ? decodeJwt(jwt) : {};
      logger8.debug(`JWT zid is: ${decodedJwt.zid}, app_tid is: ${decodedJwt.app_tid}.`);
      return decodedJwt.zid || decodedJwt.app_tid || void 0;
    }
    function isNotIasToken(decodedJwt) {
      return !decodedJwt.iss?.includes("accounts.ondemand.com") && !decodedJwt.iss?.includes("accounts400.ondemand.com");
    }
    function getSubdomain(jwt) {
      const decodedJwt = jwt ? decodeJwt(jwt) : {};
      return decodedJwt?.ext_attr?.zdn || (isNotIasToken(decodedJwt) ? (0, subdomain_replacer_1.getIssuerSubdomain)(decodedJwt) : void 0);
    }
    function audiences(decodedToken) {
      const parsedAudiences = audiencesFromAud(decodedToken);
      return parsedAudiences.length ? parsedAudiences : audiencesFromScope(decodedToken);
    }
    function audiencesFromAud({ aud }) {
      return makeArray(aud).map((audience) => audience.split(".")[0]);
    }
    function audiencesFromScope({ scope }) {
      return makeArray(scope).reduce((aud, s) => s.includes(".") ? [...aud, s.split(".")[0]] : aud, []);
    }
    function decodeJwt(token) {
      return typeof token === "string" ? decodeJwtComplete(token).payload : token;
    }
    function decodeJwtComplete(token) {
      const decodedToken = (0, jsonwebtoken_1.decode)(token, { complete: true, json: true });
      if (decodedToken !== null && isJwtWithPayloadObject(decodedToken)) {
        return decodedToken;
      }
      throw new Error("JwtError: The given jwt payload does not encode valid JSON.");
    }
    function retrieveJwt(req) {
      const authHeader = getAuthHeader(req);
      if (validateAuthHeader(authHeader)) {
        return authHeader?.split(" ")[1];
      }
    }
    function getAuthHeader(req) {
      const authHeader = (0, util_1.pickValueIgnoreCase)(req.headers, "authorization");
      if (authHeader) {
        return Array.isArray(authHeader) ? authHeader[0] : authHeader;
      }
    }
    function validateAuthHeader(header) {
      if (typeof header === "undefined") {
        logger8.warn("Authorization header not set.");
        return false;
      }
      const [authType, token] = header.split(" ");
      if (typeof token === "undefined") {
        logger8.warn("Token in auth header missing.");
        return false;
      }
      if (authType.toLowerCase() !== "bearer") {
        logger8.warn("Authorization type is not Bearer.");
        return false;
      }
      return true;
    }
    exports2.verificationKeyCache = new cache_1.Cache(9e5);
    function wrapJwtInHeader(token) {
      return { headers: { Authorization: "Bearer " + token } };
    }
    function isXsuaaToken(decodedJwt) {
      return decodedJwt?.ext_attr?.enhancer === "XSUAA";
    }
    function getJwtPair(encodedJwt) {
      return { encoded: encodedJwt, decoded: decodeJwt(encodedJwt) };
    }
    function isUserToken(token) {
      if (!token) {
        return false;
      }
      const keys = Object.keys(token.decoded);
      return !(keys.length === 1 && keys[0] === "iss");
    }
    function isJwtWithPayloadObject(decoded) {
      return typeof decoded.payload !== "string";
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/environment-accessor/service-bindings.js
var require_service_bindings2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/environment-accessor/service-bindings.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getServiceBindings = getServiceBindings;
    exports2.getServiceBinding = getServiceBinding2;
    exports2.resolveServiceBinding = resolveServiceBinding;
    exports2.getServiceBindingByInstanceName = getServiceBindingByInstanceName;
    var util_1 = require_dist6();
    var xsenv = __importStar(require_xsenv());
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "environment-accessor"
    });
    function getServiceBindings(service) {
      return xsenv.filterServices({ label: service });
    }
    function getServiceBinding2(service) {
      const services = xsenv.filterServices({ label: service });
      if (!services.length) {
        logger8.warn(`Could not find service binding of type '${service}'. This might cause errors in other parts of the application.`);
      } else if (services.length > 1) {
        logger8.warn(`Found more than one service binding for service type '${service}':${services.map(({ name }) => `
	- ${name}`).join("")}
Selecting the first one.`);
      }
      return services[0];
    }
    function resolveServiceBinding(service) {
      if (typeof service === "string") {
        const serviceInstance = getServiceBinding2(service);
        if (!serviceInstance) {
          throw Error(`Could not find service binding of type '${service}'.`);
        }
        return serviceInstance;
      }
      return service;
    }
    function getServiceBindingByInstanceName(serviceInstanceName) {
      const service = xsenv.filterServices(serviceInstanceName);
      if (!service.length) {
        throw Error(`Could not find service with name: '${serviceInstanceName}'.`);
      }
      if (service.length > 1) {
        throw Error(`Found multiple services with name: '${serviceInstanceName}'.`);
      }
      return service[0];
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/environment-accessor/service-credentials.js
var require_service_credentials2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/environment-accessor/service-credentials.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getServiceCredentials = getServiceCredentials;
    var util_1 = require_dist6();
    var jwt_1 = require_jwt3();
    var service_bindings_1 = require_service_bindings2();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "environment-accessor"
    });
    function getServiceCredentials(service, token) {
      const credentialsList = getServiceBindingsWithCredentials(service);
      if (!credentialsList.length) {
        logger8.debug(`Could not find binding to service '${service}', that includes credentials.`);
        return;
      }
      if (token) {
        const credentials = getCredentialsWithJwt(service, credentialsList, typeof token === "string" ? (0, jwt_1.decodeJwt)(token) : token);
        return credentials;
      }
      logger8.debug(`No JWT given to select binding to service '${service}'.`);
      return getCredentialsWithoutJwt(service, credentialsList);
    }
    function getServiceBindingsWithCredentials(service) {
      const services = (0, service_bindings_1.getServiceBindings)(service);
      const serviceCredentials = services.map(({ credentials }) => credentials).filter((credentials) => credentials);
      if (serviceCredentials.length < services.length) {
        const difference = services.length - serviceCredentials.length;
        logger8.warn(`Ignoring ${difference} service binding${difference > 1 ? "s" : ""} of service type '${service}' because of missing credentials.`);
      }
      return serviceCredentials;
    }
    function getCredentialsWithJwt(service, credentials, token) {
      const eligibleCredentials = credentials.filter((c) => matchesClientId(c, token) || matchesAudience(c, token));
      logResult(service, eligibleCredentials, true);
      return eligibleCredentials[0];
    }
    function getCredentialsWithoutJwt(service, credentials) {
      logResult(service, credentials, false);
      return credentials[0];
    }
    function logResult(service, credentials, usedToken) {
      if (credentials.length === 1) {
        logger8.debug(`Found one service binding for service '${service}'${usingJwtText(usedToken)}. ${appNames(credentials)}`);
      } else if (credentials.length > 1) {
        logger8.warn(`Found multiple bindings for service '${service}'${usingJwtText(usedToken)}. ${appNames(credentials)}
Choosing first one ('${credentials[0].xsappname}').`);
      } else if (usedToken) {
        logger8.warn(`Found no service binding for service '${service}' matching either the token's client id or audience.`);
      }
    }
    function usingJwtText(usedToken) {
      return usedToken ? " using JWT" : "";
    }
    function appNames(credentials) {
      const names = credentials.map(({ xsappname }) => xsappname);
      if (names.length) {
        return names.length === 1 ? `App name: ${names[0]}.` : `App names:${names.map((name) => `
	- ${name}`).join("")}`;
      }
      return "";
    }
    function matchesClientId(credentials, token) {
      return credentials.clientid === token.client_id;
    }
    function matchesAudience(credentials, token) {
      return (0, jwt_1.audiences)(token).includes(credentials.xsappname);
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/environment-accessor/destination.js
var require_destination4 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/environment-accessor/destination.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getDestinationServiceCredentials = getDestinationServiceCredentials;
    var service_credentials_1 = require_service_credentials2();
    function getDestinationServiceCredentials() {
      const credentials = (0, service_credentials_1.getServiceCredentials)("destination");
      if (!credentials) {
        throw new Error("Could not find binding to the destination service.");
      }
      return credentials;
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/environment-accessor/environment-accessor-types.js
var require_environment_accessor_types2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/environment-accessor/environment-accessor-types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/XssecError.js
var require_XssecError2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/XssecError.js"(exports2, module2) {
    var XssecError = class extends Error {
      /** 
       * @type {number} Suggested HTTP response code for consumer application catching this error
       */
      #statusCode;
      constructor(message) {
        super(message);
        this.name = "XssecError";
        this.statusCode = 500;
      }
      get statusCode() {
        return this.#statusCode;
      }
      /** 
       * @type {number} Lowercased version of {@link #statusCode} for backward-compatibility
       */
      get statuscode() {
        return this.#statusCode;
      }
      /** 
       * Allows overriding suggested response status code in subclasses, e.g. 403 in ValidationError 
       * @internal
       * @param {number} statusCode - Suggested HTTP response code for consumer application catching this error
       */
      set statusCode(statusCode) {
        this.#statusCode = statusCode;
      }
    };
    module2.exports = XssecError;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/validation/ValidationError.js
var require_ValidationError2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/validation/ValidationError.js"(exports2, module2) {
    var XssecError = require_XssecError2();
    var ValidationError = class extends XssecError {
      constructor(message) {
        super(message);
        this.name = "ValidationError";
        this.statusCode = 401;
      }
    };
    module2.exports = ValidationError;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/validation/InvalidJwtError.js
var require_InvalidJwtError2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/validation/InvalidJwtError.js"(exports2, module2) {
    var ValidationError = require_ValidationError2();
    var InvalidJwtError = class extends ValidationError {
      /** @type {Error} Error encountered during parsing */
      #parseError;
      constructor(jwt, parseError, message = `JWT could not be parsed: ${parseError.message}`) {
        super(jwt, message);
        this.name = "InvalidJwtError";
        this.jwt = jwt;
        this.#parseError = parseError;
      }
      get parseError() {
        return this.#parseError;
      }
      set parseError(value) {
        this.#parseError = value;
      }
    };
    module2.exports = InvalidJwtError;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/util/constants.js
var require_constants3 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/util/constants.js"(exports2, module2) {
    module2.exports = {
      APP_TID_HEADER: "x-app_tid",
      AZP_HEADER: "x-azp",
      CLIENT_CERTIFICATE_HEADER: "x-client_cert",
      CLIENTID_HEADER: "x-client_id",
      CORRELATIONID_HEADER_VCAP: "x-vcap-request-id",
      CORRELATIONID_HEADERS: [
        "x-correlation-id",
        "x-request-id",
        "x-correlationid",
        "x-vcap-request-id"
      ],
      DEFAULT_TIMEOUT: 2e3,
      DEFAULT_JWT_BEARER_FETCH_TIMEOUT: 1e4,
      FORWARDED_CLIENTCERTIFICATE_HEADER: "x-forwarded-client-cert",
      MAX_TIMEOUT: 1e4,
      GRANTTYPE_SAML2BEARER: "urn:ietf:params:oauth:grant-type:saml2-bearer",
      GRANTTYPE_JWTBEARER: "urn:ietf:params:oauth:grant-type:jwt-bearer",
      GRANTTYPE_USERTOKEN: "user_token",
      GRANTTYPE_REFRESHTOKEN: "refresh_token",
      GRANTTYPE_PASSWORD: "password",
      GRANTTYPE_CLIENTCREDENTIALS: "client_credentials",
      GRANTTYPE_AUTHORIZATIONCODE: "authorization_code",
      GRANTTYPE_IMPLICIT: "implicit",
      HTTP_SCHEME: "http://",
      HTTPS_SCHEME: "https://",
      PEM_HEADER: "-----BEGIN CERTIFICATE-----",
      PEM_FOOTER: "-----END CERTIFICATE-----",
      USER_AGENT: "nodejs-xssec-4",
      SERVICE_PLAN_HEADER: "x-osb_plan",
      TOKEN_DATE_LEEWAY: 60,
      // seconds around nbf / exp time in which token is still considered valid
      X5T_CNF_CLAIM: "x5t#S256",
      ZID_HEADER: "x-zid",
      ZID_QUERY_PARAMETER: "zid"
    };
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/cache/LRUCache.js
var require_LRUCache2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/cache/LRUCache.js"(exports2, module2) {
    var LRUCache = class {
      /**
       * Creates an instance of LRUCache.
       * @param {number} size - The maximum number of items the cache can hold.
       */
      constructor(size) {
        this.size = size;
        this.map = /* @__PURE__ */ new Map();
      }
      /**
       * Retrieve a value from the cache.
       * @param {string} key - The key of the item to retrieve.
       * @returns {*} The value associated with the key, or null if the key does not exist.
       */
      get(key) {
        if (!this.map.has(key)) return null;
        const value = this.map.get(key);
        this.map.delete(key);
        this.map.set(key, value);
        return value;
      }
      /**
       * Insert or update a value in the cache.
       * @param {string} key - The key of the item to insert or update.
       * @param {*} value - The value to associate with the key.
       */
      set(key, value) {
        if (this.map.has(key)) {
          this.map.delete(key);
        } else if (this.map.size >= this.size) {
          const oldestKey = this.map.keys().next().value;
          this.map.delete(oldestKey);
        }
        this.map.set(key, value);
      }
    };
    module2.exports = LRUCache;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/token/Token.js
var require_Token2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/token/Token.js"(exports2, module2) {
    var { jwtDecode } = require_cjs();
    var InvalidJwtError = require_InvalidJwtError2();
    var { TOKEN_DATE_LEEWAY } = require_constants3();
    var LRUCache = require_LRUCache2();
    var Token = class _Token {
      /**
       * A shared jwt->{header, payload} cache that is used to avoid decoding the same token multiple times.
       * @type {import("../util/Types").Cache}
       */
      static decodeCache = null;
      /**
       * Enables the shared decode cache for tokens.
       * @param {DecodeCacheConfig} [config] - Optional configuration for the decode cache.
       */
      static enableDecodeCache(config = {}) {
        if (config.impl) {
          _Token.decodeCache = config.impl;
        } else {
          _Token.decodeCache = new LRUCache(config?.size || 100);
        }
      }
      /**
       * Disables the shared decode cache for tokens.
       */
      static disableDecodeCache() {
        _Token.decodeCache = null;
      }
      #jwt;
      /** @type {JwtHeader} */
      #header;
      // parsed header
      /** @type {JwtPayload} */
      #payload;
      // parsed payload
      /**
       * @param {string|null} jwt 
       * @param {object} [content] - optional decoded content
       * @param {JwtHeader & { [key: string]: any }} [content.header] - Optional parsed header (used instead of decoding jwt parameter if both header/payload are provided)
       * @param {JwtPayload & { [key: string]: any }} [content.payload] - Optional parsed payload (used instead of decoding jwt parameter if both header/payload are provided)
       */
      constructor(jwt, { header, payload } = {}) {
        this.#jwt = jwt;
        if (!header || !payload) {
          const cached = _Token.decodeCache?.get(jwt);
          if (cached != null) {
            header = cached.header;
            payload = cached.payload;
          } else {
            ({ header, payload } = this.#parseJwt(jwt));
            _Token.decodeCache?.set(jwt, { header, payload });
          }
        }
        this.#header = header;
        this.#payload = payload;
      }
      #parseJwt(jwt) {
        try {
          return {
            header: jwtDecode(jwt, { header: true }),
            payload: jwtDecode(jwt)
          };
        } catch (e) {
          throw new InvalidJwtError(jwt, e);
        }
      }
      get audiences() {
        if (this.payload.aud) {
          return Array.isArray(this.payload.aud) ? this.payload.aud : [this.payload.aud];
        } else {
          return null;
        }
      }
      get azp() {
        return this.payload.azp;
      }
      /**
       * @returns {string|null} clientId used to fetch the token
       */
      get clientId() {
        if (this.azp) {
          return this.azp;
        }
        if (this.audiences == null || this.audiences.length != 1) {
          return null;
        }
        return this.audiences[0] || this.payload.cid;
      }
      get email() {
        return this.payload.email;
      }
      /**
       * Returns whether the token is expired based on claim exp (expiration time).
       * There is a 1min leeway after the exp in which the token still counts as valid to account for clock skew.
       * @return {Boolean} false if token has a positive {@link remainingTime}, true otherwise
       */
      get expired() {
        return this.remainingTime <= 0;
      }
      get expirationDate() {
        return this.payload.exp ? new Date(this.payload.exp * 1e3) : null;
      }
      /**
       * @returns {string|null} family name of the user
       */
      get familyName() {
        return this.payload.ext_attr?.family_name || this.payload.family_name;
      }
      /**
       * @returns {string|null} first name of the user
       */
      get givenName() {
        return this.payload.ext_attr?.given_name || this.payload.given_name;
      }
      get grantType() {
        return this.payload.grant_type;
      }
      /** @return {JwtHeader} Token header as parsed object */
      get header() {
        return this.#header;
      }
      get issuer() {
        return this.payload.iss;
      }
      get issueDate() {
        return this.payload.iat ? new Date(this.payload.iat * 1e3) : null;
      }
      /** @return {String} JWT used to construct this Token instance as raw String */
      get jwt() {
        return this.#jwt;
      }
      /**
       * Returns whether the token is not yet valid based on the optional nbf (no use before) claim.
       * There is a 1min leeway before the nbf in which the token already counts as valid to account for clock skew.
       * @return {Boolean} true if token has nbf and nbf date lies in future, false otherwise 
       */
      get notYetValid() {
        return this.payload.nbf != null && Math.floor(Date.now() / 1e3) + TOKEN_DATE_LEEWAY < this.payload.nbf;
      }
      get origin() {
        return this.payload.origin;
      }
      /** @return {JwtPayload} Token payload as parsed object */
      get payload() {
        return this.#payload;
      }
      /**
       * Returns the remaining time until expiration in seconds based on claim exp (expiration time).
       * There is a 1min leeway after the exp in which the token still counts as valid to account for clock skew.
       * @returns seconds until expiration or 0 if expired
       */
      get remainingTime() {
        return Math.max(0, this.payload.exp + TOKEN_DATE_LEEWAY - Math.floor(Date.now() / 1e3));
      }
      get subject() {
        return this.payload.sub;
      }
      get userName() {
        return this.payload.user_name;
      }
      get userId() {
        return this.payload.user_uuid;
      }
      // Methods for backward-compatibility   
      getAudiencesArray() {
        return this.audiences;
      }
      getAzp() {
        return this.azp;
      }
      getClientId() {
        return this.clientId;
      }
      getEmail() {
        return this.email;
      }
      getExpirationDate() {
        return this.expirationDate;
      }
      getFamilyName() {
        return this.familyName;
      }
      getGivenName() {
        return this.givenName;
      }
      getGrantType() {
        return this.grantType;
      }
      getHeader() {
        return this.header;
      }
      getIssuedAt() {
        return this.issueDate;
      }
      getIssuer() {
        if (this.issuer && !this.issuer.startsWith("http")) {
          return `https://${this.issuer}`;
        } else {
          return this.issuer;
        }
      }
      getPayload() {
        return this.payload;
      }
      getSubject() {
        return this.subject;
      }
      getTokenValue() {
        return this.jwt;
      }
      getUserId() {
        return this.userId;
      }
    };
    module2.exports = Token;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/validation/MissingJwtError.js
var require_MissingJwtError2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/validation/MissingJwtError.js"(exports2, module2) {
    var ValidationError = require_ValidationError2();
    var MissingJwtError = class extends ValidationError {
      constructor(message = "Request contains no jwt bearer token and neither a jwt nor a decoded Token were contained in contextConfig of createSecurityContext.") {
        super(message);
        this.name = "MissingJwtError";
      }
    };
    module2.exports = MissingJwtError;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/context/SecurityContext.js
var require_SecurityContext2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/context/SecurityContext.js"(exports2, module2) {
    var { CORRELATIONID_HEADERS, FORWARDED_CLIENTCERTIFICATE_HEADER } = require_constants3();
    var SecurityContext = class {
      /** @type {S} */
      #service;
      /** @type {T} */
      #token;
      /** @type {SecurityContextConfig} */
      config;
      /**
       * @param {S} service - The service instance.
       * @param {T} token - The token instance.
       * @param {SecurityContextConfig} contextConfig - The security context configuration.
       */
      constructor(service, token, contextConfig) {
        this.#service = service;
        this.#token = token;
        this.config = contextConfig;
      }
      /**
       * The Service instance on which this SecurityContext has been created.
       * @returns {S} service
       */
      get service() {
        return this.#service;
      }
      /**
       * @param {S} service
       */
      set service(service) {
        this.#service = service;
      }
      /**
       * The Token instance from which this SecurityContext has ben created.
       * @returns {T} token
       */
      get token() {
        return this.#token;
      }
      /**
       * @param {T} token
       */
      set token(token) {
        this.#token = token;
      }
      // Methods for backwards-compatibility   
      getAppToken() {
        return this.token.jwt;
      }
      getEmail() {
        return this.getUserInfo().email;
      }
      getExpirationDate() {
        return this.token.expirationDate;
      }
      getFamilyName() {
        return this.getUserInfo().familyName;
      }
      getGivenName() {
        return this.getUserInfo().givenName;
      }
      getGrantType() {
        return this.token.grantType;
      }
      getLogonName() {
        return this.getUserInfo().logonName;
      }
      getUserInfo() {
        return {
          email: this.token.email,
          familyName: this.token.familyName,
          givenName: this.token.givenName,
          logonName: this.token.payload.user_name
        };
      }
      getTokenInfo() {
        return this.token;
      }
      /**
       * Tries to fill up missing properties of the security context configuration from the req object in the configuration.
       * @param {SecurityContextConfig} contextConfig 
       */
      static buildContextConfig(contextConfig) {
        let { req } = contextConfig;
        for (let i = 0; contextConfig.correlationId == null && i < CORRELATIONID_HEADERS.length; i++) {
          contextConfig.correlationId = req?.headers?.[CORRELATIONID_HEADERS[i]];
        }
        contextConfig.clientCertificatePem ??= req?.headers?.[FORWARDED_CLIENTCERTIFICATE_HEADER];
        contextConfig.jwt ??= req?.headers?.authorization?.split(" ")[1];
        contextConfig.skipValidation ??= false;
        contextConfig.tokenDecodeCache ??= null;
      }
    };
    module2.exports = SecurityContext;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/configuration/ConfigurationError.js
var require_ConfigurationError2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/configuration/ConfigurationError.js"(exports2, module2) {
    var XssecError = require_XssecError2();
    var ConfigurationError = class extends XssecError {
      constructor(message) {
        super(message);
        this.name = "ConfigurationError";
        this.statusCode = 500;
      }
    };
    module2.exports = ConfigurationError;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/validation/TokenValidationError.js
var require_TokenValidationError2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/validation/TokenValidationError.js"(exports2, module2) {
    var debug = require_src();
    var debugLog = debug("xssec");
    var ValidationError = require_ValidationError2();
    var TokenValidationError = class extends ValidationError {
      /** @type {Token} */
      #token;
      constructor(token, message = "Token is not valid.") {
        super(message);
        this.name = "TokenValidationError";
        this.token = token;
        if (debugLog.enabled) {
          this.jwt = token.jwt;
        }
      }
      get token() {
        return this.#token;
      }
      set token(value) {
        this.#token = value;
      }
    };
    module2.exports = TokenValidationError;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/validation/ExpiredTokenError.js
var require_ExpiredTokenError2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/validation/ExpiredTokenError.js"(exports2, module2) {
    var TokenValidationError = require_TokenValidationError2();
    var ExpiredTokenError = class extends TokenValidationError {
      constructor(token, message = "Token is expired.") {
        super(token, message);
        this.name = "ExpiredTokenError";
      }
    };
    module2.exports = ExpiredTokenError;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/validation/InvalidClientCertificateError.js
var require_InvalidClientCertificateError2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/validation/InvalidClientCertificateError.js"(exports2, module2) {
    var ValidationError = require_ValidationError2();
    var InvalidClientCertificateError = class extends ValidationError {
      /** @type {Error} Error encountered during parsing */
      #parseError;
      constructor(clientCertificate, parseError, message = `The forwarded client certificate could not be parsed as X509 certificate: ${parseError.message}`) {
        super(message);
        this.name = "InvalidClientCertificateError";
        this.clientCertificate = clientCertificate;
        this.parseError = parseError;
      }
      get parseError() {
        return this.#parseError;
      }
      set parseError(value) {
        this.#parseError = value;
      }
    };
    module2.exports = InvalidClientCertificateError;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/configuration/InvalidCredentialsError.js
var require_InvalidCredentialsError2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/configuration/InvalidCredentialsError.js"(exports2, module2) {
    var ConfigurationError = require_ConfigurationError2();
    var InvalidCredentialsError = class extends ConfigurationError {
      constructor(message = "The service credentials are missing mandatory properties.") {
        super(message);
        this.name = "InvalidCredentialsError";
      }
    };
    module2.exports = InvalidCredentialsError;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/validation/InvalidIssuerError.js
var require_InvalidIssuerError2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/validation/InvalidIssuerError.js"(exports2, module2) {
    var TokenValidationError = require_TokenValidationError2();
    var InvalidIssuerError = class extends TokenValidationError {
      /** @type {Error} Error encountered during parsing */
      #parseError;
      constructor(token, parseError, message = `Issuer ${token.issuer} was not a valid domain or URL for use with https. Protocol schemes other than https:// are not supported.`) {
        super(token, message);
        this.name = "InvalidIssuerError";
        this.#parseError = parseError;
      }
      get parseError() {
        return this.#parseError;
      }
      set parseError(value) {
        this.#parseError = value;
      }
    };
    module2.exports = InvalidIssuerError;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/validation/InvalidTokenSignatureError.js
var require_InvalidTokenSignatureError2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/validation/InvalidTokenSignatureError.js"(exports2, module2) {
    var TokenValidationError = require_TokenValidationError2();
    var InvalidTokenSignatureError = class extends TokenValidationError {
      constructor(token, message = "Token signature is invalid.") {
        super(token, message);
        this.name = "InvalidTokenSignatureError";
      }
    };
    module2.exports = InvalidTokenSignatureError;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/validation/MissingClientCertificateError.js
var require_MissingClientCertificateError2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/validation/MissingClientCertificateError.js"(exports2, module2) {
    var ValidationError = require_ValidationError2();
    var MissingClientCertificateError = class extends ValidationError {
      constructor(message = "Request is missing a forwarded client certificate which is required to validate the token.") {
        super(message);
        this.name = "MissingClientCertificateError";
      }
    };
    module2.exports = MissingClientCertificateError;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/validation/MissingIssuerError.js
var require_MissingIssuerError2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/validation/MissingIssuerError.js"(exports2, module2) {
    var TokenValidationError = require_TokenValidationError2();
    var MissingIssuerError = class extends TokenValidationError {
      constructor(token, message = "Token is missing an issuer which is required to validate the signature.") {
        super(token, message);
        this.name = "MissingIssuerError";
      }
    };
    module2.exports = MissingIssuerError;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/validation/MissingKidError.js
var require_MissingKidError2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/validation/MissingKidError.js"(exports2, module2) {
    var ValidationError = require_ValidationError2();
    var MissingKidError = class extends ValidationError {
      /** @type {string} */
      #kid;
      constructor(kid, message = `JWKS is missing key for kid=${kid} specified in token header.`) {
        super(message);
        this.name = "MissingKidError";
        this.#kid = kid;
      }
      get kid() {
        return this.#kid;
      }
      set kid(value) {
        this.#kid = value;
      }
    };
    module2.exports = MissingKidError;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/validation/MissingVerificationKeyError.js
var require_MissingVerificationKeyError2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/validation/MissingVerificationKeyError.js"(exports2, module2) {
    var ValidationError = require_ValidationError2();
    var MissingVerificationKeyError = class extends ValidationError {
      constructor(message = "XSUAA service credentials are missing a verificationkey that would be required as JWKS fallback to validate the given token.") {
        super(message);
        this.name = "MissingVerificationKeyError";
      }
    };
    module2.exports = MissingVerificationKeyError;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/network/NetworkError.js
var require_NetworkError2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/network/NetworkError.js"(exports2, module2) {
    var XssecError = require_XssecError2();
    var NetworkError = class extends XssecError {
      /** @type {String} */
      #correlationId;
      constructor(message = "A network error has occured.") {
        super(message);
        this.name = "NetworkError";
        this.statusCode = 500;
      }
      get correlationId() {
        return this.#correlationId;
      }
      set correlationId(value) {
        this.#correlationId = value;
      }
    };
    module2.exports = NetworkError;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/validation/NotYetValidTokenError.js
var require_NotYetValidTokenError2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/validation/NotYetValidTokenError.js"(exports2, module2) {
    var TokenValidationError = require_TokenValidationError2();
    var NotYetValidTokenError = class extends TokenValidationError {
      constructor(token, message = "The token is not yet valid because its 'nbf' (no use before) date lies in the future.") {
        super(token, message);
        this.name = "NotYetValidTokenError";
      }
    };
    module2.exports = NotYetValidTokenError;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/network/RequestError.js
var require_RequestError2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/network/RequestError.js"(exports2, module2) {
    var NetworkError = require_NetworkError2();
    var RequestError = class extends NetworkError {
      /** @type {import("https").RequestOptions & {name: string}} */
      #request;
      /** @type {Error|Error[]} the original error(s) of the HTTP client for debugging. Do not code against this property as the internal HTTP client implementation may change anytime. */
      #originalError;
      #url;
      constructor(url, request, originalError, message = `HTTP request [${request.name}] to ${url} could not be sent due to: ${originalError.toString()}.`) {
        super(message);
        this.name = "RequestError";
        this.url = url;
        this.request = request;
        this.originalError = originalError;
      }
      get url() {
        return this.#url;
      }
      set url(value) {
        this.#url = value;
      }
      get request() {
        return this.#request;
      }
      set request(value) {
        this.#request = value;
      }
      get originalError() {
        return this.#originalError;
      }
      set originalError(error) {
        this.#originalError = error;
      }
    };
    module2.exports = RequestError;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/network/ResponseError.js
var require_ResponseError2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/network/ResponseError.js"(exports2, module2) {
    var NetworkError = require_NetworkError2();
    var ResponseError = class extends NetworkError {
      #url;
      #request;
      #responseCode;
      #responseText;
      constructor(url, request, responseCode, responseText, message = `HTTP response from ${url} was ${responseCode}: ${responseText}.`) {
        super(message);
        this.name = "ResponseError";
        this.url = url;
        this.request = request;
        this.responseCode = responseCode;
        this.responseText = responseText;
      }
      get url() {
        return this.#url;
      }
      set url(value) {
        this.#url = value;
      }
      get request() {
        return this.#request;
      }
      set request(value) {
        this.#request = value;
      }
      get responseCode() {
        return this.#responseCode;
      }
      set responseCode(value) {
        this.#responseCode = value;
      }
      get responseText() {
        return this.#responseText;
      }
      set responseText(value) {
        this.#responseText = value;
      }
    };
    module2.exports = ResponseError;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/network/TimeoutError.js
var require_TimeoutError2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/network/TimeoutError.js"(exports2, module2) {
    var RequestError = require_RequestError2();
    var TimeoutError = class extends RequestError {
      constructor(url, request, originalError, message = `HTTP request [${request.name}] to ${url} timed out after ${request.timeout} ms.`) {
        super(url, request, originalError, message);
        this.name = "TimeoutError";
      }
    };
    module2.exports = TimeoutError;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/validation/UnsupportedAlgorithmError.js
var require_UnsupportedAlgorithmError2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/validation/UnsupportedAlgorithmError.js"(exports2, module2) {
    var TokenValidationError = require_TokenValidationError2();
    var UnsupportedAlgorithmError = class extends TokenValidationError {
      #alg;
      constructor(token, alg, message = `Algorithm ${alg} specified in token header is not supported.`) {
        super(token, message);
        this.name = "UnsupportedAlgorithmError";
        this.alg = alg;
      }
      get alg() {
        return this.#alg;
      }
      set alg(value) {
        this.#alg = value;
      }
    };
    module2.exports = UnsupportedAlgorithmError;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/validation/UntrustedIssuerError.js
var require_UntrustedIssuerError2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/validation/UntrustedIssuerError.js"(exports2, module2) {
    var TokenValidationError = require_TokenValidationError2();
    var UntrustedIssuerError = class extends TokenValidationError {
      constructor(token, message = "Token issuer is not trusted because it is not a (sub)domain contained in the domains property of the service credentials.") {
        super(token, message);
        this.name = "UntrustedIssuerError";
      }
    };
    module2.exports = UntrustedIssuerError;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/validation/WrongAudienceError.js
var require_WrongAudienceError2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/validation/WrongAudienceError.js"(exports2, module2) {
    var TokenValidationError = require_TokenValidationError2();
    var WrongAudienceError = class extends TokenValidationError {
      /** @type {string[]} token audiences */
      audiences;
      /** @type {Service|Service[]} service(s) on which context creation was attempted */
      #service;
      constructor(token, service, message = "Token was issued for a different audience than this service.") {
        super(token, message);
        this.name = "WrongAudienceError";
        this.service = service;
        this.audiences = token.audiences;
      }
      get service() {
        return this.#service;
      }
      set service(value) {
        this.#service = value;
      }
    };
    module2.exports = WrongAudienceError;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/validation/X5tError.js
var require_X5tError2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/validation/X5tError.js"(exports2, module2) {
    var TokenValidationError = require_TokenValidationError2();
    var X5tError = class extends TokenValidationError {
      /** @type {String} client certificate used for x5t validation */
      clientCertificate;
      constructor(token, clientCertificate, message = "X5t validation of token failed.") {
        super(token, message);
        this.name = "X5tError";
        this.clientCertificate = clientCertificate;
      }
      /** For backward-compatibility because property was renamed. */
      get cert() {
        return this.clientCertificate;
      }
    };
    module2.exports = X5tError;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/index.js
var require_error2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/index.js"(exports2, module2) {
    var ConfigurationError = require_ConfigurationError2();
    var ExpiredTokenError = require_ExpiredTokenError2();
    var InvalidClientCertificateError = require_InvalidClientCertificateError2();
    var InvalidCredentialsError = require_InvalidCredentialsError2();
    var InvalidIssuerError = require_InvalidIssuerError2();
    var InvalidJwtError = require_InvalidJwtError2();
    var InvalidTokenSignatureError = require_InvalidTokenSignatureError2();
    var MissingClientCertificateError = require_MissingClientCertificateError2();
    var MissingIssuerError = require_MissingIssuerError2();
    var MissingJwtError = require_MissingJwtError2();
    var MissingKidError = require_MissingKidError2();
    var MissingVerificationKeyError = require_MissingVerificationKeyError2();
    var NetworkError = require_NetworkError2();
    var NotYetValidTokenError = require_NotYetValidTokenError2();
    var RequestError = require_RequestError2();
    var ResponseError = require_ResponseError2();
    var TimeoutError = require_TimeoutError2();
    var TokenValidationError = require_TokenValidationError2();
    var UnsupportedAlgorithmError = require_UnsupportedAlgorithmError2();
    var UntrustedIssuerError = require_UntrustedIssuerError2();
    var ValidationError = require_ValidationError2();
    var WrongAudienceError = require_WrongAudienceError2();
    var X5tError = require_X5tError2();
    var XssecError = require_XssecError2();
    module2.exports = {
      ConfigurationError,
      ExpiredTokenError,
      InvalidClientCertificateError,
      InvalidCredentialsError,
      InvalidIssuerError,
      InvalidJwtError,
      InvalidTokenSignatureError,
      MissingClientCertificateError,
      MissingIssuerError,
      MissingJwtError,
      MissingKidError,
      MissingVerificationKeyError,
      NetworkError,
      NotYetValidTokenError,
      RequestError,
      ResponseError,
      TimeoutError,
      TokenValidationError,
      UnsupportedAlgorithmError,
      UntrustedIssuerError,
      ValidationError,
      WrongAudienceError,
      X5tError,
      XssecError
    };
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/util/Logger.js
var require_Logger2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/util/Logger.js"(exports2, module2) {
    var Logger = class {
      constructor(loggingConfig, prefix) {
        this.loggingConfig = loggingConfig;
        this.prefix = prefix;
      }
      info(message, args) {
        message = `[${this.prefix}] ${message}`;
        if (args != null) {
          this.loggingConfig.info(message, args);
        } else {
          this.loggingConfig.info(message);
        }
      }
      warn(message, args) {
        message = `[${this.prefix}] ${message}`;
        if (args != null) {
          this.loggingConfig.warn(message, args);
        } else {
          this.loggingConfig.warn(message);
        }
      }
      error(message, args) {
        message = `[${this.prefix}] ${message}`;
        if (args != null) {
          this.loggingConfig.error(message, args);
        } else {
          this.loggingConfig.error(message);
        }
      }
      debug(message, args) {
        message = `[${this.prefix}] ${message}`;
        if (args != null) {
          this.loggingConfig.debug(message, args);
        } else {
          this.loggingConfig.debug(message);
        }
      }
    };
    module2.exports = Logger;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/util/logging.js
var require_logging2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/util/logging.js"(exports2, module2) {
    var debug = require_src();
    var Logger = require_Logger2();
    var debugLogger = debug("xssec");
    debugLogger.log = console.log.bind(console);
    var loggingConfig = {
      info: (message, ...args) => debugLogger(message, ...args),
      warn: (message, ...args) => debugLogger(message, ...args),
      error: (message, ...args) => debugLogger(message, ...args),
      debug: (message, ...args) => debugLogger(message, ...args)
    };
    function getLogger(prefix = "") {
      return new Logger(loggingConfig, prefix);
    }
    function setLoggers(loggers) {
      Object.assign(loggingConfig, loggers);
    }
    module2.exports = {
      getLogger,
      setLoggers
    };
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/context/createSecurityContext.js
var require_createSecurityContext2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/context/createSecurityContext.js"(exports2, module2) {
    var Token = require_Token2();
    var MissingJwtError = require_MissingJwtError2();
    var SecurityContext = require_SecurityContext2();
    var { WrongAudienceError } = require_error2();
    var { getLogger } = require_logging2();
    var LOG = getLogger("createSecurityContext.js");
    module2.exports = createSecurityContext;
    async function createSecurityContext(services, contextConfig) {
      contextConfig = { ...contextConfig };
      SecurityContext.buildContextConfig(contextConfig);
      if (contextConfig.token == null && contextConfig.jwt == null) {
        throw new MissingJwtError();
      }
      const token = contextConfig.token ?? new Token(contextConfig.jwt);
      LOG.debug(`Creating security context from JWT: ${token.jwt}`, { correlationId: contextConfig.correlationId });
      let targetService = null;
      if (Array.isArray(services)) {
        if (services.length === 1) {
          targetService = services[0];
        } else {
          targetService = findServiceForToken(services, token);
          if (targetService != null) {
            LOG.debug(`Selected ${targetService.constructor.name} with clientid ${targetService.credentials.clientid} based on token audience.`, { correlationId: contextConfig.correlationId });
          }
        }
      } else {
        targetService = services;
      }
      if (targetService == null) {
        throw new WrongAudienceError(token, services, `The audiences of the token fit none of the supplied services.`);
      }
      return targetService.createSecurityContext(token, contextConfig);
    }
    function findServiceForToken(services, token) {
      return services.find((s) => s.acceptsTokenAudience(token));
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/context/IdentityServiceSecurityContext.js
var require_IdentityServiceSecurityContext2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/context/IdentityServiceSecurityContext.js"(exports2, module2) {
    var ConfigurationError = require_ConfigurationError2();
    var SecurityContext = require_SecurityContext2();
    var IdentityServiceSecurityContext = class extends SecurityContext {
      /**
       * @param {IdentityService|null} service
       * @param {IdentityServiceToken} token 
       * @param {SecurityContextConfig} [contextConfig] 
       */
      constructor(service, token, contextConfig) {
        super(service, token, contextConfig);
      }
      /**
       * Returns the service plans of the consumer application.
       * This method is only available if the context was created from an app2service token and a service with proof token validation enabled.
       * @returns {string[]}
       */
      get servicePlans() {
        if (!this.service.hasProofTokenEnabled()) {
          throw new ConfigurationError("This property is only available on IdentityServiceSecurityContexts created on an IdentityService with proofToken validation enabled.");
        }
        return this.config.servicePlans;
      }
      /**
       * Checks whether the token from which this context was created is a token fetched by the OAuth 2.0 client for internal use.
       * This method requires the IdentityService instance to have x5t validation enabled.
       * @returns {boolean} true if the token was fetched via client credentials flow with the credentials of this context's IdentityService instance, false otherwise.
       */
      isInternal() {
        if (!this.service.hasX5tEnabled()) {
          throw new ConfigurationError("This method is only available on IdentityServiceSecurityContexts created on an IdentityService instance with x5t validation enabled.");
        }
        return this.token.azp === this.service.credentials.clientid && this.token.subject === this.service.credentials.clientid && this.token.appTid === this.service.credentials.app_tid;
      }
      // Methods for backward-compatibility
      getUserInfo() {
        return {
          ...super.getUserInfo(),
          logonName: this.token.payload.user_name || this.token.email || this.token.payload.user_uuid || ""
        };
      }
    };
    module2.exports = IdentityServiceSecurityContext;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/context/XsuaaSecurityContext.js
var require_XsuaaSecurityContext2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/context/XsuaaSecurityContext.js"(exports2, module2) {
    var SecurityContext = require_SecurityContext2();
    var { getLogger } = require_logging2();
    var { GRANTTYPE_CLIENTCREDENTIALS } = require_constants3();
    var LOG = getLogger("XsuaaSecurityContext.js");
    var XsuaaSecurityContext = class extends SecurityContext {
      /**
       * @param {XsuaaService|null} service
       * @param {XsuaaToken} token 
       * @param {SecurityContextConfig} [contextConfig] 
       */
      constructor(service, token, contextConfig) {
        super(service, token, contextConfig);
      }
      /**
       * Checks if the token of this context was issued for the given scope.
       * @param {String} scope 
       * @returns {Boolean}
       */
      checkScope(scope) {
        return this.token.scopes.includes(scope);
      }
      /**
       * Checks if the token of this context was issued for the given scope, ignoring the xsappname prefix of the service that was used to create this context when copmaring with the token's scopes.
       * @param {String} scope 
       * @returns {Boolean}
       */
      checkLocalScope(scope) {
        return this.token.scopes.includes(`${this.service.credentials.xsappname}.${scope}`);
      }
      checkFollowingInstanceScope(scope) {
        const clientId = this.token.payload.client_id;
        if (!clientId?.startsWith("sb-")) {
          return false;
        }
        const appId = clientId.substring(3);
        if (!appId.includes("|")) {
          return false;
        }
        return this.checkScope(`${appId}.${scope}`);
      }
      // Methods for backward-compatibility
      getAttributes() {
        const attributes = this.token.xsUserAttributes ?? {};
        return Object.keys(attributes).length !== 0 ? attributes : null;
      }
      getAttribute(name) {
        return this.token.getXsUserAttribute(name) || null;
      }
      getAdditionalAuthAttribute(name) {
        const additionalAuthAttributes = this.getAdditionalAuthAttributes();
        if (!additionalAuthAttributes) {
          LOG.debug("\nThe access token contains no additional authentication attributes.\n");
          return null;
        }
        if (!name) {
          LOG.debug("\nInvalid attribute name (may not be null, empty, or undefined).");
          return null;
        }
        if (!additionalAuthAttributes[name]) {
          LOG.debug('\nNo attribute "' + name + '" found as additional authentication attribute.');
          return null;
        }
        return additionalAuthAttributes[name];
      }
      getAdditionalAuthAttributes() {
        return this.token.azAttributes || null;
      }
      /**
       * @deprecated Use token.zid instead 
       */
      getAppTID() {
        return this.token.zid;
      }
      getClientId() {
        return this.token.getClientId();
      }
      getCloneServiceInstanceId() {
        return this.token.extAttributes?.serviceinstanceid || null;
      }
      getEmail() {
        return this.#ifNotClientCredentialsToken("XsuaaSecurityContext.getEmail", this.getUserInfo().email);
      }
      getFamilyName() {
        return this.#ifNotClientCredentialsToken("XsuaaSecurityContext.getFamilyName", this.getUserInfo().familyName);
      }
      getGivenName() {
        return this.#ifNotClientCredentialsToken("XsuaaSecurityContext.getGivenName", this.getUserInfo().givenName);
      }
      getLogonName() {
        return this.#ifNotClientCredentialsToken("XsuaaSecurityContext.getLogonName", this.getUserInfo().logonName);
      }
      getOrigin() {
        return this.token.origin;
      }
      getSubaccountId() {
        return this.token.subAccountId;
      }
      getSubdomain() {
        return this.token.extAttributes?.zdn ?? null;
      }
      getUniquePrincipalName(origin, logonName) {
        if (!this.#ifNotClientCredentialsToken("XsuaaSecurityContext.getUniquePrincipalName", true)) {
          return null;
        }
        if (!origin) {
          LOG.debug("Origin claim not set in JWT. Cannot create unique user name. Returning null.");
          return null;
        }
        if (!logonName) {
          LOG.debug("User login name claim not set in JWT. Cannot create unique user name. Returning null.");
          return null;
        }
        if (origin.includes("/")) {
          LOG.debug("Illegal '/' character detected in origin claim of JWT. Cannot create unique user name. Retuning null.");
          return null;
        }
        return `user/${origin}/${logonName}`;
      }
      getUserName() {
        if (this.token.grantType === GRANTTYPE_CLIENTCREDENTIALS) {
          return `client/${this.getClientId()}`;
        } else {
          return this.getUniquePrincipalName(this.token.origin, this.getLogonName());
        }
      }
      /**
       * @deprecated Use token.zid instead 
       */
      getZoneId() {
        return this.token.zid;
      }
      hasAttributes() {
        return this.#ifNotClientCredentialsToken("XsuaaSecurityContext.hasAttributes", this.token.xsUserAttributes != null);
      }
      isInForeignMode() {
        return this.service.credentials.clientid.includes("!b") && this.token.audiences.some((aud) => aud.includes(`|${this.service.credentials.clientid}`));
      }
      #ifNotClientCredentialsToken(functionName, value) {
        if (this.token.grantType === GRANTTYPE_CLIENTCREDENTIALS) {
          LOG.debug(`Call to ${functionName} not allowed with a token of grant type ${GRANTTYPE_CLIENTCREDENTIALS}.`);
          return null;
        }
        return value;
      }
    };
    module2.exports = XsuaaSecurityContext;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/context/XsaSecurityContext.js
var require_XsaSecurityContext2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/context/XsaSecurityContext.js"(exports2, module2) {
    var XsuaaSecurityContext = require_XsuaaSecurityContext2();
    var XsaSecurityContext = class extends XsuaaSecurityContext {
      /**
       * 
       * @param {XsaService|null} service 
       * @param {XsaToken} token 
       * @param {SecurityContextConfig} [contextConfig]
       */
      constructor(service, token, contextConfig) {
        super(service, token, contextConfig);
      }
      /**
       * The Service instance on which this SecurityContext has been created.
       * @returns {XsaService} service
       */
      get service() {
        return super.service;
      }
      /**
       * @param {XsaService} service
       */
      set service(service) {
        super.service = service;
      }
      /**
       * The Token instance from which this SecurityContext has ben created.
       * @returns {XsaToken} token
       */
      get token() {
        return super.token;
      }
      /**
       * @param {XsaToken} token
       */
      set token(token) {
        super.token = token;
      }
    };
    module2.exports = XsaSecurityContext;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/context/UaaSecurityContext.js
var require_UaaSecurityContext2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/context/UaaSecurityContext.js"(exports2, module2) {
    var XsuaaSecurityContext = require_XsuaaSecurityContext2();
    var UaaSecurityContext = class extends XsuaaSecurityContext {
      /**
       * @param {UaaService|null} service
       * @param {UaaToken} token 
       * @param {SecurityContextConfig} [contextConfig] 
       */
      constructor(service, token, contextConfig) {
        super(service, token, contextConfig);
      }
      /**
       * The Service instance on which this SecurityContext has been created.
       * @returns {UaaService} service
       */
      get service() {
        return super.service;
      }
      /**
       * @param {UaaService} service
       */
      set service(service) {
        super.service = service;
      }
      /**
       * The Token instance from which this SecurityContext has ben created.
       * @returns {UaaToken} token
       */
      get token() {
        return super.token;
      }
      /**
       * @param {UaaToken} token
       */
      set token(token) {
        super.token = token;
      }
    };
    module2.exports = UaaSecurityContext;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/cache/ResponseReplica.js
var require_ResponseReplica2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/cache/ResponseReplica.js"(exports2, module2) {
    var ResponseReplica = class {
      cache;
      // cache containing this replica
      key;
      // cache key of this replica
      request;
      // callback for fetching response data
      data;
      // last response data
      lastRefresh;
      // UNIX timestamp of last refresh
      expirationTime;
      // time in milliseconds that needs to pass after creation for the replica to count as expired
      pendingRequest;
      // promise for ongoing update of response or undefined
      constructor(cache, key, request) {
        Object.assign(this, { cache, key, request });
        this.data = null;
        this.expirationTime = cache.expirationTime;
      }
      /**
       * Returns the remaining time until expiration.
       * @returns time until expiration or 0 if no data available or data expired
       */
      get remainingTime() {
        if (!this.hasData || this.lastRefresh == null) {
          return 0;
        }
        const elapsedTime = Date.now() - this.lastRefresh;
        return Math.max(0, this.expirationTime - elapsedTime);
      }
      /** Returns whether the replica already has response data. **/
      hasData() {
        return this.data != null;
      }
      /** Returns whether the replica is expired. **/
      isExpired() {
        return this.remainingTime <= 0;
      }
      /**
       * Returns if the replica is considered stale given the refresh period. Stale replicas should be refreshed but may still be used before expiration.
       * @param refreshPeriod time period (in ms) before expiration time in which the replica should count as stale (but not yet as expired)
       * @returns true if the replica is already expired or will expire within the given refresh period.
       */
      isStale(refreshPeriod) {
        return this.expired || this.remainingTime <= refreshPeriod;
      }
      /**
       * Triggers a refresh of this replica. Multiple calls will still result in only one refresh at a time.
       * @param {string} correlationId 
       */
      refresh(correlationId) {
        this.pendingRequest ??= this.#fetchResponse(correlationId);
        return this.pendingRequest;
      }
      /** Fetches new data from the request. */
      async #fetchResponse(correlationId) {
        try {
          this.data = await this.request(correlationId);
        } finally {
          this.pendingRequest = null;
        }
        this.lastRefresh = Date.now();
      }
    };
    module2.exports = ResponseReplica;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/cache/ResponseCache.js
var require_ResponseCache2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/cache/ResponseCache.js"(exports2, module2) {
    var ResponseReplica = require_ResponseReplica2();
    var ConfigurationError = require_ConfigurationError2();
    var { getLogger } = require_logging2();
    var LOG = getLogger("ResponseCache.js");
    var ResponseCache = class _ResponseCache {
      static get DEFAULT_EXPIRATION_TIME() {
        return 30 * 60 * 1e3;
      }
      // 30 minutes
      static get DEFAULT_REFRESH_PERIOD() {
        return 15 * 60 * 1e3;
      }
      // 15 minutes
      /** @type {Map<string,ResponseReplica>} */
      cache;
      // map that stores response replicas by their key
      endpointName;
      // name of cached endpoint for logging purposes, e.g. "JWKS", ".well-known" etc.
      expirationTime;
      // expiration time that will be used for new cache entries
      refreshPeriod;
      // time before expiration in which a response is considered stale
      constructor({
        expirationTime = _ResponseCache.DEFAULT_EXPIRATION_TIME,
        refreshPeriod = _ResponseCache.DEFAULT_REFRESH_PERIOD,
        endpointName = "response"
      } = {}) {
        if (expirationTime < 0) {
          throw new ConfigurationError("ResponseCache expirationTime must be >=0.");
        }
        if (refreshPeriod < 0 || refreshPeriod > expirationTime) {
          throw new ConfigurationError("ResponseCache refreshPeriod must be between 0 and <expirationTime>.");
        }
        this.cache = /* @__PURE__ */ new Map();
        this.endpointName = endpointName;
        this.expirationTime = expirationTime;
        this.refreshPeriod = refreshPeriod;
      }
      /**
       * Returns an up-to-date response associated with the given key. If there is no replica yet for the key, caches a new replica under this key that
       * uses the given request callback to fetch its responses.
       * @param key cache key of response
       * @param buildRequest callback that constructs a request function for fetching new responses if no replica exists yet for the key. The request function
       *  has to throw an Error with a statusCode and statusText if it fails to fetch the data.
       */
      async getOrRequest(key, buildRequest, { correlationId }) {
        const replica = this.cache.get(key) || this.#createReplica(key, buildRequest());
        if (!replica.hasData() || replica.isExpired()) {
          LOG.debug(`Awaiting ${this.endpointName} refresh because replica for key=${key} has ${replica.hasData() ? "expired" : "no"} data.)`, { correlationId });
          await replica.refresh(correlationId);
        } else if (replica.isStale(this.refreshPeriod)) {
          LOG.debug(`Asynchronous ${this.endpointName} refresh scheduled because replica for key=${key} is stale (remaining time = ${replica.remainingTime}ms < ${replica.refreshPeriod}ms = refresh period).`);
          replica.refresh(correlationId).catch(() => {
          });
        }
        return replica.data;
      }
      #createReplica(key, request) {
        const replica = new ResponseReplica(this, key, request);
        this.cache.set(key, replica);
        return replica;
      }
    };
    module2.exports = ResponseCache;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/util/fetch.js
var require_fetch2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/util/fetch.js"(exports2, module2) {
    var https = require("https");
    var http = require("http");
    var zlib = require("zlib");
    var url = require("url");
    function selectRequestModule(protocol) {
      switch (protocol) {
        case "https:":
          return https;
        case "http:":
          return http;
        default:
          throw new Error(`Unsupported protocol: ${protocol}`);
      }
    }
    var FetchError = class extends Error {
      constructor(message, error) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.code = this.errno = error?.code;
        this.erroredSysCall = error?.syscall;
      }
      get name() {
        return this.constructor.name;
      }
    };
    var Response2 = class {
      #response;
      #request;
      constructor(response, request) {
        this.#response = response;
        this.#request = request;
      }
      async #getZip() {
        const response = this.#response;
        return new Promise((resolve, reject) => {
          const gunzip = zlib.createGunzip();
          response.pipe(gunzip);
          const data = [];
          gunzip.on("data", function(chunk) {
            data.push(chunk.toString());
          });
          gunzip.on("end", function() {
            resolve(data.join(""));
          });
          gunzip.on("error", (error) => {
            reject(new FetchError(`request to ${this.requestUrl} failed, reason: ${error.message}`, error));
          });
        });
      }
      get requestUrl() {
        const req = this.#request;
        return req.protocol + "//" + req.host + req.path;
      }
      async #getText() {
        const response = this.#response;
        if (response.headers["content-encoding"] === "gzip") {
          return this.#getZip();
        }
        return new Promise((resolve, reject) => {
          const data = [];
          response.setEncoding("utf8");
          response.on("data", function(chunk) {
            data.push(chunk);
          });
          response.on("end", function() {
            resolve(data.join(""));
          });
          response.on("error", (error) => {
            reject(new FetchError(`request to ${this.requestUrl} failed, reason: ${error.message}`, error));
          });
        });
      }
      async json() {
        return JSON.parse(await this.#getText());
      }
      async text() {
        return this.#getText();
      }
      get ok() {
        return this.status >= 200 && this.status < 300;
      }
      get status() {
        return this.#response.statusCode;
      }
      get headers() {
        const headers = /* @__PURE__ */ new Map();
        for (const [key, value] of Object.entries(this.#response.headers)) {
          headers.set(key, value);
        }
        return headers;
      }
    };
    async function xssec_fetch(inputUrl, options = {}) {
      importDefaultOptions(options);
      importDefaultHeaders(options);
      importBodyOptions(options);
      const requestModule = selectRequestModule(new url.URL(inputUrl).protocol);
      return new Promise(function(resolve, reject) {
        const req = requestModule.request(inputUrl, options, (response) => {
          resolve(new Response2(response, req));
        });
        req.on("error", (error) => {
          reject(new FetchError(`request to ${url} failed, reason: ${error.message}`, error));
        });
        req.on("timeout", () => {
          req.destroy();
          reject(new FetchError(`request to ${url} timed out.`, { code: "ETIMEDOUT" }));
        });
        if (options.data) {
          req.write(options.data);
        }
        req.end();
      });
    }
    function importDefaultOptions(options) {
      options.method ??= "GET";
    }
    function importBodyOptions(options) {
      if (options.body) {
        const method = options.method.toUpperCase();
        if (method !== "GET" && method !== "HEAD") {
          if (options.json) {
            options.data = JSON.stringify(options.body);
            options.headers["Content-Type"] = "application/json;charset=UTF-8";
          } else {
            options.data = options.body.toString();
            options.headers["Content-Type"] = "application/x-www-form-urlencoded;charset=UTF-8";
          }
          options.headers["Content-Length"] = Buffer.byteLength(options.data);
          delete options.body;
        } else {
          throw new Error("Request with GET/HEAD method cannot have body");
        }
      }
    }
    function importDefaultHeaders(options) {
      if (options.headers == null) {
        options.headers = {};
      }
      options.headers["Accept-Encoding"] = "gzip,deflate";
      if (!options.headers["Accept"] && !options.headers["accept"]) {
        options.headers["Accept"] = "*/*";
      }
    }
    module2.exports = xssec_fetch;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/network/RetryError.js
var require_RetryError2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/error/network/RetryError.js"(exports2, module2) {
    var RequestError = require_RequestError2();
    var RetryError = class extends RequestError {
      constructor(url, request, originalError, message = `HTTP request [${request.name}] to ${url} was not successful after ${originalError.length} attempts.`) {
        super(url, request, originalError, message);
        this.name = "RetryError";
      }
      get retryErrors() {
        return this.originalError;
      }
    };
    module2.exports = RetryError;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/util/util.js
var require_util4 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/util/util.js"(exports2, module2) {
    var { X509Certificate } = require("crypto");
    var InvalidClientCertificateError = require_InvalidClientCertificateError2();
    var { PEM_HEADER, PEM_FOOTER, CLIENT_CERTIFICATE_HEADER } = require_constants3();
    module2.exports = {
      /**
       * Escapes Regex special characters in the given string, so that the string can be used for a literal match inside a Regex.
       * Regex.escape is only a proposal at the time of writing.
       * The source of this code is https://github.com/tc39/proposal-regex-escaping/blob/main/polyfill.js 
       */
      escapeStringForRegex(s) {
        return String(s).replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
      },
      /**
       * Creates a string cache key from the given key-value pairs, ignoring keys with null or undefined values.
       * @param {object} parts
       * @returns a cache key in string format, e.g. app_tid:foo:client_id:bar:azp:baz
       */
      createCacheKey(parts = {}) {
        return Object.entries(parts).filter(([value]) => value != null).map(([key, value]) => `${key}=${value}`).join("|");
      },
      parsePemCertificate(pem) {
        pem = pem.replaceAll("\\n", "\n");
        if (!pem.startsWith(PEM_HEADER)) pem = `${PEM_HEADER}
${pem}`;
        if (!pem.endsWith(PEM_FOOTER)) pem = `${pem}
${PEM_FOOTER}`;
        try {
          return new X509Certificate(pem);
        } catch (error) {
          throw new InvalidClientCertificateError(pem, error);
        }
      },
      shrinkRequestOptionsForLog(request) {
        const maskedRequest = { ...request };
        maskedRequest.headers = { ...request.headers };
        if (maskedRequest.agent) {
          maskedRequest.agent = "<agent>";
        }
        if (maskedRequest.headers?.[CLIENT_CERTIFICATE_HEADER]) {
          maskedRequest.headers[CLIENT_CERTIFICATE_HEADER] = "<clientCertificatePem>";
        }
        return maskedRequest;
      }
    };
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/util/jsonRequest.js
var require_jsonRequest2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/util/jsonRequest.js"(exports2, module2) {
    var fetch2 = require_fetch2();
    var { getLogger } = require_logging2();
    var RequestError = require_RequestError2();
    var RetryError = require_RetryError2();
    var ResponseError = require_ResponseError2();
    var TimeoutError = require_TimeoutError2();
    var { CORRELATIONID_HEADER_VCAP, DEFAULT_TIMEOUT, MAX_TIMEOUT, USER_AGENT } = require_constants3();
    var { shrinkRequestOptionsForLog } = require_util4();
    var LOG = getLogger("request.js");
    var sleep = (ms) => new Promise((resolve) => {
      setTimeout(() => {
        resolve();
      }, ms);
    });
    function calculateDelay(attempt, retryConfig) {
      if (retryConfig.strategy === "exponential") {
        const delay = retryConfig.initialDelay * Math.pow(retryConfig.factor, attempt);
        return Math.min(delay, retryConfig.maxDelay);
      }
      return retryConfig.initialDelay;
    }
    function isRetryableError(e) {
      if (e instanceof ResponseError) {
        if (e.responseCode >= 500 && e.responseCode <= 600 || e.responseCode == 429 || e.responseCode == 408) {
          return true;
        }
      } else if (e instanceof RequestError) {
        return true;
      }
      return false;
    }
    async function fetchWithRetry(url, request, options) {
      const { requestName, correlationId } = options;
      const retryConfig = request.retry;
      const retryErrors = [];
      const requestWithName = { ...request, name: requestName };
      for (let attempt = 0; attempt <= retryConfig.retries; attempt++) {
        try {
          if (attempt > 0) {
            LOG.info(`Retry attempt ${attempt}/${retryConfig.retries} for [${requestName}] to ${url}`, { correlationId });
          }
          return await fetchWithoutRetry(url, request, options);
        } catch (e) {
          if (!isRetryableError(e)) {
            throw e;
          }
          retryErrors.push(e);
          if (attempt >= retryConfig.retries) {
            break;
          }
          const delay = calculateDelay(attempt, retryConfig);
          LOG.debug(`Waiting ${delay}ms before next retry`, { correlationId });
          await sleep(delay);
        }
      }
      const error = new RetryError(url, requestWithName, retryErrors);
      LOG.error(error.message, { correlationId });
      throw error;
    }
    async function fetchWithoutRetry(url, request, { requestName, correlationId, extractHeaders }) {
      if (correlationId) {
        request.headers[CORRELATIONID_HEADER_VCAP] = correlationId;
      }
      LOG.debug(`HTTP request [${requestName}] to ${url} with options`, { correlationId, ...shrinkRequestOptionsForLog(request) });
      let response;
      try {
        response = await fetch2(url, request);
      } catch (e) {
        const requestWithName = { ...request, name: requestName };
        const error = e.code === "ETIMEDOUT" ? new TimeoutError(url, requestWithName, e) : new RequestError(url, requestWithName, e);
        LOG.error(error.message, { correlationId });
        throw error;
      }
      if (!response.ok) {
        const responseText = await response.text();
        const error = new ResponseError(url, { ...request, name: requestName }, response.status, responseText);
        LOG.error(error.message, { correlationId });
        throw error;
      }
      const json2 = await response.json();
      LOG.debug(`HTTP response [${requestName}]:`, { correlationId, ...json2 });
      if (extractHeaders != null) {
        json2[extractHeaders] = response.headers;
      }
      return json2;
    }
    async function jsonRequest(url, request, options = {}) {
      Object.assign(request, {
        redirect: "error",
        follow: 0,
        timeout: Math.min(MAX_TIMEOUT, request.timeout ?? DEFAULT_TIMEOUT)
      });
      request.headers ??= {};
      Object.assign(request.headers, {
        Accept: "application/json",
        "User-Agent": USER_AGENT
      });
      if (request.retry) {
        return fetchWithRetry(url, request, options);
      } else {
        return fetchWithoutRetry(url, request, options);
      }
    }
    module2.exports = {
      jsonRequest
    };
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/service/Service.js
var require_Service2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/service/Service.js"(exports2, module2) {
    var { Agent } = require("node:https");
    var ResponseCache = require_ResponseCache2();
    var LRUCache = require_LRUCache2();
    var { ConfigurationError, ExpiredTokenError, InvalidCredentialsError, MissingKidError, NotYetValidTokenError, WrongAudienceError } = require_error2();
    var { jsonRequest } = require_jsonRequest2();
    var { createCacheKey } = require_util4();
    var { DEFAULT_JWT_BEARER_FETCH_TIMEOUT, DEFAULT_TIMEOUT, GRANTTYPE_CLIENTCREDENTIALS, GRANTTYPE_JWTBEARER, GRANTTYPE_PASSWORD, MAX_TIMEOUT } = require_constants3();
    var Service = class _Service {
      /** 
       * JWKS cache instances shared by Service subclasses indexed by their constructor name.
       * @type {Object.<string, ResponseCache>} 
       */
      static #sharedJwksCaches = {};
      /** 
       * Signature cache instances shared by Service subclasses indexed by their constructor name.
       * @type {Object.<string, LRUCache>} 
       */
      static #sharedSignatureCaches = {};
      /** @type {ResponseCache} */
      static #oidcCache = null;
      /** @type {import("../util/Types").ExponentialBackoffRetryConfig} */
      static DEFAULT_RETRY_CONFIG = {
        strategy: "exponential",
        retries: 3,
        initialDelay: 500,
        factor: 3,
        maxDelay: 4e3
      };
      /** @type {import("../util/Types").SignatureCacheConfig} */
      static DEFAULT_SIGNATURE_CACHE_CONFIG = {
        size: 100
      };
      /** @type {ServiceCredentials} */
      credentials;
      /** @type {ServiceConfig} */
      config;
      /** @type {Object.<string, string>}  */
      endpoints;
      /** @type {ResponseCache} */
      jwksCache;
      /**
       * A jwt->boolean cache used for signature validation results. Can be either an external cache implementation or one of the {@link #sharedSignatureCaches}.
       * @type {import("../util/Types").Cache}
       */
      signatureCache;
      /**
       *
       * @param {ServiceCredentials} credentials
       * @param {ServiceConfig} [serviceConfiguration={}]
       */
      constructor(credentials, serviceConfiguration = {}) {
        if (credentials == null) {
          throw new ConfigurationError("Service requires service credentials.");
        }
        this.credentials = { ...credentials };
        this.config = _Service.buildServiceConfiguration(serviceConfiguration);
        _Service.#oidcCache ??= new ResponseCache({ endpointName: "OIDC configuration" });
        this.endpoints = { ...this.endpoints, ...serviceConfiguration.endpoints || {} };
        this.jwksCache = this.config.validation.jwks.shared ? this.#getSharedJwksCache(this.config) : new ResponseCache({ ...this.config.validation.jwks, endpointName: "JWKS" });
        if (this.config.validation.signatureCache.impl) {
          this.signatureCache = this.config.validation.signatureCache.impl;
        } else if (this.config.validation.signatureCache.enabled !== false) {
          this.signatureCache = _Service.#getSharedSignatureCache(this.config.validation.signatureCache);
        }
      }
      /**
       * @internal
       * Gets the OIDC cache shared by all Service instances.
       *
       * @returns {import("../cache/ResponseCache")} The OIDC cache.
       */
      get oidcCache() {
        return _Service.#oidcCache;
      }
      /**
       * @internal
       * Sets the OIDC cache shared by all Service instances.
       */
      set oidcCache(cache) {
        _Service.#oidcCache = cache;
      }
      #getSharedJwksCache() {
        _Service.#sharedJwksCaches[this.constructor.name] ??= new ResponseCache({ ...this.config.validation.jwks, endpointName: "JWKS" });
        return _Service.#sharedJwksCaches[this.constructor.name];
      }
      /**
       * Retrieves or creates the signature cache shared by all instances of this Service subclass.
       * @param {import("../util/Types").SignatureCacheConfig} config 
       * @returns {LRUCache} the shared signature cache
       * @throws {ConfigurationError} if a shared signature cache with a different size has already been created by another Service configuration for the same Service subclass.
       */
      static #getSharedSignatureCache(config) {
        const sharedCache = _Service.#sharedSignatureCaches[this.constructor.name];
        if (sharedCache != null && sharedCache.size !== config.size) {
          throw new ConfigurationError(
            `An internal signature cache with size ${sharedCache.size} instead of ${config.size} has already been created by another ${this.constructor.name} configuration. Please use the same size in all ${this.constructor.name} configurations or provide separate, externally managed cache implementations.`
          );
        }
        _Service.#sharedSignatureCaches[this.constructor.name] ??= new LRUCache(config.size);
        return _Service.#sharedSignatureCaches[this.constructor.name];
      }
      /**
       * Checks if this service is the recipient of the given token.
       * @param {Token} token
       * @returns {Boolean}
       */
      acceptsTokenAudience(token) {
        this.validateCredentials("validate token audience", "clientid");
        return token.audiences?.includes(this.credentials.clientid);
      }
      /**
       * Called internally to validate the credentials to have the necessary properties before performing a specific action, e.g. token fetch.
       *
       * @internal
       * @param {string} action description of action for which the credentials are being validated.
       * @param {...string} mandatoryProperties mandatory properties that must be present in the credentials.
       * @throws {InvalidCredentialsError} if any of the mandatory properties are missing in the credentials.
       */
      validateCredentials(action, ...mandatoryProperties) {
        const missingProperties = mandatoryProperties.filter((p) => !this.credentials[p]);
        if (missingProperties.length > 0) {
          throw new InvalidCredentialsError(`${this.constructor.name} is missing the properties ${missingProperties} inside its credentials for: ${action}.`);
        }
      }
      /**
       * Checks if the given token is valid under the given contextConfig.
       * @param {Token} token
       * @param {SecurityContextConfig} contextConfig
       * @throws {ValidationError} if the token is not valid or could not be validated
      */
      async validateToken(token, contextConfig) {
        if (token.expired) {
          throw new ExpiredTokenError(token);
        }
        if (token.notYetValid) {
          throw new NotYetValidTokenError(token);
        }
        if (!this.acceptsTokenAudience(token)) {
          throw new WrongAudienceError(token, this);
        }
        await this.validateTokenSignature(token, contextConfig);
      }
      /**
       * Checks if the given token's signature is valid under the given contextConfig.
       * @param {Token} token
       * @param {SecurityContextConfig} contextConfig
       * @returns {Promise<void>} resolves when token signature is valid, otherwise error is thrown
       * @throws {ValidationError} if the token signature is not valid or could not be validated
       */
      async validateTokenSignature(token, contextConfig) {
        if (!token.header.kid) {
          throw new MissingKidError(token.header.kid, `Token header contained no kid.`);
        }
        const jwks = await this.getJwks(token, contextConfig);
        const jwk = jwks.get(token.header.kid);
        if (this.signatureCache) {
          jwk.validateSignature(token, this.signatureCache);
        } else {
          jwk.validateSignature(token);
        }
      }
      /**
       * @param {object} [requestOptions]
       * @param {string} [requestOptions.correlationId]
       */
      async getOpenIDConfiguration({ correlationId } = {}) {
        this.validateCredentials("fetch OIDC configuration", "url");
        const cacheKey = createCacheKey({ url: this.credentials.url });
        const buildRequest = () => {
          return (correlationId2) => this.fetchOpenIDConfiguration({ correlationId: correlationId2 });
        };
        return this.oidcCache.getOrRequest(cacheKey, buildRequest, { correlationId });
      }
      /**
       * @param {object} [requestOptions]
       * @param {string} [requestOptions.correlationId]
       */
      async fetchOpenIDConfiguration({ correlationId } = {}) {
        this.validateCredentials("fetch OIDC configuration", "url");
        const oidcUrl = new URL(this.endpoints.oidc_info, this.credentials.url);
        const request = this.buildRequest({
          method: "GET"
        });
        return jsonRequest(oidcUrl, request, { requestName: `${this.constructor.name}.fetchOpenIDConfiguration`, correlationId });
      }
      /**
       * Fetches a token from this service with this service's client credentials.
       * @param {TokenFetchOptions} options
       * @returns {Promise<TokenFetchResponse>} response
       */
      async fetchClientCredentialsToken(options = {}) {
        const grant_type = GRANTTYPE_CLIENTCREDENTIALS;
        const tokenUrl = await this.getTokenUrl(grant_type, options);
        const request = this.buildTokenRequest(grant_type, options);
        return jsonRequest(tokenUrl, request, { requestName: `${this.constructor.name}.fetchClientCredentialsToken`, correlationId: options.correlationId });
      }
      /**
       * Fetches a user token from this service with the given username and password.
       * @param {String} username
       * @param {String} password
       * @param {TokenFetchOptions} options
       * @returns {Promise<TokenFetchResponse>} response
       */
      async fetchPasswordToken(username, password, options = {}) {
        const grant_type = GRANTTYPE_PASSWORD;
        const tokenUrl = await this.getTokenUrl(grant_type, options);
        const request = this.buildTokenRequest(grant_type, options);
        request.body.append("username", username);
        request.body.append("password", password);
        return jsonRequest(tokenUrl, request, { requestName: `${this.constructor.name}.fetchPasswordToken`, correlationId: options.correlationId });
      }
      /**
       * Fetches a JWT bearer token from this service with the given user token as assertion.
       * @param {TokenFetchOptions} options - default timeout is 10 seconds as JWT bearer can be slow
       * @returns {Promise<TokenFetchResponse>} response
       */
      async fetchJwtBearerToken(assertion, options = {}) {
        const grant_type = GRANTTYPE_JWTBEARER;
        const tokenUrl = await this.getTokenUrl(grant_type, options);
        options.timeout ??= DEFAULT_JWT_BEARER_FETCH_TIMEOUT;
        const request = this.buildTokenRequest(grant_type, options);
        request.body.append("assertion", assertion);
        return jsonRequest(tokenUrl, request, { requestName: `${this.constructor.name}.fetchJwtBearerToken`, correlationId: options.correlationId });
      }
      /**
       * Builds a request for this service based on the service configuration and the given request options.
       * For example, the request will use the timeout value from the service configuration if not overridden in the request options.
       *
       * @internal
       * @param {import("node:https").RequestOptions} [requestOptions] - options for the request
       */
      buildRequest(requestOptions) {
        return {
          timeout: this.config.requests.timeout,
          retry: this.config.requests.retry,
          ...requestOptions
        };
      }
      /**
       * Builds a token request for this service with the given grant_type and options.
       *
       * @param {String} grant_type
       * @param {TokenFetchOptions} options
       */
      buildTokenRequest(grant_type, options) {
        const request = this.buildRequest({
          method: "POST",
          body: new URLSearchParams({
            grant_type
          })
        });
        this.addClientAuthentication(request, options);
        if (options.timeout) {
          request.timeout = options.timeout;
        }
        if (options.token_format) {
          request.body.append("token_format", options.token_format);
        }
        return request;
      }
      /**
       * Prepares the given request to use this service's client credentials for authentication.
       * Adds clientid and either clientsecret or an mTLS agent based on client certificate, depending on the type of credentials.
       * @param {RequestInit} request
       * @param {URLSearchParams} request.body
       * @param {TokenFetchOptions} options
       */
      addClientAuthentication(request, options = {}) {
        this.validateCredentials("fetch token", "clientid");
        request.body.append("client_id", this.credentials.clientid);
        if (this.credentials.clientsecret) {
          request.body.append("client_secret", this.credentials.clientsecret);
        } else if (this.credentials.key && this.credentials.certificate) {
          request.agent = new Agent({
            key: this.credentials.key,
            cert: this.credentials.certificate
          });
        } else {
          throw new InvalidCredentialsError("Service credentials contain neither a client secret nor certificate based authentication information.");
        }
      }
      /**
       * Updates the certificate and key in the service credentials for authentication of subsequent requests.
       * @param {String} cert PEM-encoded client certificate
       * @param {String} key PEM-encoded client key
       * @returns {void}
       */
      setCertificateAndKey(cert, key) {
        this.credentials.certificate = cert;
        this.credentials.key = key;
      }
      /**
       * Builds the configuration of this service based on the provided configuration and default values.
       * @param {ServiceConfig} config 
       */
      static buildServiceConfiguration(config) {
        config.endpoints ??= {};
        config.endpoints.oidc_info ??= "/.well-known/openid-configuration";
        config.validation ??= {};
        config.validation.jwks ??= {};
        config.validation.jwks.shared ??= false;
        config.validation.jwks.expirationTime ??= ResponseCache.DEFAULT_EXPIRATION_TIME;
        config.validation.jwks.refreshPeriod ??= ResponseCache.DEFAULT_REFRESH_PERIOD;
        config.validation.signatureCache ??= { enabled: false };
        if (config.validation.signatureCache.enabled === false || config.validation.signatureCache.size === 0) {
          config.validation.signatureCache = { enabled: false };
        } else if (config.validation.signatureCache.impl) {
          config.validation.signatureCache = { impl: config.validation.signatureCache.impl, enabled: true };
        } else {
          config.validation.signatureCache = { ..._Service.DEFAULT_SIGNATURE_CACHE_CONFIG, ...config.validation.signatureCache, enabled: true };
        }
        config.requests ??= {};
        config.requests.timeout = Math.min(MAX_TIMEOUT, config.requests.timeout ?? DEFAULT_TIMEOUT);
        if (config.requests.retry) {
          if (config.requests.retry === true) {
            config.requests.retry = { ..._Service.DEFAULT_RETRY_CONFIG };
          } else {
            config.requests.retry = { ..._Service.DEFAULT_RETRY_CONFIG, ...config.requests.retry };
          }
        }
        return config;
      }
      /**
       * Creates a new {@link SecurityContext} from this service with the given token.
       * @abstract
       * @param {String|Token} token as JWT or Token object
       * @param {SecurityContextConfig} contextConfig
       * @returns {Promise<SecurityContext>} securityContext
       */
      async createSecurityContext(token, contextConfig = {}) {
        throw new ConfigurationError("This abstract function MUST be called on a service-specific implementation.");
      }
      /**
       * Retrieves the JWKS (JSON Web Key Set) for the given token and context configuration.
       *
       * @param {string} token the token for which to retrieve the JWKS.
       * @param {SecurityContextConfig} contextConfig the context configuration object.
       * @returns {Promise<Jwks>} A promise that resolves to the JWKS (JSON Web Key Set) object.
       * @throws {Error} If an error occurs while retrieving the JWKS.
       */
      async getJwks(token, contextConfig) {
        throw new ConfigurationError("This abstract function MUST be called on a service-specific implementation.");
      }
      /**
       * Determines the URL that can be used for fetching tokens of given grant_type from this service.
       * @abstract
       * @param {GrantType} grant_type
       * @param {Object} options
       * @param {String} options.correlationId
       * @returns {Promise<URL>} URL of the service's token endpoint
       */
      async getTokenUrl(grant_type, options = {}) {
        throw new ConfigurationError("This abstract function MUST be called on a service-specific implementation.");
      }
    };
    module2.exports = Service;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/token/IdentityServiceToken.js
var require_IdentityServiceToken2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/token/IdentityServiceToken.js"(exports2, module2) {
    var Token = require_Token2();
    var IdentityServiceToken = class extends Token {
      /**
       * @param {string|null} jwt 
       * @param {object} [content] - optional parsed header and payload
       * @param {import('../util/Types').JwtHeader & { [key: string]: any }} [content.header] - parsed header
       * @param {import('../util/Types').JwtPayload & import('../util/Types').IdentityServiceJwtPayload & { [key: string]: any }} [content.payload] - parsed payload
       */
      constructor(jwt, { header, payload } = {}) {
        super(jwt, { header, payload });
      }
      /**
       * @returns {string} The ID of the caller's tenant within the SAP Cloud Identity Service application for which the token was fetched.
       */
      get appTid() {
        return this.payload.app_tid ?? this.payload.zone_uuid;
      }
      /**
       * Returns the SAP Cloud Identity Service APIs consumed by the caller (based on the token's 'ias_apis' claim).
       * @returns {string[]} The consumed APIs or [] if the caller does not consume any APIs.
       */
      get consumedApis() {
        return this.payload.ias_apis || [];
      }
      get customIssuer() {
        return this.payload.ias_iss ? this.payload.iss : null;
      }
      /** 
       * @returns {string} The issuer of the token.
       */
      get issuer() {
        return this.payload.ias_iss || this.payload.iss;
      }
      /**
       * Returns the SCIM id of the user.
       * @returns {string} The SCIM id or undefined if the token does not contain a SCIM id, e.g. because it is a technical user token.
       */
      get scimId() {
        return this.payload.scim_id;
      }
      // Methods for backward-compatibility
      getAppTID() {
        return this.appTid;
      }
      getCustomIssuer() {
        return this.customIssuer;
      }
      /**
       * @deprecated Access appTid instead
       */
      getZoneId() {
        return this.appTid;
      }
    };
    module2.exports = IdentityServiceToken;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/jwks/Jwk.js
var require_Jwk2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/jwks/Jwk.js"(exports2, module2) {
    var crypto6 = require("crypto");
    var UnsupportedAlgorithmError = require_UnsupportedAlgorithmError2();
    var InvalidTokenSignatureError = require_InvalidTokenSignatureError2();
    var availableHashes = crypto6.getHashes();
    var Jwk = class _Jwk {
      key;
      // key information from JWKS response
      pubKey;
      // Node.Js crypto public key
      nodeAlg;
      // alg as Node.Js crypto name, e.g. RSA-SHA256
      /**
       * Creates a JWK based on a jwk-formatted public key
       * @param {Object} key key information in jwk format
       */
      constructor(key) {
        this.key = key;
        this.pubKey = crypto6.createPublicKey({
          key,
          format: "jwk"
        });
      }
      /**
       * Creates a JWK based on a PEM-formatted public key
       * @param {String} pem public key in PEM format
       * @returns Jwk
       */
      static fromPEM(pem) {
        const cleanedUpPem = _Jwk.cleanUpPemKey(pem);
        const pubKey = crypto6.createPublicKey({
          key: cleanedUpPem,
          format: "pem"
        });
        const jwk = pubKey.export({ format: "jwk" });
        return new _Jwk(jwk);
      }
      /**
       * Validates if the token was signed with the private key that belongs to this public key.
       * If available, uses the signature cache to avoid validating the same signature again on subsequent requests.
       * @param {Token} token 
       * @param {import("../util/Types").Cache} [signatureCache] an optional cache for signature validation results
       * @returns void if the signature is valid
       * @throws {InvalidTokenSignatureError} when signature is invalid
       */
      validateSignature(token, signatureCache) {
        let validationResult = signatureCache?.get(token.jwt);
        if (validationResult == null) {
          validationResult = this.validateSignatureWithoutCache(token);
          signatureCache?.set(token.jwt, validationResult);
        }
        if (validationResult !== true) {
          throw new InvalidTokenSignatureError(token);
        }
      }
      /**
       * Validates if the token was signed with the private key that belongs to this public key without using a cache.
       * @param {Token} token 
       * @returns {boolean} true if the signature is valid, false otherwise
       */
      validateSignatureWithoutCache(token) {
        const nodeAlg = _Jwk.mapAlgToNodeAlg(token.header.alg);
        if (!availableHashes.includes(nodeAlg)) {
          throw new UnsupportedAlgorithmError(token, token.header.alg);
        }
        const [header, payload, signature] = token.jwt.split(".");
        const verifier = crypto6.createVerify(nodeAlg);
        verifier.update(`${header}.${payload}`);
        return verifier.verify(this.pubKey, signature, "base64");
      }
      static mapAlgToNodeAlg(alg) {
        switch (alg?.toUpperCase()) {
          case "RS256":
            return "RSA-SHA256";
          case "RS384":
            return "RSA-SHA384";
          case "RS512":
            return "RSA-SHA512";
          default:
            return null;
        }
      }
      /* 
      * Adds missing line breaks to malformed PEM keys.
      * For backward-compatibility, a specific kind of malformed PEM needs to be supported that is lacking line breaks around the header and footer.
      * This kind of PEM input can occur, for example, in old service bindings of XSA and is not always fixable by consumers of this library.
      */
      static cleanUpPemKey(pem = "") {
        if (!pem.includes("KEY-----\n")) {
          pem = pem.replace("KEY-----", "KEY-----\n");
        }
        if (!pem.includes("\n-----END")) {
          pem = pem.replace("-----END", "\n-----END");
        }
        return pem;
      }
    };
    module2.exports = Jwk;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/jwks/Jwks.js
var require_Jwks2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/jwks/Jwks.js"(exports2, module2) {
    var Jwk = require_Jwk2();
    var MissingKidError = require_MissingKidError2();
    var Jwks = class {
      constructor(keys = []) {
        this.keys = /* @__PURE__ */ Object.create(null);
        for (const k of keys) {
          this.keys[k.kid] = new Jwk(k);
        }
      }
      /**
       * Retrieves the JWK (JSON Web Key) associated with the specified key ID (kid).
       * @param {string} kid - The key ID (kid) of the JWK to retrieve.
       * @returns {Jwk} - The JWK associated with the specified key ID.
       * @throws {MissingKidError} - If the JWKS does not contain a key for the specified key ID.
       */
      get(kid) {
        const jwk = this.keys[kid];
        if (!jwk) throw new MissingKidError(kid, `JWKS does not contain a key for kid=${kid}`);
        return jwk;
      }
    };
    module2.exports = Jwks;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/service/IdentityService.js
var require_IdentityService2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/service/IdentityService.js"(exports2, module2) {
    "use strict";
    var Service = require_Service2();
    var SecurityContext = require_SecurityContext2();
    var IdentityServiceSecurityContext = require_IdentityServiceSecurityContext2();
    var IdentityServiceToken = require_IdentityServiceToken2();
    var Jwks = require_Jwks2();
    var { MissingClientCertificateError, MissingIssuerError, InvalidIssuerError, UntrustedIssuerError, X5tError, ConfigurationError, ResponseError, WrongAudienceError } = require_error2();
    var util = require_util4();
    var { createCacheKey, escapeStringForRegex } = require_util4();
    var { jsonRequest } = require_jsonRequest2();
    var { APP_TID_HEADER, AZP_HEADER, CLIENT_CERTIFICATE_HEADER, CLIENTID_HEADER, HTTPS_SCHEME, SERVICE_PLAN_HEADER, X5T_CNF_CLAIM } = require_constants3();
    var Token = require_Token2();
    var IdentityService = class _IdentityService extends Service {
      /**
       * @param {ServiceCredentials & IdentityServiceCredentials} credentials 
       * @param {ServiceConfig & IdentityServiceConfig} [serviceConfiguration={}]
       */
      constructor(credentials, serviceConfiguration) {
        super(credentials, serviceConfiguration);
      }
      /**
       * @override
       * @param {String|IdentityServiceToken} token token as JWT or IdentityServiceToken object
       * @param {SecurityContextConfig} contextConfig 
       * @returns {Promise<IdentityServiceSecurityContext>}
       */
      async createSecurityContext(token, contextConfig = {}) {
        if (typeof token === "string") {
          token = new IdentityServiceToken(token);
        } else if (token instanceof Token && !(token instanceof IdentityServiceToken)) {
          token = new IdentityServiceToken(token.jwt, { header: token.header, payload: token.payload });
        }
        SecurityContext.buildContextConfig(contextConfig);
        if (contextConfig.skipValidation !== true) {
          if (this.#proofTokenCheckRequired(token) || this.hasX5tEnabled()) {
            if (contextConfig.clientCertificatePem == null) {
              throw new MissingClientCertificateError();
            } else {
              contextConfig.clientCertificate = util.parsePemCertificate(contextConfig.clientCertificatePem);
            }
          }
          await this.validateToken(token, contextConfig);
        }
        const ctx = new IdentityServiceSecurityContext(this, token, contextConfig);
        for (let extension of this.config.context?.extensions || []) {
          await extension.extendSecurityContext(ctx);
        }
        return ctx;
      }
      /**
       * @override
       * @param {IdentityServiceToken} token 
       * @param {SecurityContextConfig} contextConfig 
       */
      async validateToken(token, contextConfig) {
        if (this.hasX5tEnabled()) {
          _IdentityService.validateTokenOwnership(token, contextConfig.clientCertificate);
        }
        await super.validateToken(token, contextConfig);
      }
      /**
       * Retrieves the JWKS (JSON Web Key Set) for the given token and context configuration.
       * 
       * @param {string} token - The token for which to retrieve the JWKS.
       * @param {SecurityContextConfig} contextConfig - The context configuration object.
       * @returns {Promise<Jwks>} - A promise that resolves to the JWKS (JSON Web Key Set) object.
       * @throws {WrongAudienceError} - if the online validation in the JWKS endpoint of the Identity Service instance responds with a 400 status code, indicating that the token should not be accepted by this service.
       * @throws {Error} - If an error occurs while retrieving the JWKS.
       */
      async getJwks(token, contextConfig) {
        this.validateCredentials("fetch JWKS", "clientid", "url");
        const issuerUrl = _IdentityService.getSafeUrlFromTokenIssuer(token, this.credentials.domains);
        const jwksParams = {
          clientid: this.credentials.clientid,
          app_tid: token.appTid,
          azp: token.azp
        };
        const keyParts = { url: issuerUrl, ...jwksParams };
        const proofTokenCheck = this.#proofTokenCheckRequired(token);
        if (proofTokenCheck) {
          keyParts.certSub = contextConfig.clientCertificate?.subject;
          jwksParams.clientCertificatePem = contextConfig.clientCertificatePem?.replaceAll("\\n", "").replaceAll("\n", "");
        }
        const cacheKey = createCacheKey(keyParts);
        const buildJwksRequest = () => {
          const issuerService = issuerUrl === this.credentials.url ? this : new _IdentityService({ url: issuerUrl, clientid: this.credentials.clientid });
          const extractHeaders = proofTokenCheck ? "headers" : null;
          return async (correlationId) => {
            const jwksResponse = await issuerService.fetchJwks(jwksParams, { correlationId, extractHeaders });
            return {
              jwks: new Jwks(jwksResponse.keys),
              servicePlans: proofTokenCheck ? jwksResponse.headers.get(SERVICE_PLAN_HEADER)?.split(",").map((plan) => plan.replaceAll('"', "")) : null
            };
          };
        };
        let cachedResponse;
        try {
          cachedResponse = await this.jwksCache.getOrRequest(cacheKey, buildJwksRequest, { correlationId: contextConfig.correlationId });
        } catch (error) {
          if (error instanceof ResponseError && error.responseCode === 400 && error.request.name === `${this.constructor.name}.fetchJwks`) {
            throw new WrongAudienceError(token, this, `The online validation in the JWKS endpoint of the Identity Service instance responded with 400: '${error.responseText}'. This indicates that the token should not be accepted by this service.`);
          }
          throw error;
        }
        const { jwks, servicePlans } = cachedResponse;
        if (proofTokenCheck) {
          contextConfig.servicePlans = servicePlans;
        }
        return jwks;
      }
      async fetchJwks({ clientid, app_tid, azp, clientCertificatePem }, { correlationId, extractHeaders }) {
        const openIDConfiguration = await this.getOpenIDConfiguration({ correlationId });
        const jwksUrl = openIDConfiguration.jwks_uri;
        const request = this.buildRequest({
          method: "GET",
          headers: {
            [CLIENTID_HEADER]: clientid
          }
        });
        if (app_tid != null) {
          request.headers[APP_TID_HEADER] = app_tid;
        }
        if (azp != null) {
          request.headers[AZP_HEADER] = azp;
        }
        if (clientCertificatePem != null) {
          request.headers[CLIENT_CERTIFICATE_HEADER] = clientCertificatePem;
        }
        return jsonRequest(jwksUrl, request, { requestName: `${this.constructor.name}.fetchJwks`, correlationId, extractHeaders });
      }
      // Re-declare JSDoc for token fetches with detailed options and return object properties
      /**
       * Fetches a token from this service with this service's client credentials.
       * @param {TokenFetchOptions & IdentityServiceTokenFetchOptions} options
       * @returns {Promise<TokenFetchResponse>}
       */
      async fetchClientCredentialsToken(options = {}) {
        return super.fetchClientCredentialsToken(options);
      }
      /**
       * Fetches a user token from this service with the given username and password.
       * @param {String} username
       * @param {String} password
       * @param {TokenFetchOptions & IdentityServiceTokenFetchOptions} options      
       * @returns {Promise<TokenFetchResponse & IdTokenFetchResponse & RefreshableTokenFetchResponse>}
       */
      async fetchPasswordToken(username, password, options = {}) {
        return super.fetchPasswordToken(username, password, options);
      }
      /**
       * Fetches a JWT bearer token from this service with the given user token as assertion.
       * @param {String} assertion JWT bearer token used as assertion   
       * @param {TokenFetchOptions & IdentityServiceTokenFetchOptions} options      
       * @returns {Promise<TokenFetchResponse & IdTokenFetchResponse & RefreshableTokenFetchResponse>}
       */
      async fetchJwtBearerToken(assertion, options = {}) {
        return super.fetchJwtBearerToken(assertion, options);
      }
      /** @override */
      buildTokenRequest(grant_type, options) {
        const request = super.buildTokenRequest(grant_type, options);
        if (options.resource) {
          [options.resource].flatMap((r) => r).forEach((resource) => request.body.append("resource", resource));
        }
        return request;
      }
      /**
       * Prepares the given formData and fetch options to use this service's client credentials for authentication.
       * Adds clientid, app_tid and either clientsecret or an mTLS agent based on client certificate, depending on the type of credentials.
       * @param {RequestInit} request 
       * @param {URLSearchParams} request.body
       * @param {TokenFetchOptions} options
       * @override
       */
      addClientAuthentication(request, options = {}) {
        super.addClientAuthentication(request, options);
        const app_tid = options.app_tid ?? this.credentials.app_tid;
        if (app_tid != null) {
          request.body.append("app_tid", app_tid);
        }
      }
      /**
       * @override
       * @inheritdoc
       */
      async getTokenUrl(grant_type, options = {}) {
        const { correlationId } = options;
        const openidConfiguration = await this.getOpenIDConfiguration({ correlationId });
        if (!openidConfiguration.grant_types_supported.includes(grant_type)) {
          throw new ConfigurationError(`This Identity Service instance does not support grant type ${grant_type} according to its openid-configuration.`);
        }
        return new URL(openidConfiguration.token_endpoint);
      }
      /** 
       * Returns whether proof token validation has been enabled via the service's configuration.
       * @returns {Boolean}
       */
      hasProofTokenEnabled() {
        return this.config.validation?.proofToken?.enabled;
      }
      /** 
       * Returns whether x5t proof of token ownership validation has been enabled via the service's configuration.
       * @returns {Boolean}
       */
      hasX5tEnabled() {
        return this.config.validation?.x5t?.enabled;
      }
      /**
       * Returns whether a proof token check has to be done for the given token.
       * The decision depends on the type of token.
       * Tokens with claim ias_api are App2App tokens for which a proof token check must not be done, even when enabled via the configuration.
       * @param {IdentityServiceToken} token 
       */
      #proofTokenCheckRequired(token) {
        return this.hasProofTokenEnabled() && token.payload.ias_apis == null;
      }
      /**
       * Returns an issuer URL based on the issuer of the token if it can be succesfully validated against a list of trusted domains.
       * @param {IdentityServiceToken} token token from which issuer is extracted
       * @param {Array<string>} trustedDomains a list of trusted domains
       * @returns {String} URL of issuer if its domain is either a trusted domain or a subdomain of a trusted domain
       * @throws {UntrustedIssuerError} if issuer is empty, not trusted or not a valid URL
       */
      static getSafeUrlFromTokenIssuer = function(token, trustedDomains = []) {
        const issuer = token?.issuer;
        if (!issuer) {
          throw new MissingIssuerError(token);
        }
        const issuerUrl = issuer.startsWith(HTTPS_SCHEME) ? issuer : `${HTTPS_SCHEME}${issuer}`;
        try {
          new URL(issuerUrl);
        } catch (e) {
          throw new InvalidIssuerError(token, e);
        }
        const issuerDomain = issuerUrl.substring(HTTPS_SCHEME.length);
        for (let d of trustedDomains) {
          const validSubdomainPattern = `^[a-zA-Z0-9-]{1,63}\\.${escapeStringForRegex(d)}$`;
          if (issuerDomain === d || issuerDomain.match(new RegExp(validSubdomainPattern))) {
            return issuerUrl;
          }
        }
        throw new UntrustedIssuerError(token);
      };
      /**
       * Validates that the client owning the given certificate is the owner of the token.
       * The validation is based on proof-of-posession via certificate binding of tokens as described in {@link https://datatracker.ietf.org/doc/html/rfc8705 RFC 8705}.
       * The validation is succesful if the token contains an base64url-encoded x5t thumbprint under claim {@link CNF_X5T_CLAIM cnf.x5t#S256} that matches the given certificate.
       * The client certificate against which the validation is performed, is typically extracted from the {@link FWD_CLIENT_CERT_HEADER x-forwarded-client-cert} request header where it is put by BTP after TLS termination.
       * @param {IdentityServiceToken} token 
       * @param {X509Certificate} cert client certificate parsed as X509Certificate
       */
      static validateTokenOwnership(token, cert) {
        const tokenX5t = token.payload.cnf?.[X5T_CNF_CLAIM];
        if (!tokenX5t) {
          throw new X5tError(token, cert, "X5t validation failed because x5t thumbprint could not be found in token.");
        }
        let certificateX5t;
        try {
          certificateX5t = Buffer.from(cert.fingerprint256.replaceAll(":", ""), "hex").toString("base64url");
        } catch (e) {
          throw new X5tError(token, cert, "x5t validation failed because x5t thumbprint could not be calculated from client certificate.");
        }
        if (tokenX5t !== certificateX5t) {
          throw new X5tError(token, cert, "x5t thumbprint did not match the thumbprint of the provided client certificate.");
        }
      }
    };
    module2.exports = IdentityService;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/token/XsuaaToken.js
var require_XsuaaToken2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/token/XsuaaToken.js"(exports2, module2) {
    var Token = require_Token2();
    var XsuaaToken = class extends Token {
      /**
       * @param {string|null} jwt 
       * @param {object} [content] - optional parsed header and payload
       * @param {import('../util/Types').JwtHeader & { [key: string]: any }} [content.header] - parsed header
       * @param {import('../util/Types').JwtPayload & import('../util/Types').XsuaaJwtPayload & { [key: string]: any }} [content.payload] - parsed payload
       */
      constructor(jwt, { header, payload } = {}) {
        super(jwt, { header, payload });
      }
      get azAttributes() {
        return this.payload.az_attr;
      }
      get extAttributes() {
        return this.payload.ext_attr;
      }
      get logonName() {
        return this.payload.user_name;
      }
      /**
       * @returns {string[]} the scopes of the token
       */
      get scopes() {
        return this.payload.scope ?? [];
      }
      get serviceInstanceId() {
        return this.payload.ext_attr?.serviceinstanceid;
      }
      get subAccountId() {
        return this.payload.ext_attr?.subaccountid || this.zid;
      }
      get userId() {
        return super.userId || this.payload.sub;
      }
      get xsUserAttributes() {
        return this.payload.ext_cxt?.["xs.user.attributes"] ?? this.payload["xs.user.attributes"];
      }
      get xsSystemAttributes() {
        return this.payload.ext_cxt?.["xs.system.attributes"] ?? this.payload["xs.system.attributes"];
      }
      /**
       * @returns {string} The zone id of the token.
       */
      get zid() {
        return this.payload.zid;
      }
      getXsUserAttribute(name) {
        return this.xsUserAttributes?.[name];
      }
      // Methods for backward-compatibility
      getAppTID() {
        return this.zid;
      }
      getCustomIssuer() {
        return this.issuer;
      }
      getZoneId() {
        return this.zid;
      }
    };
    module2.exports = XsuaaToken;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/service/XsuaaService.js
var require_XsuaaService2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/service/XsuaaService.js"(exports2, module2) {
    "use strict";
    var Service = require_Service2();
    var SecurityContext = require_SecurityContext2();
    var XsuaaSecurityContext = require_XsuaaSecurityContext2();
    var XsuaaToken = require_XsuaaToken2();
    var Jwks = require_Jwks2();
    var { jsonRequest } = require_jsonRequest2();
    var { HTTPS_SCHEME, ZID_QUERY_PARAMETER, ZID_HEADER } = require_constants3();
    var { createCacheKey } = require_util4();
    var { ResponseError, WrongAudienceError } = require_error2();
    var Token = require_Token2();
    var XsuaaService = class extends Service {
      #jwksBaseUrl;
      // base URL from which the JWKS is fetched
      /**
       * @param {ServiceCredentials & XsuaaServiceCredentials} credentials 
       * @param {ServiceConfig} [serviceConfig={}] 
       */
      constructor(credentials, serviceConfig) {
        serviceConfig ??= {};
        serviceConfig.endpoints ??= {};
        serviceConfig.endpoints.oidc_info ??= "/.well-known/openid-configuration";
        serviceConfig.endpoints.jwks ??= "/token_keys";
        serviceConfig.endpoints.token ??= "/oauth/token";
        super(credentials, serviceConfig);
      }
      /**
       * @overrides
       * @inheritdoc
       */
      acceptsTokenAudience(token) {
        this.validateCredentials("validate token audience", "clientid", "xsappname");
        if (!(token instanceof XsuaaToken)) {
          token = new XsuaaToken(null, { header: token.header, payload: token.payload });
        }
        let audiencesToConsider;
        if (token.audiences?.length > 0) {
          audiencesToConsider = [...token.audiences];
        } else if (token.scopes) {
          audiencesToConsider = [...token.scopes];
        } else {
          audiencesToConsider = [];
        }
        if (token.payload.cid) {
          audiencesToConsider.push(token.payload.cid);
        }
        return audiencesToConsider.some((a) => a === this.credentials.clientid || a.startsWith(`${this.credentials.clientid}.`)) || audiencesToConsider.some((a) => a === this.credentials.xsappname || a.startsWith(`${this.credentials.xsappname}.`)) || this.credentials.clientid.includes("!b") && audiencesToConsider.some((a) => a.endsWith(`|${this.credentials.xsappname}`));
      }
      /**
       * @override
       * @param {String|XsuaaToken} token as JWT or XsuaaToken object
       * @param {SecurityContextConfig} contextConfig 
       * @returns {Promise<XsuaaSecurityContext}
       */
      async createSecurityContext(token, contextConfig = {}) {
        if (typeof token === "string") {
          token = new XsuaaToken(token);
        } else if (token instanceof Token && !(token instanceof XsuaaToken)) {
          token = new XsuaaToken(token.jwt, { header: token.header, payload: token.payload });
        }
        SecurityContext.buildContextConfig(contextConfig);
        if (contextConfig.skipValidation !== true) {
          await this.validateToken(token, contextConfig);
        }
        const ctx = new XsuaaSecurityContext(this, token, contextConfig);
        for (let extension of this.config.context?.extensions || []) {
          await extension.extendSecurityContext(ctx);
        }
        return ctx;
      }
      async getJwks(token, contextConfig) {
        const jwksParams = {
          zid: token.zid
        };
        const keyParts = { url: this.jwksBaseUrl, ...jwksParams };
        const cacheKey = createCacheKey(keyParts);
        const buildJwksRequest = () => {
          return async (correlationId) => {
            const jwksResponse = await this.fetchJwks({ ...jwksParams, correlationId });
            return new Jwks(jwksResponse.keys);
          };
        };
        let jwks;
        try {
          jwks = await this.jwksCache.getOrRequest(cacheKey, buildJwksRequest, { correlationId: contextConfig.correlationId });
        } catch (error) {
          if (error instanceof ResponseError && error.responseCode === 400) {
            throw new WrongAudienceError(token, this, `The online validation in the JWKS endpoint of the XSUAA server responded with 400: '${error.responseText}'. This indicates that the token should not be accepted by this service.`);
          }
          throw error;
        }
        return jwks;
      }
      /**
       * @internal
       * Returns the base URL (https protocol + uaadomain from the credentials) that can be used for JWKS fetches.
       * @returns {String} base URL for JWKS fetches
       */
      get jwksBaseUrl() {
        if (!this.#jwksBaseUrl) {
          this.validateCredentials("fetch JWKS", "uaadomain");
          const { uaadomain } = this.credentials;
          if (uaadomain.startsWith(HTTPS_SCHEME)) {
            this.#jwksBaseUrl = uaadomain;
          } else {
            this.#jwksBaseUrl = `${HTTPS_SCHEME}${uaadomain}`;
          }
        }
        return this.#jwksBaseUrl;
      }
      async fetchJwks(jwksParams, correlationId) {
        const jwksUrl = new URL(this.jwksBaseUrl + this.endpoints.jwks);
        if (jwksParams.zid) {
          jwksUrl.searchParams.append(ZID_QUERY_PARAMETER, jwksParams.zid);
        }
        const request = this.buildRequest({
          method: "GET"
        });
        return jsonRequest(jwksUrl, request, { requestName: `${this.constructor.name}.fetchJwks`, correlationId });
      }
      // Re-declare JSDoc for token fetches with detailed options and return object properties
      /**
       * Fetches a token from this service with this service's client credentials.
       * @param {TokenFetchOptions & XsuaaTokenFetchOptions} options
       * @returns {Promise<TokenFetchResponse>} response
       */
      async fetchClientCredentialsToken(options = {}) {
        return super.fetchClientCredentialsToken(options);
      }
      /**
       * Fetches a user token from this service with the given username and password.
       * @param {String} username
       * @param {String} password
       * @param {TokenFetchOptions & XsuaaTokenFetchOptions} options
       * @returns {Promise<TokenFetchResponse & RefreshableTokenFetchResponse>} response
       */
      async fetchPasswordToken(username, password, options = {}) {
        return super.fetchPasswordToken(username, password, options);
      }
      /**
       * Fetches a JWT bearer token from this service with the given user token as assertion.
       * @param {String} assertion JWT bearer token used as assertion   
       * @param {TokenFetchOptions & XsuaaTokenFetchOptions} options
       * @returns {Promise<TokenFetchResponse & RefreshableTokenFetchResponse>} response
       */
      async fetchJwtBearerToken(assertion, options = {}) {
        return super.fetchJwtBearerToken(assertion, options);
      }
      /** @override */
      buildTokenRequest(grant_type, options) {
        const request = super.buildTokenRequest(grant_type, options);
        if (options.scope) {
          request.body.append("scope", options.scope);
        }
        if (options.authorities) {
          request.body.append("authorities", JSON.stringify({ az_attr: options.authorities }));
        }
        if (options.zid) {
          request.headers ??= {};
          request.headers[ZID_HEADER] = options.zid;
        }
        return request;
      }
      /**
       * Determines the URL that can be used for fetching tokens from this service, optionally adjusted for a tenant in the same subaccount.
       * @override
       * @inheritdoc
       * @param {GrantType} grant_type
       * @param {String} options.tenant
       */
      async getTokenUrl(grant_type, options = {}) {
        const { tenant } = options;
        let baseUrl;
        if (tenant) {
          this.validateCredentials("build token fetch URL for custom tenant subdomain", "uaadomain");
          const uaaDomain = this.credentials.certificate ? this.credentials.uaadomain.replace("authentication.", "authentication.cert.") : this.credentials.uaadomain;
          baseUrl = `${HTTPS_SCHEME}${tenant}.${uaaDomain}`;
        } else {
          if (this.credentials.certificate) {
            this.validateCredentials("fetch token via certificate authentication", "certurl");
            baseUrl = this.credentials.certurl;
          } else {
            this.validateCredentials("fetch token via client secret authentication", "url");
            baseUrl = this.credentials.url;
          }
        }
        return new URL(this.endpoints.token, baseUrl);
      }
    };
    module2.exports = XsuaaService;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/token/XsaToken.js
var require_XsaToken2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/token/XsaToken.js"(exports2, module2) {
    var XsuaaToken = require_XsuaaToken2();
    var XsaToken = class extends XsuaaToken {
    };
    module2.exports = XsaToken;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/service/XsaService.js
var require_XsaService2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/service/XsaService.js"(exports2, module2) {
    "use strict";
    var SecurityContext = require_SecurityContext2();
    var XsaSecurityContext = require_XsaSecurityContext2();
    var XsaToken = require_XsaToken2();
    var Jwk = require_Jwk2();
    var MissingKidError = require_MissingKidError2();
    var MissingVerificationKeyError = require_MissingVerificationKeyError2();
    var { getLogger } = require_logging2();
    var XsuaaService = require_XsuaaService2();
    var Token = require_Token2();
    var LOG = getLogger("XsaService.js");
    var XsaService = class extends XsuaaService {
      /**
       * @param {ServiceCredentials & XsaServiceCredentials} credentials 
       * @param {ServiceConfig} [serviceConfig={}]
       */
      constructor(credentials, serviceConfig) {
        super(credentials, serviceConfig);
      }
      /**
       * @override
       * @param {String|XsaToken} token token as JWT or XsaToken object
       * @param {SecurityContextConfig} contextConfig 
       * @returns {Promise<XsaSecurityContext>}
       */
      async createSecurityContext(token, contextConfig = {}) {
        if (typeof token === "string") {
          token = new XsaToken(token);
        } else if (token instanceof Token && !(token instanceof XsaToken)) {
          token = new XsaToken(token.jwt, { header: token.header, payload: token.payload });
        }
        SecurityContext.buildContextConfig(contextConfig);
        if (contextConfig.skipValidation !== true) {
          await this.validateToken(token, contextConfig);
        }
        const ctx = new XsaSecurityContext(this, token, contextConfig);
        for (let extension of this.config.context?.extensions || []) {
          await extension.extendSecurityContext(ctx);
        }
        return ctx;
      }
      async validateTokenSignature(token, contextConfig) {
        const pemKeyFromConfig = this.credentials.verificationkey;
        if (!token.header.jku || !token.header.kid || token.header.kid == "legacy-token-key") {
          LOG.info("Token header contained no JKU or KID or the KID was 'legacy-token-key'");
          return this.#validateTokenSignatureWithFallback(token, pemKeyFromConfig);
        }
        try {
          await super.validateTokenSignature(token, contextConfig);
        } catch (error) {
          if (error instanceof MissingKidError) {
            LOG.info("JWKS did not contain kid.");
            return this.#validateTokenSignatureWithFallback(token, pemKeyFromConfig);
          } else {
            throw error;
          }
        }
      }
      #validateTokenSignatureWithFallback(token, pemKeyFromConfig) {
        if (!pemKeyFromConfig) {
          throw new MissingVerificationKeyError();
        } else {
          LOG.info("Validating token signature with verificationkey from service configuration.");
          return Jwk.fromPEM(pemKeyFromConfig).validateSignature(token);
        }
      }
      /**
       * Fetches a token from this service with this service's client credentials.
       * @param {TokenFetchOptions} options
       * @returns {Promise<TokenFetchResponse>} response
       */
      async fetchClientCredentialsToken(options = {}) {
        return super.fetchClientCredentialsToken(options);
      }
      /**
       * Fetches a user token from this service with the given username and password.
       * @param {String} username
       * @param {String} password
       * @param {TokenFetchOptions} options
       * @returns {Promise<TokenFetchResponse & RefreshableTokenFetchResponse>} response
       */
      async fetchPasswordToken(username, password, options = {}) {
        return super.fetchPasswordToken(username, password, options);
      }
      /**
       * Fetches a JWT bearer token from this service with the given user token as assertion.
       * @param {String} assertion JWT bearer token used as assertion   
       * @param {TokenFetchOptions} options
       * @returns {Promise<TokenFetchResponse & RefreshableTokenFetchResponse>} response
       */
      async fetchJwtBearerToken(assertion, options = {}) {
        return super.fetchJwtBearerToken(assertion, options);
      }
      /**
       * Determines the URL that can be used for fetching tokens from this service.
       * @param {GrantType} grant_type
       */
      async getTokenUrl(grant_type) {
        let baseUrl;
        if (this.credentials.certificate) {
          this.validateCredentials("fetch token via certificate authentication", "certurl");
          baseUrl = this.credentials.certurl;
        } else {
          this.validateCredentials("fetch token via client secret authentication", "url");
          baseUrl = this.credentials.url;
        }
        return new URL(this.endpoints.token, baseUrl);
      }
      /**
       * @override
       * @inheritdoc
       */
      get jwksBaseUrl() {
        this.validateCredentials("fetch JWKS", "url");
        return this.credentials.url;
      }
    };
    module2.exports = XsaService;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/token/UaaToken.js
var require_UaaToken2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/token/UaaToken.js"(exports2, module2) {
    var XsuaaToken = require_XsuaaToken2();
    var UaaToken = class extends XsuaaToken {
    };
    module2.exports = UaaToken;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/service/UaaService.js
var require_UaaService2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/service/UaaService.js"(exports2, module2) {
    "use strict";
    var SecurityContext = require_SecurityContext2();
    var UaaSecurityContext = require_UaaSecurityContext2();
    var Token = require_Token2();
    var UaaToken = require_UaaToken2();
    var XsuaaService = require_XsuaaService2();
    var UaaService = class extends XsuaaService {
      /**
       * @param {ServiceCredentials | UaaServiceCredentials} credentials 
       * @param {ServiceConfig} [serviceConfig={}]
       */
      constructor(credentials, serviceConfig) {
        super(credentials, serviceConfig);
      }
      /**
       * @override
       * @param {String|UaaToken} token token as JWT or UaaToken object
       * @param {SecurityContextConfig} contextConfig 
       * @returns {Promise<UaaSecurityContext>}
       */
      async createSecurityContext(token, contextConfig = {}) {
        if (typeof token === "string") {
          token = new UaaToken(token);
        } else if (token instanceof Token && !(token instanceof UaaToken)) {
          token = new UaaToken(token.jwt, { header: token.header, payload: token.payload });
        }
        SecurityContext.buildContextConfig(contextConfig);
        if (contextConfig.skipValidation !== true) {
          await this.validateToken(token, contextConfig);
        }
        const ctx = new UaaSecurityContext(this, token, contextConfig);
        for (let extension of this.config.context?.extensions || []) {
          await extension.extendSecurityContext(ctx);
        }
        return ctx;
      }
      /**
      * @overrides
      * @inheritdoc
      */
      acceptsTokenAudience(token) {
        this.validateCredentials("validate token audience", "clientid");
        if (!(token instanceof UaaToken)) {
          token = new UaaToken(null, { header: token.header, payload: token.payload });
        }
        const tokenAudiences = token.audiences?.length > 0 ? token.audiences : token.scopes ?? [];
        if (token.payload.cid) {
          tokenAudiences.push(token.payload.cid);
        }
        return tokenAudiences.some((a) => a === this.credentials.clientid || a.startsWith(`${this.credentials.clientid}.`));
      }
    };
    module2.exports = UaaService;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/passport/XssecPassportStrategy.js
var require_XssecPassportStrategy2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/passport/XssecPassportStrategy.js"(exports2, module2) {
    var createSecurityContext = require_createSecurityContext2();
    var ConfigurationError = require_ConfigurationError2();
    var ValidationError = require_ValidationError2();
    var { getLogger } = require_logging2();
    var LOG = getLogger("XssecPassportStrategy.js");
    var XssecPassportStrategy = class _XssecPassportStrategy {
      /** @type {Service|Service[]} service(s) against which incoming JWTs are authenticated */
      services;
      /** @type {string|Symbol} the property on the req object where the SecurityContext is placed after authentication. */
      reqProperty;
      /**
       * Creates a new XssecPassportStrategy that uses the provided service(s) to create security contexts for incoming requests.
       * @param {Service|Service[]} services 
       * @param {string|Symbol} [reqProperty="securityContext"] the property (Default: "securityContext") on the req object where the SecurityContext is placed after authentication.
       */
      constructor(services, reqProperty = "securityContext") {
        this.name = "JWT";
        this.services = services;
        this.reqProperty = reqProperty;
      }
      async authenticate(req, passportOptions = {}) {
        try {
          const securityContext = await createSecurityContext(this.services, { req });
          if (passportOptions.scope) {
            if (!(typeof securityContext.checkScope === "function")) {
              return this.error(new ConfigurationError("XssecPassportStrategy was configured with scope but the authentication was performed via a Service whose SecurityContext does not support checkLocalScope."));
            }
            const hasScope = [passportOptions.scope].flatMap((s) => s).some((s) => securityContext.checkLocalScope(s));
            if (!hasScope) {
              return this.fail("Token is missing required scope.", 403);
            }
          }
          const passportUser = _XssecPassportStrategy.#buildPassportUser(securityContext.token);
          req[this.reqProperty] = securityContext;
          req.tokenInfo = securityContext.token;
          return this.success(passportUser, securityContext);
        } catch (error) {
          req.xssecError = error;
          if (error instanceof ValidationError) {
            LOG.debug("ValidationError:", error);
            return this.fail(401);
          } else {
            return this.error(error);
          }
        }
      }
      /**
       * @param {Token} token 
       */
      static #buildPassportUser(token) {
        return {
          id: token.logonName || token.userName,
          name: {
            givenName: token.givenName,
            familyName: token.familyName
          },
          emails: [
            {
              value: token.email
            }
          ]
        };
      }
    };
    module2.exports = XssecPassportStrategy;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/v3/createService.js
var require_createService2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/v3/createService.js"(exports2, module2) {
    var IdentityService = require_IdentityService2();
    var XsuaaService = require_XsuaaService2();
    var XsaService = require_XsaService2();
    var UaaService = require_UaaService2();
    module2.exports = createServiceFromCredentials;
    function createServiceFromCredentials(credentials, serviceConfiguration) {
      if (credentials.xsappname && credentials.uaadomain) {
        return new XsuaaService(credentials, serviceConfiguration);
      } else if (credentials.xsappname && credentials.uaadomain == null) {
        return new XsaService(credentials, serviceConfiguration);
      } else if (credentials.xsappname == null && credentials.uaadomain) {
        return new UaaService(credentials, serviceConfiguration);
      } else {
        return new IdentityService(credentials, serviceConfiguration);
      }
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/v3/createSecurityContextV3.js
var require_createSecurityContextV32 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/v3/createSecurityContextV3.js"(exports2, module2) {
    var createSecurityContext = require_createSecurityContext2();
    var ConfigurationError = require_ConfigurationError2();
    var { getLogger } = require_logging2();
    var XsuaaService = require_XsuaaService2();
    var IdentityService = require_IdentityService2();
    var UaaService = require_IdentityService2();
    var createServiceFromCredentials = require_createService2();
    var ValidationError = require_ValidationError2();
    var XsaService = require_XsaService2();
    var LOG = getLogger("createSecurityContextV3.js");
    async function createSecurityContextV3(jwt, configParameter, forceType, cb) {
      if (typeof forceType === "function") {
        cb = forceType;
        forceType = null;
      }
      if (cb == null || typeof cb !== "function") {
        throw new ConfigurationError("The callback parameter must be a function.");
      }
      let securityContext;
      try {
        if (configParameter == null) {
          throw new ConfigurationError("The configParameter parameter must not be null or undefined.");
        } else if (jwt == null) {
          throw new ConfigurationError("The jwt parameter must not be null or undefined.");
        }
        const contextConfig = buildContextConfig(configParameter, jwt);
        const serviceConfig = buildServiceConfig(configParameter);
        const services = buildServices(contextConfig.credentials, forceType, serviceConfig);
        securityContext = await createSecurityContext(services, contextConfig);
      } catch (error) {
        if (error instanceof ValidationError) {
          return cb(error, null, { isValid: () => false, getErrorObject: () => error });
        }
        return cb(error);
      }
      return cb(null, securityContext, securityContext.token);
    }
    function buildContextConfig(configParameter, jwt) {
      const contextConfig = configParameter.credentials ? configParameter : { credentials: configParameter };
      contextConfig.jwt = jwt;
      contextConfig.correlationId ??= contextConfig.credentials.correlationId;
      contextConfig.clientCertificatePem ??= contextConfig.x509Certificate ?? contextConfig.credentials.x509Certificate;
      return contextConfig;
    }
    function buildServiceConfig(configParameter) {
      const serviceConfig = {};
      serviceConfig.endpoints ??= configParameter.endpoints || {};
      serviceConfig.validation ??= configParameter.validation || {};
      serviceConfig.validation.x5t ??= {};
      serviceConfig.validation.x5t.enabled ??= configParameter.x5tValidation;
      serviceConfig.validation.jwks ??= configParameter.jwksCache || {};
      serviceConfig.validation.jwks.shared = true;
      if (configParameter.disableCache) {
        LOG.warn(`The 'disableCache' option to disable the JWKS cache is not supported by the v3 compatibility package. The cache is always enabled.`);
      }
      return serviceConfig;
    }
    function buildServices(credentials, forceType, serviceConfig) {
      const credentialsArray = Array.isArray(credentials) ? credentials : [credentials];
      insertXsAppnameFromEnv(credentialsArray);
      if (forceType) {
        LOG.info(`forceType === ${forceType}. Creating ${forceType} service(s) from credentials.`);
      }
      switch (forceType) {
        case "XSUAA":
          return credentialsArray.map((c) => new XsuaaService(c, serviceConfig));
        case "XSA":
          return credentialsArray.map((c) => new XsaService(c, serviceConfig));
        case "IAS":
          return credentialsArray.map((c) => new IdentityService(c, serviceConfig));
        case "UAA":
          return credentialsArray.map((c) => new UaaService(c, serviceConfig));
        case null:
        case void 0:
        default:
          return credentialsArray.map((c) => createServiceFromCredentials(c, serviceConfig));
      }
    }
    function insertXsAppnameFromEnv(credentials) {
      if (process.env.XSAPPNAME) {
        for (const c of credentials) {
          c.xsappname = process.env.XSAPPNAME;
        }
      }
    }
    module2.exports = createSecurityContextV3;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/v3/requestsV3.js
var require_requestsV32 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/v3/requestsV3.js"(exports2, module2) {
    var IdentityService = require_IdentityService2();
    var XsuaaService = require_XsuaaService2();
    async function requestClientCredentialsToken(subdomain, config, additionalAttributes, zoneId, cb) {
      if (typeof zoneId === "function") {
        cb = zoneId;
        zoneId = null;
      }
      const credentials = config.credentials ?? config;
      const service = config.type?.toUpperCase() === "IAS" ? new IdentityService(credentials) : new XsuaaService(credentials);
      const options = {
        authorities: additionalAttributes,
        correlationId: config.correlationId,
        resource: config.resource,
        scope: config.scopes,
        tenant: subdomain,
        timeout: config.timeout,
        app_tid: zoneId
      };
      try {
        const response = await service.fetchClientCredentialsToken(options);
        return cb(null, response.access_token, response);
      } catch (e) {
        return cb(e);
      }
    }
    async function requestPasswordUserToken(subdomain, config, additionalAttributes, cb) {
      const credentials = config.credentials ?? config;
      const service = config.type?.toUpperCase() === "IAS" ? new IdentityService(credentials) : new XsuaaService(credentials);
      const options = {
        authorities: additionalAttributes,
        correlationId: config.correlationId,
        resource: config.resource,
        scope: config.scopes,
        tenant: subdomain,
        timeout: config.timeout
      };
      try {
        const response = await service.fetchPasswordToken(config.username, config.password, options);
        return cb(null, config.type?.toUpperCase() === "IAS" ? response.id_token : response.access_token, response);
      } catch (e) {
        return cb(e);
      }
    }
    async function requestUserToken(appToken, config, additionalAttributes, scopes, subdomain, zoneId, cb) {
      if (typeof zoneId === "function") {
        cb = zoneId;
        zoneId = null;
      }
      const credentials = config.credentials ?? config;
      const service = config.type?.toUpperCase() === "IAS" ? new IdentityService(credentials) : new XsuaaService(credentials);
      const options = {
        authorities: additionalAttributes,
        correlationId: config.correlationId,
        resource: config.resource,
        scope: scopes ?? config.scopes,
        tenant: subdomain,
        timeout: config.timeout,
        app_tid: zoneId,
        zid: zoneId
      };
      try {
        const response = await service.fetchJwtBearerToken(appToken, options);
        return cb(null, config.type?.toUpperCase() === "IAS" ? response.id_token : response.access_token, response);
      } catch (e) {
        return cb(e);
      }
    }
    module2.exports = {
      requestClientCredentialsToken,
      requestPasswordUserToken,
      requestUserToken
    };
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/v3/constantsV3.js
var require_constantsV32 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/v3/constantsV3.js"(exports2) {
    Object.defineProperty(exports2, "XSAPPNAMEPREFIX", {
      value: "$XSAPPNAME.",
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "SYSTEM", {
      value: "System",
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "JOBSCHEDULER", {
      value: "JobScheduler",
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "HDB", {
      value: "HDB",
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "GRANTTYPE_AUTHCODE", {
      value: "authorization_code",
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "GRANTTYPE_PASSWORD", {
      value: "password",
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "GRANTTYPE_CLIENTCREDENTIAL", {
      value: "client_credentials",
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "GRANTTYPE_USERTOKEN", {
      value: "user_token",
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "GRANTTYPE_SAML2BEARER", {
      value: "urn:ietf:params:oauth:grant-type:saml2-bearer",
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "TYPE_USER_TOKEN", {
      value: 0,
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "TYPE_CLIENT_CREDENTIALS_TOKEN", {
      value: 1,
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "USER_AGENT", {
      value: "nodejs-xssec-3",
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "FWD_CLIENT_CERT_HEADER", {
      value: "x-forwarded-client-cert",
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "CNF_X5T_CLAIM", {
      value: "x5t#S256",
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "PEM_HEADER", {
      value: "-----BEGIN CERTIFICATE-----",
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "PEM_FOOTER", {
      value: "-----END CERTIFICATE-----",
      enumerable: true,
      writable: false,
      configurable: false
    });
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/v3/XssecPassportStrategyV3.js
var require_XssecPassportStrategyV32 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/v3/XssecPassportStrategyV3.js"(exports2, module2) {
    "use strict";
    var createSecurityContext = require_createSecurityContextV32();
    var { getLogger } = require_logging2();
    var { FWD_CLIENT_CERT_HEADER } = require_constantsV32();
    var LOG = getLogger("XssecPassportStrategyV3.js");
    function JWTStrategy(options, forceType) {
      this.options = options;
      this.name = "JWT";
      this._forceType = forceType;
    }
    function SimpleError(errorStr) {
      const errobj = new Error(errorStr);
      this.getErrorObject = function() {
        return errobj;
      };
    }
    JWTStrategy.prototype.authenticate = function(req, passportOptions) {
      var authorization = req.headers.authorization;
      const authParams = passportOptions;
      if (!authorization) {
        LOG.debug("Missing Authorization header");
        req.tokenInfo = new SimpleError("Missing Authorization header");
        return this.fail(401);
      }
      var parts = authorization.split(" ");
      if (parts.length < 2) {
        LOG.debug("Invalid Authorization header format");
        req.tokenInfo = new SimpleError("Invalid Authorization header format");
        return this.fail(400);
      }
      var scheme = parts[0];
      var token = parts[1];
      if (scheme.toLowerCase() !== "bearer") {
        LOG.debug("Authorization header is not a Bearer token");
        req.tokenInfo = new SimpleError("Authorization header is not a Bearer token");
        return this.fail(401);
      }
      const correlationId = req.headers["x-correlationid"] || req.headers["x-vcap-request-id"];
      const x509Certificate = req.headers[FWD_CLIENT_CERT_HEADER];
      try {
        let callback = function(err, ctx, tokenInfo) {
          req.tokenInfo = tokenInfo;
          if (err) {
            if (!req.tokenInfo) {
              req.tokenInfo = new SimpleError(err.toString());
            }
            return err.statuscode ? self2.fail(err.statuscode, err) : self2.error(err);
          }
          if (authParams && authParams.scope) {
            var scopes = Array.isArray(authParams.scope) ? authParams.scope : [authParams.scope];
            for (var scope of scopes) {
              if (!ctx.checkScope(self2.options.xsappname + "." + scope)) {
                return self2.fail(403);
              }
            }
          }
          var jwtLogonName = ctx.getLogonName();
          var jwtGivenName = ctx.getGivenName();
          var jwtFamilyName = ctx.getFamilyName();
          var jwtEmail = ctx.getEmail();
          var user = !jwtLogonName ? {} : {
            id: jwtLogonName,
            name: {
              givenName: jwtGivenName,
              familyName: jwtFamilyName
            },
            emails: [{ value: jwtEmail }]
          };
          self2.success(user, ctx);
        };
        var self2 = this;
        var paramA = this._forceType ? this._forceType : callback;
        var paramB = this._forceType ? callback : void 0;
        const config = { ...passportOptions, credentials: this.options, correlationId };
        if (x509Certificate) {
          config.x509Certificate = x509Certificate;
        }
        createSecurityContext(token, config, paramA, paramB);
      } catch (err) {
        LOG.error("JWT verification error: ", err);
        this.error(err);
      }
    };
    JWTStrategy.JWTStrategy = JWTStrategy;
    module2.exports = JWTStrategy;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/v3/index.js
var require_v32 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/v3/index.js"(exports2, module2) {
    var createSecurityContext = require_createSecurityContextV32();
    var requests = require_requestsV32();
    var constants = require_constantsV32();
    var TokenInfo = require_Token2();
    var JWTStrategy = require_XssecPassportStrategyV32();
    module2.exports = {
      createSecurityContext,
      requests,
      constants,
      TokenInfo,
      JWTStrategy
    };
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/util/Types.js
var require_Types2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/util/Types.js"(exports2, module2) {
    module2.exports = {};
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/context/SecurityContextSymbol.js
var require_SecurityContextSymbol2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/context/SecurityContextSymbol.js"(exports2, module2) {
    var SECURITY_CONTEXT = Symbol("XSSEC_SECURITY_CONTEXT");
    module2.exports = SECURITY_CONTEXT;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/index.js
var require_src3 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap/xssec/src/index.js"(exports2, module2) {
    var createSecurityContext = require_createSecurityContext2();
    var SecurityContext = require_SecurityContext2();
    var IdentityServiceSecurityContext = require_IdentityServiceSecurityContext2();
    var XsuaaSecurityContext = require_XsuaaSecurityContext2();
    var XsaSecurityContext = require_XsaSecurityContext2();
    var UaaSecurityContext = require_UaaSecurityContext2();
    var Service = require_Service2();
    var IdentityService = require_IdentityService2();
    var XsuaaService = require_XsuaaService2();
    var XsaService = require_XsaService2();
    var UaaService = require_UaaService2();
    var XssecPassportStrategy = require_XssecPassportStrategy2();
    var Token = require_Token2();
    var IdentityServiceToken = require_IdentityServiceToken2();
    var XsuaaToken = require_XsuaaToken2();
    var XsaToken = require_XsaToken2();
    var UaaToken = require_UaaToken2();
    var errors = require_error2();
    var constants = require_constants3();
    var v3 = require_v32();
    var Types = require_Types2();
    var SECURITY_CONTEXT = require_SecurityContextSymbol2();
    module2.exports = {
      createSecurityContext,
      SecurityContext,
      IdentityServiceSecurityContext,
      XsuaaSecurityContext,
      XsaSecurityContext,
      UaaSecurityContext,
      Service,
      IdentityService,
      XsuaaService,
      XsaService,
      UaaService,
      XssecPassportStrategy,
      Token,
      IdentityServiceToken,
      XsuaaToken,
      XsaToken,
      UaaToken,
      errors,
      constants,
      v3,
      Types,
      SECURITY_CONTEXT
    };
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/environment-accessor/xsuaa.js
var require_xsuaa2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/environment-accessor/xsuaa.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getXsuaaServiceCredentials = getXsuaaServiceCredentials;
    exports2.clearXsuaaServices = clearXsuaaServices;
    exports2.getXsuaaService = getXsuaaService;
    var xssec_1 = require_src3();
    var service_credentials_1 = require_service_credentials2();
    function getXsuaaServiceCredentials(token) {
      const credentials = (0, service_credentials_1.getServiceCredentials)("xsuaa", token);
      if (!credentials) {
        throw new Error(token ? "Could not find XSUAA service binding matching the token." : "Could not find XSUAA service binding.");
      }
      return credentials;
    }
    var xsuaaServices = {};
    function clearXsuaaServices() {
      Object.keys(xsuaaServices).forEach((key) => delete xsuaaServices[key]);
    }
    function getXsuaaService(options) {
      const credentials = options?.credentials || getXsuaaServiceCredentials(options?.jwt);
      const disableCache = !!options?.disableCache;
      const serviceConfig = disableCache ? {
        validation: {
          jwks: {
            expirationTime: 0,
            refreshPeriod: 0
          }
        }
      } : void 0;
      const cacheKey = `${credentials.clientid}:${disableCache}`;
      if (!xsuaaServices[cacheKey]) {
        xsuaaServices[cacheKey] = new xssec_1.XsuaaService(credentials, serviceConfig);
      }
      return xsuaaServices[cacheKey];
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/environment-accessor/index.js
var require_environment_accessor2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/environment-accessor/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_destination4(), exports2);
    __exportStar(require_service_bindings2(), exports2);
    __exportStar(require_environment_accessor_types2(), exports2);
    __exportStar(require_service_credentials2(), exports2);
    __exportStar(require_xsuaa2(), exports2);
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/jwt/binding.js
var require_binding2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/jwt/binding.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeOrMakeJwt = decodeOrMakeJwt;
    exports2.getTenantIdFromBinding = getTenantIdFromBinding;
    var environment_accessor_1 = require_environment_accessor2();
    var jwt_1 = require_jwt3();
    function decodeOrMakeJwt(jwt) {
      if (jwt) {
        const decodedJwt = typeof jwt === "string" ? (0, jwt_1.decodeJwt)(jwt) : jwt;
        if ((0, jwt_1.getTenantId)(decodedJwt)) {
          return decodedJwt;
        }
      }
      const providerTenantId = getTenantIdFromBinding();
      if (providerTenantId) {
        return { zid: providerTenantId };
      }
    }
    function getTenantIdFromBinding() {
      return (0, environment_accessor_1.getServiceCredentials)("xsuaa")?.tenantid || (0, environment_accessor_1.getServiceCredentials)("identity")?.app_tid || (0, environment_accessor_1.getServiceCredentials)("destination")?.tenantid;
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/jwt/verify.js
var require_verify3 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/jwt/verify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.verifyJwt = verifyJwt;
    var xssec_1 = require_src3();
    var util_1 = require_dist6();
    var environment_accessor_1 = require_environment_accessor2();
    async function verifyJwt(jwt, options) {
      const disableCache = !{ ...defaultVerifyJwtOptions, ...options }.cacheVerificationKeys;
      const xsuaaService = (0, environment_accessor_1.getXsuaaService)({ disableCache, jwt });
      const { token } = await (0, xssec_1.createSecurityContext)(xsuaaService, {
        jwt
      }).catch((e) => {
        throw new util_1.ErrorWithCause("Failed to verify JWT.", e);
      });
      return token.payload;
    }
    var defaultVerifyJwtOptions = {
      cacheVerificationKeys: true
    };
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/jwt/index.js
var require_jwt4 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/jwt/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_binding2(), exports2);
    __exportStar(require_jwt3(), exports2);
    __exportStar(require_verify3(), exports2);
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/client-credentials-token-cache.js
var require_client_credentials_token_cache2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/client-credentials-token-cache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.clientCredentialsTokenCache = void 0;
    exports2.getCacheKey = getCacheKey2;
    var util_1 = require_dist6();
    var cache_1 = require_cache3();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "client-credentials-token-cache"
    });
    var ClientCredentialsTokenCache = (cache) => ({
      getToken: (tenantId, clientId) => cache.get(getCacheKey2(tenantId, clientId)),
      cacheToken: (tenantId, clientId, token) => {
        cache.set(getCacheKey2(tenantId, clientId), {
          entry: token,
          expires: token.expires_in ? Date.now() + token.expires_in * 1e3 : void 0
        });
      },
      clear: () => {
        cache.clear();
      },
      getCacheInstance: () => cache
    });
    function getCacheKey2(tenantId, clientId) {
      if (!tenantId) {
        logger8.warn("Cannot create cache key for client credentials token cache. The given tenant ID is undefined.");
        return;
      }
      if (!clientId) {
        logger8.warn("Cannot create cache key for client credentials token cache. The given client ID is undefined.");
        return;
      }
      return [tenantId, clientId].join(":");
    }
    exports2.clientCredentialsTokenCache = ClientCredentialsTokenCache(new cache_1.Cache(
      5 * 60 * 1e3
      /* 5 minutes in ms */
    ));
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/resilience/dist/timeout.js
var require_timeout2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/resilience/dist/timeout.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.timeout = timeout;
    var util_1 = require_dist6();
    var defaultTimeout = 1e4;
    var logger8 = (0, util_1.createLogger)({
      package: "resilience",
      messageContext: "timeout"
    });
    function timeout(timeoutValue = defaultTimeout) {
      if (timeoutValue <= 0) {
        throw new Error("Timeout must be greater than 0.");
      }
      if (timeoutValue < 10) {
        logger8.warn(`The timeout of ${timeoutValue} ms is too low. Make sure this is not intentional.`);
      }
      return function(options) {
        const message = `Request to URL: ${options.context.uri} ran into a timeout after ${timeoutValue}ms.`;
        return (arg) => wrapInTimeout(options.fn(arg), timeoutValue, message);
      };
    }
    function getTimeoutPromise(timeoutValue, message) {
      let timeoutNode;
      const promise = new Promise((resolve, reject) => {
        timeoutNode = setTimeout(() => reject(new Error(message)), timeoutValue);
      });
      return [promise, timeoutNode];
    }
    async function wrapInTimeout(promise, timeoutValue, message) {
      const [timeoutPromise, timeoutInstance] = getTimeoutPromise(timeoutValue, message);
      const withClearTimeout = promise.finally(() => {
        clearTimeout(timeoutInstance);
      });
      return Promise.race([withClearTimeout, timeoutPromise]);
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/resilience/dist/retry.js
var require_retry4 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/resilience/dist/retry.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.retry = retry;
    var util_1 = require_dist6();
    var asyncRetry = __importStar(require_lib());
    var logger8 = (0, util_1.createLogger)({
      package: "resilience",
      messageContext: "retry"
    });
    var defaultRetries = 3;
    function retry(retries = defaultRetries) {
      if (retries < 0) {
        throw new Error("Number of retries must be greater or equal to 0.");
      }
      return function(options) {
        return (arg) => asyncRetry.default(async (bail) => {
          try {
            return await options.fn(arg);
          } catch (error) {
            const status = error?.response?.status;
            if (!status) {
              logger8.debug("HTTP request failed but error did not contain a response status field as expected. Rethrowing error.");
            } else if (status.toString().startsWith("4")) {
              bail(new util_1.ErrorWithCause(`Request failed with status code ${status}`, error));
              return void 0;
            }
            throw error;
          }
        }, { retries });
      };
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/resilience/dist/middleware.js
var require_middleware2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/resilience/dist/middleware.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.executeWithMiddleware = executeWithMiddleware;
    function executeWithMiddleware(middlewares, { fn, context, fnArgument }) {
      if (!middlewares?.length) {
        return fn(fnArgument);
      }
      const initial = { context, fn };
      const functionWithMiddlewares = addMiddlewaresToInitialFunction(middlewares, initial);
      return functionWithMiddlewares(fnArgument);
    }
    function addMiddlewaresToInitialFunction(middlewares, initial) {
      const { context } = initial;
      const functionWithMiddlewares = middlewares.reduceRight((prev, curr) => ({ fn: curr(prev), context }), initial);
      return functionWithMiddlewares.fn;
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/resilience/dist/circuit-breaker.js
var require_circuit_breaker2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/resilience/dist/circuit-breaker.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.circuitBreakerDefaultOptions = exports2.circuitBreakers = void 0;
    exports2.circuitBreaker = circuitBreaker;
    var opossum_1 = __importDefault(require_opossum());
    exports2.circuitBreakers = {};
    exports2.circuitBreakerDefaultOptions = {
      timeout: false,
      errorThresholdPercentage: 50,
      volumeThreshold: 10,
      resetTimeout: 3e4,
      cache: false
    };
    function httpErrorFilter(error) {
      return !!error.response?.status && error.response.status.toString().startsWith("4");
    }
    function circuitBreakerKeyBuilder({ uri, tenantId = "tenant_id" }) {
      return `${uri}::${tenantId}`;
    }
    function circuitBreaker() {
      return circuitBreakerGeneric(circuitBreakerKeyBuilder, httpErrorFilter);
    }
    function circuitBreakerGeneric(keyBuilder, errorFilter) {
      return (options) => (fnArgument) => getCircuitBreaker(keyBuilder(options.context), errorFilter).fire(options.fn, fnArgument);
    }
    function getCircuitBreaker(key, errorFilter) {
      if (!exports2.circuitBreakers[key]) {
        exports2.circuitBreakers[key] = new opossum_1.default(executeFunction, {
          ...exports2.circuitBreakerDefaultOptions,
          errorFilter
        });
      }
      return exports2.circuitBreakers[key];
    }
    function executeFunction(fn, ...parameters) {
      return fn(...parameters);
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/resilience/dist/resilience.js
var require_resilience2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/resilience/dist/resilience.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resilience = resilience;
    var timeout_1 = require_timeout2();
    var retry_1 = require_retry4();
    var circuit_breaker_1 = require_circuit_breaker2();
    var defaultResilienceOptions = {
      retry: false,
      timeout: true,
      circuitBreaker: true
    };
    function resilience(options) {
      const resilienceOption = { ...defaultResilienceOptions, ...options };
      const middlewares = [];
      if (typeof resilienceOption.retry === "number") {
        middlewares.push((0, retry_1.retry)(resilienceOption.retry));
      } else if (resilienceOption.retry) {
        middlewares.push((0, retry_1.retry)());
      }
      if (resilienceOption.circuitBreaker) {
        middlewares.push((0, circuit_breaker_1.circuitBreaker)());
      }
      if (typeof resilienceOption.timeout === "number") {
        middlewares.push((0, timeout_1.timeout)(resilienceOption.timeout));
      } else if (resilienceOption.timeout) {
        middlewares.push((0, timeout_1.timeout)());
      }
      return middlewares;
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/resilience/dist/internal.js
var require_internal5 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/resilience/dist/internal.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_timeout2(), exports2);
    __exportStar(require_retry4(), exports2);
    __exportStar(require_middleware2(), exports2);
    __exportStar(require_circuit_breaker2(), exports2);
    __exportStar(require_resilience2(), exports2);
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/resilience/internal.js
var require_internal6 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/resilience/internal.js"(exports2) {
    "use strict";
    function __export2(m) {
      for (const p in m) {
        if (!exports2.hasOwnProperty(p)) {
          exports2[p] = m[p];
        }
      }
    }
    Object.defineProperty(exports2, "__esModule", { value: true });
    __export2(require_internal5());
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/resilience/dist/index.js
var require_dist7 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/resilience/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resilience = exports2.circuitBreaker = exports2.retry = exports2.timeout = void 0;
    var timeout_1 = require_timeout2();
    Object.defineProperty(exports2, "timeout", { enumerable: true, get: function() {
      return timeout_1.timeout;
    } });
    var retry_1 = require_retry4();
    Object.defineProperty(exports2, "retry", { enumerable: true, get: function() {
      return retry_1.retry;
    } });
    var circuit_breaker_1 = require_circuit_breaker2();
    Object.defineProperty(exports2, "circuitBreaker", { enumerable: true, get: function() {
      return circuit_breaker_1.circuitBreaker;
    } });
    var resilience_1 = require_resilience2();
    Object.defineProperty(exports2, "resilience", { enumerable: true, get: function() {
      return resilience_1.resilience;
    } });
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/xsuaa-service.js
var require_xsuaa_service2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/xsuaa-service.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getClientCredentialsToken = getClientCredentialsToken;
    exports2.getUserToken = getUserToken;
    var internal_1 = require_internal6();
    var resilience_1 = require_dist7();
    var environment_accessor_1 = require_environment_accessor2();
    var jwt_1 = require_jwt4();
    async function getClientCredentialsToken(service, jwt) {
      const decodedJwt = jwt ? (0, jwt_1.decodeJwt)(jwt) : {};
      const fnArgument = {
        subdomain: (0, jwt_1.getSubdomain)(decodedJwt),
        zoneId: (0, jwt_1.getTenantId)(decodedJwt),
        serviceCredentials: (0, environment_accessor_1.resolveServiceBinding)(service).credentials
      };
      const xssecPromise = function(arg) {
        const xsuaaService = (0, environment_accessor_1.getXsuaaService)({
          credentials: arg.serviceCredentials
        });
        return xsuaaService.fetchClientCredentialsToken({
          // tenant is the subdomain, not tenant ID
          tenant: arg.zoneId ? void 0 : arg.subdomain,
          zid: arg.zoneId
        });
      };
      return (0, internal_1.executeWithMiddleware)((0, resilience_1.resilience)(), {
        fn: xssecPromise,
        fnArgument,
        context: {
          uri: fnArgument.serviceCredentials.url,
          tenantId: fnArgument.zoneId ?? fnArgument.serviceCredentials.tenantid
        }
      }).catch((err) => {
        throw new Error(`Could not fetch client credentials token for service of type ${(0, environment_accessor_1.resolveServiceBinding)(service).label}: ${err.message}`);
      });
    }
    function getUserToken(service, userJwt) {
      const decodedUserJwt = (0, jwt_1.decodeJwt)(userJwt);
      const fnArgument = {
        subdomain: (0, jwt_1.getSubdomain)(decodedUserJwt),
        zoneId: (0, jwt_1.getTenantId)(decodedUserJwt),
        serviceCredentials: service.credentials,
        userJwt
      };
      const xssecPromise = function(arg) {
        const xsuaaService = (0, environment_accessor_1.getXsuaaService)({
          credentials: arg.serviceCredentials
        });
        return xsuaaService.fetchJwtBearerToken(arg.userJwt, {
          // tenant is the subdomain, not tenant ID
          tenant: arg.zoneId ? void 0 : arg.subdomain,
          zid: arg.zoneId
        }).then((token) => token.access_token);
      };
      return (0, internal_1.executeWithMiddleware)((0, resilience_1.resilience)(), {
        fn: xssecPromise,
        fnArgument,
        context: {
          uri: service.credentials.url,
          tenantId: fnArgument.zoneId ?? service.credentials.tenantid
        }
      }).catch((err) => {
        throw new Error(`Could not fetch JWT bearer token for service of type ${service.label}: ${err.message}`);
      });
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/token-accessor.js
var require_token_accessor2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/token-accessor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.serviceToken = serviceToken;
    exports2.jwtBearerToken = jwtBearerToken;
    var util_1 = require_dist6();
    var jwt_1 = require_jwt4();
    var client_credentials_token_cache_1 = require_client_credentials_token_cache2();
    var environment_accessor_1 = require_environment_accessor2();
    var xsuaa_service_1 = require_xsuaa_service2();
    async function serviceToken(service, options) {
      const opts = {
        useCache: true,
        enableCircuitBreaker: true,
        ...options
      };
      const serviceBinding = (0, environment_accessor_1.resolveServiceBinding)(service);
      const serviceCredentials = serviceBinding.credentials;
      const tenantForCaching = options?.jwt ? (0, jwt_1.getTenantId)(options.jwt) || (0, jwt_1.getSubdomain)(options.jwt) : (0, jwt_1.getTenantIdFromBinding)() || (0, jwt_1.getDefaultTenantId)();
      if (opts.useCache) {
        const cachedToken = client_credentials_token_cache_1.clientCredentialsTokenCache.getToken(tenantForCaching, serviceCredentials.clientid);
        if (cachedToken) {
          return cachedToken.access_token;
        }
      }
      try {
        const token = await (0, xsuaa_service_1.getClientCredentialsToken)(serviceBinding, options?.jwt);
        if (opts.useCache) {
          client_credentials_token_cache_1.clientCredentialsTokenCache.cacheToken(tenantForCaching, serviceCredentials.clientid, token);
        }
        return token.access_token;
      } catch (err) {
        throw new util_1.ErrorWithCause(`Could not fetch client credentials token for service of type "${serviceBinding.label}".`, err);
      }
    }
    async function jwtBearerToken(jwt, service) {
      const resolvedService = (0, environment_accessor_1.resolveServiceBinding)(service);
      return (0, xsuaa_service_1.getUserToken)(resolvedService, jwt);
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/identity-service.js
var require_identity_service2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/identity-service.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.exchangeToken = exchangeToken;
    exports2.shouldExchangeToken = shouldExchangeToken;
    var jwt_1 = require_jwt4();
    var token_accessor_1 = require_token_accessor2();
    async function exchangeToken(jwt) {
      return (0, token_accessor_1.jwtBearerToken)(jwt, "xsuaa");
    }
    function shouldExchangeToken(options) {
      return options.iasToXsuaaTokenExchange === true && !!options.jwt && !(0, jwt_1.isXsuaaToken)((0, jwt_1.decodeJwt)(options.jwt));
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-accessor-types.js
var require_destination_accessor_types2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-accessor-types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isDestinationFetchOptions = isDestinationFetchOptions;
    function isDestinationFetchOptions(destination) {
      return destination.destinationName !== void 0;
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination.js
var require_destination5 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sanitizeDestination = sanitizeDestination;
    exports2.parseDestination = parseDestination;
    exports2.getAdditionalHeadersAndQueryParameters = getAdditionalHeadersAndQueryParameters;
    exports2.getAdditionalHeaders = getAdditionalHeaders;
    exports2.getAdditionalQueryParameters = getAdditionalQueryParameters;
    exports2.getDestinationConfig = getDestinationConfig;
    exports2.toDestinationNameUrl = toDestinationNameUrl;
    exports2.parseCertificate = parseCertificate;
    exports2.isDestinationConfiguration = isDestinationConfiguration;
    exports2.isDestinationJson = isDestinationJson;
    exports2.noDestinationErrorMessage = noDestinationErrorMessage;
    var destination_accessor_types_1 = require_destination_accessor_types2();
    function sanitizeDestination(destination) {
      let parsedDestination = parseAuthTokens(destination);
      parsedDestination = parseCertificates(parsedDestination);
      parsedDestination = setDefaultAuthenticationFallback(parsedDestination);
      parsedDestination = setTrustAll(parsedDestination);
      parsedDestination = setForwardAuthToken(parsedDestination);
      parsedDestination = setOriginalProperties(parsedDestination);
      return parsedDestination;
    }
    function parseDestination(destinationJson) {
      const destinationConfig = getDestinationConfig(destinationJson);
      const destination = Object.entries(destinationConfig).reduce((dest, [originalKey, value]) => {
        if (originalKey in configMapping) {
          dest[configMapping[originalKey]] = value;
        }
        return dest;
      }, {
        originalProperties: destinationJson,
        authTokens: destinationJson["authTokens"] || [],
        certificates: destinationJson["certificates"] || []
      });
      const additionalHeadersAndQueryParameters = getAdditionalHeadersAndQueryParameters(destinationConfig);
      return sanitizeDestination({
        ...destination,
        ...additionalHeadersAndQueryParameters
      });
    }
    function getAdditionalProperties(destinationConfig, originalKeyPrefix) {
      const relevantConfigEntries = Object.entries(destinationConfig).filter(([key]) => key.startsWith(originalKeyPrefix));
      return relevantConfigEntries.reduce((additionalProperties, [originalKey, value]) => {
        const headerKey = originalKey.replace(originalKeyPrefix, "");
        additionalProperties[headerKey] = value;
        return additionalProperties;
      }, {});
    }
    function getAdditionalHeadersAndQueryParameters(destinationConfig) {
      const additionalProperties = {};
      const additionalHeaders = getAdditionalHeaders(destinationConfig).headers;
      if (additionalHeaders && Object.keys(additionalHeaders).length) {
        additionalProperties["headers"] = additionalHeaders;
      }
      const additionalQueryParameters = getAdditionalQueryParameters(destinationConfig).queryParameters;
      if (additionalQueryParameters && Object.keys(additionalQueryParameters).length) {
        additionalProperties["queryParameters"] = additionalQueryParameters;
      }
      return additionalProperties;
    }
    function getAdditionalHeaders(destinationConfig) {
      const additionalHeaders = getAdditionalProperties(destinationConfig, "URL.headers.");
      const additionalProperties = {};
      if (Object.keys(additionalHeaders).length) {
        additionalProperties["headers"] = additionalHeaders;
      }
      return additionalProperties;
    }
    function getAdditionalQueryParameters(destinationConfig) {
      const additionalQueryParameters = getAdditionalProperties(destinationConfig, "URL.queries.");
      const additionalProperties = {};
      if (Object.keys(additionalQueryParameters).length) {
        additionalProperties["queryParameters"] = additionalQueryParameters;
      }
      return additionalProperties;
    }
    function getDestinationConfig(destinationJson) {
      return isDestinationJson(destinationJson) ? destinationJson.destinationConfiguration : destinationJson;
    }
    function toDestinationNameUrl(destination) {
      if ((0, destination_accessor_types_1.isDestinationFetchOptions)(destination)) {
        return `name: ${destination.destinationName}`;
      }
      const text = ["name", "url"].filter((key) => destination[key]).map((key) => `${key}: ${destination[key]}`);
      return text.length > 0 ? text.join(",") : "Destination does not have a 'name' or 'url' property.";
    }
    function setOriginalProperties(destination) {
      const originalProperties = destination.originalProperties ? destination.originalProperties : destination;
      return {
        ...destination,
        originalProperties
      };
    }
    function setDefaultAuthenticationFallback(destination) {
      return destination.authentication ? destination : {
        ...destination,
        authentication: getAuthenticationType(destination)
      };
    }
    function parseCertificate(certificate) {
      return {
        name: certificate.Name || certificate.name,
        content: certificate.Content || certificate.content,
        type: certificate.Type || certificate.type
      };
    }
    function parseCertificates(destination) {
      return {
        ...destination,
        certificates: (destination.certificates || []).map((certificate) => parseCertificate(certificate))
      };
    }
    function parseAuthToken(authToken) {
      return {
        type: authToken.type,
        value: authToken.value,
        expiresIn: authToken.expires_in,
        error: "error" in authToken ? authToken.error : null,
        http_header: authToken.http_header
      };
    }
    function parseAuthTokens(destination) {
      return {
        ...destination,
        authTokens: (destination.authTokens || []).map((token) => parseAuthToken(token))
      };
    }
    function setTrustAll(destination) {
      return {
        ...destination,
        isTrustingAllCertificates: parseTrustAll(destination.isTrustingAllCertificates)
      };
    }
    function parseTrustAll(isTrustingAllCertificates) {
      if (typeof isTrustingAllCertificates === "string") {
        return isTrustingAllCertificates.toLowerCase() === "true";
      }
      return !!isTrustingAllCertificates;
    }
    function getAuthenticationType(destination) {
      return destination.authentication || destination.username && destination.password ? "BasicAuthentication" : "NoAuthentication";
    }
    function setForwardAuthToken(destination) {
      const forwardAuthToken = destination.originalProperties?.forwardAuthToken ?? destination.originalProperties?.["HTML5.ForwardAuthToken"] ?? destination.forwardAuthToken;
      return {
        ...destination,
        forwardAuthToken: forwardAuthToken === "true" || forwardAuthToken === true
      };
    }
    function isDestinationConfiguration(destination) {
      return destination.URL !== void 0;
    }
    function isDestinationJson(destination) {
      return Object.keys(destination).includes("destinationConfiguration");
    }
    var configMapping = {
      URL: "url",
      Name: "name",
      User: "username",
      Password: "password",
      ProxyType: "proxyType",
      "sap-client": "sapClient",
      Authentication: "authentication",
      TrustAll: "isTrustingAllCertificates",
      Type: "type",
      tokenServiceURL: "tokenServiceUrl",
      clientId: "clientId",
      clientSecret: "clientSecret",
      tokenServiceUser: "tokenServiceUser",
      tokenServicePassword: "tokenServicePassword",
      CloudConnectorLocationId: "cloudConnectorLocationId",
      certificates: "certificates",
      KeyStoreLocation: "keyStoreName",
      KeyStorePassword: "keyStorePassword",
      SystemUser: "systemUser",
      /**
       * Base64-encoded JSON web key set, containing the signing keys which are used to validate the JWT provided in the X-User-Token header.
       */
      "x_user_token.jwks": "jwks",
      /**
       * URI of the JSON web key set, containing the signing keys which are used to validate the JWT provided in the X-User-Token header.
       */
      "x_user_token.jwks_uri": "jwksUri",
      "HTML5.ForwardAuthToken": "forwardAuthToken",
      /**
       * This overwrites `HTML5.ForwardAuthToken`, if both exist (during sanitize).
       */
      forwardAuthToken: "forwardAuthToken"
    };
    function noDestinationErrorMessage(destination) {
      return (0, destination_accessor_types_1.isDestinationFetchOptions)(destination) ? `Could not find a destination with name "${destination.destinationName}"! Unable to execute request.` : "Could not find a destination to execute request against and no destination name has been provided (this should never happen)!";
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/protocol.js
var require_protocol2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/protocol.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getProtocol = getProtocol;
    var protocols = {
      http: "http",
      https: "https",
      socks: "socks"
    };
    function getProtocol(protocol) {
      return protocol.endsWith(":") ? getProtocol(protocol.slice(0, -1)) : protocols[protocol];
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/authorization-header.js
var require_authorization_header2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/authorization-header.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getAuthHeader = getAuthHeader;
    exports2.basicHeader = basicHeader;
    exports2.buildAuthorizationHeaders = buildAuthorizationHeaders;
    var util_1 = require_dist6();
    var destination_1 = require_destination5();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "authorization-header"
    });
    function getAuthHeader(authenticationType, customHeaders) {
      if (authenticationType === "PrincipalPropagation") {
        const principalPropagationHeader = (0, util_1.pickValueIgnoreCase)(customHeaders, "SAP-Connectivity-Authentication");
        if (principalPropagationHeader) {
          return { "SAP-Connectivity-Authentication": principalPropagationHeader };
        }
      }
      const authorizationHeader = (0, util_1.pickValueIgnoreCase)(customHeaders, "authorization");
      if (authorizationHeader) {
        return { authorization: authorizationHeader };
      }
    }
    function headerFromTokens(authenticationType, authTokens) {
      if (!authTokens || !authTokens.length) {
        throw Error(`\`AuthenticationType\` is "${authenticationType}", but no auth tokens could be fetched from the destination service.`);
      }
      const usableTokens = authTokens.filter((token) => !token.error);
      if (!usableTokens.length) {
        throw Error([
          "The destination tried to provide authorization tokens but failed in all cases. This is most likely due to misconfiguration.",
          "Original error messages:",
          ...authTokens.map((token) => token.error)
        ].join(util_1.unixEOL));
      }
      const authToken = usableTokens[0];
      return { authorization: authToken.http_header.value };
    }
    function headerFromBasicAuthDestination(destination) {
      if ((0, util_1.isNullish)(destination.username) || (0, util_1.isNullish)(destination.password)) {
        throw Error('AuthenticationType is "BasicAuthentication", but "username" and / or "password" are missing!');
      }
      return {
        authorization: basicHeader(destination.username, destination.password)
      };
    }
    function basicHeader(username, password) {
      return "Basic " + (0, util_1.encodeBase64)(`${username}:${password}`);
    }
    function headerForPrincipalPropagation(destination) {
      const principalPropagationHeader = destination?.proxyConfiguration?.headers?.["SAP-Connectivity-Authentication"];
      if (!principalPropagationHeader) {
        throw Error("Principal propagation was selected in destination, but no SAP-Connectivity-Authentication bearer header was added by connectivity service.");
      }
      return {
        "SAP-Connectivity-Authentication": principalPropagationHeader
      };
    }
    function getProxyRelatedAuthHeaders(destination) {
      const authHeader = destination?.proxyConfiguration?.headers?.["Proxy-Authorization"];
      if (authHeader) {
        return { "Proxy-Authorization": authHeader };
      }
    }
    async function getAuthenticationRelatedHeaders(destination) {
      const destinationAuthHeaders = getAuthHeader(destination.authentication, destination.headers);
      logger8.debug(`Getting authentication related headers for authentication type: ${destination.authentication}`);
      if (destinationAuthHeaders) {
        logger8.debug("Authentication header from 'destination.headers' used.");
        return destinationAuthHeaders;
      }
      switch (destination.authentication) {
        case null:
        case void 0:
          logger8.warn('No authentication type is specified on the destination. Assuming "NoAuthentication".');
          return;
        case "NoAuthentication":
          return;
        case "ClientCertificateAuthentication":
          return;
        case "SAMLAssertion":
        case "OAuth2SAMLBearerAssertion":
        case "OAuth2UserTokenExchange":
        case "OAuth2JWTBearer":
        case "OAuth2ClientCredentials":
        case "OAuth2Password":
        case "OAuth2RefreshToken": {
          const header = headerFromTokens(destination.authentication, destination.authTokens);
          if (destination.authentication === "SAMLAssertion") {
            logger8.warn("Destination authentication flow is 'SamlAssertion' and the auth header contains the SAML assertion. In most cases you want to translate the assertion to a Bearer token using the 'OAuth2SAMLBearerAssertion' flow.");
            return {
              ...header,
              "x-sap-security-session": "create"
            };
          }
          return header;
        }
        case "BasicAuthentication":
          return headerFromBasicAuthDestination(destination);
        case "PrincipalPropagation":
          return headerForPrincipalPropagation(destination);
        default:
          throw Error(`The destination used "${destination.authentication}" as authentication type which is not supported by the SAP Cloud SDK.`);
      }
    }
    async function buildAuthorizationHeaders(destination) {
      const sanitizedDestination = (0, destination_1.sanitizeDestination)(destination);
      return {
        ...await getAuthenticationRelatedHeaders(sanitizedDestination),
        ...getProxyRelatedAuthHeaders(sanitizedDestination)
      };
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/get-protocol.js
var require_get_protocol2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/get-protocol.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getProtocolOrDefault = getProtocolOrDefault;
    var util_1 = require_dist6();
    var protocol_1 = require_protocol2();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "get-protocol"
    });
    function getProtocolOrDefault(destination) {
      const urlParts = destination.url.toLowerCase()?.split("://");
      if (!urlParts || urlParts.length === 1) {
        logger8.warn(`URL of the provided destination (${destination.url}) has no protocol specified! Assuming HTTPS.`);
        return "https";
      }
      const protocol = (0, protocol_1.getProtocol)(urlParts[0]);
      if (!protocol) {
        throw new Error(`Protocol of the provided destination (${destination.url}) is not supported! Currently only HTTP and HTTPS are supported.`);
      }
      return protocol;
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-service-types.js
var require_destination_service_types2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-service-types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assertHttpDestination = assertHttpDestination2;
    exports2.isHttpDestination = isHttpDestination;
    function assertHttpDestination2(destination) {
      if (!isHttpDestination(destination)) {
        throw new Error(destination.url ? `The 'type' property is  ${destination.type} instead of  HTTP for destination '${destination.name}' which is mandatory if you use it as an 'HTTP destination` : `The 'url' property is not set for destination ${destination.name} which is mandatory if you use it as an 'HTTP destination`);
      }
    }
    function isHttpDestination(destination) {
      return !!destination && !!destination.url && (!destination.type || destination.type === "HTTP");
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/http-proxy-util.js
var require_http_proxy_util2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/http-proxy-util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.proxyStrategy = proxyStrategy;
    exports2.parseProxyEnv = parseProxyEnv;
    exports2.addProxyConfigurationInternet = addProxyConfigurationInternet;
    exports2.getProxyConfig = getProxyConfig;
    var node_url_1 = require("node:url");
    var util_1 = require_dist6();
    var protocol_1 = require_protocol2();
    var authorization_header_1 = require_authorization_header2();
    var get_protocol_1 = require_get_protocol2();
    var destination_service_types_1 = require_destination_service_types2();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "proxy-util"
    });
    function proxyStrategy(destination) {
      if (destination.proxyType === "OnPremise") {
        logger8.debug("OnPrem destination proxy settings from connectivity service will be used.");
        return "on-premise";
      }
      if (destination.proxyType === "PrivateLink") {
        logger8.debug("PrivateLink destination proxy settings will be used. This is not supported in local/CI/CD environments.");
        return "private-link";
      }
      if ((0, destination_service_types_1.isHttpDestination)(destination)) {
        const destinationProtocol = (0, get_protocol_1.getProtocolOrDefault)(destination);
        return getProxyStrategyFromProxyEnvValue(destinationProtocol, destination.url);
      }
      return "no-proxy";
    }
    function getProxyStrategyFromProxyEnvValue(protocol, destinationUrl) {
      if (!getProxyEnvValue(protocol)) {
        logger8.debug(`Could not find proxy settings for ${protocol} in the environment variables - no proxy used.`);
        return "no-proxy";
      }
      if (getNoProxyEnvValue().includes(destinationUrl)) {
        logger8.debug(`Destination URL ${destinationUrl} is in no_proxy list: ${getNoProxyEnvValue()} - no proxy used.`);
        return "no-proxy";
      }
      if (getProxyEnvValue(protocol)) {
        logger8.debug(`Proxy settings for ${protocol} are found in environment variables.`);
        return "internet";
      }
      return "no-proxy";
    }
    function getProxyEnvValue(protocol) {
      const proxyEnvKey = protocol + "_proxy";
      const proxyEnvValue = process.env[proxyEnvKey.toLowerCase()] || process.env[proxyEnvKey.toUpperCase()];
      logger8.debug(`Tried to read ${proxyEnvKey.toLowerCase()} or ${proxyEnvKey.toUpperCase()} from the environment variables. Value is ${proxyEnvValue}.`);
      return proxyEnvValue || void 0;
    }
    function getNoProxyEnvValue() {
      const noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
      if (!noProxyEnv) {
        return [];
      }
      const split = noProxyEnv.split(",").map((s) => s.trim());
      if (split.find((s) => s.includes("*"))) {
        logger8.warn(`The no_proxy env contains a wildcard ${noProxyEnv}, which is currently not supported`);
      }
      return split;
    }
    function getPort(url) {
      if (url.port) {
        return parseInt(url.port);
      }
      return url.protocol === "https:" ? 443 : 80;
    }
    function getOriginalProtocol(href) {
      const test = href.match(/^[\w.-]+:\/\//);
      return test ? test[0].slice(0, -2) : void 0;
    }
    function sanitizeUrl(href) {
      const protocol = getOriginalProtocol(href);
      if (!protocol) {
        logger8.debug('No protocol specified, using "http:".');
        return `http://${href}`;
      }
      return href;
    }
    function validateUrl(url) {
      if (url.protocol !== "http:" && url.protocol !== "https:") {
        throw new Error(`Unsupported protocol "${url.protocol}".`);
      }
      if (url.protocol === "https:") {
        logger8.debug('Using protocol "https:" to connect to a proxy. This is unusual but possible.');
      }
      if (url.username && !url.password) {
        throw new Error("Password missing.");
      }
    }
    function parseProxyEnv(proxyEnvValue) {
      const href = sanitizeUrl(proxyEnvValue);
      try {
        const url = new node_url_1.URL(href);
        validateUrl(url);
        const proxyConfig = {
          host: url.hostname,
          protocol: (0, protocol_1.getProtocol)(url.protocol),
          port: getPort(url)
        };
        if (url.username && url.password) {
          proxyConfig.headers = {
            "Proxy-Authorization": (0, authorization_header_1.basicHeader)(decodeURIComponent(url.username), decodeURIComponent(url.password))
          };
        }
        if (proxyConfig) {
          const loggableConfig = {
            ...proxyConfig,
            headers: (0, util_1.sanitizeRecord)(proxyConfig.headers || {}, "Authorization header present. Not logged for security reasons.")
          };
          logger8.debug(`Used Proxy Configuration: ${JSON.stringify(loggableConfig, null, 2)}.`);
        }
        return proxyConfig;
      } catch (err) {
        logger8.warn(`Could not parse proxy configuration from environment variable. Reason: ${err.message}`);
        return void 0;
      }
    }
    function addProxyConfigurationInternet(destination) {
      const proxyEnvValue = getProxyEnvValue((0, get_protocol_1.getProtocolOrDefault)(destination));
      if (proxyEnvValue) {
        return {
          ...destination,
          proxyConfiguration: parseProxyEnv(proxyEnvValue) || destination.proxyConfiguration
        };
      }
      logger8.warn("Attempt to get proxy config from environment variables failed. At this point this should not happen - no proxy used.");
      return { ...destination };
    }
    function getProxyConfig(destination) {
      if (destination.proxyConfiguration) {
        const { host, protocol, port } = destination.proxyConfiguration;
        return { host, protocol, port };
      }
      return false;
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/forward-auth-token.js
var require_forward_auth_token2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/forward-auth-token.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setForwardedAuthTokenIfNeeded = setForwardedAuthTokenIfNeeded;
    var util_1 = require_dist6();
    var jwt_1 = require_jwt4();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "forward-auth-token"
    });
    function buildDestinationAuthToken(token) {
      const decodedJwt = (0, jwt_1.decodeJwt)(token);
      return [
        {
          value: token,
          expiresIn: decodedJwt.exp?.toString(),
          error: null,
          http_header: { key: "Authorization", value: `Bearer ${token}` },
          type: "Bearer"
        }
      ];
    }
    function validateToken(token) {
      if (!token) {
        logger8.warn("Option 'forwardAuthToken' was set on destination but no token was provided to forward. This is most likely unintended and will lead to an authorization error on request execution.");
      }
      return !!token;
    }
    function setForwardedAuthTokenIfNeeded(destination, token) {
      if (destination.forwardAuthToken) {
        if (validateToken(token)) {
          logger8.debug("Option 'forwardAuthToken' enabled on destination. Using the given token for the destination.");
          destination.authTokens = buildDestinationAuthToken(token);
        }
      }
      return destination;
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-from-env.js
var require_destination_from_env2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-from-env.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getDestinationsFromEnv = getDestinationsFromEnv;
    exports2.getDestinationFromEnvByName = getDestinationFromEnvByName;
    exports2.getDestinationsEnvVariable = getDestinationsEnvVariable;
    exports2.searchEnvVariablesForDestination = searchEnvVariablesForDestination;
    exports2.validateNameAvailable = validateNameAvailable;
    exports2.setDestinationsInEnv = setDestinationsInEnv;
    var util_1 = require_dist6();
    var destination_1 = require_destination5();
    var http_proxy_util_1 = require_http_proxy_util2();
    var destination_service_types_1 = require_destination_service_types2();
    var forward_auth_token_1 = require_forward_auth_token2();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "env-destination-accessor"
    });
    function getDestinationsFromEnv() {
      const destinationsEnv = getDestinationsEnvVariable();
      logger8.debug(`The value for the destination environment variable is: ${destinationsEnv}`);
      if (destinationsEnv) {
        let destinations;
        try {
          destinations = JSON.parse(destinationsEnv);
        } catch (err) {
          throw new util_1.ErrorWithCause("Error in parsing the destinations from the environment variable.", err);
        }
        validateDestinations(destinations);
        return destinations.map((destination) => (0, destination_1.isDestinationConfiguration)(destination) ? (0, destination_1.parseDestination)(destination) : (0, destination_1.sanitizeDestination)(destination));
      }
      return [];
    }
    function getDestinationFromEnvByName(name) {
      const matchingDestinations = getDestinationsFromEnv().filter((dest) => dest.name === name);
      if (!matchingDestinations.length) {
        return null;
      }
      if (matchingDestinations.length > 1) {
        logger8.warn(`The 'destinations' env variable contains multiple destinations with the name '${name}'. Only the first entry will be considered.`);
      }
      return matchingDestinations[0];
    }
    function getDestinationsEnvVariable() {
      return process.env["destinations"];
    }
    function validateDestinations(destinations) {
      destinations.forEach((destination) => {
        if (typeof destination.name === "undefined" && typeof destination.Name === "undefined") {
          logger8.warn("Destination from 'destinations' env variable is missing 'name' or 'Name' property.");
        }
      });
    }
    function searchEnvVariablesForDestination(options) {
      logger8.debug("Attempting to retrieve destination from environment variable.");
      if (getDestinationsEnvVariable()) {
        try {
          const destination = getDestinationFromEnvByName(options.destinationName);
          if (destination) {
            logger8.info(`Successfully retrieved destination '${options.destinationName}' from environment variable.`);
            (0, forward_auth_token_1.setForwardedAuthTokenIfNeeded)(destination, options.jwt);
            return (0, destination_service_types_1.isHttpDestination)(destination) && ["internet", "private-link"].includes((0, http_proxy_util_1.proxyStrategy)(destination)) ? (0, http_proxy_util_1.addProxyConfigurationInternet)(destination) : destination;
          }
        } catch (error) {
          logger8.error(`Error in reading the given destinations from the environment variable ${error.message}.`);
        }
      }
      logger8.debug("No environment variable set.");
      return null;
    }
    function validateNameAvailable(destinationName, existingNames) {
      if (existingNames.has(destinationName)) {
        throw new Error(`Parsing destinations failed, destination with name "${destinationName}" already exists in the "destinations" environment variables.`);
      }
    }
    function setDestinationsInEnv(destinations) {
      process.env.destinations = JSON.stringify(destinations);
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/service-binding-to-destination.js
var require_service_binding_to_destination2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/service-binding-to-destination.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.serviceToDestinationTransformers = void 0;
    exports2.transformServiceBindingToDestination = transformServiceBindingToDestination2;
    exports2.transformServiceBindingToClientCredentialsDestination = transformServiceBindingToClientCredentialsDestination;
    var token_accessor_1 = require_token_accessor2();
    var jwt_1 = require_jwt4();
    exports2.serviceToDestinationTransformers = {
      "business-logging": businessLoggingBindingToDestination,
      "s4-hana-cloud": xfS4hanaCloudBindingToDestination,
      destination: destinationBindingToDestination,
      "saas-registry": saasRegistryBindingToDestination,
      workflow: workflowBindingToDestination,
      "service-manager": serviceManagerBindingToDestination,
      xsuaa: xsuaaToDestination,
      aicore: aicoreToDestination
    };
    async function transformServiceBindingToDestination2(serviceBinding, options) {
      if (exports2.serviceToDestinationTransformers[serviceBinding.label]) {
        return exports2.serviceToDestinationTransformers[serviceBinding.label](serviceBinding, options);
      }
      throw new Error(`The provided service binding of type ${serviceBinding.label} is not supported out of the box for destination transformation.`);
    }
    async function transformServiceBindingToClientCredentialsDestination(service, options) {
      const token = await (0, token_accessor_1.serviceToken)(service, options);
      return buildClientCredentialsDestination(token, options?.url ?? service.url, service.name);
    }
    async function aicoreToDestination(service, options) {
      const token = await (0, token_accessor_1.serviceToken)(service, options);
      return buildClientCredentialsDestination(token, service.credentials.serviceurls.AI_API_URL, service.name);
    }
    async function xsuaaToDestination(service, options) {
      const token = await (0, token_accessor_1.serviceToken)(service, options);
      return buildClientCredentialsDestination(token, service.credentials.apiurl, service.name);
    }
    async function serviceManagerBindingToDestination(service, options) {
      const token = await (0, token_accessor_1.serviceToken)(service, options);
      return buildClientCredentialsDestination(token, service.credentials.sm_url, service.name);
    }
    async function destinationBindingToDestination(service, options) {
      const token = await (0, token_accessor_1.serviceToken)(service, options);
      return buildClientCredentialsDestination(token, service.credentials.uri, service.name);
    }
    async function saasRegistryBindingToDestination(service, options) {
      const token = await (0, token_accessor_1.serviceToken)(service, options);
      return buildClientCredentialsDestination(token, service.credentials["saas_registry_url"], service.name);
    }
    async function businessLoggingBindingToDestination(service, options) {
      const transformedService = {
        ...service,
        credentials: { ...service.credentials.uaa }
      };
      const token = await (0, token_accessor_1.serviceToken)(transformedService, options);
      return buildClientCredentialsDestination(token, service.credentials.writeUrl, service.name);
    }
    async function workflowBindingToDestination(service, options) {
      const transformedService = {
        ...service,
        credentials: { ...service.credentials.uaa }
      };
      const token = await (0, token_accessor_1.serviceToken)(transformedService, options);
      return buildClientCredentialsDestination(token, service.credentials.endpoints.workflow_odata_url, service.name);
    }
    async function xfS4hanaCloudBindingToDestination(service) {
      return {
        url: service.credentials.URL,
        authentication: "BasicAuthentication",
        username: service.credentials.User,
        password: service.credentials.Password
      };
    }
    function buildClientCredentialsDestination(token, url, name) {
      const expirationTime = (0, jwt_1.decodeJwt)(token).exp;
      const expiresIn = expirationTime ? Math.floor((expirationTime * 1e3 - Date.now()) / 1e3).toString(10) : void 0;
      return {
        url,
        name,
        authentication: "OAuth2ClientCredentials",
        authTokens: [
          {
            value: token,
            type: "bearer",
            expiresIn,
            http_header: { key: "Authorization", value: `Bearer ${token}` },
            error: null
          }
        ]
      };
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-from-vcap.js
var require_destination_from_vcap2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-from-vcap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getDestinationFromServiceBinding = getDestinationFromServiceBinding;
    exports2.searchServiceBindingForDestination = searchServiceBindingForDestination;
    var util_1 = require_dist6();
    var jwt_1 = require_jwt4();
    var environment_accessor_1 = require_environment_accessor2();
    var http_proxy_util_1 = require_http_proxy_util2();
    var destination_service_types_1 = require_destination_service_types2();
    var service_binding_to_destination_1 = require_service_binding_to_destination2();
    var forward_auth_token_1 = require_forward_auth_token2();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "destination-accessor-vcap"
    });
    async function getDestinationFromServiceBinding(options) {
      const decodedJwt = options.iss ? { iss: options.iss } : options.jwt ? (0, jwt_1.decodeJwt)(options.jwt) : void 0;
      const retrievalOptions = { ...options, jwt: decodedJwt };
      const destination = await retrieveDestination(retrievalOptions);
      const destWithProxy = destination && (0, destination_service_types_1.isHttpDestination)(destination) && ["internet", "private-link"].includes((0, http_proxy_util_1.proxyStrategy)(destination)) ? (0, http_proxy_util_1.addProxyConfigurationInternet)(destination) : destination;
      if (destWithProxy) {
        (0, forward_auth_token_1.setForwardedAuthTokenIfNeeded)(destWithProxy, options.jwt);
      }
      return destWithProxy;
    }
    async function retrieveDestination({ useCache, jwt, destinationName, serviceBindingTransformFn }) {
      const service = (0, environment_accessor_1.getServiceBindingByInstanceName)(destinationName);
      const destination = await (serviceBindingTransformFn || transform)(service, {
        useCache,
        jwt
      });
      return { name: destinationName, ...destination };
    }
    async function transform(service, options) {
      if (!service_binding_to_destination_1.serviceToDestinationTransformers[service.label]) {
        throw serviceTypeNotSupportedError(service);
      }
      return service_binding_to_destination_1.serviceToDestinationTransformers[service.label](service, options);
    }
    function serviceTypeNotSupportedError(service) {
      return Error(`The service "${service.name}" is of type "${service.label}" which is not supported! Consider providing your own transformation function when calling \`getDestinationFromServiceBinding()\`, like this:
  destinationServiceForBinding(yourServiceName, { serviceBindingToDestination: yourTransformationFunction });`);
    }
    async function searchServiceBindingForDestination(options) {
      logger8.debug("Attempting to retrieve destination from service binding.");
      try {
        const destination = await getDestinationFromServiceBinding(options);
        logger8.info("Successfully retrieved destination from service binding.");
        return destination;
      } catch (error) {
        logger8.debug(`Could not retrieve destination from service binding. If you are not using SAP Extension Factory, this information probably does not concern you. ${error.message}`);
      }
      return null;
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/connectivity-service.js
var require_connectivity_service2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/connectivity-service.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addProxyConfigurationOnPrem = addProxyConfigurationOnPrem;
    exports2.httpProxyHostAndPort = httpProxyHostAndPort;
    exports2.socksProxyHostAndPort = socksProxyHostAndPort;
    var util_1 = require_dist6();
    var environment_accessor_1 = require_environment_accessor2();
    var token_accessor_1 = require_token_accessor2();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "connectivity-service"
    });
    async function addProxyConfigurationOnPrem(destination, subscriberToken) {
      if (destination.type === "MAIL") {
        return {
          ...destination,
          proxyConfiguration: await socksProxyHostAndPort(subscriberToken?.userJwt.decoded)
        };
      }
      const proxyConfiguration = {
        ...httpProxyHostAndPort(),
        headers: {
          ...await proxyHeaders(destination.authentication, subscriberToken)
        }
      };
      return { ...destination, proxyConfiguration };
    }
    function httpProxyHostAndPort() {
      const service = readConnectivityServiceBinding();
      return {
        host: service.credentials.onpremise_proxy_host,
        port: service.credentials.onpremise_proxy_http_port || service.credentials.onpremise_proxy_port,
        protocol: "http"
      };
    }
    async function socksProxyHostAndPort(userJwt) {
      const service = readConnectivityServiceBinding();
      const connectivityServiceToken = await (0, token_accessor_1.serviceToken)(service, {
        jwt: userJwt
      });
      return {
        host: service.credentials.onpremise_proxy_host,
        port: parseInt(service.credentials.onpremise_socks5_proxy_port),
        protocol: "socks",
        "proxy-authorization": connectivityServiceToken
      };
    }
    function readConnectivityServiceBinding() {
      const serviceBindings = (0, environment_accessor_1.getServiceBindings)("connectivity");
      if (!serviceBindings.length) {
        throw new Error("No binding to a connectivity service found! Please make sure to bind an instance of the connectivity service to your app if you want to connect to on-premise destinations.");
      }
      return serviceBindings[0];
    }
    async function proxyHeaders(authenticationType, subscriberToken) {
      const proxyAuthHeader = await proxyAuthorizationHeader(subscriberToken?.serviceJwt.encoded);
      const sapConnectivityHeader = sapConnectivityAuthenticationHeader(authenticationType, subscriberToken?.userJwt.encoded);
      return {
        ...proxyAuthHeader,
        ...sapConnectivityHeader
      };
    }
    async function proxyAuthorizationHeader(jwt) {
      try {
        const connServiceBinding = readConnectivityServiceBinding();
        const token = await (0, token_accessor_1.serviceToken)(connServiceBinding, { jwt });
        return { "Proxy-Authorization": `Bearer ${token}` };
      } catch (error) {
        throw new util_1.ErrorWithCause("Failed to add proxy authorization header - client credentials grant failed!", error);
      }
    }
    function sapConnectivityAuthenticationHeader(authenticationType, jwt) {
      if (authenticationType === "PrincipalPropagation") {
        if (jwt) {
          return {
            "SAP-Connectivity-Authentication": `Bearer ${jwt}`
          };
        }
        throw new Error(`Unable to create "SAP-Connectivity-Authentication" header: no JWT found on the current request.
     Connecting to on-premise systems via principle propagation is not possible.`);
      }
      if (authenticationType === "BasicAuthentication") {
        logger8.warn("You are connecting to an On-Premise system using basic authentication. For productive usage Principal propagation is recommended.");
      }
      return {};
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/tenant.js
var require_tenant2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/tenant.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isIdenticalTenant = isIdenticalTenant;
    var jwt_1 = require_jwt4();
    function isIdenticalTenant(userTokenPayload, providerTokenPayload) {
      return (0, jwt_1.getTenantId)(userTokenPayload) === (0, jwt_1.getTenantId)(providerTokenPayload);
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/async-cache.js
var require_async_cache2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/async-cache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AsyncCache = void 0;
    var cache_1 = require_cache3();
    var AsyncCache = class {
      constructor(defaultValidityTime = 0) {
        this.cache = new cache_1.Cache(defaultValidityTime);
      }
      /**
       * Specifies whether an entry with a given key is defined in cache.
       * @param key - The entry's key.
       * @returns A boolean value that indicates whether the entry exists in cache.
       */
      async hasKey(key) {
        return this.cache.hasKey(key);
      }
      /**
       * Getter of cached entries.
       * @param key - The key of the entry to retrieve.
       * @returns The corresponding entry to the provided key if it is still valid, returns `undefined` otherwise.
       */
      async get(key) {
        return this.cache.get(key);
      }
      /**
       * Setter of entries in cache.
       * @param key - The entry's key.
       * @param item - The entry to cache.
       * @returns A promise to oid.
       */
      async set(key, item) {
        return this.cache.set(key, item);
      }
      /**
       * Clear all cached items.
       * @returns A promise to void.
       */
      async clear() {
        return this.cache.clear();
      }
    };
    exports2.AsyncCache = AsyncCache;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-cache.js
var require_destination_cache2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-cache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.destinationCache = exports2.DestinationCache = exports2.DefaultDestinationCache = void 0;
    exports2.getDestinationCacheKey = getDestinationCacheKey;
    exports2.setDestinationCache = setDestinationCache;
    exports2.getDefaultIsolationStrategy = getDefaultIsolationStrategy;
    var util_1 = require_dist6();
    var jwt_1 = require_jwt4();
    var async_cache_1 = require_async_cache2();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "destination-cache"
    });
    var DefaultDestinationCache = class extends async_cache_1.AsyncCache {
      constructor(defaultValidityTime = 0) {
        super(defaultValidityTime);
      }
    };
    exports2.DefaultDestinationCache = DefaultDestinationCache;
    var DestinationCache = (cache = new DefaultDestinationCache(3e5)) => ({
      retrieveDestinationFromCache: async (token, name, isolation) => cache.get(getDestinationCacheKey(token, name, isolation)),
      cacheRetrievedDestination: async (token, destination, isolation) => {
        cacheRetrievedDestination(token, destination, isolation, cache);
      },
      cacheRetrievedDestinations: async (token, retrievedDestinations, isolation) => {
        retrievedDestinations.subaccount.forEach((dest) => cacheRetrievedDestination(token, dest, isolation, cache));
        retrievedDestinations.instance.forEach((dest) => cacheRetrievedDestination(token, dest, isolation, cache));
      },
      clear: async () => {
        cache.clear();
      },
      getCacheInstance: () => cache
    });
    exports2.DestinationCache = DestinationCache;
    function getJwtForTenant(token) {
      return token?.serviceJwt?.decoded || token;
    }
    function getJwtForUser(token) {
      return token?.userJwt?.decoded || token;
    }
    function getDestinationCacheKey(token, destinationName, isolationStrategy = "tenant-user") {
      if (isolationStrategy === "tenant") {
        return getTenantCacheKey(destinationName, (0, jwt_1.getTenantId)(getJwtForTenant(token)));
      }
      if (isolationStrategy === "tenant-user") {
        return getTenantUserCacheKey(destinationName, (0, jwt_1.getTenantId)(getJwtForTenant(token)), (0, jwt_1.userId)(getJwtForUser(token)));
      }
      logger8.warn(`Could not build destination cache key. Isolation strategy '${isolationStrategy}' is not supported.`);
    }
    function getTenantCacheKey(destinationName, tenant) {
      if (tenant) {
        return `${tenant}::${destinationName}`;
      }
      logger8.warn("Could not build destination cache key. Isolation strategy 'tenant' is used, but tenant ID is undefined in JWT.");
    }
    function getTenantUserCacheKey(destinationName, tenant, user) {
      if (tenant && user) {
        return `${user}:${tenant}:${destinationName}`;
      }
      logger8.warn("Could not build destination cache key. Isolation strategy 'tenant-user' is used, but tenant id or user id is undefined in JWT.");
    }
    async function cacheRetrievedDestination(token, destination, isolation, cache) {
      if (!destination.name) {
        throw new Error("The destination name is undefined.");
      }
      const key = getDestinationCacheKey(token, destination.name, isolation);
      const expiresIn = (0, util_1.first)(destination.authTokens || [])?.expiresIn;
      const expirationTime = expiresIn ? Date.now() + parseInt(expiresIn) * 1e3 : void 0;
      cache.set(key, { entry: destination, expires: expirationTime });
    }
    function setDestinationCache(cache) {
      exports2.destinationCache = (0, exports2.DestinationCache)(cache);
    }
    exports2.destinationCache = (0, exports2.DestinationCache)();
    function getDefaultIsolationStrategy(jwt) {
      return jwt && (0, jwt_1.userId)(jwt) ? "tenant-user" : "tenant";
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-selection-strategies.js
var require_destination_selection_strategies2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-selection-strategies.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DestinationSelectionStrategies = void 0;
    exports2.alwaysProvider = alwaysProvider;
    exports2.alwaysSubscriber = alwaysSubscriber;
    exports2.subscriberFirst = subscriberFirst;
    var util_1 = require_dist6();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "destination-selection-strategies"
    });
    function alwaysProvider(allDestinations, destinationName) {
      return findDestination(allDestinations.provider, destinationName) || null;
    }
    function alwaysSubscriber(allDestinations, destinationName) {
      return findDestination(allDestinations.subscriber, destinationName) || null;
    }
    function subscriberFirst(allDestinations, destinationName) {
      return findDestination(allDestinations.subscriber, destinationName) || findDestination(allDestinations.provider, destinationName) || null;
    }
    exports2.DestinationSelectionStrategies = {
      alwaysProvider,
      alwaysSubscriber,
      subscriberFirst
    };
    function findDestination(destinations, destinationName) {
      const isRequestedDestination = (destination) => destination.name === destinationName;
      const instanceDest = destinations.instance.find(isRequestedDestination);
      const subAccountDest = destinations.subaccount.find(isRequestedDestination);
      if (instanceDest && subAccountDest) {
        logger8.warn(`Found destinations named '${destinationName}' for both, the destination service instance and subaccount. Using instance destination.`);
      }
      return instanceDest || subAccountDest;
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/http-agent/agent-config.js
var require_agent_config2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/http-agent/agent-config.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/register-destination-cache.js
var require_register_destination_cache2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/register-destination-cache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.registerDestinationCache = exports2.RegisterDestinationCache = void 0;
    var promises_1 = require("fs/promises");
    var crypto_1 = require("crypto");
    var util_1 = require_dist6();
    var async_cache_1 = require_async_cache2();
    var destination_cache_1 = require_destination_cache2();
    var logger8 = (0, util_1.createLogger)("register-destination-cache");
    var DefaultMtlsCache = class extends async_cache_1.AsyncCache {
      constructor(defaultValidityTime = 3e5) {
        super(defaultValidityTime);
      }
    };
    var MtlsCache = (mtlsCache = new DefaultMtlsCache()) => {
      const that = {
        useMtlsCache: false,
        retrieveMtlsOptionsFromCache: async () => mtlsCache.get("mtlsOptions"),
        cacheMtlsOptions: async () => {
          const getCert = (0, promises_1.readFile)(process.env.CF_INSTANCE_CERT, "utf8");
          const getKey = (0, promises_1.readFile)(process.env.CF_INSTANCE_KEY, "utf8");
          const [cert, key] = await Promise.all([getCert, getKey]);
          mtlsCache.set("mtlsOptions", {
            entry: { cert, key },
            expires: getCertExpirationDate(cert)
          });
        },
        getMtlsOptions: async () => {
          let mtlsOptions = await that.retrieveMtlsOptionsFromCache();
          if (!mtlsOptions) {
            await that.cacheMtlsOptions();
            mtlsOptions = await that.retrieveMtlsOptionsFromCache();
            if (!mtlsOptions) {
              logger8.warn("Neither the previous nor the current mtls certificate is valid anymore.");
            }
          }
          return mtlsOptions || {};
        },
        clear: async () => mtlsCache.clear(),
        getCacheInstance: () => mtlsCache
      };
      return that;
    };
    function getCertExpirationDate(cert) {
      return Number(new crypto_1.X509Certificate(cert).validTo);
    }
    var RegisterDestinationCache = () => ({
      destination: (0, destination_cache_1.DestinationCache)(new destination_cache_1.DefaultDestinationCache(0)),
      mtls: MtlsCache()
    });
    exports2.RegisterDestinationCache = RegisterDestinationCache;
    exports2.registerDestinationCache = (0, exports2.RegisterDestinationCache)();
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/http-agent/http-agent.js
var require_http_agent3 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/http-agent/http-agent.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getAgentConfig = getAgentConfig;
    exports2.urlAndAgent = urlAndAgent;
    var promises_1 = require("fs/promises");
    var http_1 = __importDefault(require("http"));
    var https_1 = __importDefault(require("https"));
    var util_1 = require_dist6();
    var get_protocol_1 = require_get_protocol2();
    var http_proxy_util_1 = require_http_proxy_util2();
    var register_destination_cache_1 = require_register_destination_cache2();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "http-agent"
    });
    async function getAgentConfig(destination) {
      const certificateOptions = {
        ...getTrustStoreOptions(destination),
        ...getKeyStoreOptions(destination),
        ...await getMtlsOptions(destination)
      };
      return createAgent(destination, certificateOptions);
    }
    function getTrustStoreOptions(destination) {
      if ((0, get_protocol_1.getProtocolOrDefault)(destination) === "http") {
        if (destination.isTrustingAllCertificates) {
          logger8.warn('"isTrustingAllCertificates" is not available for HTTP.');
        }
        if (destination.trustStoreCertificate) {
          logger8.warn('"trustStore" is not available for HTTP.');
        }
        return {};
      }
      if (destination.isTrustingAllCertificates && destination.trustStoreCertificate) {
        logger8.warn(`Destination ${destination.name} contains the 'trustAll' and 'trustStoreLocation' property which is a redundant setup.`);
      }
      if (destination.isTrustingAllCertificates) {
        logger8.warn('"isTrustingAllCertificates" property in the provided destination is set to "true". This is highly discouraged in production.');
        return { rejectUnauthorized: !destination.isTrustingAllCertificates };
      }
      if (destination.trustStoreCertificate) {
        const decoded = Buffer.from(destination.trustStoreCertificate.content, "base64").toString("utf8");
        return {
          rejectUnauthorized: true,
          ca: [decoded]
        };
      }
      return { rejectUnauthorized: true };
    }
    function getKeyStoreOptions(destination) {
      if (
        // Only add certificates, when using ClientCertificateAuthentication (https://github.com/SAP/cloud-sdk-js/issues/3544)
        destination.authentication === "ClientCertificateAuthentication" && !mtlsIsEnabled(destination) && destination.keyStoreName
      ) {
        const certificate = selectCertificate(destination);
        validateFormat(certificate);
        logger8.debug(`Certificate with name "${certificate.name}" selected.`);
        if (!destination.keyStorePassword) {
          logger8.debug(`Destination '${destination.name}' does not have a keystore password.`);
        }
        const certBuffer = Buffer.from(certificate.content, "base64");
        if (getFormat(certificate) === "pem") {
          return {
            cert: certBuffer,
            key: certBuffer,
            passphrase: destination.keyStorePassword
          };
        }
        return {
          pfx: certBuffer,
          passphrase: destination.keyStorePassword
        };
      }
      return {};
    }
    async function getMtlsOptions(destination) {
      if (destination.mtls && !(process.env.CF_INSTANCE_CERT && process.env.CF_INSTANCE_KEY)) {
        logger8.warn(`Destination ${destination.name ? destination.name : ""} has mTLS enabled, but the required Cloud Foundry environment variables (CF_INSTANCE_CERT and CF_INSTANCE_KEY) are not defined. Note that 'inferMtls' only works on Cloud Foundry.`);
      }
      if (mtlsIsEnabled(destination)) {
        if (register_destination_cache_1.registerDestinationCache.mtls.useMtlsCache) {
          return register_destination_cache_1.registerDestinationCache.mtls.getMtlsOptions();
        }
        const getCert = (0, promises_1.readFile)(process.env.CF_INSTANCE_CERT, "utf8");
        const getKey = (0, promises_1.readFile)(process.env.CF_INSTANCE_KEY, "utf8");
        const [cert, key] = await Promise.all([getCert, getKey]);
        return {
          cert,
          key
        };
      }
      return {};
    }
    function mtlsIsEnabled(destination) {
      return destination.mtls && process.env.CF_INSTANCE_CERT && process.env.CF_INSTANCE_KEY;
    }
    var supportedCertificateFormats = ["p12", "pfx", "pem"];
    function isSupportedFormat(format) {
      return !!format && supportedCertificateFormats.includes(format);
    }
    function selectCertificate(destination) {
      const certificate = destination.certificates.find((c) => c.name === destination.keyStoreName);
      if (!certificate) {
        throw Error(`No certificate with name ${destination.keyStoreName} could be found on the destination!`);
      }
      return certificate;
    }
    function getFormat(certificate) {
      return (0, util_1.last)(certificate.name.split("."));
    }
    function validateFormat(certificate) {
      const format = getFormat(certificate);
      if (!isSupportedFormat(format)) {
        throw Error(`The format of the provided certificate '${certificate.name}' is not supported. Supported formats are: ${supportedCertificateFormats.join(", ")}. ${format && ["jks", "keystore"].includes(format) ? "You can convert Java Keystores (.jks, .keystore) into PKCS#12 keystores using the JVM's keytool CLI: keytool -importkeystore -srckeystore your-keystore.jks -destkeystore your-keystore.p12 -deststoretype pkcs12" : ""}`);
      }
    }
    function createAgent(destination, options) {
      return (0, get_protocol_1.getProtocolOrDefault)(destination) === "https" ? { httpsAgent: new https_1.default.Agent(options) } : { httpAgent: new http_1.default.Agent(options) };
    }
    async function urlAndAgent(targetUri) {
      let destination = { url: targetUri, proxyType: "Internet" };
      if ((0, http_proxy_util_1.proxyStrategy)(destination) === "internet") {
        destination = (0, http_proxy_util_1.addProxyConfigurationInternet)(destination);
      }
      return {
        baseURL: destination.url,
        ...await getAgentConfig(destination),
        proxy: (0, http_proxy_util_1.getProxyConfig)(destination)
      };
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/http-agent/index.js
var require_http_agent4 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/http-agent/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_agent_config2(), exports2);
    __exportStar(require_http_agent3(), exports2);
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-service-cache.js
var require_destination_service_cache2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-service-cache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.destinationServiceCache = void 0;
    var cache_1 = require_cache3();
    var destination_cache_1 = require_destination_cache2();
    var DestinationServiceCache = (cache) => ({
      retrieveDestinationsFromCache: (targetUrl, decodedJwt) => cache.get((0, destination_cache_1.getDestinationCacheKey)(decodedJwt, targetUrl, "tenant")),
      cacheRetrievedDestinations: (destinationServiceUri, decodedJwt, destinations) => {
        const key = (0, destination_cache_1.getDestinationCacheKey)(decodedJwt, destinationServiceUri, "tenant");
        cache.set(key, { entry: destinations });
      },
      clear: () => {
        cache.clear();
      },
      getCacheInstance: () => cache
    });
    exports2.destinationServiceCache = DestinationServiceCache(new cache_1.Cache(3e5));
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-service.js
var require_destination_service2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-service.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fetchDestinations = fetchDestinations;
    exports2.fetchDestinationWithoutTokenRetrieval = fetchDestinationWithoutTokenRetrieval;
    exports2.fetchCertificate = fetchCertificate;
    exports2.fetchDestinationWithTokenRetrieval = fetchDestinationWithTokenRetrieval;
    var util_1 = require_dist6();
    var axios_1 = __importDefault(require_axios());
    var internal_1 = require_internal6();
    var resilience_1 = require_dist7();
    var async_retry_1 = __importDefault(require_lib());
    var jwt_1 = require_jwt4();
    var http_agent_1 = require_http_agent4();
    var authorization_header_1 = require_authorization_header2();
    var destination_1 = require_destination5();
    var destination_service_cache_1 = require_destination_service_cache2();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "destination-service"
    });
    async function fetchDestinations(destinationServiceUri, serviceToken, type, options) {
      const targetUri = `${(0, util_1.removeTrailingSlashes)(destinationServiceUri)}/destination-configuration/v1/${type}Destinations`;
      if (options?.useCache) {
        const destinationsFromCache = destination_service_cache_1.destinationServiceCache.retrieveDestinationsFromCache(targetUri, (0, jwt_1.decodeJwt)(serviceToken));
        if (destinationsFromCache) {
          logger8.debug(`Destinations retrieved from cache. There were ${destinationsFromCache.length} destinations returned from the cache.`);
          return destinationsFromCache;
        }
      }
      const headers = (0, jwt_1.wrapJwtInHeader)(serviceToken).headers;
      return callDestinationEndpoint({ uri: targetUri, tenantId: getTenantIdFromTokens(serviceToken) }, headers).then((response) => {
        const destinations = response.data.map((destination) => (0, destination_1.parseDestination)(destination));
        if (options?.useCache) {
          destination_service_cache_1.destinationServiceCache.cacheRetrievedDestinations(targetUri, (0, jwt_1.decodeJwt)(serviceToken), destinations);
        }
        return destinations;
      }).catch((error) => {
        throw new util_1.ErrorWithCause(`Failed to fetch ${type} destinations.${errorMessageFromResponse(error)}`, error);
      });
    }
    async function fetchDestinationWithoutTokenRetrieval(destinationName, destinationServiceUri, serviceToken) {
      const targetUri = `${(0, util_1.removeTrailingSlashes)(destinationServiceUri)}/destination-configuration/v1/destinations/${destinationName}?$skipTokenRetrieval=true`;
      try {
        const response = await callDestinationEndpoint({ uri: targetUri, tenantId: getTenantIdFromTokens(serviceToken) }, { Authorization: `Bearer ${serviceToken}` });
        const destination = (0, destination_1.parseDestination)(response.data.destinationConfiguration);
        return {
          instance: response.data.owner?.InstanceId ? [destination] : [],
          subaccount: !response.data.owner?.InstanceId && response.data.owner?.SubaccountId ? [destination] : []
        };
      } catch (err) {
        if (err.response?.status === 404 && err.response?.data?.ErrorMessage === "Configuration with the specified name was not found") {
          return {
            instance: [],
            subaccount: []
          };
        }
        throw new util_1.ErrorWithCause(`Failed to fetch destination.${errorMessageFromResponse(err)}`, err);
      }
    }
    async function fetchCertificate(destinationServiceUri, token, certificateName) {
      const filetype = certificateName.split(".")[1];
      if (filetype.toLowerCase() !== "pem") {
        logger8.warn(`The provided truststore ${certificateName} is not in 'pem' format which is currently the only supported format. Truststore is ignored.`);
        return;
      }
      const accountUri = `${(0, util_1.removeTrailingSlashes)(destinationServiceUri)}/destination-configuration/v1/subaccountCertificates/${certificateName}`;
      const instanceUri = `${(0, util_1.removeTrailingSlashes)(destinationServiceUri)}/destination-configuration/v1/instanceCertificates/${certificateName}`;
      const header = (0, jwt_1.wrapJwtInHeader)(token).headers;
      try {
        const response = await callCertificateEndpoint({ uri: accountUri, tenantId: getTenantIdFromTokens(token) }, header).catch(() => callCertificateEndpoint({
          uri: instanceUri,
          tenantId: getTenantIdFromTokens(token)
        }, header));
        return (0, destination_1.parseCertificate)(response.data);
      } catch (err) {
        logger8.warn(`Failed to fetch truststore certificate ${certificateName} - Continuing without certificate. This may cause failing requests`, err);
      }
    }
    function getTenantIdFromTokens(token) {
      let tenant;
      if (typeof token === "string") {
        tenant = (0, jwt_1.getTenantId)(token);
      } else {
        tenant = // represents the tenant as string already see https://api.sap.com/api/SAP_CP_CF_Connectivity_Destination/resource
        token.exchangeTenant || (0, jwt_1.getTenantId)(token.exchangeHeaderJwt) || (0, jwt_1.getTenantId)(token.authHeaderJwt);
      }
      if (!tenant) {
        throw new Error("Could not obtain tenant identifier from JWT.");
      }
      return tenant;
    }
    async function fetchDestinationWithTokenRetrieval(destinationServiceUri, token, options) {
      const targetUri = `${(0, util_1.removeTrailingSlashes)(destinationServiceUri)}/destination-configuration/v1/destinations/${options.destinationName}`;
      token = typeof token === "string" ? { authHeaderJwt: token } : token;
      let authHeader = (0, jwt_1.wrapJwtInHeader)(token.authHeaderJwt).headers;
      authHeader = token.exchangeHeaderJwt ? { ...authHeader, "X-user-token": token.exchangeHeaderJwt } : authHeader;
      authHeader = token.exchangeTenant ? { ...authHeader, "X-tenant": token.exchangeTenant } : authHeader;
      authHeader = token.refreshToken ? { ...authHeader, "X-refresh-token": token.refreshToken } : authHeader;
      return callDestinationEndpoint({ uri: targetUri, tenantId: getTenantIdFromTokens(token) }, authHeader, options).then((response) => {
        const destination = (0, destination_1.parseDestination)(response.data);
        return destination;
      }).catch((error) => {
        {
          throw new util_1.ErrorWithCause(`Failed to fetch destination ${options.destinationName}.${errorMessageFromResponse(error)}`, error);
        }
      });
    }
    function errorMessageFromResponse(error) {
      return (0, util_1.propertyExists)(error, "response", "data", "ErrorMessage") ? ` ${error.response.data.ErrorMessage}` : "";
    }
    function retryDestination(destinationName) {
      return (options) => (arg) => {
        let retryCount = 1;
        return (0, async_retry_1.default)(async (bail) => {
          try {
            const destination = await options.fn(arg);
            if (retryCount < 3) {
              retryCount++;
              await (0, authorization_header_1.buildAuthorizationHeaders)((0, destination_1.parseDestination)(destination.data));
            }
            return destination;
          } catch (error) {
            const status = error?.response?.status;
            if (status.toString().startsWith("4")) {
              bail(new util_1.ErrorWithCause(`Request failed with status code ${status}`, error));
              return void 0;
            }
            throw error;
          }
        }, {
          retries: 3,
          onRetry: (err) => logger8.warn(`Failed to retrieve destination ${destinationName} - doing a retry. Original Error ${err.message}`)
        });
      };
    }
    async function callCertificateEndpoint(context, headers) {
      if (!context.uri.includes("Certificates")) {
        throw new Error(`callCertificateEndpoint was called with illegal argument: ${context.uri}. URL must be certificate endpoint of destination service.`);
      }
      return callDestinationService(context, headers);
    }
    async function callDestinationEndpoint(context, headers, options) {
      if (!context.uri.match(/[instance|subaccount]Destinations|v1\/destinations/)) {
        throw new Error(`callDestinationEndpoint was called with illegal argument: ${context.uri}. URL must be destination(s) endpoint of destination service.`);
      }
      return callDestinationService(context, headers, options);
    }
    async function callDestinationService(context, headers, options) {
      const { destinationName, retry } = options || {};
      const requestConfig = {
        ...await (0, http_agent_1.urlAndAgent)(context.uri),
        method: "get",
        headers
      };
      const resilienceMiddleware = (0, resilience_1.resilience)();
      if (destinationName && retry) {
        resilienceMiddleware.unshift(retryDestination(destinationName));
      }
      return (0, internal_1.executeWithMiddleware)(resilienceMiddleware, {
        context,
        fnArgument: requestConfig,
        fn: (config) => axios_1.default.request(config)
      });
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/get-provider-token.js
var require_get_provider_token2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/get-provider-token.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getProviderServiceToken = getProviderServiceToken;
    var jwt_1 = require_jwt4();
    var token_accessor_1 = require_token_accessor2();
    async function getProviderServiceToken(options) {
      const { jwt, ...optionsWithoutJwt } = options;
      const encoded = await (0, token_accessor_1.serviceToken)("destination", optionsWithoutJwt);
      return { encoded, decoded: (0, jwt_1.decodeJwt)(encoded) };
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/get-subscriber-token.js
var require_get_subscriber_token2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/get-subscriber-token.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isSubscriberToken = isSubscriberToken;
    exports2.getSubscriberToken = getSubscriberToken;
    exports2.getRequiredSubscriberToken = getRequiredSubscriberToken;
    exports2.hasTokens = hasTokens;
    exports2.getJwtForTenant = getJwtForTenant;
    exports2.getJwtForUser = getJwtForUser;
    var util_1 = require_dist6();
    var jwt_1 = require_jwt4();
    var token_accessor_1 = require_token_accessor2();
    var subdomain_replacer_1 = require_subdomain_replacer2();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "destination-accessor-service"
    });
    function isSubscriberToken(token) {
      return token.userJwt || token.serviceJwt;
    }
    async function getSubscriberToken(options) {
      const isXsuaaJwt = !!options.jwt && (0, jwt_1.isXsuaaToken)((0, jwt_1.decodeJwt)(options.jwt));
      const userJwt = await retrieveUserToken(options, isXsuaaJwt);
      const serviceJwt = await retrieveServiceToken(options, userJwt?.decoded);
      return { userJwt, serviceJwt };
    }
    async function retrieveUserToken(options, isXsuaaJwt) {
      if (options.jwt) {
        if (!options.iss && isXsuaaJwt) {
          await (0, jwt_1.verifyJwt)(options.jwt, options);
        }
        return (0, jwt_1.getJwtPair)(options.jwt);
      }
    }
    async function retrieveServiceToken(options, decodedUserJwt) {
      const jwt = getJwtForServiceToken(options.iss, decodedUserJwt);
      if (jwt) {
        try {
          return (0, jwt_1.getJwtPair)(await (0, token_accessor_1.serviceToken)("destination", {
            ...options,
            jwt
          }));
        } catch (err) {
          logger8.warn(`Failed to fetch subscriber service token for destination. This is only relevant if you are using subscriber destinations. Failure caused by: ${err.message}`);
        }
      }
    }
    function getJwtForServiceToken(iss, decodedUserJwt) {
      if (iss) {
        logger8.debug("Using `iss` option instead of a full JWT to fetch a destination. No validation is performed.");
        return { ext_attr: { zdn: (0, subdomain_replacer_1.getIssuerSubdomain)({ iss }) } };
      }
      if (decodedUserJwt?.zid || decodedUserJwt?.app_tid) {
        return decodedUserJwt;
      }
    }
    function getRequiredSubscriberToken(token) {
      if (token) {
        const { userJwt, serviceJwt } = token;
        const requiredToken = {
          userJwt: userJwt || serviceJwt,
          serviceJwt: serviceJwt || userJwt
        };
        if (isRequired(requiredToken)) {
          return requiredToken;
        }
      }
      throw new Error("Could not get subscriber token: Token value is undefined.");
    }
    function isRequired(token) {
      return !!(token?.userJwt && token.serviceJwt);
    }
    function hasTokens(token) {
      return !!token?.userJwt || !!token?.serviceJwt;
    }
    function getJwtForTenant(token) {
      return token.serviceJwt;
    }
    function getJwtForUser(token) {
      return token.userJwt;
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-from-service.js
var require_destination_from_service2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-from-service.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DestinationFromServiceRetriever = void 0;
    exports2.getDestinationFromDestinationService = getDestinationFromDestinationService;
    var util_1 = require_dist6();
    var connectivity_service_1 = require_connectivity_service2();
    var environment_accessor_1 = require_environment_accessor2();
    var identity_service_1 = require_identity_service2();
    var jwt_1 = require_jwt4();
    var tenant_1 = require_tenant2();
    var token_accessor_1 = require_token_accessor2();
    var destination_cache_1 = require_destination_cache2();
    var destination_selection_strategies_1 = require_destination_selection_strategies2();
    var destination_service_1 = require_destination_service2();
    var destination_service_types_1 = require_destination_service_types2();
    var get_provider_token_1 = require_get_provider_token2();
    var get_subscriber_token_1 = require_get_subscriber_token2();
    var http_proxy_util_1 = require_http_proxy_util2();
    var forward_auth_token_1 = require_forward_auth_token2();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "destination-accessor-service"
    });
    var emptyDestinationByType = {
      instance: [],
      subaccount: []
    };
    async function getDestinationFromDestinationService(options) {
      logger8.debug("Attempting to retrieve destination from destination service.");
      return DestinationFromServiceRetriever.getDestinationFromDestinationService(options);
    }
    var DestinationFromServiceRetriever = class _DestinationFromServiceRetriever {
      static async getDestinationFromDestinationService(options) {
        if ((0, identity_service_1.shouldExchangeToken)(options) && options.jwt) {
          options.jwt = await (0, identity_service_1.exchangeToken)(options.jwt);
        }
        const subscriberToken = await (0, get_subscriber_token_1.getSubscriberToken)(options);
        const providerToken = await (0, get_provider_token_1.getProviderServiceToken)(options);
        const da = new _DestinationFromServiceRetriever(options, subscriberToken, providerToken);
        const destinationResult = await da.searchDestinationWithSelectionStrategyAndCache();
        if (!destinationResult) {
          return null;
        }
        let { destination } = destinationResult;
        (0, forward_auth_token_1.setForwardedAuthTokenIfNeeded)(destination, options.jwt);
        if (destinationResult.fromCache) {
          return da.addProxyConfiguration(destination);
        }
        if (!destination.forwardAuthToken) {
          if (destination.authentication === "OAuth2UserTokenExchange" || destination.authentication === "OAuth2JWTBearer" || destination.authentication === "SAMLAssertion" || destination.authentication === "OAuth2SAMLBearerAssertion" && !da.usesSystemUser(destination)) {
            destination = await da.fetchDestinationWithUserExchangeFlows(destinationResult);
          }
          if (destination.authentication === "PrincipalPropagation") {
            if (!this.isUserJwt(da.subscriberToken)) {
              _DestinationFromServiceRetriever.throwUserTokenMissing(destination);
            }
          }
          if (destination.authentication === "OAuth2Password" || destination.authentication === "ClientCertificateAuthentication" || destination.authentication === "OAuth2ClientCredentials" || da.usesSystemUser(destination)) {
            destination = await da.fetchDestinationWithNonUserExchangeFlows(destinationResult);
          }
          if (destination.authentication === "OAuth2RefreshToken") {
            destination = await da.fetchDestinationWithRefreshTokenFlow(destinationResult);
          }
        }
        const withTrustStore = await da.addTrustStoreConfiguration(destination, destinationResult.origin);
        await da.updateDestinationCache(withTrustStore, destinationResult.origin);
        return da.addProxyConfiguration(withTrustStore);
      }
      static throwUserTokenMissing(destination) {
        throw Error(`No user token (JWT) has been provided. This is strictly necessary for '${destination.authentication}'.`);
      }
      static checkDestinationForCustomJwt(destination) {
        if (!destination.jwks && !destination.jwksUri) {
          throw new Error("Failed to verify the JWT with no JKU! Destination must have `x_user_token.jwks` or `x_user_token.jwks_uri` property.");
        }
      }
      static isUserJwt(token) {
        return !!token?.userJwt;
      }
      constructor(options, subscriberToken, providerServiceToken) {
        this.subscriberToken = subscriberToken;
        this.providerServiceToken = providerServiceToken;
        const defaultOptions2 = {
          isolationStrategy: (0, destination_cache_1.getDefaultIsolationStrategy)(subscriberToken?.userJwt?.decoded),
          selectionStrategy: destination_selection_strategies_1.subscriberFirst,
          useCache: true
        };
        this.options = { ...defaultOptions2, ...options };
      }
      async searchDestinationWithSelectionStrategyAndCache() {
        let destinationSearchResult;
        if (this.isSubscriberNeeded()) {
          destinationSearchResult = await this.searchSubscriberAccountForDestination();
        }
        if (this.isProviderNeeded(destinationSearchResult)) {
          destinationSearchResult = await this.searchProviderAccountForDestination();
        }
        if (destinationSearchResult) {
          if (destinationSearchResult.fromCache) {
            logger8.debug(`Successfully retrieved destination from destination service cache for ${destinationSearchResult.origin} destinations.`);
          } else {
            logger8.debug("Successfully retrieved destination from destination service.");
          }
        } else {
          logger8.debug("Could not retrieve destination from destination service.");
        }
        return destinationSearchResult;
      }
      getExchangeTenant(destination) {
        if (destination.authentication !== "OAuth2ClientCredentials") {
          return void 0;
        }
        if (destination.originalProperties?.["tokenServiceURLType"] !== "Common") {
          return void 0;
        }
        const subdomainSubscriber = (0, jwt_1.getSubdomain)(this.subscriberToken?.serviceJwt?.decoded) || (0, jwt_1.getSubdomain)(this.subscriberToken?.userJwt?.decoded);
        const subdomainProvider = (0, jwt_1.getSubdomain)(this.providerServiceToken?.decoded);
        return subdomainSubscriber || subdomainProvider || void 0;
      }
      async getAuthTokenForOAuth2ClientCredentials(destinationResult) {
        const { destination, origin } = destinationResult;
        const exchangeTenant = this.getExchangeTenant(destination);
        const authHeaderJwt = origin === "provider" ? this.providerServiceToken.encoded : this.subscriberToken?.serviceJwt?.encoded;
        if (!authHeaderJwt) {
          throw Error("Could not retrieve service token for the destination service.");
        }
        return { authHeaderJwt, exchangeTenant };
      }
      // This covers the two technical user propagation https://help.sap.com/viewer/cca91383641e40ffbe03bdc78f00f681/Cloud/en-US/3cb7b81115c44cf594e0e3631291af94.html
      usesSystemUser(destination) {
        if (destination.systemUser && destination.authentication === "OAuth2SAMLBearerAssertion") {
          logger8.debug(`System user found on destination: "${destination.name}". 
The property SystemUser has been deprecated. 
It is highly recommended that you stop using it.
Possible alternatives for such technical user authentication are BasicAuthentication, OAuth2ClientCredentials, or ClientCertificateAuthentication`);
          return true;
        }
        return false;
      }
      async getAuthTokenForOAuth2UserBasedTokenExchanges(destinationResult) {
        const { destination, origin } = destinationResult;
        const { destinationName } = this.options;
        if (!_DestinationFromServiceRetriever.isUserJwt(this.subscriberToken)) {
          throw _DestinationFromServiceRetriever.throwUserTokenMissing(destination);
        }
        const isXsuaaUserJwt = (0, jwt_1.isXsuaaToken)(this.subscriberToken.userJwt.decoded);
        if (!isXsuaaUserJwt) {
          _DestinationFromServiceRetriever.checkDestinationForCustomJwt(destination);
        }
        if (isXsuaaUserJwt && (0, tenant_1.isIdenticalTenant)(this.subscriberToken.userJwt.decoded, this.providerServiceToken.decoded)) {
          logger8.debug(`UserExchange flow started without user exchange token for destination ${destinationName} of the provider account.`);
          return {
            authHeaderJwt: await (0, token_accessor_1.jwtBearerToken)(this.subscriberToken.userJwt.encoded, getDestinationService())
          };
        }
        const serviceJwt = origin === "provider" ? this.providerServiceToken : (
          // on type level this could be undefined, but logically if the origin is subscriber, it must be defined.
          this.subscriberToken.serviceJwt
        );
        logger8.debug(`UserExchange flow started for destination ${destinationName} of the ${origin} account.`);
        return {
          authHeaderJwt: serviceJwt.encoded,
          // token to get destination from service
          exchangeHeaderJwt: this.subscriberToken.userJwt.encoded
          // token considered for user and tenant
        };
      }
      async getAuthTokenForOAuth2RefreshToken(destinationResult) {
        const { destination, origin } = destinationResult;
        const { refreshToken } = this.options;
        if (!refreshToken) {
          throw Error(`No refresh token has been provided. This is strictly necessary for '${destination.authentication}'.`);
        }
        const clientGrant = origin === "provider" ? this.providerServiceToken.encoded : this.subscriberToken.serviceJwt.encoded;
        return { authHeaderJwt: clientGrant, refreshToken };
      }
      /**
       * @internal
       * This method calls the 'find destination by name' endpoint of the destination service using a client credentials grant.
       * For the find by name endpoint, the destination service will take care of OAuth flows and include the token in the destination.
       * @param destinationResult - Result of the getDestinations call for which the exchange flow is triggered.
       * @returns Destination containing the auth token.
       */
      async fetchDestinationWithNonUserExchangeFlows(destinationResult) {
        const token = await this.getAuthTokenForOAuth2ClientCredentials(destinationResult);
        return (0, destination_service_1.fetchDestinationWithTokenRetrieval)((0, environment_accessor_1.getDestinationServiceCredentials)().uri, token, this.options);
      }
      async fetchDestinationWithUserExchangeFlows(destinationResult) {
        const token = await this.getAuthTokenForOAuth2UserBasedTokenExchanges(destinationResult);
        return (0, destination_service_1.fetchDestinationWithTokenRetrieval)((0, environment_accessor_1.getDestinationServiceCredentials)().uri, token, this.options);
      }
      async fetchDestinationWithRefreshTokenFlow(destinationResult) {
        const token = await this.getAuthTokenForOAuth2RefreshToken(destinationResult);
        return (0, destination_service_1.fetchDestinationWithTokenRetrieval)((0, environment_accessor_1.getDestinationServiceCredentials)().uri, token, this.options);
      }
      async addProxyConfiguration(destination) {
        switch ((0, http_proxy_util_1.proxyStrategy)(destination)) {
          case "on-premise":
            return (0, connectivity_service_1.addProxyConfigurationOnPrem)(destination, (0, get_subscriber_token_1.hasTokens)(this.subscriberToken) ? (0, get_subscriber_token_1.getRequiredSubscriberToken)(this.subscriberToken) : void 0);
          case "internet":
          case "private-link":
            (0, destination_service_types_1.assertHttpDestination)(destination);
            return (0, http_proxy_util_1.addProxyConfigurationInternet)(destination);
          case "no-proxy":
            return destination;
          default:
            throw new Error("Illegal argument: No valid proxy configuration found in the destination input to be added.");
        }
      }
      async updateDestinationCache(destination, destinationOrigin) {
        if (!this.options.useCache) {
          return destination;
        }
        await destination_cache_1.destinationCache.cacheRetrievedDestination(destinationOrigin === "subscriber" ? (0, get_subscriber_token_1.getRequiredSubscriberToken)(this.subscriberToken) : this.providerServiceToken.decoded, destination, this.options.isolationStrategy);
      }
      async getProviderDestinationService() {
        const providerDestination = await (0, destination_service_1.fetchDestinationWithoutTokenRetrieval)(this.options.destinationName, (0, environment_accessor_1.getDestinationServiceCredentials)().uri, this.providerServiceToken.encoded);
        const destination = this.options.selectionStrategy({
          subscriber: emptyDestinationByType,
          provider: providerDestination
        }, this.options.destinationName);
        if (destination) {
          return { destination, fromCache: false, origin: "provider" };
        }
      }
      async getProviderDestinationCache() {
        const destination = await destination_cache_1.destinationCache.retrieveDestinationFromCache(this.providerServiceToken.decoded, this.options.destinationName, this.options.isolationStrategy);
        if (destination) {
          return { destination, fromCache: true, origin: "provider" };
        }
      }
      async getSubscriberDestinationService() {
        if (!this.subscriberToken?.serviceJwt) {
          throw new Error("Try to get destinations from subscriber account but service JWT was not set.");
        }
        const subscriberDestination = await (0, destination_service_1.fetchDestinationWithoutTokenRetrieval)(this.options.destinationName, (0, environment_accessor_1.getDestinationServiceCredentials)().uri, this.subscriberToken.serviceJwt.encoded);
        const destination = this.options.selectionStrategy({
          subscriber: subscriberDestination,
          provider: emptyDestinationByType
        }, this.options.destinationName);
        if (destination) {
          return { destination, fromCache: false, origin: "subscriber" };
        }
      }
      async getSubscriberDestinationCache() {
        const destination = await destination_cache_1.destinationCache.retrieveDestinationFromCache((0, get_subscriber_token_1.getRequiredSubscriberToken)(this.subscriberToken), this.options.destinationName, this.options.isolationStrategy);
        if (destination) {
          return { destination, fromCache: true, origin: "subscriber" };
        }
      }
      isProviderNeeded(resultFromSubscriber) {
        if (this.options.selectionStrategy.toString() === destination_selection_strategies_1.alwaysSubscriber.toString()) {
          return false;
        }
        if (this.options.selectionStrategy.toString() === destination_selection_strategies_1.subscriberFirst.toString() && resultFromSubscriber) {
          return false;
        }
        return true;
      }
      isSubscriberNeeded() {
        if (!this.subscriberToken?.serviceJwt) {
          return false;
        }
        return this.options.selectionStrategy.toString() !== destination_selection_strategies_1.alwaysProvider.toString();
      }
      async searchProviderAccountForDestination() {
        return this.options.useCache && await this.getProviderDestinationCache() || this.getProviderDestinationService();
      }
      async searchSubscriberAccountForDestination() {
        return this.options.useCache && await this.getSubscriberDestinationCache() || this.getSubscriberDestinationService();
      }
      async addTrustStoreConfiguration(destination, origin) {
        if (destination.originalProperties?.TrustStoreLocation) {
          const trustStoreCertificate = await (0, destination_service_1.fetchCertificate)((0, environment_accessor_1.getDestinationServiceCredentials)().uri, origin === "provider" ? this.providerServiceToken.encoded : this.subscriberToken.serviceJwt.encoded, destination.originalProperties.TrustStoreLocation);
          destination.trustStoreCertificate = trustStoreCertificate;
        }
        return destination;
      }
    };
    exports2.DestinationFromServiceRetriever = DestinationFromServiceRetriever;
    function getDestinationService() {
      const destinationService = (0, environment_accessor_1.getServiceBinding)("destination");
      if (!destinationService) {
        throw Error("No binding to a destination service found.");
      }
      return destinationService;
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-from-registration.js
var require_destination_from_registration2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-from-registration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.registerDestination = registerDestination;
    exports2.searchRegisteredDestination = searchRegisteredDestination;
    var util_1 = require_dist6();
    var jwt_1 = require_jwt4();
    var destination_cache_1 = require_destination_cache2();
    var destination_service_types_1 = require_destination_service_types2();
    var http_proxy_util_1 = require_http_proxy_util2();
    var register_destination_cache_1 = require_register_destination_cache2();
    var forward_auth_token_1 = require_forward_auth_token2();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "register-destination"
    });
    async function registerDestination(destination, options) {
      if (!destination.name) {
        throw Error("Registering destinations requires a destination name.");
      }
      destination.mtls = !!options?.inferMtls;
      if (options?.useMtlsCache) {
        register_destination_cache_1.registerDestinationCache.mtls.useMtlsCache = true;
        await register_destination_cache_1.registerDestinationCache.mtls.cacheMtlsOptions();
      }
      await register_destination_cache_1.registerDestinationCache.destination.cacheRetrievedDestination(getJwtForCaching(options), destination, isolationStrategy(options));
    }
    function getJwtForCaching(options) {
      const jwt = (0, jwt_1.decodeOrMakeJwt)(options?.jwt);
      if (!(0, jwt_1.getTenantId)(jwt)) {
        if (options?.jwt) {
          throw Error("Could not determine tenant from JWT nor XSUAA, identity or destination service binding. Destination is registered without tenant information.");
        } else {
          logger8.debug("Could not determine tenant from XSUAA, identity or destination service binding. Destination is registered without tenant information.");
        }
        return { zid: jwt_1.defaultTenantId };
      }
      return jwt;
    }
    async function searchRegisteredDestination(options) {
      const destination = await register_destination_cache_1.registerDestinationCache.destination.retrieveDestinationFromCache(getJwtForCaching(options), options.destinationName, isolationStrategy(options));
      if (!destination) {
        logger8.debug(`Could not retrieve '${options.destinationName}' from registered destinations.`);
        return null;
      }
      logger8.info(`Successfully retrieved destination '${options.destinationName}' from registered destinations.`);
      (0, forward_auth_token_1.setForwardedAuthTokenIfNeeded)(destination, options.jwt);
      return (0, destination_service_types_1.isHttpDestination)(destination) && ["internet", "private-link"].includes((0, http_proxy_util_1.proxyStrategy)(destination)) ? (0, http_proxy_util_1.addProxyConfigurationInternet)(destination) : destination;
    }
    function isolationStrategy(options) {
      if (options?.isolationStrategy) {
        return options.isolationStrategy;
      }
      const decoded = options?.jwt ? (0, jwt_1.decodeJwt)(options.jwt) : void 0;
      return (0, destination_cache_1.getDefaultIsolationStrategy)(decoded);
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-accessor.js
var require_destination_accessor2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-accessor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.useOrFetchDestination = useOrFetchDestination2;
    exports2.resolveDestination = resolveDestination;
    exports2.getDestination = getDestination;
    exports2.getAllDestinationsFromDestinationService = getAllDestinationsFromDestinationService;
    var util_1 = require_dist6();
    var identity_service_1 = require_identity_service2();
    var environment_accessor_1 = require_environment_accessor2();
    var jwt_1 = require_jwt4();
    var destination_1 = require_destination5();
    var destination_from_env_1 = require_destination_from_env2();
    var destination_from_vcap_1 = require_destination_from_vcap2();
    var destination_from_service_1 = require_destination_from_service2();
    var destination_accessor_types_1 = require_destination_accessor_types2();
    var destination_from_registration_1 = require_destination_from_registration2();
    var get_subscriber_token_1 = require_get_subscriber_token2();
    var get_provider_token_1 = require_get_provider_token2();
    var destination_service_1 = require_destination_service2();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "destination-accessor"
    });
    async function useOrFetchDestination2(destination) {
      return (0, destination_accessor_types_1.isDestinationFetchOptions)(destination) ? getDestination(destination) : (0, destination_1.sanitizeDestination)(destination);
    }
    async function resolveDestination(destination) {
      const resolvedDestination = await useOrFetchDestination2(destination).catch((error) => {
        throw new util_1.ErrorWithCause("Failed to load destination.", error);
      });
      if (!resolvedDestination) {
        throw Error(`Failed to resolve the destination '${(0, destination_1.toDestinationNameUrl)(destination)}'.`);
      }
      return resolvedDestination;
    }
    async function getDestination(options) {
      const destination = (0, destination_from_env_1.searchEnvVariablesForDestination)(options) || await (0, destination_from_registration_1.searchRegisteredDestination)(options) || await (0, destination_from_vcap_1.searchServiceBindingForDestination)(options) || await (0, destination_from_service_1.getDestinationFromDestinationService)(options);
      return destination;
    }
    function createDestinationFetchLogs(origin, destinations) {
      return destinations.reduce((prevLogMessages, currentDestination) => prevLogMessages + `Retrieving ${origin} destination: ${currentDestination.name}.
`, "");
    }
    async function getAllDestinationsFromDestinationService(options = {}) {
      options = {
        ...options,
        // Enable caching by default
        useCache: options.useCache ?? true
      };
      logger8.debug("Attempting to retrieve all destinations from destination service.");
      if ((0, identity_service_1.shouldExchangeToken)(options) && options.jwt) {
        options.jwt = await (0, identity_service_1.exchangeToken)(options.jwt);
      }
      const token = (await (0, get_subscriber_token_1.getSubscriberToken)(options))?.serviceJwt || await (0, get_provider_token_1.getProviderServiceToken)(options);
      const destinationServiceUri = (0, environment_accessor_1.getDestinationServiceCredentials)().uri;
      const subdomain = (0, jwt_1.getSubdomain)(token.decoded);
      logger8.debug(`Retrieving all destinations for account: "${subdomain}" from destination service.`);
      const [instance, subaccount] = await Promise.all([
        (0, destination_service_1.fetchDestinations)(destinationServiceUri, token.encoded, "instance", options),
        (0, destination_service_1.fetchDestinations)(destinationServiceUri, token.encoded, "subaccount", options)
      ]);
      const loggerMessage = createDestinationFetchLogs("instance", instance) + createDestinationFetchLogs("subaccount", subaccount);
      logger8.debug(loggerMessage);
      const allDestinations = [...instance, ...subaccount];
      if (allDestinations?.length) {
        logger8.debug(`Successfully retrieved all destinations for account: "${subdomain}" from destination service.`);
      } else {
        logger8.debug("Didn't receive any destinations from destination service.");
        return [];
      }
      const allDestinationsWithoutToken = allDestinations.map((destination) => {
        delete destination.authTokens;
        return destination;
      });
      return allDestinationsWithoutToken;
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/index.js
var require_destination6 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_destination_accessor2(), exports2);
    __exportStar(require_destination_accessor_types2(), exports2);
    __exportStar(require_destination_cache2(), exports2);
    __exportStar(require_destination_from_env2(), exports2);
    __exportStar(require_destination_from_service2(), exports2);
    __exportStar(require_destination_from_registration2(), exports2);
    __exportStar(require_destination_from_vcap2(), exports2);
    __exportStar(require_destination_selection_strategies2(), exports2);
    __exportStar(require_destination_service_cache2(), exports2);
    __exportStar(require_destination_service_types2(), exports2);
    __exportStar(require_destination_service2(), exports2);
    __exportStar(require_destination5(), exports2);
    __exportStar(require_forward_auth_token2(), exports2);
    __exportStar(require_get_subscriber_token2(), exports2);
    __exportStar(require_get_provider_token2(), exports2);
    __exportStar(require_http_proxy_util2(), exports2);
    __exportStar(require_service_binding_to_destination2(), exports2);
    __exportStar(require_register_destination_cache2(), exports2);
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/connectivity-service-types.js
var require_connectivity_service_types2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/connectivity-service-types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/header-builder-for-destination.js
var require_header_builder_for_destination2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/header-builder-for-destination.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildHeadersForDestination = buildHeadersForDestination;
    var util_1 = require_dist6();
    var authorization_header_1 = require_authorization_header2();
    async function buildHeadersForDestination(destination) {
      const authHeaders = await (0, authorization_header_1.buildAuthorizationHeaders)(destination);
      const sapHeaders = getSapHeaders(destination);
      return (0, util_1.mergeIgnoreCase)(destination.headers, {
        ...authHeaders,
        ...sapHeaders
      });
    }
    function getSapHeaders(destination) {
      const defaultHeaders = (0, util_1.pickNonNullish)({
        "sap-client": destination.sapClient,
        "SAP-Connectivity-SCC-Location_ID": destination.cloudConnectorLocationId
      });
      return (0, util_1.mergeLeftIgnoreCase)(defaultHeaders, destination.headers);
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/jsonwebtoken-type.js
var require_jsonwebtoken_type2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/jsonwebtoken-type.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/xsuaa-service-types.js
var require_xsuaa_service_types2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/xsuaa-service-types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/index.js
var require_scp_cf2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_destination6(), exports2);
    __exportStar(require_authorization_header2(), exports2);
    __exportStar(require_cache3(), exports2);
    __exportStar(require_client_credentials_token_cache2(), exports2);
    __exportStar(require_connectivity_service2(), exports2);
    __exportStar(require_connectivity_service_types2(), exports2);
    __exportStar(require_environment_accessor2(), exports2);
    __exportStar(require_get_protocol2(), exports2);
    __exportStar(require_header_builder_for_destination2(), exports2);
    __exportStar(require_identity_service2(), exports2);
    __exportStar(require_jsonwebtoken_type2(), exports2);
    __exportStar(require_jwt4(), exports2);
    __exportStar(require_protocol2(), exports2);
    __exportStar(require_subdomain_replacer2(), exports2);
    __exportStar(require_tenant2(), exports2);
    __exportStar(require_token_accessor2(), exports2);
    __exportStar(require_xsuaa_service_types2(), exports2);
    __exportStar(require_xsuaa_service2(), exports2);
    __exportStar(require_async_cache2(), exports2);
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/index.js
var require_dist8 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getAgentConfig = exports2.transformServiceBindingToClientCredentialsDestination = exports2.getTenantId = exports2.getAllDestinationsFromDestinationService = exports2.transformServiceBindingToDestination = exports2.getDestinationFromServiceBinding = exports2.getServiceBinding = exports2.setDestinationCache = exports2.registerDestination = exports2.getUserToken = exports2.getClientCredentialsToken = exports2.buildHeadersForDestination = exports2.DestinationSelectionStrategies = exports2.assertHttpDestination = exports2.isHttpDestination = exports2.serviceToken = exports2.jwtBearerToken = exports2.retrieveJwt = exports2.decodeJwt = exports2.parseProxyEnv = exports2.subscriberFirst = exports2.alwaysSubscriber = exports2.alwaysProvider = exports2.getDestinationFromDestinationService = exports2.useOrFetchDestination = exports2.getDestination = exports2.sanitizeDestination = exports2.toDestinationNameUrl = void 0;
    var scp_cf_1 = require_scp_cf2();
    Object.defineProperty(exports2, "toDestinationNameUrl", { enumerable: true, get: function() {
      return scp_cf_1.toDestinationNameUrl;
    } });
    Object.defineProperty(exports2, "sanitizeDestination", { enumerable: true, get: function() {
      return scp_cf_1.sanitizeDestination;
    } });
    Object.defineProperty(exports2, "getDestination", { enumerable: true, get: function() {
      return scp_cf_1.getDestination;
    } });
    Object.defineProperty(exports2, "useOrFetchDestination", { enumerable: true, get: function() {
      return scp_cf_1.useOrFetchDestination;
    } });
    Object.defineProperty(exports2, "getDestinationFromDestinationService", { enumerable: true, get: function() {
      return scp_cf_1.getDestinationFromDestinationService;
    } });
    Object.defineProperty(exports2, "alwaysProvider", { enumerable: true, get: function() {
      return scp_cf_1.alwaysProvider;
    } });
    Object.defineProperty(exports2, "alwaysSubscriber", { enumerable: true, get: function() {
      return scp_cf_1.alwaysSubscriber;
    } });
    Object.defineProperty(exports2, "subscriberFirst", { enumerable: true, get: function() {
      return scp_cf_1.subscriberFirst;
    } });
    Object.defineProperty(exports2, "parseProxyEnv", { enumerable: true, get: function() {
      return scp_cf_1.parseProxyEnv;
    } });
    Object.defineProperty(exports2, "decodeJwt", { enumerable: true, get: function() {
      return scp_cf_1.decodeJwt;
    } });
    Object.defineProperty(exports2, "retrieveJwt", { enumerable: true, get: function() {
      return scp_cf_1.retrieveJwt;
    } });
    Object.defineProperty(exports2, "jwtBearerToken", { enumerable: true, get: function() {
      return scp_cf_1.jwtBearerToken;
    } });
    Object.defineProperty(exports2, "serviceToken", { enumerable: true, get: function() {
      return scp_cf_1.serviceToken;
    } });
    Object.defineProperty(exports2, "isHttpDestination", { enumerable: true, get: function() {
      return scp_cf_1.isHttpDestination;
    } });
    Object.defineProperty(exports2, "assertHttpDestination", { enumerable: true, get: function() {
      return scp_cf_1.assertHttpDestination;
    } });
    Object.defineProperty(exports2, "DestinationSelectionStrategies", { enumerable: true, get: function() {
      return scp_cf_1.DestinationSelectionStrategies;
    } });
    Object.defineProperty(exports2, "buildHeadersForDestination", { enumerable: true, get: function() {
      return scp_cf_1.buildHeadersForDestination;
    } });
    Object.defineProperty(exports2, "getClientCredentialsToken", { enumerable: true, get: function() {
      return scp_cf_1.getClientCredentialsToken;
    } });
    Object.defineProperty(exports2, "getUserToken", { enumerable: true, get: function() {
      return scp_cf_1.getUserToken;
    } });
    Object.defineProperty(exports2, "registerDestination", { enumerable: true, get: function() {
      return scp_cf_1.registerDestination;
    } });
    Object.defineProperty(exports2, "setDestinationCache", { enumerable: true, get: function() {
      return scp_cf_1.setDestinationCache;
    } });
    Object.defineProperty(exports2, "getServiceBinding", { enumerable: true, get: function() {
      return scp_cf_1.getServiceBinding;
    } });
    Object.defineProperty(exports2, "getDestinationFromServiceBinding", { enumerable: true, get: function() {
      return scp_cf_1.getDestinationFromServiceBinding;
    } });
    Object.defineProperty(exports2, "transformServiceBindingToDestination", { enumerable: true, get: function() {
      return scp_cf_1.transformServiceBindingToDestination;
    } });
    Object.defineProperty(exports2, "getAllDestinationsFromDestinationService", { enumerable: true, get: function() {
      return scp_cf_1.getAllDestinationsFromDestinationService;
    } });
    Object.defineProperty(exports2, "getTenantId", { enumerable: true, get: function() {
      return scp_cf_1.getTenantId;
    } });
    Object.defineProperty(exports2, "transformServiceBindingToClientCredentialsDestination", { enumerable: true, get: function() {
      return scp_cf_1.transformServiceBindingToClientCredentialsDestination;
    } });
    var http_agent_1 = require_http_agent4();
    Object.defineProperty(exports2, "getAgentConfig", { enumerable: true, get: function() {
      return http_agent_1.getAgentConfig;
    } });
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/internal.js
var require_internal7 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/dist/internal.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_http_agent4(), exports2);
    __exportStar(require_scp_cf2(), exports2);
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/internal.js
var require_internal8 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/connectivity/internal.js"(exports2) {
    "use strict";
    function __export2(m) {
      for (const p in m) {
        if (!exports2.hasOwnProperty(p)) {
          exports2[p] = m[p];
        }
      }
    }
    Object.defineProperty(exports2, "__esModule", { value: true });
    __export2(require_internal7());
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/http-client/dist/csrf-token-middleware.js
var require_csrf_token_middleware2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/http-client/dist/csrf-token-middleware.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.csrf = csrf;
    exports2.buildCsrfFetchHeaders = buildCsrfFetchHeaders;
    var util_1 = require_dist6();
    var axios_1 = __importDefault(require_axios());
    var internal_1 = require_internal6();
    var logger8 = (0, util_1.createLogger)("csrf-middleware");
    function csrf(options) {
      return (middlewareOptions) => async (requestConfig) => {
        if (!needsCsrfToken(requestConfig)) {
          return middlewareOptions.fn(requestConfig);
        }
        const csrfToken = await makeCsrfRequests(requestConfig, {
          ...options,
          ...middlewareOptions
        });
        if (csrfToken?.cookie) {
          csrfToken.cookie = requestConfig.headers?.cookie ? [requestConfig.headers?.cookie, csrfToken?.cookie].join(";") : csrfToken?.cookie;
        }
        requestConfig.headers = { ...requestConfig.headers, ...csrfToken };
        return middlewareOptions.fn(requestConfig);
      };
    }
    function needsCsrfToken(requestConfig) {
      if (requestConfig.method.toLowerCase() === "get") {
        logger8.debug("Method is GET no CSRF token needed.");
        return false;
      }
      if ((0, util_1.pickValueIgnoreCase)(requestConfig.headers, "x-csrf-token")) {
        logger8.debug("CSRF token header was already provided. Existing token used.");
        return false;
      }
      return true;
    }
    function appendSlash(requestConfig) {
      if (!requestConfig.url) {
        requestConfig.url = "/";
      } else if (!requestConfig.url.endsWith("/")) {
        requestConfig.url = `${requestConfig.url}/`;
      }
      return requestConfig;
    }
    function removeSlash(requestConfig) {
      if (requestConfig.url.endsWith("/")) {
        requestConfig.url = (0, util_1.removeTrailingSlashes)(requestConfig.url);
      }
      return requestConfig;
    }
    function getCsrfToken(headers) {
      return Object.values((0, util_1.pickIgnoreCase)(headers, "x-csrf-token"))[0];
    }
    function getSetCookieHeader(headers) {
      const cookies = Object.values((0, util_1.pickIgnoreCase)(headers, "set-cookie"));
      return (0, util_1.flatten)(cookies).map((cookie) => cookie.split(";")[0]).join(";");
    }
    function buildCsrfFetchHeaders(headers) {
      const contentLengthHeaderKey = (0, util_1.first)(Object.keys((0, util_1.pickIgnoreCase)(headers, "content-length"))) || "content-length";
      return {
        "x-csrf-token": "Fetch",
        ...headers,
        [contentLengthHeaderKey]: 0
      };
    }
    async function makeCsrfRequest(requestConfig, options) {
      try {
        const response = await (0, internal_1.executeWithMiddleware)(options.middleware, {
          fn: axios_1.default.request,
          fnArgument: requestConfig,
          context: options.context
        });
        return findCsrfHeader(response.headers);
      } catch (error) {
        if (findCsrfHeader(error.response?.headers)) {
          return findCsrfHeader(error.response?.headers);
        }
        logger8.warn(new util_1.ErrorWithCause(`Failed to get CSRF token from  URL: ${requestConfig.url}.`, error));
      }
    }
    function findCsrfHeader(headers) {
      if (!headers) {
        return;
      }
      const csrfHeader = getCsrfToken(headers);
      if (!csrfHeader) {
        return;
      }
      const cookieHeader = getSetCookieHeader(headers) ? { cookie: getSetCookieHeader(headers) } : {};
      return { "x-csrf-token": csrfHeader, ...cookieHeader };
    }
    async function makeCsrfRequests(requestConfig, options) {
      const { data, params, parameterEncoder, ...requestConfigWithoutData } = requestConfig;
      const axiosConfig = {
        ...requestConfigWithoutData,
        method: options.method || "head",
        url: options.url || requestConfig.url,
        headers: buildCsrfFetchHeaders(requestConfig.headers)
      };
      if (options.url) {
        return makeCsrfRequest(axiosConfig, options);
      }
      return await makeCsrfRequest(appendSlash(axiosConfig), options) ?? await makeCsrfRequest(removeSlash(axiosConfig), options);
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/http-client/dist/http-client-types.js
var require_http_client_types2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/http-client/dist/http-client-types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isOriginOptions = isOriginOptions;
    exports2.isHttpRequestConfigWithOrigin = isHttpRequestConfigWithOrigin;
    function isOriginOptions(obj) {
      return !!obj && (typeof obj["requestConfig"] === "object" || typeof obj["custom"] === "object");
    }
    function isHttpRequestConfigWithOrigin(requestConfig) {
      return isOriginOptions(requestConfig.headers) || isOriginOptions(requestConfig.params);
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/http-client/dist/http-request-config.js
var require_http_request_config2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/http-client/dist/http-request-config.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.origins = exports2.defaultDisallowedKeys = void 0;
    exports2.filterCustomRequestConfig = filterCustomRequestConfig;
    exports2.mergeOptionsWithPriority = mergeOptionsWithPriority;
    var util_1 = require_dist6();
    var logger8 = (0, util_1.createLogger)({
      package: "http-client",
      messageContext: "http-request-config"
    });
    function filterCustomRequestConfig(customRequestConfig, disallowedKeys = exports2.defaultDisallowedKeys) {
      const removedKeys = Object.keys(customRequestConfig).filter((key) => disallowedKeys.includes(key));
      if (removedKeys.length) {
        logger8.warn(`The following keys are found in the custom request config that will be removed: ${removedKeys.join(", ")}`);
      }
      return (0, util_1.exclude)(disallowedKeys, customRequestConfig);
    }
    exports2.defaultDisallowedKeys = [
      "url",
      "baseURL",
      "data",
      "headers",
      "params"
    ];
    function mergeOptionsWithPriority(headersOrParams) {
      if (headersOrParams) {
        return exports2.origins.reduce((mergedHeadersOrParams, origin) => (0, util_1.mergeIgnoreCase)(mergedHeadersOrParams, headersOrParams[origin]), {});
      }
    }
    exports2.origins = [
      "requestConfig",
      "destination",
      "destinationProperty",
      "custom"
    ];
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/http-client/dist/http-client.js
var require_http_client2 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/http-client/dist/http-client.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encodeAllParameters = exports2.oDataTypedClientParameterEncoder = void 0;
    exports2.buildHttpRequest = buildHttpRequest;
    exports2.execute = execute;
    exports2.buildHttpRequestConfigWithOrigin = buildHttpRequestConfigWithOrigin;
    exports2.buildRequestWithMergedHeadersAndQueryParameters = buildRequestWithMergedHeadersAndQueryParameters;
    exports2.executeHttpRequest = executeHttpRequest2;
    exports2.executeHttpRequestWithOrigin = executeHttpRequestWithOrigin;
    exports2.getAxiosConfigWithDefaults = getAxiosConfigWithDefaults;
    exports2.getAxiosConfigWithDefaultsWithoutMethod = getAxiosConfigWithDefaultsWithoutMethod;
    exports2.getDefaultHttpRequestConfigOptions = getDefaultHttpRequestConfigOptions;
    exports2.getDefaultHttpRequestOptions = getDefaultHttpRequestOptions;
    var http = __importStar(require("http"));
    var https = __importStar(require("https"));
    var connectivity_1 = require_dist8();
    var internal_1 = require_internal8();
    var internal_2 = require_internal6();
    var util_1 = require_dist6();
    var axios_1 = __importDefault(require_axios());
    var http_client_types_1 = require_http_client_types2();
    var http_request_config_1 = require_http_request_config2();
    var csrf_token_middleware_1 = require_csrf_token_middleware2();
    var logger8 = (0, util_1.createLogger)({
      package: "http-client",
      messageContext: "http-client"
    });
    async function buildHttpRequest(destination) {
      const resolvedDestination = await (0, internal_1.resolveDestination)(destination);
      (0, internal_1.assertHttpDestination)(resolvedDestination);
      const headers = await buildHeaders(resolvedDestination);
      return buildDestinationHttpRequestConfig(resolvedDestination, headers);
    }
    function execute(executeFn) {
      return async function(destination, requestConfig, options) {
        const resolvedDestination = await (0, internal_1.resolveDestination)(destination);
        (0, internal_1.assertHttpDestination)(resolvedDestination);
        const destinationRequestConfig = await buildHttpRequest(resolvedDestination);
        logCustomHeadersWarning(requestConfig.headers);
        const request = await buildRequestWithMergedHeadersAndQueryParameters(requestConfig, resolvedDestination, destinationRequestConfig, destination.jwt);
        if (options?.fetchCsrfToken) {
          requestConfig.middleware = [...requestConfig.middleware || [], (0, csrf_token_middleware_1.csrf)()];
        }
        return (0, internal_2.executeWithMiddleware)(requestConfig.middleware, {
          fnArgument: request,
          fn: (req) => {
            logRequestInformation(request);
            return executeFn(req);
          },
          context: {
            jwt: destination.jwt,
            uri: resolvedDestination.url,
            destinationName: resolvedDestination.name ?? void 0,
            tenantId: (0, connectivity_1.getTenantId)(destination.jwt)
          }
        });
      };
    }
    function buildHttpRequestConfigWithOrigin(requestConfig) {
      if (!requestConfig) {
        return getDefaultHttpRequestConfigOptions();
      }
      if ((0, http_client_types_1.isHttpRequestConfigWithOrigin)(requestConfig)) {
        return requestConfig;
      }
      return {
        ...requestConfig,
        headers: {
          requestConfig: {},
          ...requestConfig.headers && { custom: requestConfig.headers }
        },
        params: {
          requestConfig: {},
          ...requestConfig.params && { custom: requestConfig.params }
        }
      };
    }
    var oDataTypedClientParameterEncoder = (params) => params;
    exports2.oDataTypedClientParameterEncoder = oDataTypedClientParameterEncoder;
    function encodeQueryParameters(options) {
      const { parameterEncoder, parameters, exclude } = options;
      return Object.fromEntries(Object.entries(parameters).map(([key, value]) => exclude.includes(key) ? [key, value] : [key, value ? parameterEncoder(value) : value]));
    }
    function isOdataTypedClientParameterEncoder(parameterEncoder) {
      return parameterEncoder.name === exports2.oDataTypedClientParameterEncoder.name;
    }
    function getEncodedParameters(parameters, requestConfig) {
      const { parameterEncoder } = requestConfig;
      if ((0, util_1.isNullish)(parameterEncoder)) {
        return encodeQueryParameters({
          parameters,
          parameterEncoder: exports2.encodeAllParameters,
          exclude: ["custom"]
        });
      }
      if (isOdataTypedClientParameterEncoder(parameterEncoder)) {
        return encodeQueryParameters({
          parameters,
          parameterEncoder: exports2.encodeAllParameters,
          exclude: ["custom", "requestConfig"]
        });
      }
      return encodeQueryParameters({ parameters, parameterEncoder, exclude: [] });
    }
    async function buildRequestWithMergedHeadersAndQueryParameters(requestConfig, destination, destinationRequestConfig, jwt) {
      const { paramsOriginOptions, headersOriginOptions, requestConfigBase } = splitRequestConfig(requestConfig);
      const parameters = collectParametersFromAllOrigins(destination, paramsOriginOptions);
      const encodedParameters = getEncodedParameters(parameters, requestConfig);
      const mergedQueryParameter = (0, http_request_config_1.mergeOptionsWithPriority)(encodedParameters);
      const mergedHeaders = await getMergedHeaders(destination, destinationRequestConfig.headers, headersOriginOptions, jwt);
      const request = merge(destinationRequestConfig, requestConfigBase);
      request.headers = mergedHeaders || {};
      request.params = mergedQueryParameter || {};
      return request;
    }
    async function getMergedHeaders(destination, headersDestination, headersOriginOptions, jwt) {
      const queryParametersDestinationProperty = (0, internal_1.getAdditionalHeaders)(destination.originalProperties || {}).headers;
      headersDestination = destination.forwardAuthToken ? addForwardAuthTokenHeader(headersDestination, jwt) : headersDestination;
      return (0, http_request_config_1.mergeOptionsWithPriority)({
        requestConfig: headersOriginOptions?.requestConfig,
        custom: { ...headersOriginOptions?.custom },
        destinationProperty: queryParametersDestinationProperty,
        destination: headersDestination
      });
    }
    function addForwardAuthTokenHeader(headersDestination, jwt) {
      if (jwt) {
        return { ...headersDestination, authorization: `Bearer ${jwt}` };
      }
      logger8.debug("The `forwardAuthToken` is set, but the JWT is missing. Please provide a valid JWT to enable token forwarding.");
      return headersDestination;
    }
    function collectParametersFromAllOrigins(destination, paramsOriginOptions) {
      const queryParametersDestinationProperty = (0, internal_1.getAdditionalQueryParameters)(destination.originalProperties || {}).queryParameters;
      return {
        ...paramsOriginOptions,
        destinationProperty: queryParametersDestinationProperty,
        destination: destination.queryParameters
      };
    }
    function splitRequestConfig(requestConfig) {
      const paramsOriginOptions = requestConfig.params;
      const headersOriginOptions = requestConfig.headers;
      return {
        paramsOriginOptions,
        headersOriginOptions,
        requestConfigBase: requestConfig
      };
    }
    function logCustomHeadersWarning(headers) {
      if (!headers) {
        return;
      }
      const customHeaders = headers.custom;
      const requestConfigHeaders = headers.requestConfig;
      if (customHeaders && requestConfigHeaders) {
        const headerKeysToBeOverwritten = Object.keys(customHeaders).filter((customHeaderKey) => Object.keys(requestConfigHeaders).includes(customHeaderKey));
        if (headerKeysToBeOverwritten.length) {
          logger8.debug(`The following custom headers will overwrite headers created by the SDK, if they use the same key:
${headerKeysToBeOverwritten.map((key) => `  - "${key}"`).join("\n")}
If the parameters from multiple origins use the same key, the priority is 1. Custom, 2. Destination, 3. Internal.`);
        }
      }
    }
    function logRequestInformation(request) {
      const basicRequestInfo = `Execute '${request.method}' request with target: ${request.url}.`;
      if (request.headers) {
        const headerText = Object.entries((0, util_1.sanitizeRecord)(request.headers)).map(([key, value]) => `${key}:${value}`).join(util_1.unixEOL);
        logger8.debug(`${basicRequestInfo}${util_1.unixEOL}The headers of the request are:${util_1.unixEOL}${headerText}`);
      } else {
        logger8.debug(basicRequestInfo);
      }
    }
    function executeHttpRequest2(destination, requestConfig, options) {
      const requestConfigWithOrigin = buildHttpRequestConfigWithOrigin(requestConfig);
      return execute(executeWithAxios)(destination, requestConfigWithOrigin, {
        ...getDefaultHttpRequestOptions(),
        ...options
      });
    }
    function executeHttpRequestWithOrigin(destination, requestConfig, options) {
      const requestConfigWithDefaults = requestConfig ?? getDefaultHttpRequestConfigOptions();
      return execute(executeWithAxios)(destination, requestConfigWithDefaults, {
        ...getDefaultHttpRequestOptions(),
        ...options
      });
    }
    async function buildDestinationHttpRequestConfig(destination, headers) {
      return {
        baseURL: destination.url,
        headers,
        params: destination.queryParameters,
        proxy: (0, internal_1.getProxyConfig)(destination),
        ...await (0, connectivity_1.getAgentConfig)(destination)
      };
    }
    async function buildHeaders(destination) {
      try {
        return await (0, connectivity_1.buildHeadersForDestination)(destination);
      } catch (error) {
        throw new util_1.ErrorWithCause("Failed to build headers.", error);
      }
    }
    function merge(destinationRequestConfig, customRequestConfig) {
      return {
        ...destinationRequestConfig,
        ...customRequestConfig,
        headers: {
          ...destinationRequestConfig.headers,
          ...customRequestConfig.headers
        }
      };
    }
    function mergeRequestWithAxiosDefaults(request) {
      return { ...getAxiosConfigWithDefaults(), ...request };
    }
    function executeWithAxios(request) {
      return axios_1.default.request(mergeRequestWithAxiosDefaults(request));
    }
    function getAxiosConfigWithDefaults() {
      return {
        ...getAxiosConfigWithDefaultsWithoutMethod(),
        method: "get"
      };
    }
    function getAxiosConfigWithDefaultsWithoutMethod() {
      return {
        httpAgent: new http.Agent(),
        httpsAgent: new https.Agent(),
        timeout: 0,
        // zero means no timeout https://github.com/axios/axios/blob/main/README.md#request-config
        paramsSerializer: {
          serialize: (params = {}) => Object.entries(params).map(([key, value]) => `${key}=${value}`).join("&")
        }
      };
    }
    function getDefaultHttpRequestConfigOptions() {
      return {
        method: "get"
      };
    }
    function getDefaultHttpRequestOptions() {
      return {
        fetchCsrfToken: true
      };
    }
    var encodeAllParameters = function(parameter) {
      return Object.fromEntries(Object.entries(parameter).map(([key, value]) => [
        encodeURIComponent(key),
        encodeURIComponent(value)
      ]));
    };
    exports2.encodeAllParameters = encodeAllParameters;
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/http-client/dist/index.js
var require_dist9 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/http-client/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultDisallowedKeys = exports2.executeHttpRequestWithOrigin = exports2.executeHttpRequest = exports2.encodeAllParameters = exports2.buildHttpRequest = exports2.csrf = void 0;
    var csrf_token_middleware_1 = require_csrf_token_middleware2();
    Object.defineProperty(exports2, "csrf", { enumerable: true, get: function() {
      return csrf_token_middleware_1.csrf;
    } });
    var http_client_1 = require_http_client2();
    Object.defineProperty(exports2, "buildHttpRequest", { enumerable: true, get: function() {
      return http_client_1.buildHttpRequest;
    } });
    Object.defineProperty(exports2, "encodeAllParameters", { enumerable: true, get: function() {
      return http_client_1.encodeAllParameters;
    } });
    Object.defineProperty(exports2, "executeHttpRequest", { enumerable: true, get: function() {
      return http_client_1.executeHttpRequest;
    } });
    Object.defineProperty(exports2, "executeHttpRequestWithOrigin", { enumerable: true, get: function() {
      return http_client_1.executeHttpRequestWithOrigin;
    } });
    var http_request_config_1 = require_http_request_config2();
    Object.defineProperty(exports2, "defaultDisallowedKeys", { enumerable: true, get: function() {
      return http_request_config_1.defaultDisallowedKeys;
    } });
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/http-client/dist/internal.js
var require_internal9 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/http-client/dist/internal.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_csrf_token_middleware2(), exports2);
    __exportStar(require_http_client2(), exports2);
    __exportStar(require_http_client_types2(), exports2);
    __exportStar(require_http_request_config2(), exports2);
  }
});

// node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/http-client/internal.js
var require_internal10 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/node_modules/@sap-cloud-sdk/http-client/internal.js"(exports2) {
    "use strict";
    function __export2(m) {
      for (const p in m) {
        if (!exports2.hasOwnProperty(p)) {
          exports2[p] = m[p];
        }
      }
    }
    Object.defineProperty(exports2, "__esModule", { value: true });
    __export2(require_internal9());
  }
});

// node_modules/@sap-cloud-sdk/openapi/dist/openapi-request-builder.js
var require_openapi_request_builder = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/dist/openapi-request-builder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OpenApiRequestBuilder = void 0;
    var util_1 = require_dist6();
    var connectivity_1 = require_dist8();
    var internal_1 = require_internal8();
    var http_client_1 = require_dist9();
    var internal_2 = require_internal10();
    var OpenApiRequestBuilder2 = class {
      /**
       * Create an instance of `OpenApiRequestBuilder`.
       * @param method - HTTP method of the request to be built.
       * @param pathPattern - Path for the request containing path parameter references as in the OpenAPI specification.
       * @param parameters - Query parameters and or body to pass to the request.
       * @param basePath - The custom path to be prefixed to the API path pattern.
       */
      constructor(method, pathPattern, parameters, basePath) {
        this.method = method;
        this.pathPattern = pathPattern;
        this.parameters = parameters;
        this.basePath = basePath;
        this._fetchCsrfToken = true;
        this.customHeaders = {};
        this.customRequestConfiguration = {};
        this._middlewares = [];
      }
      /**
       * Add custom headers to the request. If a header field with the given name already exists it is overwritten.
       * @param headers - Key-value pairs denoting additional custom headers.
       * @returns The request builder itself, to facilitate method chaining.
       */
      addCustomHeaders(headers) {
        Object.entries(headers).forEach(([key, value]) => {
          this.customHeaders[key.toLowerCase()] = value;
        });
        return this;
      }
      /**
       * Add custom request configuration to the request. Typically, this is used when specifying response type for downloading files.
       * If the custom request configuration contains keys in this list {@link @sap-cloud-sdk/http-client!defaultDisallowedKeys}, they will be removed.
       * @param requestConfiguration - Key-value pairs denoting additional custom request configuration options to be set in the request.
       * @returns The request builder itself, to facilitate method chaining.
       */
      addCustomRequestConfiguration(requestConfiguration) {
        Object.entries(requestConfiguration).forEach(([key, value]) => {
          this.customRequestConfiguration[key] = value;
        });
        return this;
      }
      /**
       * Skip fetching csrf token for this request, which is typically useful when the csrf token is not required.
       * @returns The request builder itself, to facilitate method chaining.
       */
      skipCsrfTokenFetching() {
        this._fetchCsrfToken = false;
        return this;
      }
      middleware(first, ...rest) {
        this._middlewares = (0, util_1.transformVariadicArgumentToArray)(first, rest);
        return this;
      }
      /**
       * Execute request and get a raw {@link @sap-cloud-sdk/http-client!HttpResponse}, including all information about the HTTP response.
       * This especially comes in handy, when you need to access the headers or status code of the response.
       * @param destination - Destination or DestinationFetchOptions to execute the request against.
       * @returns A promise resolving to an {@link @sap-cloud-sdk/http-client!HttpResponse}.
       */
      async executeRaw(destination) {
        const fetchCsrfToken = this._fetchCsrfToken && ["post", "put", "patch", "delete"].includes(this.method.toLowerCase());
        const resolvedDestination = await (0, connectivity_1.useOrFetchDestination)(destination);
        if ((0, util_1.isNullish)(destination)) {
          throw Error((0, internal_1.noDestinationErrorMessage)(destination));
        }
        (0, internal_1.assertHttpDestination)(resolvedDestination);
        return (0, http_client_1.executeHttpRequest)(resolvedDestination, await this.requestConfig(), {
          fetchCsrfToken
        });
      }
      /**
       * Execute request and get the response data. Use this to conveniently access the data of a service without technical information about the response.
       * @param destination - Destination or DestinationFetchOptions to execute the request against.
       * @returns A promise resolving to the requested return type.
       */
      async execute(destination) {
        const response = await this.executeRaw(destination);
        if (isAxiosResponse(response)) {
          return response.data;
        }
        throw new Error("Could not access response data. Response was not an axios response.");
      }
      /**
       * Set the custom base path that gets prefixed to the API path parameter before a request.
       * @param basePath - Base path to be set.
       * @returns The request builder itself, to facilitate method chaining.
       */
      setBasePath(basePath) {
        this.basePath = basePath;
        return this;
      }
      /**
       * Get http request config.
       * @returns Promise of http request config with origin.
       */
      async requestConfig() {
        const defaultConfig = {
          method: this.method,
          url: this.getPath(),
          headers: this.getHeaders(),
          params: this.getParameters(),
          middleware: this._middlewares,
          data: this.parameters?.body
        };
        return {
          ...defaultConfig,
          ...(0, internal_2.filterCustomRequestConfig)(this.customRequestConfiguration)
        };
      }
      getHeaders() {
        const options = { requestConfig: this.parameters?.headerParameters || {} };
        if (Object.keys(this.customHeaders).length) {
          return { custom: this.customHeaders, ...options };
        }
        return options;
      }
      getParameters() {
        return { requestConfig: this.parameters?.queryParameters || {} };
      }
      getPath() {
        const pathParameters = this.parameters?.pathParameters || {};
        const placeholders = this.pathPattern.match(/{[^/?#{}]+}/g) || [];
        return (this.basePath ? (0, util_1.removeSlashes)(this.basePath) : "") + placeholders.reduce((path, placeholder) => {
          const strippedPlaceholder = placeholder.slice(1, -1);
          const parameterValue = pathParameters[strippedPlaceholder];
          return path.replace(placeholder, encodeURIComponent(parameterValue));
        }, this.pathPattern);
      }
    };
    exports2.OpenApiRequestBuilder = OpenApiRequestBuilder2;
    function isAxiosResponse(val) {
      return "data" in val;
    }
  }
});

// node_modules/@sap-cloud-sdk/openapi/dist/index.js
var require_dist10 = __commonJS({
  "node_modules/@sap-cloud-sdk/openapi/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OpenApiRequestBuilder = void 0;
    var openapi_request_builder_1 = require_openapi_request_builder();
    Object.defineProperty(exports2, "OpenApiRequestBuilder", { enumerable: true, get: function() {
      return openapi_request_builder_1.OpenApiRequestBuilder;
    } });
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/array.js
var require_array4 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/array.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.flatten = void 0;
    exports2.flat = flat;
    exports2.unique = unique;
    exports2.last = last;
    exports2.first = first;
    exports2.splitInChunks = splitInChunks;
    exports2.transformVariadicArgumentToArray = transformVariadicArgumentToArray;
    exports2.zip = zip;
    exports2.partition = partition2;
    exports2.filterDuplicates = filterDuplicates;
    exports2.filterDuplicatesRight = filterDuplicatesRight;
    function flat(arr2) {
      return arr2.reduce((flattened, subArr) => [...flattened, ...subArr], []);
    }
    function unique(arr2) {
      return Array.from(new Set(arr2));
    }
    function last(arr2) {
      return arr2.length ? arr2[arr2.length - 1] : void 0;
    }
    function first(arr2) {
      return arr2[0];
    }
    function splitInChunks(arr2, chunkSize) {
      const chunks = [];
      if (arr2) {
        for (let i = 0; i < arr2.length; i += chunkSize) {
          chunks.push(arr2.slice(i, i + chunkSize));
        }
      }
      return chunks;
    }
    function transformVariadicArgumentToArray(firstOrArray, rest) {
      if (Array.isArray(firstOrArray)) {
        return [...firstOrArray, ...rest];
      }
      return firstOrArray ? [firstOrArray, ...rest] : [...rest];
    }
    var flatten = (input) => {
      const flatResult = [];
      const stack = [...input];
      while (stack.length > 0) {
        const current = stack.pop();
        if (!Array.isArray(current)) {
          flatResult.push(current);
        } else {
          stack.push(...current);
        }
      }
      return flatResult.reverse();
    };
    exports2.flatten = flatten;
    function zip(left, right) {
      const longerArr = left.length > right.length ? left : right;
      return longerArr.reduce((zipped, _, i) => {
        const currentZipped = [];
        if (left.length > i) {
          currentZipped.push(left[i]);
        }
        if (right.length > i) {
          currentZipped.push(right[i]);
        }
        return [...zipped, ...currentZipped];
      }, []);
    }
    function partition2(arr2, condition) {
      return arr2.reduce(([conditionTrue, conditionFalse], item) => condition(item) ? [[...conditionTrue, item], conditionFalse] : [conditionTrue, [...conditionFalse, item]], [[], []]);
    }
    function filterDuplicates(arr2, comparator = (left, right) => left === right) {
      return arr2.filter((item, index) => !arr2.slice(0, index).find((filteredItem) => comparator(item, filteredItem)));
    }
    function filterDuplicatesRight(arr2, comparator = (left, right) => left === right) {
      return filterDuplicates(arr2.reverse(), comparator).reverse();
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/string-formatter.js
var require_string_formatter4 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/string-formatter.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.webEOL = exports2.unixEOL = void 0;
    exports2.upperCaseSnakeCase = upperCaseSnakeCase;
    exports2.camelCase = camelCase2;
    exports2.titleFormat = titleFormat;
    exports2.pascalCase = pascalCase;
    exports2.kebabCase = kebabCase;
    exports2.formatJson = formatJson;
    var voca_1 = __importDefault(require_voca());
    exports2.unixEOL = "\n";
    exports2.webEOL = "\r\n";
    function upperCaseSnakeCase(str) {
      return voca_1.default.upperCase(voca_1.default.snakeCase(str));
    }
    function camelCase2(str) {
      return voca_1.default.camelCase(str);
    }
    function titleFormat(str) {
      return voca_1.default.titleCase(voca_1.default.words(str).join(" "));
    }
    function pascalCase(str) {
      return voca_1.default.words(str).map((word) => voca_1.default.capitalize(word)).join("");
    }
    function kebabCase(str) {
      return voca_1.default.kebabCase(str);
    }
    function formatJson(json2) {
      return JSON.stringify(json2, null, 2) + exports2.unixEOL;
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/string.js
var require_string4 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/string.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encodeBase64 = encodeBase64;
    exports2.trimLeft = trimLeft;
    exports2.trimRight = trimRight;
    exports2.trim = trim;
    exports2.removeFileExtension = removeFileExtension;
    var string_formatter_1 = require_string_formatter4();
    function encodeBase64(str) {
      return Buffer.from(str).toString("base64");
    }
    function trimLeft(string) {
      const subStrings = string.split(string_formatter_1.unixEOL);
      const leftTrimmed = subStrings[0].trimStart();
      if (!leftTrimmed) {
        subStrings.shift();
      } else {
        subStrings[0] = leftTrimmed;
      }
      return subStrings.join(string_formatter_1.unixEOL);
    }
    function trimRight(string) {
      const subStrings = string.split(string_formatter_1.unixEOL);
      const rightTrimmed = subStrings[subStrings.length - 1].trimEnd();
      if (!rightTrimmed) {
        subStrings.pop();
      } else {
        subStrings[subStrings.length - 1] = rightTrimmed;
      }
      return subStrings.join(string_formatter_1.unixEOL);
    }
    function trim(string) {
      return trimRight(trimLeft(string));
    }
    function removeFileExtension(fileName) {
      return fileName.includes(".") ? fileName.split(".").slice(0, -1).join(".") : fileName;
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/code-block.js
var require_code_block4 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/code-block.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.codeBlock = codeBlock;
    var string_formatter_1 = require_string_formatter4();
    var array_1 = require_array4();
    var string_1 = require_string4();
    function codeBlock(strings, ...args) {
      const pre = strings.slice(0, -1).map((string) => {
        const trimmed = trimRightNewlines(string);
        return trimmed.length === string.length ? string : trimmed + string_formatter_1.unixEOL;
      });
      pre.push(strings[strings.length - 1]);
      const indents = strings.slice(0, -1).map((s) => {
        const indentation = s.split(string_formatter_1.unixEOL).pop();
        return !indentation.trim() ? indentation : "";
      });
      const post = args.map((arg, i) => ("" + arg).split(string_formatter_1.unixEOL).map((subArg) => indents[i] + subArg).join(string_formatter_1.unixEOL));
      const zipped = (0, array_1.zip)(pre, post);
      return (0, string_1.trim)(zipped.join(""));
    }
    function trimRightNewlines(string) {
      let subStrings = string.split(string_formatter_1.unixEOL);
      if (!subStrings[subStrings.length - 1].trim()) {
        subStrings = subStrings.slice(0, -1);
      }
      return subStrings.join(string_formatter_1.unixEOL);
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/logger/format/local.js
var require_local4 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/logger/format/local.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.local = void 0;
    exports2.getMessageOrStack = getMessageOrStack;
    var chalk_1 = __importDefault(require_source());
    var winston_1 = require_winston();
    var { combine, timestamp, cli, printf, errors } = winston_1.format;
    exports2.local = combine(errors({ stack: true }), timestamp(), (0, winston_1.format)(localTransformer)(), cli(), printf((info) => {
      const messageContext = info.custom_fields && typeof info.custom_fields === "object" && "messageContext" in info.custom_fields ? `${chalk_1.default.blue(`(${info.custom_fields.messageContext})`)}: ` : "";
      const message = typeof info.message === "string" ? info.message : "";
      const trimmedMessage = message.replace(/^\s*/, "");
      const paddingLength = message.length - trimmedMessage.length + messageContext.length;
      if (info.error) {
        info.level = chalk_1.default.inverse(info.level);
      }
      return `${chalk_1.default.gray(`[${info.timestamp}]`)} ${info.level} ${messageContext.padStart(paddingLength, " ")}${trimmedMessage}`;
    }));
    function getMessageOrStack(info) {
      const isString = (value) => typeof value === "string";
      const hasStackTrace = info.stack && info.level === "error";
      if (hasStackTrace && isString(info.stack)) {
        return info.stack;
      }
      if (isString(info.message)) {
        return info.message;
      }
      return "";
    }
    function localTransformer(info) {
      return {
        ...info,
        level: info.level.toUpperCase(),
        message: getMessageOrStack(info)
      };
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/logger/format/kibana.js
var require_kibana4 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/logger/format/kibana.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.kibana = void 0;
    var winston_1 = require_winston();
    var local_1 = require_local4();
    var { combine, timestamp, json: json2, errors } = winston_1.format;
    exports2.kibana = combine(errors({ stack: true }), timestamp(), (0, winston_1.format)(kibanaTransformer)(), json2());
    function kibanaTransformer(info) {
      return {
        ...info,
        msg: (0, local_1.getMessageOrStack)(info),
        written_ts: new Date(info.timestamp).getTime(),
        written_at: info.timestamp
      };
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/logger/format/index.js
var require_format5 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/logger/format/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_kibana4(), exports2);
    __exportStar(require_local4(), exports2);
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/logger/cloud-sdk-logger.js
var require_cloud_sdk_logger4 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/logger/cloud-sdk-logger.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.cloudSdkExceptionLogger = exports2.logFormat = void 0;
    exports2.muteLoggers = muteLoggers;
    exports2.unmuteLoggers = unmuteLoggers;
    exports2.disableExceptionLogger = disableExceptionLogger;
    exports2.enableExceptionLogger = enableExceptionLogger;
    exports2.createLogger = createLogger8;
    exports2.getLogger = getLogger;
    exports2.setLogLevel = setLogLevel;
    exports2.setGlobalLogLevel = setGlobalLogLevel;
    exports2.getGlobalLogLevel = getGlobalLogLevel;
    exports2.setGlobalTransports = setGlobalTransports;
    exports2.setLogFormat = setLogFormat;
    exports2.setGlobalLogFormat = setGlobalLogFormat;
    exports2.getGlobalLogFormat = getGlobalLogFormat;
    exports2.sanitizeRecord = sanitizeRecord;
    exports2.resetCustomLogLevels = resetCustomLogLevels;
    exports2.resetCustomLogFormats = resetCustomLogFormats;
    var winston_1 = require_winston();
    var format_1 = require_format5();
    var loggerReference = "sap-cloud-sdk-logger";
    var exceptionLoggerId = "sap-cloud-sdk-exception-logger";
    var container = new winston_1.Container();
    exports2.logFormat = {
      kibana: format_1.kibana,
      local: format_1.local
    };
    container.options.format = process.env.NODE_ENV === "production" ? exports2.logFormat.kibana : exports2.logFormat.local;
    var exceptionTransport = new winston_1.transports.Console();
    var customLogLevels = {};
    var customLogFormats = {};
    var DEFAULT_LOGGER__MESSAGE_CONTEXT = "__DEFAULT_LOGGER__MESSAGE_CONTEXT";
    var silent = false;
    var moduleLogger = createLogger8({
      package: "util",
      messageContext: "cloud-sdk-logger"
    });
    function toggleMuteLoggers(silence) {
      silent = silence;
      container.loggers.forEach((logger8) => toggleSilenceTransports(logger8, silence));
    }
    function toggleSilenceTransports(logger8, silence) {
      logger8.transports.forEach((transport) => transport.silent = silence);
    }
    function muteLoggers() {
      toggleMuteLoggers(true);
    }
    function unmuteLoggers() {
      toggleMuteLoggers(false);
    }
    exports2.cloudSdkExceptionLogger = container.get(exceptionLoggerId, {
      defaultMeta: { logger: loggerReference, test: "exception" },
      format: container.options.format,
      exceptionHandlers: [exceptionTransport]
    });
    function disableExceptionLogger() {
      exports2.cloudSdkExceptionLogger.exceptions.unhandle();
    }
    function enableExceptionLogger() {
      disableExceptionLogger();
      exports2.cloudSdkExceptionLogger.exceptions.handle(exceptionTransport);
    }
    function createLogger8(messageContext) {
      const customFields = typeof messageContext === "string" ? { messageContext } : { ...messageContext };
      const logger8 = container.get(customFields.messageContext, {
        level: process.env.SAP_CLOUD_SDK_LOG_LEVEL || customLogLevels[customFields.messageContext] || customFields.level || container.options.level || "info",
        defaultMeta: {
          ...Object.entries(customFields).length && {
            custom_fields: customFields
          },
          logger: customFields.logger || loggerReference
        },
        format: customLogFormats[customFields.messageContext] || customFields.format || container.options.format || exports2.logFormat.local,
        transports: [new winston_1.transports.Console()]
      });
      toggleSilenceTransports(logger8, silent);
      return logger8;
    }
    function getLogger(messageContext = DEFAULT_LOGGER__MESSAGE_CONTEXT) {
      if (container.has(messageContext)) {
        return container.get(messageContext);
      }
    }
    function setLogLevel(level, messageContextOrLogger = DEFAULT_LOGGER__MESSAGE_CONTEXT) {
      const messageContext = typeof messageContextOrLogger === "string" ? messageContextOrLogger : getMessageContext(messageContextOrLogger);
      if (messageContext) {
        customLogLevels[messageContext] = level;
        if (container.has(messageContext)) {
          const logger8 = container.get(messageContext);
          logger8.level = level;
        }
      } else if (typeof messageContextOrLogger !== "string") {
        moduleLogger.warn("Setting log level for logger with unknown message context");
        messageContextOrLogger.level = level;
      }
    }
    function setGlobalLogLevel(level) {
      container.options.level = level;
      container.loggers.forEach((logger8) => {
        logger8.level = level;
      });
    }
    function getGlobalLogLevel() {
      return container.options.level;
    }
    function setGlobalTransports(customTransports) {
      container.options.transports = customTransports;
      container.loggers.forEach((logger8) => {
        logger8.clear();
        return Array.isArray(customTransports) ? customTransports.forEach((transport) => logger8.add(transport)) : logger8.add(customTransports);
      });
    }
    function setLogFormat(format, messageContextOrLogger = DEFAULT_LOGGER__MESSAGE_CONTEXT) {
      const messageContext = typeof messageContextOrLogger === "string" ? messageContextOrLogger : getMessageContext(messageContextOrLogger);
      if (messageContext) {
        customLogFormats[messageContext] = format;
        if (container.has(messageContext)) {
          const logger8 = container.get(messageContext);
          logger8.format = format;
        }
      } else if (typeof messageContextOrLogger !== "string") {
        moduleLogger.warn("Setting log format for logger with unknown message context");
        messageContextOrLogger.format = format;
      }
    }
    function setGlobalLogFormat(format) {
      container.options.format = format;
      container.loggers.forEach((logger8) => {
        logger8.format = format;
      });
    }
    function getGlobalLogFormat() {
      return container.options.format;
    }
    var defaultSensitiveKeys = [
      "access_token",
      "authentication",
      "authorization",
      "apiKey",
      "credentials",
      "csrf",
      "xsrf",
      "secret",
      "password",
      "JTENANT",
      "JSESSION"
    ];
    function isSensitive(inputKey, value, sensitiveKeys) {
      const normalizedKeys = sensitiveKeys.map((key) => key.toLowerCase());
      const input = isCookieHeader(inputKey, value) ? value : inputKey;
      return normalizedKeys.some((normalizedKey) => input.toLowerCase().includes(normalizedKey));
    }
    function isCookieHeader(inputKey, value) {
      return inputKey.toLowerCase() === "cookie" && typeof value === "string";
    }
    function sanitizeRecord(input, replacementString = "<DATA NOT LOGGED TO PREVENT LEAKING SENSITIVE DATA>", sensitiveKeys = defaultSensitiveKeys) {
      return Object.fromEntries(Object.entries(input).map(([inputKey, value]) => isSensitive(inputKey, value, sensitiveKeys) ? [inputKey, replacementString] : [inputKey, value]));
    }
    function getMessageContext(logger8) {
      const loggerOptions = logger8;
      if (loggerOptions && loggerOptions.defaultMeta && loggerOptions.defaultMeta.custom_fields) {
        return loggerOptions.defaultMeta.custom_fields.messageContext;
      }
    }
    function resetCustomLogLevels() {
      Object.keys(customLogLevels).forEach((key) => delete customLogLevels[key]);
    }
    function resetCustomLogFormats() {
      Object.keys(customLogFormats).forEach((key) => delete customLogFormats[key]);
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/logger/index.js
var require_logger5 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/logger/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_cloud_sdk_logger4(), exports2);
    __exportStar(require_format5(), exports2);
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/documentation-block.js
var require_documentation_block4 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/documentation-block.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.documentationBlock = documentationBlock;
    var array_1 = require_array4();
    var logger_1 = require_logger5();
    var string_formatter_1 = require_string_formatter4();
    var logger8 = (0, logger_1.createLogger)("documentation-block");
    function documentationBlock(strings, ...args) {
      const firstLineTrimmed = removeLeadingEmptyLines(strings.raw[0]);
      const textIndentation = getIndentation(firstLineTrimmed);
      const argsWithIndentation = addIndentationToArguments(args, textIndentation);
      let content = (0, array_1.zip)([firstLineTrimmed, ...strings.raw.slice(1)], argsWithIndentation).join("");
      if (!content.match(/\w/)) {
        return "";
      }
      content = maskProblematicCharacters(content);
      let lines = content.split(string_formatter_1.unixEOL);
      lines = adjustIndentation(lines, textIndentation);
      content = lines.join(`${string_formatter_1.unixEOL} * `);
      const result = ["/**", ` * ${content}`, " */"].join(string_formatter_1.unixEOL);
      return result;
    }
    function removeLeadingEmptyLines(firstLine) {
      const lines = firstLine.split(string_formatter_1.unixEOL);
      const indexFirstNonEmpty = lines.findIndex((str) => str.match(/\w/)) || 0;
      return lines.splice(indexFirstNonEmpty).join(string_formatter_1.unixEOL);
    }
    function addIndentationToArguments(args, textIndentation) {
      const argsWithIndentation = args.map((arg) => arg.replace(/\n/g, string_formatter_1.unixEOL + " ".repeat(textIndentation)));
      return argsWithIndentation;
    }
    function adjustIndentation(lines, textIndentation) {
      return lines.map((str) => str.slice(textIndentation));
    }
    function getIndentation(firstLine) {
      const removeStarting = firstLine?.replace(/^\n*/g, "");
      const countEmptySpaces = removeStarting?.search(/\S/);
      return countEmptySpaces > 0 ? countEmptySpaces : 0;
    }
    function maskProblematicCharacters(str) {
      if (str.includes("*/")) {
        logger8.warn(`The documentation block ${str}'
      )} contained */ in the text will be masked as \\*\\/.`);
      }
      return str.replace(/\*\//g, "\\*\\/");
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/nullish.js
var require_nullish4 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/nullish.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isNullish = isNullish;
    function isNullish(val) {
      return val === null || val === void 0;
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/equal.js
var require_equal4 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/equal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.equalObjects = equalObjects;
    exports2.equal = equal;
    exports2.equalArrays = equalArrays;
    var nullish_1 = require_nullish4();
    function equalObjects(obj1, obj2) {
      const keys1 = Object.keys(obj1);
      return Object.keys(obj1).length === Object.keys(obj2).length && keys1.every((key) => equal(obj1[key], obj2[key]));
    }
    function equal(item1, item2) {
      if (Array.isArray(item1) && Array.isArray(item2)) {
        return equalArrays(item1, item2);
      }
      if (typeof item1 === "object" && typeof item2 === "object" && !(0, nullish_1.isNullish)(item1) && !(0, nullish_1.isNullish)(item2)) {
        return equalObjects(item1, item2);
      }
      return item1 === item2;
    }
    function equalArrays(arr1, arr2) {
      return arr1.length === arr2.length && arr1.every((item1, i) => equal(item1, arr2[i]));
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/error-with-cause.js
var require_error_with_cause4 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/error-with-cause.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ErrorWithCause = void 0;
    exports2.isErrorWithCause = isErrorWithCause;
    var string_formatter_1 = require_string_formatter4();
    var logger_1 = require_logger5();
    var logger8 = (0, logger_1.createLogger)({
      package: "util",
      messageContext: "error-with-cause"
    });
    var ErrorWithCause3 = class extends Error {
      /**
       * Create an instance of ErrorWithCause.
       * @param message - Error message.
       * @param cause - Original error, causing this error.
       */
      constructor(message, cause) {
        super(message);
        this.cause = cause;
        Object.setPrototypeOf(this, new.target.prototype);
        this.name = "ErrorWithCause";
        this.addStack(cause);
      }
      isAxiosError(err) {
        return err["isAxiosError"] === true;
      }
      addStack(cause) {
        if (this.isAxiosError(cause)) {
          let response = "";
          if (cause.response?.data) {
            try {
              response = `${string_formatter_1.unixEOL}${JSON.stringify(cause.response?.data, null, 2)}`;
            } catch (error) {
              logger8.warn(`Failed to stringify response data: ${error.message}`);
              response = `${string_formatter_1.unixEOL}${cause.response?.data}`;
            }
          }
          this.stack = `${this.stack}${string_formatter_1.unixEOL}Caused by:${string_formatter_1.unixEOL}HTTP Response: ${cause.message}${response}`;
        } else if (this.stack && cause?.stack) {
          this.stack = `${this.stack}${string_formatter_1.unixEOL}Caused by:${string_formatter_1.unixEOL}${cause.stack}`;
        }
      }
      /**
       * Root cause of the error.
       * If there are multiple errors caused one by another, the root cause is the first error that occurred.
       * In case there is no root cause.
       * @returns The root cause.
       */
      get rootCause() {
        return isErrorWithCause(this.cause) ? this.cause.rootCause : this.cause;
      }
    };
    exports2.ErrorWithCause = ErrorWithCause3;
    function isErrorWithCause(err) {
      return err?.name === "ErrorWithCause";
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/fs.js
var require_fs4 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.findProjectRoot = findProjectRoot;
    exports2.readJSON = readJSON;
    var fs_1 = require("fs");
    var path_1 = require("path");
    var logger_1 = require_logger5();
    var logger8 = (0, logger_1.createLogger)({
      package: "util",
      messageContext: "fs"
    });
    function findProjectRoot(path, lastPath = path) {
      if (!path) {
        return lastPath;
      }
      const inProject = (0, fs_1.readdirSync)(path).includes("package.json") || (0, fs_1.readdirSync)(path).includes("node_modules") || path.includes("node_modules");
      if (!inProject) {
        return lastPath;
      }
      return findProjectRoot((0, path_1.resolve)(path, ".."), path);
    }
    function readJSON(path) {
      if ((0, fs_1.existsSync)(path)) {
        return JSON.parse((0, fs_1.readFileSync)(path, "utf8"));
      }
      logger8.warn(`File "${path}" does not exist, return empty object.`);
      return {};
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/object.js
var require_object4 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/object.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.exclude = exports2.pick = exports2.renameKeys = void 0;
    exports2.propertyExists = propertyExists;
    exports2.toSanitizedObject = toSanitizedObject;
    exports2.pickIgnoreCase = pickIgnoreCase;
    exports2.pickValueIgnoreCase = pickValueIgnoreCase;
    exports2.pickNonNullish = pickNonNullish;
    exports2.mergeLeftIgnoreCase = mergeLeftIgnoreCase;
    exports2.mergeIgnoreCase = mergeIgnoreCase2;
    var nullish_1 = require_nullish4();
    function propertyExists(obj, ...properties) {
      if (!properties.length) {
        return true;
      }
      if (obj && obj.hasOwnProperty(properties[0])) {
        return propertyExists(obj[properties[0]], ...properties.slice(1));
      }
      return false;
    }
    var renameKeys = (keyMapping, obj) => {
      const unchangedEntries = Object.keys(obj).filter((k) => !Object.keys(keyMapping).includes(k)).reduce((newObj, key) => ({ ...newObj, [key]: obj[key] }), {});
      return Object.entries(keyMapping).reduce((newObj, [oldKey, newKey]) => ({ ...newObj, [newKey]: obj[oldKey] }), unchangedEntries);
    };
    exports2.renameKeys = renameKeys;
    var pick = (keys, obj) => {
      const result = {};
      keys.forEach((key) => {
        const value = obj[key];
        if (Object.keys(obj).includes(key)) {
          result[key] = value;
        }
      });
      return result;
    };
    exports2.pick = pick;
    var exclude = (keys, obj) => {
      const result = {};
      Object.keys(obj).forEach((key) => {
        const value = obj[key];
        if (!keys.includes(key)) {
          result[key] = value;
        }
      });
      return result;
    };
    exports2.exclude = exclude;
    function toSanitizedObject(key, value) {
      return (0, nullish_1.isNullish)(key) || (0, nullish_1.isNullish)(value) ? {} : { [key]: value };
    }
    function pickIgnoreCase(obj = {}, ...keys) {
      return keys.reduce((filteredHeaders, providedKey) => {
        const originalKey = Object.keys(obj).find((objKey) => objKey.toLowerCase() === providedKey.toLowerCase());
        return {
          ...filteredHeaders,
          ...originalKey && { [originalKey]: obj[originalKey] }
        };
      }, {});
    }
    function pickValueIgnoreCase(obj = {}, key) {
      return Object.values(pickIgnoreCase(obj, key))[0];
    }
    function pickNonNullish(obj = {}) {
      return Object.entries(obj).filter(([key, value]) => !(0, nullish_1.isNullish)(key) && !(0, nullish_1.isNullish)(value)).reduce((filtered, [key, value]) => ({ ...filtered, [key]: value }), {});
    }
    function mergeLeftIgnoreCase(left = {}, right = {}) {
      return Object.entries(left).map(([key, value]) => pickValueIgnoreCase(right, key) ? pickIgnoreCase(right, key) : { [key]: value }).reduce((replaced, obj) => ({ ...replaced, ...obj }), {});
    }
    function mergeIgnoreCase2(left = {}, right = {}) {
      return {
        ...mergeLeftIgnoreCase(left, right),
        ...right
      };
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/pipe.js
var require_pipe4 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/pipe.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.identity = identity;
    function identity(value) {
      return value;
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/promise.js
var require_promise4 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/promise.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.finishAll = finishAll;
    async function finishAll(promises, errorMessage) {
      const settledPromises = await Promise.allSettled(promises);
      const rejectedPromises = settledPromises.filter((promise) => promise.status === "rejected");
      if (rejectedPromises.length) {
        const reasons = rejectedPromises.map((promise) => `	${promise.reason}`).join("\n");
        const message = errorMessage ? `${errorMessage} ` : "";
        throw new Error(`${message}Errors: [
${reasons}
]`);
      }
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/remove-slashes.js
var require_remove_slashes4 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/remove-slashes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.removeSlashes = removeSlashes;
    exports2.removeTrailingSlashes = removeTrailingSlashes2;
    exports2.removeLeadingSlashes = removeLeadingSlashes2;
    function removeSlashes(path) {
      path = removeLeadingSlashes2(path);
      path = removeTrailingSlashes2(path);
      return path;
    }
    function removeTrailingSlashes2(path) {
      return path.endsWith("/") ? path.slice(0, -1) : path;
    }
    function removeLeadingSlashes2(path) {
      return path.startsWith("/") ? path.slice(1) : path;
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/types.js
var require_types4 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.caps = caps;
    function caps(oDataVersion) {
      return oDataVersion ? oDataVersion.toUpperCase() : "V2";
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/unique-name-generator.js
var require_unique_name_generator4 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/unique-name-generator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UniqueNameGenerator = void 0;
    var UniqueNameGenerator = class _UniqueNameGenerator {
      static getNameForComparison(name, caseSensitive) {
        return caseSensitive ? name : name.toLowerCase();
      }
      /**
       * Creates an instance of UniqueNameGenerator.
       * @param indexSeparator - The separator to be used when adding an index.
       * @param usedNames - Sets the already used names considered in the finding process.
       */
      constructor(indexSeparator = "_", usedNames = []) {
        this.indexSeparator = indexSeparator;
        this.usedNames = [];
        this.addToUsedNames(...usedNames);
      }
      /**
       * Adds the name(s) to the already used names.
       * @param names - Names to be added.
       */
      addToUsedNames(...names) {
        this.usedNames.push(...names);
      }
      /**
       * Generate a unique name by appending an index separated by the `indexSeparator` if necessary, e.g. if `MyName` is already taken `MyName_1` will be found by default.
       * If the name is already unique nothing is appended.
       * @param name - The name to get a unique name from.
       * @param caseSensitive - Whether to check the already used names in a case sensitive manner.
       * @returns A unique name.
       */
      generateUniqueName(name, caseSensitive = true) {
        return this.generateUniqueNamesWithSuffixes(name, [], caseSensitive)[0];
      }
      /**
       * Generate a unique name by appending an index separated by the `indexSeparator` if necessary, e.g. if `MyName` is already taken `MyName_1` will be found by default.
       * The generated name is added to the used names.
       * If the name is already unique nothing is appended.
       * @param name - The name to get a unique name from.
       * @param caseSensitive - Whether to check the already used names in a case sensitive manner.
       * @returns A unique name.
       */
      generateAndSaveUniqueName(name, caseSensitive = true) {
        const uniqueName = this.generateUniqueName(name, caseSensitive);
        this.addToUsedNames(uniqueName);
        return uniqueName;
      }
      /**
       * Generate unique names by appending an index separated by the `indexSeparator` if necessary, while respecting the given suffixes.
       * If the name is already unique nothing is appended.
       * Each given suffix is appended to the unique name in the result.
       * The resulting names are also checked for uniqueness.
       * All names in the result have the same number suffix.
       * @example if `MyName` and `MyName_1MySuffix` is already taken, `[MyName_2, MyName_2MySuffix]` will be generated by default.
       * @param name - The name to get a unique name from.
       * @param suffixes - Additional name of suffixes to be considered for the finding process, as well as the output.
       * @param caseSensitive - Whether to check the already used names in a case sensitive manner.
       * @returns A list of unique names. The length of this array is one plus the number of suffixes provided. The first entry corresponds to the given name.
       */
      generateUniqueNamesWithSuffixes(name, suffixes, caseSensitive = true) {
        const relevantUsedNames = this.getUsedNamesStartingWith(name, caseSensitive);
        const namesWithSuffixes = this.generateNamesWithSuffixes(name, suffixes);
        if (!this.areNamesUsed(namesWithSuffixes, relevantUsedNames, caseSensitive)) {
          return [name, ...namesWithSuffixes];
        }
        const index = this.getUniqueIndex(name, relevantUsedNames, suffixes, caseSensitive);
        return this.generateNamesWithIndexAndSuffixes(name, index, suffixes);
      }
      /**
       * Generate unique names by appending an index separated by the `indexSeparator` if necessary, while respecting the given suffixes.
       * If the name is already unique nothing is appended.
       * The generated names are added to the used names.
       * Each given suffix is appended to the unique name in the result.
       * The resulting names are also checked for uniqueness.
       * All names in the result have the same number suffix.
       * @example if `MyName` and `MyName_1MySuffix` is already taken, `[MyName_2, MyName_2MySuffix]` will be generated by default.
       * @param name - The name to get a unique name from.
       * @param suffixes - Additional name of suffixes to be considered for the finding process, as well as the output.
       * @param caseSensitive - Whether to check the already used names in a case sensitive manner.
       * @returns A list of unique names. The length of this array is one plus the number of suffixes provided. The first entry corresponds to the given name.
       */
      generateAndSaveUniqueNamesWithSuffixes(name, suffixes, caseSensitive = true) {
        const uniqueNames = this.generateUniqueNamesWithSuffixes(name, suffixes, caseSensitive);
        this.addToUsedNames(...uniqueNames);
        return uniqueNames;
      }
      getUsedNamesForComparison(caseSensitive) {
        return this.usedNames.map((name) => _UniqueNameGenerator.getNameForComparison(name, caseSensitive));
      }
      areNamesUsed(names, usedNames, caseSensitive) {
        return names.some((name) => usedNames.map((usedName) => _UniqueNameGenerator.getNameForComparison(usedName, caseSensitive)).includes(_UniqueNameGenerator.getNameForComparison(name, caseSensitive)));
      }
      generateNamesWithIndexAndSuffixes(name, index, suffixes) {
        const nameWithoutIndex = this.getNameWithoutIndex(name);
        return this.generateNamesWithSuffixes(`${nameWithoutIndex}${this.indexSeparator}${index}`, suffixes);
      }
      generateNamesWithSuffixes(name, suffixes) {
        return [name, ...suffixes.map((nameSuffix) => `${name}${nameSuffix}`)];
      }
      getUsedNamesStartingWith(name, caseSensitive) {
        const modifiedName = this.getNameWithoutIndex(name);
        return this.getUsedNamesForComparison(caseSensitive).filter((used) => used.startsWith(_UniqueNameGenerator.getNameForComparison(modifiedName, caseSensitive)));
      }
      getUniqueIndex(name, usedNames, suffixes, caseSensitive) {
        let index = 1;
        while (index < _UniqueNameGenerator.MAXIMUM_NUMBER_OF_SUFFIX) {
          const newNames = this.generateNamesWithIndexAndSuffixes(name, index, suffixes);
          if (!this.areNamesUsed(newNames, usedNames, caseSensitive)) {
            return index;
          }
          index++;
        }
        throw new Error(`Unable to find a unique name for ${name} within the range of ${_UniqueNameGenerator.MAXIMUM_NUMBER_OF_SUFFIX} suffixes.`);
      }
      getNameWithoutIndex(name) {
        return name.replace(new RegExp(`${this.indexSeparator}\\d+$`), "");
      }
    };
    exports2.UniqueNameGenerator = UniqueNameGenerator;
    UniqueNameGenerator.MAXIMUM_NUMBER_OF_SUFFIX = 1e3;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/url.js
var require_url4 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/url.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkUrlExists = checkUrlExists;
    var axios_1 = __importDefault(require_axios());
    async function checkUrlExists(url) {
      return axios_1.default.request({ url, method: "HEAD" }).then((response) => response.status);
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/index.js
var require_dist11 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/util/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_array4(), exports2);
    __exportStar(require_code_block4(), exports2);
    __exportStar(require_documentation_block4(), exports2);
    __exportStar(require_equal4(), exports2);
    __exportStar(require_error_with_cause4(), exports2);
    __exportStar(require_fs4(), exports2);
    __exportStar(require_logger5(), exports2);
    __exportStar(require_nullish4(), exports2);
    __exportStar(require_object4(), exports2);
    __exportStar(require_pipe4(), exports2);
    __exportStar(require_promise4(), exports2);
    __exportStar(require_remove_slashes4(), exports2);
    __exportStar(require_string4(), exports2);
    __exportStar(require_string_formatter4(), exports2);
    __exportStar(require_types4(), exports2);
    __exportStar(require_unique_name_generator4(), exports2);
    __exportStar(require_url4(), exports2);
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/http-agent/agent-config.js
var require_agent_config3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/http-agent/agent-config.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/protocol.js
var require_protocol3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/protocol.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getProtocol = getProtocol;
    var protocols = {
      http: "http",
      https: "https",
      socks: "socks"
    };
    function getProtocol(protocol) {
      return protocol.endsWith(":") ? getProtocol(protocol.slice(0, -1)) : protocols[protocol];
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/get-protocol.js
var require_get_protocol3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/get-protocol.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getProtocolOrDefault = getProtocolOrDefault;
    var util_1 = require_dist11();
    var protocol_1 = require_protocol3();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "get-protocol"
    });
    function getProtocolOrDefault(destination) {
      const urlParts = destination.url.toLowerCase()?.split("://");
      if (!urlParts || urlParts.length === 1) {
        logger8.warn(`URL of the provided destination (${destination.url}) has no protocol specified! Assuming HTTPS.`);
        return "https";
      }
      const protocol = (0, protocol_1.getProtocol)(urlParts[0]);
      if (!protocol) {
        throw new Error(`Protocol of the provided destination (${destination.url}) is not supported! Currently only HTTP and HTTPS are supported.`);
      }
      return protocol;
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-accessor-types.js
var require_destination_accessor_types3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-accessor-types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isDestinationFetchOptions = isDestinationFetchOptions;
    function isDestinationFetchOptions(destination) {
      return destination.destinationName !== void 0;
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination.js
var require_destination7 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sanitizeDestination = sanitizeDestination;
    exports2.parseDestination = parseDestination;
    exports2.getAdditionalHeadersAndQueryParameters = getAdditionalHeadersAndQueryParameters;
    exports2.getAdditionalHeaders = getAdditionalHeaders;
    exports2.getAdditionalQueryParameters = getAdditionalQueryParameters;
    exports2.getDestinationConfig = getDestinationConfig;
    exports2.toDestinationNameUrl = toDestinationNameUrl;
    exports2.parseCertificate = parseCertificate;
    exports2.isDestinationConfiguration = isDestinationConfiguration;
    exports2.isDestinationJson = isDestinationJson;
    exports2.noDestinationErrorMessage = noDestinationErrorMessage;
    var destination_accessor_types_1 = require_destination_accessor_types3();
    function sanitizeDestination(destination) {
      let parsedDestination = parseAuthTokens(destination);
      parsedDestination = parseCertificates(parsedDestination);
      parsedDestination = setDefaultAuthenticationFallback(parsedDestination);
      parsedDestination = setTrustAll(parsedDestination);
      parsedDestination = setForwardAuthToken(parsedDestination);
      parsedDestination = setOriginalProperties(parsedDestination);
      return parsedDestination;
    }
    function parseDestination(destinationJson) {
      const destinationConfig = getDestinationConfig(destinationJson);
      const destination = Object.entries(destinationConfig).reduce((dest, [originalKey, value]) => {
        if (originalKey in configMapping) {
          dest[configMapping[originalKey]] = value;
        }
        return dest;
      }, {
        originalProperties: destinationJson,
        authTokens: destinationJson["authTokens"] || [],
        certificates: destinationJson["certificates"] || []
      });
      const additionalHeadersAndQueryParameters = getAdditionalHeadersAndQueryParameters(destinationConfig);
      return sanitizeDestination({
        ...destination,
        ...additionalHeadersAndQueryParameters
      });
    }
    function getAdditionalProperties(destinationConfig, originalKeyPrefix) {
      const relevantConfigEntries = Object.entries(destinationConfig).filter(([key]) => key.startsWith(originalKeyPrefix));
      return relevantConfigEntries.reduce((additionalProperties, [originalKey, value]) => {
        const headerKey = originalKey.replace(originalKeyPrefix, "");
        additionalProperties[headerKey] = value;
        return additionalProperties;
      }, {});
    }
    function getAdditionalHeadersAndQueryParameters(destinationConfig) {
      const additionalProperties = {};
      const additionalHeaders = getAdditionalHeaders(destinationConfig).headers;
      if (additionalHeaders && Object.keys(additionalHeaders).length) {
        additionalProperties["headers"] = additionalHeaders;
      }
      const additionalQueryParameters = getAdditionalQueryParameters(destinationConfig).queryParameters;
      if (additionalQueryParameters && Object.keys(additionalQueryParameters).length) {
        additionalProperties["queryParameters"] = additionalQueryParameters;
      }
      return additionalProperties;
    }
    function getAdditionalHeaders(destinationConfig) {
      const additionalHeaders = getAdditionalProperties(destinationConfig, "URL.headers.");
      const additionalProperties = {};
      if (Object.keys(additionalHeaders).length) {
        additionalProperties["headers"] = additionalHeaders;
      }
      return additionalProperties;
    }
    function getAdditionalQueryParameters(destinationConfig) {
      const additionalQueryParameters = getAdditionalProperties(destinationConfig, "URL.queries.");
      const additionalProperties = {};
      if (Object.keys(additionalQueryParameters).length) {
        additionalProperties["queryParameters"] = additionalQueryParameters;
      }
      return additionalProperties;
    }
    function getDestinationConfig(destinationJson) {
      return isDestinationJson(destinationJson) ? destinationJson.destinationConfiguration : destinationJson;
    }
    function toDestinationNameUrl(destination) {
      if ((0, destination_accessor_types_1.isDestinationFetchOptions)(destination)) {
        return `name: ${destination.destinationName}`;
      }
      const text = ["name", "url"].filter((key) => destination[key]).map((key) => `${key}: ${destination[key]}`);
      return text.length > 0 ? text.join(",") : "Destination does not have a 'name' or 'url' property.";
    }
    function setOriginalProperties(destination) {
      const originalProperties = destination.originalProperties ? destination.originalProperties : destination;
      return {
        ...destination,
        originalProperties
      };
    }
    function setDefaultAuthenticationFallback(destination) {
      return destination.authentication ? destination : {
        ...destination,
        authentication: getAuthenticationType(destination)
      };
    }
    function parseCertificate(certificate) {
      return {
        name: certificate.Name || certificate.name,
        content: certificate.Content || certificate.content,
        type: certificate.Type || certificate.type
      };
    }
    function parseCertificates(destination) {
      return {
        ...destination,
        certificates: (destination.certificates || []).map((certificate) => parseCertificate(certificate))
      };
    }
    function parseAuthToken(authToken) {
      return {
        type: authToken.type,
        value: authToken.value,
        expiresIn: authToken.expires_in,
        error: "error" in authToken ? authToken.error : null,
        http_header: authToken.http_header
      };
    }
    function parseAuthTokens(destination) {
      return {
        ...destination,
        authTokens: (destination.authTokens || []).map((token) => parseAuthToken(token))
      };
    }
    function setTrustAll(destination) {
      return {
        ...destination,
        isTrustingAllCertificates: parseTrustAll(destination.isTrustingAllCertificates)
      };
    }
    function parseTrustAll(isTrustingAllCertificates) {
      if (typeof isTrustingAllCertificates === "string") {
        return isTrustingAllCertificates.toLowerCase() === "true";
      }
      return !!isTrustingAllCertificates;
    }
    function getAuthenticationType(destination) {
      return destination.authentication || destination.username && destination.password ? "BasicAuthentication" : "NoAuthentication";
    }
    function setForwardAuthToken(destination) {
      const forwardAuthToken = destination.originalProperties?.forwardAuthToken ?? destination.originalProperties?.["HTML5.ForwardAuthToken"] ?? destination.forwardAuthToken;
      return {
        ...destination,
        forwardAuthToken: forwardAuthToken === "true" || forwardAuthToken === true
      };
    }
    function isDestinationConfiguration(destination) {
      return destination.URL !== void 0;
    }
    function isDestinationJson(destination) {
      return Object.keys(destination).includes("destinationConfiguration");
    }
    var configMapping = {
      URL: "url",
      Name: "name",
      User: "username",
      Password: "password",
      ProxyType: "proxyType",
      "sap-client": "sapClient",
      Authentication: "authentication",
      TrustAll: "isTrustingAllCertificates",
      Type: "type",
      tokenServiceURL: "tokenServiceUrl",
      clientId: "clientId",
      clientSecret: "clientSecret",
      tokenServiceUser: "tokenServiceUser",
      tokenServicePassword: "tokenServicePassword",
      CloudConnectorLocationId: "cloudConnectorLocationId",
      certificates: "certificates",
      KeyStoreLocation: "keyStoreName",
      KeyStorePassword: "keyStorePassword",
      SystemUser: "systemUser",
      /**
       * Base64-encoded JSON web key set, containing the signing keys which are used to validate the JWT provided in the X-User-Token header.
       */
      "x_user_token.jwks": "jwks",
      /**
       * URI of the JSON web key set, containing the signing keys which are used to validate the JWT provided in the X-User-Token header.
       */
      "x_user_token.jwks_uri": "jwksUri",
      "HTML5.ForwardAuthToken": "forwardAuthToken",
      /**
       * This overwrites `HTML5.ForwardAuthToken`, if both exist (during sanitize).
       */
      forwardAuthToken: "forwardAuthToken"
    };
    function noDestinationErrorMessage(destination) {
      return (0, destination_accessor_types_1.isDestinationFetchOptions)(destination) ? `Could not find a destination with name "${destination.destinationName}"! Unable to execute request.` : "Could not find a destination to execute request against and no destination name has been provided (this should never happen)!";
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/authorization-header.js
var require_authorization_header3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/authorization-header.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getAuthHeader = getAuthHeader;
    exports2.basicHeader = basicHeader;
    exports2.buildAuthorizationHeaders = buildAuthorizationHeaders;
    var util_1 = require_dist11();
    var destination_1 = require_destination7();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "authorization-header"
    });
    function getAuthHeader(authenticationType, customHeaders) {
      if (authenticationType === "PrincipalPropagation") {
        const principalPropagationHeader = (0, util_1.pickValueIgnoreCase)(customHeaders, "SAP-Connectivity-Authentication");
        if (principalPropagationHeader) {
          return { "SAP-Connectivity-Authentication": principalPropagationHeader };
        }
      }
      const authorizationHeader = (0, util_1.pickValueIgnoreCase)(customHeaders, "authorization");
      if (authorizationHeader) {
        return { authorization: authorizationHeader };
      }
    }
    function headerFromTokens(authenticationType, authTokens) {
      if (!authTokens || !authTokens.length) {
        throw Error(`\`AuthenticationType\` is "${authenticationType}", but no auth tokens could be fetched from the destination service.`);
      }
      const usableTokens = authTokens.filter((token) => !token.error);
      if (!usableTokens.length) {
        throw Error([
          "The destination tried to provide authorization tokens but failed in all cases. This is most likely due to misconfiguration.",
          "Original error messages:",
          ...authTokens.map((token) => token.error)
        ].join(util_1.unixEOL));
      }
      const authToken = usableTokens[0];
      return { authorization: authToken.http_header.value };
    }
    function headerFromBasicAuthDestination(destination) {
      if ((0, util_1.isNullish)(destination.username) || (0, util_1.isNullish)(destination.password)) {
        throw Error('AuthenticationType is "BasicAuthentication", but "username" and / or "password" are missing!');
      }
      return {
        authorization: basicHeader(destination.username, destination.password)
      };
    }
    function basicHeader(username, password) {
      return "Basic " + (0, util_1.encodeBase64)(`${username}:${password}`);
    }
    function headerForPrincipalPropagation(destination) {
      const principalPropagationHeader = destination?.proxyConfiguration?.headers?.["SAP-Connectivity-Authentication"];
      if (!principalPropagationHeader) {
        throw Error("Principal propagation was selected in destination, but no SAP-Connectivity-Authentication bearer header was added by connectivity service.");
      }
      return {
        "SAP-Connectivity-Authentication": principalPropagationHeader
      };
    }
    function getProxyRelatedAuthHeaders(destination) {
      const authHeader = destination?.proxyConfiguration?.headers?.["Proxy-Authorization"];
      if (authHeader) {
        return { "Proxy-Authorization": authHeader };
      }
    }
    async function getAuthenticationRelatedHeaders(destination) {
      const destinationAuthHeaders = getAuthHeader(destination.authentication, destination.headers);
      logger8.debug(`Getting authentication related headers for authentication type: ${destination.authentication}`);
      if (destinationAuthHeaders) {
        logger8.debug("Authentication header from 'destination.headers' used.");
        return destinationAuthHeaders;
      }
      switch (destination.authentication) {
        case null:
        case void 0:
          logger8.warn('No authentication type is specified on the destination. Assuming "NoAuthentication".');
          return;
        case "NoAuthentication":
          return;
        case "ClientCertificateAuthentication":
          return;
        case "SAMLAssertion":
        case "OAuth2SAMLBearerAssertion":
        case "OAuth2UserTokenExchange":
        case "OAuth2JWTBearer":
        case "OAuth2ClientCredentials":
        case "OAuth2Password":
        case "OAuth2RefreshToken": {
          const header = headerFromTokens(destination.authentication, destination.authTokens);
          if (destination.authentication === "SAMLAssertion") {
            logger8.warn("Destination authentication flow is 'SamlAssertion' and the auth header contains the SAML assertion. In most cases you want to translate the assertion to a Bearer token using the 'OAuth2SAMLBearerAssertion' flow.");
            return {
              ...header,
              "x-sap-security-session": "create"
            };
          }
          return header;
        }
        case "BasicAuthentication":
          return headerFromBasicAuthDestination(destination);
        case "PrincipalPropagation":
          return headerForPrincipalPropagation(destination);
        default:
          throw Error(`The destination used "${destination.authentication}" as authentication type which is not supported by the SAP Cloud SDK.`);
      }
    }
    async function buildAuthorizationHeaders(destination) {
      const sanitizedDestination = (0, destination_1.sanitizeDestination)(destination);
      return {
        ...await getAuthenticationRelatedHeaders(sanitizedDestination),
        ...getProxyRelatedAuthHeaders(sanitizedDestination)
      };
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-service-types.js
var require_destination_service_types3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-service-types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assertHttpDestination = assertHttpDestination2;
    exports2.isHttpDestination = isHttpDestination;
    function assertHttpDestination2(destination) {
      if (!isHttpDestination(destination)) {
        throw new Error(destination.url ? `The 'type' property is  ${destination.type} instead of  HTTP for destination '${destination.name}' which is mandatory if you use it as an 'HTTP destination` : `The 'url' property is not set for destination ${destination.name} which is mandatory if you use it as an 'HTTP destination`);
      }
    }
    function isHttpDestination(destination) {
      return !!destination && !!destination.url && (!destination.type || destination.type === "HTTP");
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/http-proxy-util.js
var require_http_proxy_util3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/http-proxy-util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.proxyStrategy = proxyStrategy;
    exports2.parseProxyEnv = parseProxyEnv;
    exports2.addProxyConfigurationInternet = addProxyConfigurationInternet;
    exports2.getProxyConfig = getProxyConfig;
    var node_url_1 = require("node:url");
    var util_1 = require_dist11();
    var protocol_1 = require_protocol3();
    var authorization_header_1 = require_authorization_header3();
    var get_protocol_1 = require_get_protocol3();
    var destination_service_types_1 = require_destination_service_types3();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "proxy-util"
    });
    function proxyStrategy(destination) {
      if (destination.proxyType === "OnPremise") {
        logger8.debug("OnPrem destination proxy settings from connectivity service will be used.");
        return "on-premise";
      }
      if (destination.proxyType === "PrivateLink") {
        logger8.debug("PrivateLink destination proxy settings will be used. This is not supported in local/CI/CD environments.");
        return "private-link";
      }
      if ((0, destination_service_types_1.isHttpDestination)(destination)) {
        const destinationProtocol = (0, get_protocol_1.getProtocolOrDefault)(destination);
        return getProxyStrategyFromProxyEnvValue(destinationProtocol, destination.url);
      }
      return "no-proxy";
    }
    function getProxyStrategyFromProxyEnvValue(protocol, destinationUrl) {
      if (!getProxyEnvValue(protocol)) {
        logger8.debug(`Could not find proxy settings for ${protocol} in the environment variables - no proxy used.`);
        return "no-proxy";
      }
      if (getNoProxyEnvValue().includes(destinationUrl)) {
        logger8.debug(`Destination URL ${destinationUrl} is in no_proxy list: ${getNoProxyEnvValue()} - no proxy used.`);
        return "no-proxy";
      }
      if (getProxyEnvValue(protocol)) {
        logger8.debug(`Proxy settings for ${protocol} are found in environment variables.`);
        return "internet";
      }
      return "no-proxy";
    }
    function getProxyEnvValue(protocol) {
      const proxyEnvKey = protocol + "_proxy";
      const proxyEnvValue = process.env[proxyEnvKey.toLowerCase()] || process.env[proxyEnvKey.toUpperCase()];
      logger8.debug(`Tried to read ${proxyEnvKey.toLowerCase()} or ${proxyEnvKey.toUpperCase()} from the environment variables. Value is ${proxyEnvValue}.`);
      return proxyEnvValue || void 0;
    }
    function getNoProxyEnvValue() {
      const noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
      if (!noProxyEnv) {
        return [];
      }
      const split = noProxyEnv.split(",").map((s) => s.trim());
      if (split.find((s) => s.includes("*"))) {
        logger8.warn(`The no_proxy env contains a wildcard ${noProxyEnv}, which is currently not supported`);
      }
      return split;
    }
    function getPort(url) {
      if (url.port) {
        return parseInt(url.port);
      }
      return url.protocol === "https:" ? 443 : 80;
    }
    function getOriginalProtocol(href) {
      const test = href.match(/^[\w.-]+:\/\//);
      return test ? test[0].slice(0, -2) : void 0;
    }
    function sanitizeUrl(href) {
      const protocol = getOriginalProtocol(href);
      if (!protocol) {
        logger8.debug('No protocol specified, using "http:".');
        return `http://${href}`;
      }
      return href;
    }
    function validateUrl(url) {
      if (url.protocol !== "http:" && url.protocol !== "https:") {
        throw new Error(`Unsupported protocol "${url.protocol}".`);
      }
      if (url.protocol === "https:") {
        logger8.debug('Using protocol "https:" to connect to a proxy. This is unusual but possible.');
      }
      if (url.username && !url.password) {
        throw new Error("Password missing.");
      }
    }
    function parseProxyEnv(proxyEnvValue) {
      const href = sanitizeUrl(proxyEnvValue);
      try {
        const url = new node_url_1.URL(href);
        validateUrl(url);
        const proxyConfig = {
          host: url.hostname,
          protocol: (0, protocol_1.getProtocol)(url.protocol),
          port: getPort(url)
        };
        if (url.username && url.password) {
          proxyConfig.headers = {
            "Proxy-Authorization": (0, authorization_header_1.basicHeader)(decodeURIComponent(url.username), decodeURIComponent(url.password))
          };
        }
        if (proxyConfig) {
          const loggableConfig = {
            ...proxyConfig,
            headers: (0, util_1.sanitizeRecord)(proxyConfig.headers || {}, "Authorization header present. Not logged for security reasons.")
          };
          logger8.debug(`Used Proxy Configuration: ${JSON.stringify(loggableConfig, null, 2)}.`);
        }
        return proxyConfig;
      } catch (err) {
        logger8.warn(`Could not parse proxy configuration from environment variable. Reason: ${err.message}`);
        return void 0;
      }
    }
    function addProxyConfigurationInternet(destination) {
      const proxyEnvValue = getProxyEnvValue((0, get_protocol_1.getProtocolOrDefault)(destination));
      if (proxyEnvValue) {
        return {
          ...destination,
          proxyConfiguration: parseProxyEnv(proxyEnvValue) || destination.proxyConfiguration
        };
      }
      logger8.warn("Attempt to get proxy config from environment variables failed. At this point this should not happen - no proxy used.");
      return { ...destination };
    }
    function getProxyConfig(destination) {
      if (destination.proxyConfiguration) {
        const { host, protocol, port } = destination.proxyConfiguration;
        return { host, protocol, port };
      }
      return false;
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/cache.js
var require_cache4 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/cache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Cache = void 0;
    var Cache2 = class {
      /**
       * Creates an instance of Cache.
       * @param defaultValidityTime - The default validity time in milliseconds. Use 0 for unlimited cache duration.
       */
      constructor(defaultValidityTime) {
        this.defaultValidityTime = defaultValidityTime;
        this.cache = {};
      }
      /**
       * Clear all cached items.
       */
      clear() {
        this.cache = {};
      }
      /**
       * Specifies whether an entry with a given key is defined in cache.
       * @param key - The entry's key.
       * @returns A boolean value that indicates whether the entry exists in cache.
       */
      hasKey(key) {
        return this.cache.hasOwnProperty(key);
      }
      /**
       * Getter of cached entries.
       * @param key - The key of the entry to retrieve.
       * @returns The corresponding entry to the provided key if it is still valid, returns `undefined` otherwise.
       */
      get(key) {
        return key && this.hasKey(key) && !isExpired(this.cache[key]) ? this.cache[key].entry : void 0;
      }
      /**
       * Setter of entries in cache.
       * @param key - The entry's key.
       * @param item - The entry to cache.
       */
      set(key, item) {
        if (key) {
          const expires = item.expires ?? this.inferDefaultExpirationTime();
          this.cache[key] = { entry: item.entry, expires };
        }
      }
      inferDefaultExpirationTime() {
        const now = /* @__PURE__ */ new Date();
        return this.defaultValidityTime ? now.setMilliseconds(now.getMilliseconds() + this.defaultValidityTime).valueOf() : void 0;
      }
    };
    exports2.Cache = Cache2;
    function isExpired(item) {
      if (item.expires === void 0) {
        return false;
      }
      return item.expires < Date.now();
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/async-cache.js
var require_async_cache3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/async-cache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AsyncCache = void 0;
    var cache_1 = require_cache4();
    var AsyncCache = class {
      constructor(defaultValidityTime = 0) {
        this.cache = new cache_1.Cache(defaultValidityTime);
      }
      /**
       * Specifies whether an entry with a given key is defined in cache.
       * @param key - The entry's key.
       * @returns A boolean value that indicates whether the entry exists in cache.
       */
      async hasKey(key) {
        return this.cache.hasKey(key);
      }
      /**
       * Getter of cached entries.
       * @param key - The key of the entry to retrieve.
       * @returns The corresponding entry to the provided key if it is still valid, returns `undefined` otherwise.
       */
      async get(key) {
        return this.cache.get(key);
      }
      /**
       * Setter of entries in cache.
       * @param key - The entry's key.
       * @param item - The entry to cache.
       * @returns A promise to oid.
       */
      async set(key, item) {
        return this.cache.set(key, item);
      }
      /**
       * Clear all cached items.
       * @returns A promise to void.
       */
      async clear() {
        return this.cache.clear();
      }
    };
    exports2.AsyncCache = AsyncCache;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/subdomain-replacer.js
var require_subdomain_replacer3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/subdomain-replacer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getIssuerSubdomain = getIssuerSubdomain;
    var url_1 = require("url");
    function getIssuerSubdomain(decodedJwt) {
      const iss = decodedJwt?.iss;
      if (iss) {
        if (!isValidUrl(iss)) {
          throw new Error(`Issuer URL in JWT is not a valid URL: "${iss}".`);
        }
        return getHost(new url_1.URL(iss)).split(".")[0];
      }
    }
    function getHost(url) {
      const { host } = url;
      if (!host || host.indexOf(".") === -1) {
        throw new Error(`Failed to determine sub-domain: invalid host in "${url}".`);
      }
      return host;
    }
    function isValidUrl(url) {
      try {
        new url_1.URL(url);
        return true;
      } catch {
        return false;
      }
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/jwt/jwt.js
var require_jwt5 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/jwt/jwt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.verificationKeyCache = exports2.defaultTenantId = void 0;
    exports2.userId = userId;
    exports2.getDefaultTenantId = getDefaultTenantId;
    exports2.getTenantId = getTenantId;
    exports2.getSubdomain = getSubdomain;
    exports2.audiences = audiences;
    exports2.decodeJwt = decodeJwt;
    exports2.decodeJwtComplete = decodeJwtComplete;
    exports2.retrieveJwt = retrieveJwt;
    exports2.wrapJwtInHeader = wrapJwtInHeader;
    exports2.isXsuaaToken = isXsuaaToken;
    exports2.getJwtPair = getJwtPair;
    exports2.isUserToken = isUserToken;
    var util_1 = require_dist11();
    var jsonwebtoken_1 = require_jsonwebtoken();
    var cache_1 = require_cache4();
    var subdomain_replacer_1 = require_subdomain_replacer3();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "jwt"
    });
    exports2.defaultTenantId = "provider-tenant";
    function makeArray(val) {
      return val ? Array.isArray(val) ? val : [val] : [];
    }
    function userId({ user_id }) {
      logger8.debug(`JWT user_id is: ${user_id}.`);
      return user_id;
    }
    function getDefaultTenantId() {
      logger8.debug("Could not determine tenant from JWT nor XSUAA, identity or destination service binding. Client Credentials token is cached without tenant information.");
      return exports2.defaultTenantId;
    }
    function getTenantId(jwt) {
      const decodedJwt = jwt ? decodeJwt(jwt) : {};
      logger8.debug(`JWT zid is: ${decodedJwt.zid}, app_tid is: ${decodedJwt.app_tid}.`);
      return decodedJwt.zid || decodedJwt.app_tid || void 0;
    }
    function isNotIasToken(decodedJwt) {
      return !decodedJwt.iss?.includes("accounts.ondemand.com") && !decodedJwt.iss?.includes("accounts400.ondemand.com");
    }
    function getSubdomain(jwt) {
      const decodedJwt = jwt ? decodeJwt(jwt) : {};
      return decodedJwt?.ext_attr?.zdn || (isNotIasToken(decodedJwt) ? (0, subdomain_replacer_1.getIssuerSubdomain)(decodedJwt) : void 0);
    }
    function audiences(decodedToken) {
      const parsedAudiences = audiencesFromAud(decodedToken);
      return parsedAudiences.length ? parsedAudiences : audiencesFromScope(decodedToken);
    }
    function audiencesFromAud({ aud }) {
      return makeArray(aud).map((audience) => audience.split(".")[0]);
    }
    function audiencesFromScope({ scope }) {
      return makeArray(scope).reduce((aud, s) => s.includes(".") ? [...aud, s.split(".")[0]] : aud, []);
    }
    function decodeJwt(token) {
      return typeof token === "string" ? decodeJwtComplete(token).payload : token;
    }
    function decodeJwtComplete(token) {
      const decodedToken = (0, jsonwebtoken_1.decode)(token, { complete: true, json: true });
      if (decodedToken !== null && isJwtWithPayloadObject(decodedToken)) {
        return decodedToken;
      }
      throw new Error("JwtError: The given jwt payload does not encode valid JSON.");
    }
    function retrieveJwt(req) {
      const authHeader = getAuthHeader(req);
      if (validateAuthHeader(authHeader)) {
        return authHeader?.split(" ")[1];
      }
    }
    function getAuthHeader(req) {
      const authHeader = (0, util_1.pickValueIgnoreCase)(req.headers, "authorization");
      if (authHeader) {
        return Array.isArray(authHeader) ? authHeader[0] : authHeader;
      }
    }
    function validateAuthHeader(header) {
      if (typeof header === "undefined") {
        logger8.warn("Authorization header not set.");
        return false;
      }
      const [authType, token] = header.split(" ");
      if (typeof token === "undefined") {
        logger8.warn("Token in auth header missing.");
        return false;
      }
      if (authType.toLowerCase() !== "bearer") {
        logger8.warn("Authorization type is not Bearer.");
        return false;
      }
      return true;
    }
    exports2.verificationKeyCache = new cache_1.Cache(9e5);
    function wrapJwtInHeader(token) {
      return { headers: { Authorization: "Bearer " + token } };
    }
    function isXsuaaToken(decodedJwt) {
      return decodedJwt?.ext_attr?.enhancer === "XSUAA";
    }
    function getJwtPair(encodedJwt) {
      return { encoded: encodedJwt, decoded: decodeJwt(encodedJwt) };
    }
    function isUserToken(token) {
      if (!token) {
        return false;
      }
      const keys = Object.keys(token.decoded);
      return !(keys.length === 1 && keys[0] === "iss");
    }
    function isJwtWithPayloadObject(decoded) {
      return typeof decoded.payload !== "string";
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/environment-accessor/service-bindings.js
var require_service_bindings3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/environment-accessor/service-bindings.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getServiceBindings = getServiceBindings;
    exports2.getServiceBinding = getServiceBinding2;
    exports2.resolveServiceBinding = resolveServiceBinding;
    exports2.getServiceBindingByInstanceName = getServiceBindingByInstanceName;
    var util_1 = require_dist11();
    var xsenv = __importStar(require_xsenv());
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "environment-accessor"
    });
    function getServiceBindings(service) {
      return xsenv.filterServices({ label: service });
    }
    function getServiceBinding2(service) {
      const services = xsenv.filterServices({ label: service });
      if (!services.length) {
        logger8.warn(`Could not find service binding of type '${service}'. This might cause errors in other parts of the application.`);
      } else if (services.length > 1) {
        logger8.warn(`Found more than one service binding for service type '${service}':${services.map(({ name }) => `
	- ${name}`).join("")}
Selecting the first one.`);
      }
      return services[0];
    }
    function resolveServiceBinding(service) {
      if (typeof service === "string") {
        const serviceInstance = getServiceBinding2(service);
        if (!serviceInstance) {
          throw Error(`Could not find service binding of type '${service}'.`);
        }
        return serviceInstance;
      }
      return service;
    }
    function getServiceBindingByInstanceName(serviceInstanceName) {
      const service = xsenv.filterServices(serviceInstanceName);
      if (!service.length) {
        throw Error(`Could not find service with name: '${serviceInstanceName}'.`);
      }
      if (service.length > 1) {
        throw Error(`Found multiple services with name: '${serviceInstanceName}'.`);
      }
      return service[0];
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/environment-accessor/service-credentials.js
var require_service_credentials3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/environment-accessor/service-credentials.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getServiceCredentials = getServiceCredentials;
    var util_1 = require_dist11();
    var jwt_1 = require_jwt5();
    var service_bindings_1 = require_service_bindings3();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "environment-accessor"
    });
    function getServiceCredentials(service, token) {
      const credentialsList = getServiceBindingsWithCredentials(service);
      if (!credentialsList.length) {
        logger8.debug(`Could not find binding to service '${service}', that includes credentials.`);
        return;
      }
      if (token) {
        const credentials = getCredentialsWithJwt(service, credentialsList, typeof token === "string" ? (0, jwt_1.decodeJwt)(token) : token);
        return credentials;
      }
      logger8.debug(`No JWT given to select binding to service '${service}'.`);
      return getCredentialsWithoutJwt(service, credentialsList);
    }
    function getServiceBindingsWithCredentials(service) {
      const services = (0, service_bindings_1.getServiceBindings)(service);
      const serviceCredentials = services.map(({ credentials }) => credentials).filter((credentials) => credentials);
      if (serviceCredentials.length < services.length) {
        const difference = services.length - serviceCredentials.length;
        logger8.warn(`Ignoring ${difference} service binding${difference > 1 ? "s" : ""} of service type '${service}' because of missing credentials.`);
      }
      return serviceCredentials;
    }
    function getCredentialsWithJwt(service, credentials, token) {
      const eligibleCredentials = credentials.filter((c) => matchesClientId(c, token) || matchesAudience(c, token));
      logResult(service, eligibleCredentials, true);
      return eligibleCredentials[0];
    }
    function getCredentialsWithoutJwt(service, credentials) {
      logResult(service, credentials, false);
      return credentials[0];
    }
    function logResult(service, credentials, usedToken) {
      if (credentials.length === 1) {
        logger8.debug(`Found one service binding for service '${service}'${usingJwtText(usedToken)}. ${appNames(credentials)}`);
      } else if (credentials.length > 1) {
        logger8.warn(`Found multiple bindings for service '${service}'${usingJwtText(usedToken)}. ${appNames(credentials)}
Choosing first one ('${credentials[0].xsappname}').`);
      } else if (usedToken) {
        logger8.warn(`Found no service binding for service '${service}' matching either the token's client id or audience.`);
      }
    }
    function usingJwtText(usedToken) {
      return usedToken ? " using JWT" : "";
    }
    function appNames(credentials) {
      const names = credentials.map(({ xsappname }) => xsappname);
      if (names.length) {
        return names.length === 1 ? `App name: ${names[0]}.` : `App names:${names.map((name) => `
	- ${name}`).join("")}`;
      }
      return "";
    }
    function matchesClientId(credentials, token) {
      return credentials.clientid === token.client_id;
    }
    function matchesAudience(credentials, token) {
      return (0, jwt_1.audiences)(token).includes(credentials.xsappname);
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/environment-accessor/destination.js
var require_destination8 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/environment-accessor/destination.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getDestinationServiceCredentials = getDestinationServiceCredentials;
    var service_credentials_1 = require_service_credentials3();
    function getDestinationServiceCredentials() {
      const credentials = (0, service_credentials_1.getServiceCredentials)("destination");
      if (!credentials) {
        throw new Error("Could not find binding to the destination service.");
      }
      return credentials;
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/environment-accessor/environment-accessor-types.js
var require_environment_accessor_types3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/environment-accessor/environment-accessor-types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/XssecError.js
var require_XssecError3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/XssecError.js"(exports2, module2) {
    var XssecError = class extends Error {
      /** 
       * @type {number} Suggested HTTP response code for consumer application catching this error
       */
      #statusCode;
      constructor(message) {
        super(message);
        this.name = "XssecError";
        this.statusCode = 500;
      }
      get statusCode() {
        return this.#statusCode;
      }
      /** 
       * @type {number} Lowercased version of {@link #statusCode} for backward-compatibility
       */
      get statuscode() {
        return this.#statusCode;
      }
      /** 
       * Allows overriding suggested response status code in subclasses, e.g. 403 in ValidationError 
       * @internal
       * @param {number} statusCode - Suggested HTTP response code for consumer application catching this error
       */
      set statusCode(statusCode) {
        this.#statusCode = statusCode;
      }
    };
    module2.exports = XssecError;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/validation/ValidationError.js
var require_ValidationError3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/validation/ValidationError.js"(exports2, module2) {
    var XssecError = require_XssecError3();
    var ValidationError = class extends XssecError {
      constructor(message) {
        super(message);
        this.name = "ValidationError";
        this.statusCode = 401;
      }
    };
    module2.exports = ValidationError;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/validation/InvalidJwtError.js
var require_InvalidJwtError3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/validation/InvalidJwtError.js"(exports2, module2) {
    var ValidationError = require_ValidationError3();
    var InvalidJwtError = class extends ValidationError {
      /** @type {Error} Error encountered during parsing */
      #parseError;
      constructor(jwt, parseError, message = `JWT could not be parsed: ${parseError.message}`) {
        super(jwt, message);
        this.name = "InvalidJwtError";
        this.jwt = jwt;
        this.#parseError = parseError;
      }
      get parseError() {
        return this.#parseError;
      }
      set parseError(value) {
        this.#parseError = value;
      }
    };
    module2.exports = InvalidJwtError;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/util/constants.js
var require_constants4 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/util/constants.js"(exports2, module2) {
    module2.exports = {
      APP_TID_HEADER: "x-app_tid",
      AZP_HEADER: "x-azp",
      CLIENT_CERTIFICATE_HEADER: "x-client_cert",
      CLIENTID_HEADER: "x-client_id",
      CORRELATIONID_HEADER_VCAP: "x-vcap-request-id",
      CORRELATIONID_HEADERS: [
        "x-correlation-id",
        "x-request-id",
        "x-correlationid",
        "x-vcap-request-id"
      ],
      DEFAULT_TIMEOUT: 2e3,
      DEFAULT_JWT_BEARER_FETCH_TIMEOUT: 1e4,
      FORWARDED_CLIENTCERTIFICATE_HEADER: "x-forwarded-client-cert",
      MAX_TIMEOUT: 1e4,
      GRANTTYPE_SAML2BEARER: "urn:ietf:params:oauth:grant-type:saml2-bearer",
      GRANTTYPE_JWTBEARER: "urn:ietf:params:oauth:grant-type:jwt-bearer",
      GRANTTYPE_USERTOKEN: "user_token",
      GRANTTYPE_REFRESHTOKEN: "refresh_token",
      GRANTTYPE_PASSWORD: "password",
      GRANTTYPE_CLIENTCREDENTIALS: "client_credentials",
      GRANTTYPE_AUTHORIZATIONCODE: "authorization_code",
      GRANTTYPE_IMPLICIT: "implicit",
      HTTP_SCHEME: "http://",
      HTTPS_SCHEME: "https://",
      PEM_HEADER: "-----BEGIN CERTIFICATE-----",
      PEM_FOOTER: "-----END CERTIFICATE-----",
      USER_AGENT: "nodejs-xssec-4",
      SERVICE_PLAN_HEADER: "x-osb_plan",
      TOKEN_DATE_LEEWAY: 60,
      // seconds around nbf / exp time in which token is still considered valid
      X5T_CNF_CLAIM: "x5t#S256",
      ZID_HEADER: "x-zid",
      ZID_QUERY_PARAMETER: "zid"
    };
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/cache/LRUCache.js
var require_LRUCache3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/cache/LRUCache.js"(exports2, module2) {
    var LRUCache = class {
      /**
       * Creates an instance of LRUCache.
       * @param {number} size - The maximum number of items the cache can hold.
       */
      constructor(size) {
        this.size = size;
        this.map = /* @__PURE__ */ new Map();
      }
      /**
       * Retrieve a value from the cache.
       * @param {string} key - The key of the item to retrieve.
       * @returns {*} The value associated with the key, or null if the key does not exist.
       */
      get(key) {
        if (!this.map.has(key)) return null;
        const value = this.map.get(key);
        this.map.delete(key);
        this.map.set(key, value);
        return value;
      }
      /**
       * Insert or update a value in the cache.
       * @param {string} key - The key of the item to insert or update.
       * @param {*} value - The value to associate with the key.
       */
      set(key, value) {
        if (this.map.has(key)) {
          this.map.delete(key);
        } else if (this.map.size >= this.size) {
          const oldestKey = this.map.keys().next().value;
          this.map.delete(oldestKey);
        }
        this.map.set(key, value);
      }
    };
    module2.exports = LRUCache;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/token/Token.js
var require_Token3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/token/Token.js"(exports2, module2) {
    var { jwtDecode } = require_cjs();
    var InvalidJwtError = require_InvalidJwtError3();
    var { TOKEN_DATE_LEEWAY } = require_constants4();
    var LRUCache = require_LRUCache3();
    var Token = class _Token {
      /**
       * A shared jwt->{header, payload} cache that is used to avoid decoding the same token multiple times.
       * @type {import("../util/Types").Cache}
       */
      static decodeCache = null;
      /**
       * Enables the shared decode cache for tokens.
       * @param {DecodeCacheConfig} [config] - Optional configuration for the decode cache.
       */
      static enableDecodeCache(config = {}) {
        if (config.impl) {
          _Token.decodeCache = config.impl;
        } else {
          _Token.decodeCache = new LRUCache(config?.size || 100);
        }
      }
      /**
       * Disables the shared decode cache for tokens.
       */
      static disableDecodeCache() {
        _Token.decodeCache = null;
      }
      #jwt;
      /** @type {JwtHeader} */
      #header;
      // parsed header
      /** @type {JwtPayload} */
      #payload;
      // parsed payload
      /**
       * @param {string|null} jwt 
       * @param {object} [content] - optional decoded content
       * @param {JwtHeader & { [key: string]: any }} [content.header] - Optional parsed header (used instead of decoding jwt parameter if both header/payload are provided)
       * @param {JwtPayload & { [key: string]: any }} [content.payload] - Optional parsed payload (used instead of decoding jwt parameter if both header/payload are provided)
       */
      constructor(jwt, { header, payload } = {}) {
        this.#jwt = jwt;
        if (!header || !payload) {
          const cached = _Token.decodeCache?.get(jwt);
          if (cached != null) {
            header = cached.header;
            payload = cached.payload;
          } else {
            ({ header, payload } = this.#parseJwt(jwt));
            _Token.decodeCache?.set(jwt, { header, payload });
          }
        }
        this.#header = header;
        this.#payload = payload;
      }
      #parseJwt(jwt) {
        try {
          return {
            header: jwtDecode(jwt, { header: true }),
            payload: jwtDecode(jwt)
          };
        } catch (e) {
          throw new InvalidJwtError(jwt, e);
        }
      }
      get audiences() {
        if (this.payload.aud) {
          return Array.isArray(this.payload.aud) ? this.payload.aud : [this.payload.aud];
        } else {
          return null;
        }
      }
      get azp() {
        return this.payload.azp;
      }
      /**
       * @returns {string|null} clientId used to fetch the token
       */
      get clientId() {
        if (this.azp) {
          return this.azp;
        }
        if (this.audiences == null || this.audiences.length != 1) {
          return null;
        }
        return this.audiences[0] || this.payload.cid;
      }
      get email() {
        return this.payload.email;
      }
      /**
       * Returns whether the token is expired based on claim exp (expiration time).
       * There is a 1min leeway after the exp in which the token still counts as valid to account for clock skew.
       * @return {Boolean} false if token has a positive {@link remainingTime}, true otherwise
       */
      get expired() {
        return this.remainingTime <= 0;
      }
      get expirationDate() {
        return this.payload.exp ? new Date(this.payload.exp * 1e3) : null;
      }
      /**
       * @returns {string|null} family name of the user
       */
      get familyName() {
        return this.payload.ext_attr?.family_name || this.payload.family_name;
      }
      /**
       * @returns {string|null} first name of the user
       */
      get givenName() {
        return this.payload.ext_attr?.given_name || this.payload.given_name;
      }
      get grantType() {
        return this.payload.grant_type;
      }
      /** @return {JwtHeader} Token header as parsed object */
      get header() {
        return this.#header;
      }
      get issuer() {
        return this.payload.iss;
      }
      get issueDate() {
        return this.payload.iat ? new Date(this.payload.iat * 1e3) : null;
      }
      /** @return {String} JWT used to construct this Token instance as raw String */
      get jwt() {
        return this.#jwt;
      }
      /**
       * Returns whether the token is not yet valid based on the optional nbf (no use before) claim.
       * There is a 1min leeway before the nbf in which the token already counts as valid to account for clock skew.
       * @return {Boolean} true if token has nbf and nbf date lies in future, false otherwise 
       */
      get notYetValid() {
        return this.payload.nbf != null && Math.floor(Date.now() / 1e3) + TOKEN_DATE_LEEWAY < this.payload.nbf;
      }
      get origin() {
        return this.payload.origin;
      }
      /** @return {JwtPayload} Token payload as parsed object */
      get payload() {
        return this.#payload;
      }
      /**
       * Returns the remaining time until expiration in seconds based on claim exp (expiration time).
       * There is a 1min leeway after the exp in which the token still counts as valid to account for clock skew.
       * @returns seconds until expiration or 0 if expired
       */
      get remainingTime() {
        return Math.max(0, this.payload.exp + TOKEN_DATE_LEEWAY - Math.floor(Date.now() / 1e3));
      }
      get subject() {
        return this.payload.sub;
      }
      get userName() {
        return this.payload.user_name;
      }
      get userId() {
        return this.payload.user_uuid;
      }
      // Methods for backward-compatibility   
      getAudiencesArray() {
        return this.audiences;
      }
      getAzp() {
        return this.azp;
      }
      getClientId() {
        return this.clientId;
      }
      getEmail() {
        return this.email;
      }
      getExpirationDate() {
        return this.expirationDate;
      }
      getFamilyName() {
        return this.familyName;
      }
      getGivenName() {
        return this.givenName;
      }
      getGrantType() {
        return this.grantType;
      }
      getHeader() {
        return this.header;
      }
      getIssuedAt() {
        return this.issueDate;
      }
      getIssuer() {
        if (this.issuer && !this.issuer.startsWith("http")) {
          return `https://${this.issuer}`;
        } else {
          return this.issuer;
        }
      }
      getPayload() {
        return this.payload;
      }
      getSubject() {
        return this.subject;
      }
      getTokenValue() {
        return this.jwt;
      }
      getUserId() {
        return this.userId;
      }
    };
    module2.exports = Token;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/validation/MissingJwtError.js
var require_MissingJwtError3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/validation/MissingJwtError.js"(exports2, module2) {
    var ValidationError = require_ValidationError3();
    var MissingJwtError = class extends ValidationError {
      constructor(message = "Request contains no jwt bearer token and neither a jwt nor a decoded Token were contained in contextConfig of createSecurityContext.") {
        super(message);
        this.name = "MissingJwtError";
      }
    };
    module2.exports = MissingJwtError;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/context/SecurityContext.js
var require_SecurityContext3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/context/SecurityContext.js"(exports2, module2) {
    var { CORRELATIONID_HEADERS, FORWARDED_CLIENTCERTIFICATE_HEADER } = require_constants4();
    var SecurityContext = class {
      /** @type {S} */
      #service;
      /** @type {T} */
      #token;
      /** @type {SecurityContextConfig} */
      config;
      /**
       * @param {S} service - The service instance.
       * @param {T} token - The token instance.
       * @param {SecurityContextConfig} contextConfig - The security context configuration.
       */
      constructor(service, token, contextConfig) {
        this.#service = service;
        this.#token = token;
        this.config = contextConfig;
      }
      /**
       * The Service instance on which this SecurityContext has been created.
       * @returns {S} service
       */
      get service() {
        return this.#service;
      }
      /**
       * @param {S} service
       */
      set service(service) {
        this.#service = service;
      }
      /**
       * The Token instance from which this SecurityContext has ben created.
       * @returns {T} token
       */
      get token() {
        return this.#token;
      }
      /**
       * @param {T} token
       */
      set token(token) {
        this.#token = token;
      }
      // Methods for backwards-compatibility   
      getAppToken() {
        return this.token.jwt;
      }
      getEmail() {
        return this.getUserInfo().email;
      }
      getExpirationDate() {
        return this.token.expirationDate;
      }
      getFamilyName() {
        return this.getUserInfo().familyName;
      }
      getGivenName() {
        return this.getUserInfo().givenName;
      }
      getGrantType() {
        return this.token.grantType;
      }
      getLogonName() {
        return this.getUserInfo().logonName;
      }
      getUserInfo() {
        return {
          email: this.token.email,
          familyName: this.token.familyName,
          givenName: this.token.givenName,
          logonName: this.token.payload.user_name
        };
      }
      getTokenInfo() {
        return this.token;
      }
      /**
       * Tries to fill up missing properties of the security context configuration from the req object in the configuration.
       * @param {SecurityContextConfig} contextConfig 
       */
      static buildContextConfig(contextConfig) {
        let { req } = contextConfig;
        for (let i = 0; contextConfig.correlationId == null && i < CORRELATIONID_HEADERS.length; i++) {
          contextConfig.correlationId = req?.headers?.[CORRELATIONID_HEADERS[i]];
        }
        contextConfig.clientCertificatePem ??= req?.headers?.[FORWARDED_CLIENTCERTIFICATE_HEADER];
        contextConfig.jwt ??= req?.headers?.authorization?.split(" ")[1];
        contextConfig.skipValidation ??= false;
        contextConfig.tokenDecodeCache ??= null;
      }
    };
    module2.exports = SecurityContext;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/configuration/ConfigurationError.js
var require_ConfigurationError3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/configuration/ConfigurationError.js"(exports2, module2) {
    var XssecError = require_XssecError3();
    var ConfigurationError = class extends XssecError {
      constructor(message) {
        super(message);
        this.name = "ConfigurationError";
        this.statusCode = 500;
      }
    };
    module2.exports = ConfigurationError;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/validation/TokenValidationError.js
var require_TokenValidationError3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/validation/TokenValidationError.js"(exports2, module2) {
    var debug = require_src();
    var debugLog = debug("xssec");
    var ValidationError = require_ValidationError3();
    var TokenValidationError = class extends ValidationError {
      /** @type {Token} */
      #token;
      constructor(token, message = "Token is not valid.") {
        super(message);
        this.name = "TokenValidationError";
        this.token = token;
        if (debugLog.enabled) {
          this.jwt = token.jwt;
        }
      }
      get token() {
        return this.#token;
      }
      set token(value) {
        this.#token = value;
      }
    };
    module2.exports = TokenValidationError;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/validation/ExpiredTokenError.js
var require_ExpiredTokenError3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/validation/ExpiredTokenError.js"(exports2, module2) {
    var TokenValidationError = require_TokenValidationError3();
    var ExpiredTokenError = class extends TokenValidationError {
      constructor(token, message = "Token is expired.") {
        super(token, message);
        this.name = "ExpiredTokenError";
      }
    };
    module2.exports = ExpiredTokenError;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/validation/InvalidClientCertificateError.js
var require_InvalidClientCertificateError3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/validation/InvalidClientCertificateError.js"(exports2, module2) {
    var ValidationError = require_ValidationError3();
    var InvalidClientCertificateError = class extends ValidationError {
      /** @type {Error} Error encountered during parsing */
      #parseError;
      constructor(clientCertificate, parseError, message = `The forwarded client certificate could not be parsed as X509 certificate: ${parseError.message}`) {
        super(message);
        this.name = "InvalidClientCertificateError";
        this.clientCertificate = clientCertificate;
        this.parseError = parseError;
      }
      get parseError() {
        return this.#parseError;
      }
      set parseError(value) {
        this.#parseError = value;
      }
    };
    module2.exports = InvalidClientCertificateError;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/configuration/InvalidCredentialsError.js
var require_InvalidCredentialsError3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/configuration/InvalidCredentialsError.js"(exports2, module2) {
    var ConfigurationError = require_ConfigurationError3();
    var InvalidCredentialsError = class extends ConfigurationError {
      constructor(message = "The service credentials are missing mandatory properties.") {
        super(message);
        this.name = "InvalidCredentialsError";
      }
    };
    module2.exports = InvalidCredentialsError;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/validation/InvalidIssuerError.js
var require_InvalidIssuerError3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/validation/InvalidIssuerError.js"(exports2, module2) {
    var TokenValidationError = require_TokenValidationError3();
    var InvalidIssuerError = class extends TokenValidationError {
      /** @type {Error} Error encountered during parsing */
      #parseError;
      constructor(token, parseError, message = `Issuer ${token.issuer} was not a valid domain or URL for use with https. Protocol schemes other than https:// are not supported.`) {
        super(token, message);
        this.name = "InvalidIssuerError";
        this.#parseError = parseError;
      }
      get parseError() {
        return this.#parseError;
      }
      set parseError(value) {
        this.#parseError = value;
      }
    };
    module2.exports = InvalidIssuerError;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/validation/InvalidTokenSignatureError.js
var require_InvalidTokenSignatureError3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/validation/InvalidTokenSignatureError.js"(exports2, module2) {
    var TokenValidationError = require_TokenValidationError3();
    var InvalidTokenSignatureError = class extends TokenValidationError {
      constructor(token, message = "Token signature is invalid.") {
        super(token, message);
        this.name = "InvalidTokenSignatureError";
      }
    };
    module2.exports = InvalidTokenSignatureError;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/validation/MissingClientCertificateError.js
var require_MissingClientCertificateError3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/validation/MissingClientCertificateError.js"(exports2, module2) {
    var ValidationError = require_ValidationError3();
    var MissingClientCertificateError = class extends ValidationError {
      constructor(message = "Request is missing a forwarded client certificate which is required to validate the token.") {
        super(message);
        this.name = "MissingClientCertificateError";
      }
    };
    module2.exports = MissingClientCertificateError;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/validation/MissingIssuerError.js
var require_MissingIssuerError3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/validation/MissingIssuerError.js"(exports2, module2) {
    var TokenValidationError = require_TokenValidationError3();
    var MissingIssuerError = class extends TokenValidationError {
      constructor(token, message = "Token is missing an issuer which is required to validate the signature.") {
        super(token, message);
        this.name = "MissingIssuerError";
      }
    };
    module2.exports = MissingIssuerError;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/validation/MissingKidError.js
var require_MissingKidError3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/validation/MissingKidError.js"(exports2, module2) {
    var ValidationError = require_ValidationError3();
    var MissingKidError = class extends ValidationError {
      /** @type {string} */
      #kid;
      constructor(kid, message = `JWKS is missing key for kid=${kid} specified in token header.`) {
        super(message);
        this.name = "MissingKidError";
        this.#kid = kid;
      }
      get kid() {
        return this.#kid;
      }
      set kid(value) {
        this.#kid = value;
      }
    };
    module2.exports = MissingKidError;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/validation/MissingVerificationKeyError.js
var require_MissingVerificationKeyError3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/validation/MissingVerificationKeyError.js"(exports2, module2) {
    var ValidationError = require_ValidationError3();
    var MissingVerificationKeyError = class extends ValidationError {
      constructor(message = "XSUAA service credentials are missing a verificationkey that would be required as JWKS fallback to validate the given token.") {
        super(message);
        this.name = "MissingVerificationKeyError";
      }
    };
    module2.exports = MissingVerificationKeyError;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/network/NetworkError.js
var require_NetworkError3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/network/NetworkError.js"(exports2, module2) {
    var XssecError = require_XssecError3();
    var NetworkError = class extends XssecError {
      /** @type {String} */
      #correlationId;
      constructor(message = "A network error has occured.") {
        super(message);
        this.name = "NetworkError";
        this.statusCode = 500;
      }
      get correlationId() {
        return this.#correlationId;
      }
      set correlationId(value) {
        this.#correlationId = value;
      }
    };
    module2.exports = NetworkError;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/validation/NotYetValidTokenError.js
var require_NotYetValidTokenError3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/validation/NotYetValidTokenError.js"(exports2, module2) {
    var TokenValidationError = require_TokenValidationError3();
    var NotYetValidTokenError = class extends TokenValidationError {
      constructor(token, message = "The token is not yet valid because its 'nbf' (no use before) date lies in the future.") {
        super(token, message);
        this.name = "NotYetValidTokenError";
      }
    };
    module2.exports = NotYetValidTokenError;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/network/RequestError.js
var require_RequestError3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/network/RequestError.js"(exports2, module2) {
    var NetworkError = require_NetworkError3();
    var RequestError = class extends NetworkError {
      /** @type {import("https").RequestOptions & {name: string}} */
      #request;
      /** @type {Error|Error[]} the original error(s) of the HTTP client for debugging. Do not code against this property as the internal HTTP client implementation may change anytime. */
      #originalError;
      #url;
      constructor(url, request, originalError, message = `HTTP request [${request.name}] to ${url} could not be sent due to: ${originalError.toString()}.`) {
        super(message);
        this.name = "RequestError";
        this.url = url;
        this.request = request;
        this.originalError = originalError;
      }
      get url() {
        return this.#url;
      }
      set url(value) {
        this.#url = value;
      }
      get request() {
        return this.#request;
      }
      set request(value) {
        this.#request = value;
      }
      get originalError() {
        return this.#originalError;
      }
      set originalError(error) {
        this.#originalError = error;
      }
    };
    module2.exports = RequestError;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/network/ResponseError.js
var require_ResponseError3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/network/ResponseError.js"(exports2, module2) {
    var NetworkError = require_NetworkError3();
    var ResponseError = class extends NetworkError {
      #url;
      #request;
      #responseCode;
      #responseText;
      constructor(url, request, responseCode, responseText, message = `HTTP response from ${url} was ${responseCode}: ${responseText}.`) {
        super(message);
        this.name = "ResponseError";
        this.url = url;
        this.request = request;
        this.responseCode = responseCode;
        this.responseText = responseText;
      }
      get url() {
        return this.#url;
      }
      set url(value) {
        this.#url = value;
      }
      get request() {
        return this.#request;
      }
      set request(value) {
        this.#request = value;
      }
      get responseCode() {
        return this.#responseCode;
      }
      set responseCode(value) {
        this.#responseCode = value;
      }
      get responseText() {
        return this.#responseText;
      }
      set responseText(value) {
        this.#responseText = value;
      }
    };
    module2.exports = ResponseError;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/network/TimeoutError.js
var require_TimeoutError3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/network/TimeoutError.js"(exports2, module2) {
    var RequestError = require_RequestError3();
    var TimeoutError = class extends RequestError {
      constructor(url, request, originalError, message = `HTTP request [${request.name}] to ${url} timed out after ${request.timeout} ms.`) {
        super(url, request, originalError, message);
        this.name = "TimeoutError";
      }
    };
    module2.exports = TimeoutError;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/validation/UnsupportedAlgorithmError.js
var require_UnsupportedAlgorithmError3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/validation/UnsupportedAlgorithmError.js"(exports2, module2) {
    var TokenValidationError = require_TokenValidationError3();
    var UnsupportedAlgorithmError = class extends TokenValidationError {
      #alg;
      constructor(token, alg, message = `Algorithm ${alg} specified in token header is not supported.`) {
        super(token, message);
        this.name = "UnsupportedAlgorithmError";
        this.alg = alg;
      }
      get alg() {
        return this.#alg;
      }
      set alg(value) {
        this.#alg = value;
      }
    };
    module2.exports = UnsupportedAlgorithmError;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/validation/UntrustedIssuerError.js
var require_UntrustedIssuerError3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/validation/UntrustedIssuerError.js"(exports2, module2) {
    var TokenValidationError = require_TokenValidationError3();
    var UntrustedIssuerError = class extends TokenValidationError {
      constructor(token, message = "Token issuer is not trusted because it is not a (sub)domain contained in the domains property of the service credentials.") {
        super(token, message);
        this.name = "UntrustedIssuerError";
      }
    };
    module2.exports = UntrustedIssuerError;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/validation/WrongAudienceError.js
var require_WrongAudienceError3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/validation/WrongAudienceError.js"(exports2, module2) {
    var TokenValidationError = require_TokenValidationError3();
    var WrongAudienceError = class extends TokenValidationError {
      /** @type {string[]} token audiences */
      audiences;
      /** @type {Service|Service[]} service(s) on which context creation was attempted */
      #service;
      constructor(token, service, message = "Token was issued for a different audience than this service.") {
        super(token, message);
        this.name = "WrongAudienceError";
        this.service = service;
        this.audiences = token.audiences;
      }
      get service() {
        return this.#service;
      }
      set service(value) {
        this.#service = value;
      }
    };
    module2.exports = WrongAudienceError;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/validation/X5tError.js
var require_X5tError3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/validation/X5tError.js"(exports2, module2) {
    var TokenValidationError = require_TokenValidationError3();
    var X5tError = class extends TokenValidationError {
      /** @type {String} client certificate used for x5t validation */
      clientCertificate;
      constructor(token, clientCertificate, message = "X5t validation of token failed.") {
        super(token, message);
        this.name = "X5tError";
        this.clientCertificate = clientCertificate;
      }
      /** For backward-compatibility because property was renamed. */
      get cert() {
        return this.clientCertificate;
      }
    };
    module2.exports = X5tError;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/index.js
var require_error3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/index.js"(exports2, module2) {
    var ConfigurationError = require_ConfigurationError3();
    var ExpiredTokenError = require_ExpiredTokenError3();
    var InvalidClientCertificateError = require_InvalidClientCertificateError3();
    var InvalidCredentialsError = require_InvalidCredentialsError3();
    var InvalidIssuerError = require_InvalidIssuerError3();
    var InvalidJwtError = require_InvalidJwtError3();
    var InvalidTokenSignatureError = require_InvalidTokenSignatureError3();
    var MissingClientCertificateError = require_MissingClientCertificateError3();
    var MissingIssuerError = require_MissingIssuerError3();
    var MissingJwtError = require_MissingJwtError3();
    var MissingKidError = require_MissingKidError3();
    var MissingVerificationKeyError = require_MissingVerificationKeyError3();
    var NetworkError = require_NetworkError3();
    var NotYetValidTokenError = require_NotYetValidTokenError3();
    var RequestError = require_RequestError3();
    var ResponseError = require_ResponseError3();
    var TimeoutError = require_TimeoutError3();
    var TokenValidationError = require_TokenValidationError3();
    var UnsupportedAlgorithmError = require_UnsupportedAlgorithmError3();
    var UntrustedIssuerError = require_UntrustedIssuerError3();
    var ValidationError = require_ValidationError3();
    var WrongAudienceError = require_WrongAudienceError3();
    var X5tError = require_X5tError3();
    var XssecError = require_XssecError3();
    module2.exports = {
      ConfigurationError,
      ExpiredTokenError,
      InvalidClientCertificateError,
      InvalidCredentialsError,
      InvalidIssuerError,
      InvalidJwtError,
      InvalidTokenSignatureError,
      MissingClientCertificateError,
      MissingIssuerError,
      MissingJwtError,
      MissingKidError,
      MissingVerificationKeyError,
      NetworkError,
      NotYetValidTokenError,
      RequestError,
      ResponseError,
      TimeoutError,
      TokenValidationError,
      UnsupportedAlgorithmError,
      UntrustedIssuerError,
      ValidationError,
      WrongAudienceError,
      X5tError,
      XssecError
    };
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/util/Logger.js
var require_Logger3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/util/Logger.js"(exports2, module2) {
    var Logger = class {
      constructor(loggingConfig, prefix) {
        this.loggingConfig = loggingConfig;
        this.prefix = prefix;
      }
      info(message, args) {
        message = `[${this.prefix}] ${message}`;
        if (args != null) {
          this.loggingConfig.info(message, args);
        } else {
          this.loggingConfig.info(message);
        }
      }
      warn(message, args) {
        message = `[${this.prefix}] ${message}`;
        if (args != null) {
          this.loggingConfig.warn(message, args);
        } else {
          this.loggingConfig.warn(message);
        }
      }
      error(message, args) {
        message = `[${this.prefix}] ${message}`;
        if (args != null) {
          this.loggingConfig.error(message, args);
        } else {
          this.loggingConfig.error(message);
        }
      }
      debug(message, args) {
        message = `[${this.prefix}] ${message}`;
        if (args != null) {
          this.loggingConfig.debug(message, args);
        } else {
          this.loggingConfig.debug(message);
        }
      }
    };
    module2.exports = Logger;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/util/logging.js
var require_logging3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/util/logging.js"(exports2, module2) {
    var debug = require_src();
    var Logger = require_Logger3();
    var debugLogger = debug("xssec");
    debugLogger.log = console.log.bind(console);
    var loggingConfig = {
      info: (message, ...args) => debugLogger(message, ...args),
      warn: (message, ...args) => debugLogger(message, ...args),
      error: (message, ...args) => debugLogger(message, ...args),
      debug: (message, ...args) => debugLogger(message, ...args)
    };
    function getLogger(prefix = "") {
      return new Logger(loggingConfig, prefix);
    }
    function setLoggers(loggers) {
      Object.assign(loggingConfig, loggers);
    }
    module2.exports = {
      getLogger,
      setLoggers
    };
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/context/createSecurityContext.js
var require_createSecurityContext3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/context/createSecurityContext.js"(exports2, module2) {
    var Token = require_Token3();
    var MissingJwtError = require_MissingJwtError3();
    var SecurityContext = require_SecurityContext3();
    var { WrongAudienceError } = require_error3();
    var { getLogger } = require_logging3();
    var LOG = getLogger("createSecurityContext.js");
    module2.exports = createSecurityContext;
    async function createSecurityContext(services, contextConfig) {
      contextConfig = { ...contextConfig };
      SecurityContext.buildContextConfig(contextConfig);
      if (contextConfig.token == null && contextConfig.jwt == null) {
        throw new MissingJwtError();
      }
      const token = contextConfig.token ?? new Token(contextConfig.jwt);
      LOG.debug(`Creating security context from JWT: ${token.jwt}`, { correlationId: contextConfig.correlationId });
      let targetService = null;
      if (Array.isArray(services)) {
        if (services.length === 1) {
          targetService = services[0];
        } else {
          targetService = findServiceForToken(services, token);
          if (targetService != null) {
            LOG.debug(`Selected ${targetService.constructor.name} with clientid ${targetService.credentials.clientid} based on token audience.`, { correlationId: contextConfig.correlationId });
          }
        }
      } else {
        targetService = services;
      }
      if (targetService == null) {
        throw new WrongAudienceError(token, services, `The audiences of the token fit none of the supplied services.`);
      }
      return targetService.createSecurityContext(token, contextConfig);
    }
    function findServiceForToken(services, token) {
      return services.find((s) => s.acceptsTokenAudience(token));
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/context/IdentityServiceSecurityContext.js
var require_IdentityServiceSecurityContext3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/context/IdentityServiceSecurityContext.js"(exports2, module2) {
    var ConfigurationError = require_ConfigurationError3();
    var SecurityContext = require_SecurityContext3();
    var IdentityServiceSecurityContext = class extends SecurityContext {
      /**
       * @param {IdentityService|null} service
       * @param {IdentityServiceToken} token 
       * @param {SecurityContextConfig} [contextConfig] 
       */
      constructor(service, token, contextConfig) {
        super(service, token, contextConfig);
      }
      /**
       * Returns the service plans of the consumer application.
       * This method is only available if the context was created from an app2service token and a service with proof token validation enabled.
       * @returns {string[]}
       */
      get servicePlans() {
        if (!this.service.hasProofTokenEnabled()) {
          throw new ConfigurationError("This property is only available on IdentityServiceSecurityContexts created on an IdentityService with proofToken validation enabled.");
        }
        return this.config.servicePlans;
      }
      /**
       * Checks whether the token from which this context was created is a token fetched by the OAuth 2.0 client for internal use.
       * This method requires the IdentityService instance to have x5t validation enabled.
       * @returns {boolean} true if the token was fetched via client credentials flow with the credentials of this context's IdentityService instance, false otherwise.
       */
      isInternal() {
        if (!this.service.hasX5tEnabled()) {
          throw new ConfigurationError("This method is only available on IdentityServiceSecurityContexts created on an IdentityService instance with x5t validation enabled.");
        }
        return this.token.azp === this.service.credentials.clientid && this.token.subject === this.service.credentials.clientid && this.token.appTid === this.service.credentials.app_tid;
      }
      // Methods for backward-compatibility
      getUserInfo() {
        return {
          ...super.getUserInfo(),
          logonName: this.token.payload.user_name || this.token.email || this.token.payload.user_uuid || ""
        };
      }
    };
    module2.exports = IdentityServiceSecurityContext;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/context/XsuaaSecurityContext.js
var require_XsuaaSecurityContext3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/context/XsuaaSecurityContext.js"(exports2, module2) {
    var SecurityContext = require_SecurityContext3();
    var { getLogger } = require_logging3();
    var { GRANTTYPE_CLIENTCREDENTIALS } = require_constants4();
    var LOG = getLogger("XsuaaSecurityContext.js");
    var XsuaaSecurityContext = class extends SecurityContext {
      /**
       * @param {XsuaaService|null} service
       * @param {XsuaaToken} token 
       * @param {SecurityContextConfig} [contextConfig] 
       */
      constructor(service, token, contextConfig) {
        super(service, token, contextConfig);
      }
      /**
       * Checks if the token of this context was issued for the given scope.
       * @param {String} scope 
       * @returns {Boolean}
       */
      checkScope(scope) {
        return this.token.scopes.includes(scope);
      }
      /**
       * Checks if the token of this context was issued for the given scope, ignoring the xsappname prefix of the service that was used to create this context when copmaring with the token's scopes.
       * @param {String} scope 
       * @returns {Boolean}
       */
      checkLocalScope(scope) {
        return this.token.scopes.includes(`${this.service.credentials.xsappname}.${scope}`);
      }
      checkFollowingInstanceScope(scope) {
        const clientId = this.token.payload.client_id;
        if (!clientId?.startsWith("sb-")) {
          return false;
        }
        const appId = clientId.substring(3);
        if (!appId.includes("|")) {
          return false;
        }
        return this.checkScope(`${appId}.${scope}`);
      }
      // Methods for backward-compatibility
      getAttributes() {
        const attributes = this.token.xsUserAttributes ?? {};
        return Object.keys(attributes).length !== 0 ? attributes : null;
      }
      getAttribute(name) {
        return this.token.getXsUserAttribute(name) || null;
      }
      getAdditionalAuthAttribute(name) {
        const additionalAuthAttributes = this.getAdditionalAuthAttributes();
        if (!additionalAuthAttributes) {
          LOG.debug("\nThe access token contains no additional authentication attributes.\n");
          return null;
        }
        if (!name) {
          LOG.debug("\nInvalid attribute name (may not be null, empty, or undefined).");
          return null;
        }
        if (!additionalAuthAttributes[name]) {
          LOG.debug('\nNo attribute "' + name + '" found as additional authentication attribute.');
          return null;
        }
        return additionalAuthAttributes[name];
      }
      getAdditionalAuthAttributes() {
        return this.token.azAttributes || null;
      }
      /**
       * @deprecated Use token.zid instead 
       */
      getAppTID() {
        return this.token.zid;
      }
      getClientId() {
        return this.token.getClientId();
      }
      getCloneServiceInstanceId() {
        return this.token.extAttributes?.serviceinstanceid || null;
      }
      getEmail() {
        return this.#ifNotClientCredentialsToken("XsuaaSecurityContext.getEmail", this.getUserInfo().email);
      }
      getFamilyName() {
        return this.#ifNotClientCredentialsToken("XsuaaSecurityContext.getFamilyName", this.getUserInfo().familyName);
      }
      getGivenName() {
        return this.#ifNotClientCredentialsToken("XsuaaSecurityContext.getGivenName", this.getUserInfo().givenName);
      }
      getLogonName() {
        return this.#ifNotClientCredentialsToken("XsuaaSecurityContext.getLogonName", this.getUserInfo().logonName);
      }
      getOrigin() {
        return this.token.origin;
      }
      getSubaccountId() {
        return this.token.subAccountId;
      }
      getSubdomain() {
        return this.token.extAttributes?.zdn ?? null;
      }
      getUniquePrincipalName(origin, logonName) {
        if (!this.#ifNotClientCredentialsToken("XsuaaSecurityContext.getUniquePrincipalName", true)) {
          return null;
        }
        if (!origin) {
          LOG.debug("Origin claim not set in JWT. Cannot create unique user name. Returning null.");
          return null;
        }
        if (!logonName) {
          LOG.debug("User login name claim not set in JWT. Cannot create unique user name. Returning null.");
          return null;
        }
        if (origin.includes("/")) {
          LOG.debug("Illegal '/' character detected in origin claim of JWT. Cannot create unique user name. Retuning null.");
          return null;
        }
        return `user/${origin}/${logonName}`;
      }
      getUserName() {
        if (this.token.grantType === GRANTTYPE_CLIENTCREDENTIALS) {
          return `client/${this.getClientId()}`;
        } else {
          return this.getUniquePrincipalName(this.token.origin, this.getLogonName());
        }
      }
      /**
       * @deprecated Use token.zid instead 
       */
      getZoneId() {
        return this.token.zid;
      }
      hasAttributes() {
        return this.#ifNotClientCredentialsToken("XsuaaSecurityContext.hasAttributes", this.token.xsUserAttributes != null);
      }
      isInForeignMode() {
        return this.service.credentials.clientid.includes("!b") && this.token.audiences.some((aud) => aud.includes(`|${this.service.credentials.clientid}`));
      }
      #ifNotClientCredentialsToken(functionName, value) {
        if (this.token.grantType === GRANTTYPE_CLIENTCREDENTIALS) {
          LOG.debug(`Call to ${functionName} not allowed with a token of grant type ${GRANTTYPE_CLIENTCREDENTIALS}.`);
          return null;
        }
        return value;
      }
    };
    module2.exports = XsuaaSecurityContext;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/context/XsaSecurityContext.js
var require_XsaSecurityContext3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/context/XsaSecurityContext.js"(exports2, module2) {
    var XsuaaSecurityContext = require_XsuaaSecurityContext3();
    var XsaSecurityContext = class extends XsuaaSecurityContext {
      /**
       * 
       * @param {XsaService|null} service 
       * @param {XsaToken} token 
       * @param {SecurityContextConfig} [contextConfig]
       */
      constructor(service, token, contextConfig) {
        super(service, token, contextConfig);
      }
      /**
       * The Service instance on which this SecurityContext has been created.
       * @returns {XsaService} service
       */
      get service() {
        return super.service;
      }
      /**
       * @param {XsaService} service
       */
      set service(service) {
        super.service = service;
      }
      /**
       * The Token instance from which this SecurityContext has ben created.
       * @returns {XsaToken} token
       */
      get token() {
        return super.token;
      }
      /**
       * @param {XsaToken} token
       */
      set token(token) {
        super.token = token;
      }
    };
    module2.exports = XsaSecurityContext;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/context/UaaSecurityContext.js
var require_UaaSecurityContext3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/context/UaaSecurityContext.js"(exports2, module2) {
    var XsuaaSecurityContext = require_XsuaaSecurityContext3();
    var UaaSecurityContext = class extends XsuaaSecurityContext {
      /**
       * @param {UaaService|null} service
       * @param {UaaToken} token 
       * @param {SecurityContextConfig} [contextConfig] 
       */
      constructor(service, token, contextConfig) {
        super(service, token, contextConfig);
      }
      /**
       * The Service instance on which this SecurityContext has been created.
       * @returns {UaaService} service
       */
      get service() {
        return super.service;
      }
      /**
       * @param {UaaService} service
       */
      set service(service) {
        super.service = service;
      }
      /**
       * The Token instance from which this SecurityContext has ben created.
       * @returns {UaaToken} token
       */
      get token() {
        return super.token;
      }
      /**
       * @param {UaaToken} token
       */
      set token(token) {
        super.token = token;
      }
    };
    module2.exports = UaaSecurityContext;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/cache/ResponseReplica.js
var require_ResponseReplica3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/cache/ResponseReplica.js"(exports2, module2) {
    var ResponseReplica = class {
      cache;
      // cache containing this replica
      key;
      // cache key of this replica
      request;
      // callback for fetching response data
      data;
      // last response data
      lastRefresh;
      // UNIX timestamp of last refresh
      expirationTime;
      // time in milliseconds that needs to pass after creation for the replica to count as expired
      pendingRequest;
      // promise for ongoing update of response or undefined
      constructor(cache, key, request) {
        Object.assign(this, { cache, key, request });
        this.data = null;
        this.expirationTime = cache.expirationTime;
      }
      /**
       * Returns the remaining time until expiration.
       * @returns time until expiration or 0 if no data available or data expired
       */
      get remainingTime() {
        if (!this.hasData || this.lastRefresh == null) {
          return 0;
        }
        const elapsedTime = Date.now() - this.lastRefresh;
        return Math.max(0, this.expirationTime - elapsedTime);
      }
      /** Returns whether the replica already has response data. **/
      hasData() {
        return this.data != null;
      }
      /** Returns whether the replica is expired. **/
      isExpired() {
        return this.remainingTime <= 0;
      }
      /**
       * Returns if the replica is considered stale given the refresh period. Stale replicas should be refreshed but may still be used before expiration.
       * @param refreshPeriod time period (in ms) before expiration time in which the replica should count as stale (but not yet as expired)
       * @returns true if the replica is already expired or will expire within the given refresh period.
       */
      isStale(refreshPeriod) {
        return this.expired || this.remainingTime <= refreshPeriod;
      }
      /**
       * Triggers a refresh of this replica. Multiple calls will still result in only one refresh at a time.
       * @param {string} correlationId 
       */
      refresh(correlationId) {
        this.pendingRequest ??= this.#fetchResponse(correlationId);
        return this.pendingRequest;
      }
      /** Fetches new data from the request. */
      async #fetchResponse(correlationId) {
        try {
          this.data = await this.request(correlationId);
        } finally {
          this.pendingRequest = null;
        }
        this.lastRefresh = Date.now();
      }
    };
    module2.exports = ResponseReplica;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/cache/ResponseCache.js
var require_ResponseCache3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/cache/ResponseCache.js"(exports2, module2) {
    var ResponseReplica = require_ResponseReplica3();
    var ConfigurationError = require_ConfigurationError3();
    var { getLogger } = require_logging3();
    var LOG = getLogger("ResponseCache.js");
    var ResponseCache = class _ResponseCache {
      static get DEFAULT_EXPIRATION_TIME() {
        return 30 * 60 * 1e3;
      }
      // 30 minutes
      static get DEFAULT_REFRESH_PERIOD() {
        return 15 * 60 * 1e3;
      }
      // 15 minutes
      /** @type {Map<string,ResponseReplica>} */
      cache;
      // map that stores response replicas by their key
      endpointName;
      // name of cached endpoint for logging purposes, e.g. "JWKS", ".well-known" etc.
      expirationTime;
      // expiration time that will be used for new cache entries
      refreshPeriod;
      // time before expiration in which a response is considered stale
      constructor({
        expirationTime = _ResponseCache.DEFAULT_EXPIRATION_TIME,
        refreshPeriod = _ResponseCache.DEFAULT_REFRESH_PERIOD,
        endpointName = "response"
      } = {}) {
        if (expirationTime < 0) {
          throw new ConfigurationError("ResponseCache expirationTime must be >=0.");
        }
        if (refreshPeriod < 0 || refreshPeriod > expirationTime) {
          throw new ConfigurationError("ResponseCache refreshPeriod must be between 0 and <expirationTime>.");
        }
        this.cache = /* @__PURE__ */ new Map();
        this.endpointName = endpointName;
        this.expirationTime = expirationTime;
        this.refreshPeriod = refreshPeriod;
      }
      /**
       * Returns an up-to-date response associated with the given key. If there is no replica yet for the key, caches a new replica under this key that
       * uses the given request callback to fetch its responses.
       * @param key cache key of response
       * @param buildRequest callback that constructs a request function for fetching new responses if no replica exists yet for the key. The request function
       *  has to throw an Error with a statusCode and statusText if it fails to fetch the data.
       */
      async getOrRequest(key, buildRequest, { correlationId }) {
        const replica = this.cache.get(key) || this.#createReplica(key, buildRequest());
        if (!replica.hasData() || replica.isExpired()) {
          LOG.debug(`Awaiting ${this.endpointName} refresh because replica for key=${key} has ${replica.hasData() ? "expired" : "no"} data.)`, { correlationId });
          await replica.refresh(correlationId);
        } else if (replica.isStale(this.refreshPeriod)) {
          LOG.debug(`Asynchronous ${this.endpointName} refresh scheduled because replica for key=${key} is stale (remaining time = ${replica.remainingTime}ms < ${replica.refreshPeriod}ms = refresh period).`);
          replica.refresh(correlationId).catch(() => {
          });
        }
        return replica.data;
      }
      #createReplica(key, request) {
        const replica = new ResponseReplica(this, key, request);
        this.cache.set(key, replica);
        return replica;
      }
    };
    module2.exports = ResponseCache;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/util/fetch.js
var require_fetch3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/util/fetch.js"(exports2, module2) {
    var https = require("https");
    var http = require("http");
    var zlib = require("zlib");
    var url = require("url");
    function selectRequestModule(protocol) {
      switch (protocol) {
        case "https:":
          return https;
        case "http:":
          return http;
        default:
          throw new Error(`Unsupported protocol: ${protocol}`);
      }
    }
    var FetchError = class extends Error {
      constructor(message, error) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.code = this.errno = error?.code;
        this.erroredSysCall = error?.syscall;
      }
      get name() {
        return this.constructor.name;
      }
    };
    var Response2 = class {
      #response;
      #request;
      constructor(response, request) {
        this.#response = response;
        this.#request = request;
      }
      async #getZip() {
        const response = this.#response;
        return new Promise((resolve, reject) => {
          const gunzip = zlib.createGunzip();
          response.pipe(gunzip);
          const data = [];
          gunzip.on("data", function(chunk) {
            data.push(chunk.toString());
          });
          gunzip.on("end", function() {
            resolve(data.join(""));
          });
          gunzip.on("error", (error) => {
            reject(new FetchError(`request to ${this.requestUrl} failed, reason: ${error.message}`, error));
          });
        });
      }
      get requestUrl() {
        const req = this.#request;
        return req.protocol + "//" + req.host + req.path;
      }
      async #getText() {
        const response = this.#response;
        if (response.headers["content-encoding"] === "gzip") {
          return this.#getZip();
        }
        return new Promise((resolve, reject) => {
          const data = [];
          response.setEncoding("utf8");
          response.on("data", function(chunk) {
            data.push(chunk);
          });
          response.on("end", function() {
            resolve(data.join(""));
          });
          response.on("error", (error) => {
            reject(new FetchError(`request to ${this.requestUrl} failed, reason: ${error.message}`, error));
          });
        });
      }
      async json() {
        return JSON.parse(await this.#getText());
      }
      async text() {
        return this.#getText();
      }
      get ok() {
        return this.status >= 200 && this.status < 300;
      }
      get status() {
        return this.#response.statusCode;
      }
      get headers() {
        const headers = /* @__PURE__ */ new Map();
        for (const [key, value] of Object.entries(this.#response.headers)) {
          headers.set(key, value);
        }
        return headers;
      }
    };
    async function xssec_fetch(inputUrl, options = {}) {
      importDefaultOptions(options);
      importDefaultHeaders(options);
      importBodyOptions(options);
      const requestModule = selectRequestModule(new url.URL(inputUrl).protocol);
      return new Promise(function(resolve, reject) {
        const req = requestModule.request(inputUrl, options, (response) => {
          resolve(new Response2(response, req));
        });
        req.on("error", (error) => {
          reject(new FetchError(`request to ${url} failed, reason: ${error.message}`, error));
        });
        req.on("timeout", () => {
          req.destroy();
          reject(new FetchError(`request to ${url} timed out.`, { code: "ETIMEDOUT" }));
        });
        if (options.data) {
          req.write(options.data);
        }
        req.end();
      });
    }
    function importDefaultOptions(options) {
      options.method ??= "GET";
    }
    function importBodyOptions(options) {
      if (options.body) {
        const method = options.method.toUpperCase();
        if (method !== "GET" && method !== "HEAD") {
          if (options.json) {
            options.data = JSON.stringify(options.body);
            options.headers["Content-Type"] = "application/json;charset=UTF-8";
          } else {
            options.data = options.body.toString();
            options.headers["Content-Type"] = "application/x-www-form-urlencoded;charset=UTF-8";
          }
          options.headers["Content-Length"] = Buffer.byteLength(options.data);
          delete options.body;
        } else {
          throw new Error("Request with GET/HEAD method cannot have body");
        }
      }
    }
    function importDefaultHeaders(options) {
      if (options.headers == null) {
        options.headers = {};
      }
      options.headers["Accept-Encoding"] = "gzip,deflate";
      if (!options.headers["Accept"] && !options.headers["accept"]) {
        options.headers["Accept"] = "*/*";
      }
    }
    module2.exports = xssec_fetch;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/network/RetryError.js
var require_RetryError3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/error/network/RetryError.js"(exports2, module2) {
    var RequestError = require_RequestError3();
    var RetryError = class extends RequestError {
      constructor(url, request, originalError, message = `HTTP request [${request.name}] to ${url} was not successful after ${originalError.length} attempts.`) {
        super(url, request, originalError, message);
        this.name = "RetryError";
      }
      get retryErrors() {
        return this.originalError;
      }
    };
    module2.exports = RetryError;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/util/util.js
var require_util5 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/util/util.js"(exports2, module2) {
    var { X509Certificate } = require("crypto");
    var InvalidClientCertificateError = require_InvalidClientCertificateError3();
    var { PEM_HEADER, PEM_FOOTER, CLIENT_CERTIFICATE_HEADER } = require_constants4();
    module2.exports = {
      /**
       * Escapes Regex special characters in the given string, so that the string can be used for a literal match inside a Regex.
       * Regex.escape is only a proposal at the time of writing.
       * The source of this code is https://github.com/tc39/proposal-regex-escaping/blob/main/polyfill.js 
       */
      escapeStringForRegex(s) {
        return String(s).replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
      },
      /**
       * Creates a string cache key from the given key-value pairs, ignoring keys with null or undefined values.
       * @param {object} parts
       * @returns a cache key in string format, e.g. app_tid:foo:client_id:bar:azp:baz
       */
      createCacheKey(parts = {}) {
        return Object.entries(parts).filter(([value]) => value != null).map(([key, value]) => `${key}=${value}`).join("|");
      },
      parsePemCertificate(pem) {
        pem = pem.replaceAll("\\n", "\n");
        if (!pem.startsWith(PEM_HEADER)) pem = `${PEM_HEADER}
${pem}`;
        if (!pem.endsWith(PEM_FOOTER)) pem = `${pem}
${PEM_FOOTER}`;
        try {
          return new X509Certificate(pem);
        } catch (error) {
          throw new InvalidClientCertificateError(pem, error);
        }
      },
      shrinkRequestOptionsForLog(request) {
        const maskedRequest = { ...request };
        maskedRequest.headers = { ...request.headers };
        if (maskedRequest.agent) {
          maskedRequest.agent = "<agent>";
        }
        if (maskedRequest.headers?.[CLIENT_CERTIFICATE_HEADER]) {
          maskedRequest.headers[CLIENT_CERTIFICATE_HEADER] = "<clientCertificatePem>";
        }
        return maskedRequest;
      }
    };
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/util/jsonRequest.js
var require_jsonRequest3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/util/jsonRequest.js"(exports2, module2) {
    var fetch2 = require_fetch3();
    var { getLogger } = require_logging3();
    var RequestError = require_RequestError3();
    var RetryError = require_RetryError3();
    var ResponseError = require_ResponseError3();
    var TimeoutError = require_TimeoutError3();
    var { CORRELATIONID_HEADER_VCAP, DEFAULT_TIMEOUT, MAX_TIMEOUT, USER_AGENT } = require_constants4();
    var { shrinkRequestOptionsForLog } = require_util5();
    var LOG = getLogger("request.js");
    var sleep = (ms) => new Promise((resolve) => {
      setTimeout(() => {
        resolve();
      }, ms);
    });
    function calculateDelay(attempt, retryConfig) {
      if (retryConfig.strategy === "exponential") {
        const delay = retryConfig.initialDelay * Math.pow(retryConfig.factor, attempt);
        return Math.min(delay, retryConfig.maxDelay);
      }
      return retryConfig.initialDelay;
    }
    function isRetryableError(e) {
      if (e instanceof ResponseError) {
        if (e.responseCode >= 500 && e.responseCode <= 600 || e.responseCode == 429 || e.responseCode == 408) {
          return true;
        }
      } else if (e instanceof RequestError) {
        return true;
      }
      return false;
    }
    async function fetchWithRetry(url, request, options) {
      const { requestName, correlationId } = options;
      const retryConfig = request.retry;
      const retryErrors = [];
      const requestWithName = { ...request, name: requestName };
      for (let attempt = 0; attempt <= retryConfig.retries; attempt++) {
        try {
          if (attempt > 0) {
            LOG.info(`Retry attempt ${attempt}/${retryConfig.retries} for [${requestName}] to ${url}`, { correlationId });
          }
          return await fetchWithoutRetry(url, request, options);
        } catch (e) {
          if (!isRetryableError(e)) {
            throw e;
          }
          retryErrors.push(e);
          if (attempt >= retryConfig.retries) {
            break;
          }
          const delay = calculateDelay(attempt, retryConfig);
          LOG.debug(`Waiting ${delay}ms before next retry`, { correlationId });
          await sleep(delay);
        }
      }
      const error = new RetryError(url, requestWithName, retryErrors);
      LOG.error(error.message, { correlationId });
      throw error;
    }
    async function fetchWithoutRetry(url, request, { requestName, correlationId, extractHeaders }) {
      if (correlationId) {
        request.headers[CORRELATIONID_HEADER_VCAP] = correlationId;
      }
      LOG.debug(`HTTP request [${requestName}] to ${url} with options`, { correlationId, ...shrinkRequestOptionsForLog(request) });
      let response;
      try {
        response = await fetch2(url, request);
      } catch (e) {
        const requestWithName = { ...request, name: requestName };
        const error = e.code === "ETIMEDOUT" ? new TimeoutError(url, requestWithName, e) : new RequestError(url, requestWithName, e);
        LOG.error(error.message, { correlationId });
        throw error;
      }
      if (!response.ok) {
        const responseText = await response.text();
        const error = new ResponseError(url, { ...request, name: requestName }, response.status, responseText);
        LOG.error(error.message, { correlationId });
        throw error;
      }
      const json2 = await response.json();
      LOG.debug(`HTTP response [${requestName}]:`, { correlationId, ...json2 });
      if (extractHeaders != null) {
        json2[extractHeaders] = response.headers;
      }
      return json2;
    }
    async function jsonRequest(url, request, options = {}) {
      Object.assign(request, {
        redirect: "error",
        follow: 0,
        timeout: Math.min(MAX_TIMEOUT, request.timeout ?? DEFAULT_TIMEOUT)
      });
      request.headers ??= {};
      Object.assign(request.headers, {
        Accept: "application/json",
        "User-Agent": USER_AGENT
      });
      if (request.retry) {
        return fetchWithRetry(url, request, options);
      } else {
        return fetchWithoutRetry(url, request, options);
      }
    }
    module2.exports = {
      jsonRequest
    };
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/service/Service.js
var require_Service3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/service/Service.js"(exports2, module2) {
    var { Agent } = require("node:https");
    var ResponseCache = require_ResponseCache3();
    var LRUCache = require_LRUCache3();
    var { ConfigurationError, ExpiredTokenError, InvalidCredentialsError, MissingKidError, NotYetValidTokenError, WrongAudienceError } = require_error3();
    var { jsonRequest } = require_jsonRequest3();
    var { createCacheKey } = require_util5();
    var { DEFAULT_JWT_BEARER_FETCH_TIMEOUT, DEFAULT_TIMEOUT, GRANTTYPE_CLIENTCREDENTIALS, GRANTTYPE_JWTBEARER, GRANTTYPE_PASSWORD, MAX_TIMEOUT } = require_constants4();
    var Service = class _Service {
      /** 
       * JWKS cache instances shared by Service subclasses indexed by their constructor name.
       * @type {Object.<string, ResponseCache>} 
       */
      static #sharedJwksCaches = {};
      /** 
       * Signature cache instances shared by Service subclasses indexed by their constructor name.
       * @type {Object.<string, LRUCache>} 
       */
      static #sharedSignatureCaches = {};
      /** @type {ResponseCache} */
      static #oidcCache = null;
      /** @type {import("../util/Types").ExponentialBackoffRetryConfig} */
      static DEFAULT_RETRY_CONFIG = {
        strategy: "exponential",
        retries: 3,
        initialDelay: 500,
        factor: 3,
        maxDelay: 4e3
      };
      /** @type {import("../util/Types").SignatureCacheConfig} */
      static DEFAULT_SIGNATURE_CACHE_CONFIG = {
        size: 100
      };
      /** @type {ServiceCredentials} */
      credentials;
      /** @type {ServiceConfig} */
      config;
      /** @type {Object.<string, string>}  */
      endpoints;
      /** @type {ResponseCache} */
      jwksCache;
      /**
       * A jwt->boolean cache used for signature validation results. Can be either an external cache implementation or one of the {@link #sharedSignatureCaches}.
       * @type {import("../util/Types").Cache}
       */
      signatureCache;
      /**
       *
       * @param {ServiceCredentials} credentials
       * @param {ServiceConfig} [serviceConfiguration={}]
       */
      constructor(credentials, serviceConfiguration = {}) {
        if (credentials == null) {
          throw new ConfigurationError("Service requires service credentials.");
        }
        this.credentials = { ...credentials };
        this.config = _Service.buildServiceConfiguration(serviceConfiguration);
        _Service.#oidcCache ??= new ResponseCache({ endpointName: "OIDC configuration" });
        this.endpoints = { ...this.endpoints, ...serviceConfiguration.endpoints || {} };
        this.jwksCache = this.config.validation.jwks.shared ? this.#getSharedJwksCache(this.config) : new ResponseCache({ ...this.config.validation.jwks, endpointName: "JWKS" });
        if (this.config.validation.signatureCache.impl) {
          this.signatureCache = this.config.validation.signatureCache.impl;
        } else if (this.config.validation.signatureCache.enabled !== false) {
          this.signatureCache = _Service.#getSharedSignatureCache(this.config.validation.signatureCache);
        }
      }
      /**
       * @internal
       * Gets the OIDC cache shared by all Service instances.
       *
       * @returns {import("../cache/ResponseCache")} The OIDC cache.
       */
      get oidcCache() {
        return _Service.#oidcCache;
      }
      /**
       * @internal
       * Sets the OIDC cache shared by all Service instances.
       */
      set oidcCache(cache) {
        _Service.#oidcCache = cache;
      }
      #getSharedJwksCache() {
        _Service.#sharedJwksCaches[this.constructor.name] ??= new ResponseCache({ ...this.config.validation.jwks, endpointName: "JWKS" });
        return _Service.#sharedJwksCaches[this.constructor.name];
      }
      /**
       * Retrieves or creates the signature cache shared by all instances of this Service subclass.
       * @param {import("../util/Types").SignatureCacheConfig} config 
       * @returns {LRUCache} the shared signature cache
       * @throws {ConfigurationError} if a shared signature cache with a different size has already been created by another Service configuration for the same Service subclass.
       */
      static #getSharedSignatureCache(config) {
        const sharedCache = _Service.#sharedSignatureCaches[this.constructor.name];
        if (sharedCache != null && sharedCache.size !== config.size) {
          throw new ConfigurationError(
            `An internal signature cache with size ${sharedCache.size} instead of ${config.size} has already been created by another ${this.constructor.name} configuration. Please use the same size in all ${this.constructor.name} configurations or provide separate, externally managed cache implementations.`
          );
        }
        _Service.#sharedSignatureCaches[this.constructor.name] ??= new LRUCache(config.size);
        return _Service.#sharedSignatureCaches[this.constructor.name];
      }
      /**
       * Checks if this service is the recipient of the given token.
       * @param {Token} token
       * @returns {Boolean}
       */
      acceptsTokenAudience(token) {
        this.validateCredentials("validate token audience", "clientid");
        return token.audiences?.includes(this.credentials.clientid);
      }
      /**
       * Called internally to validate the credentials to have the necessary properties before performing a specific action, e.g. token fetch.
       *
       * @internal
       * @param {string} action description of action for which the credentials are being validated.
       * @param {...string} mandatoryProperties mandatory properties that must be present in the credentials.
       * @throws {InvalidCredentialsError} if any of the mandatory properties are missing in the credentials.
       */
      validateCredentials(action, ...mandatoryProperties) {
        const missingProperties = mandatoryProperties.filter((p) => !this.credentials[p]);
        if (missingProperties.length > 0) {
          throw new InvalidCredentialsError(`${this.constructor.name} is missing the properties ${missingProperties} inside its credentials for: ${action}.`);
        }
      }
      /**
       * Checks if the given token is valid under the given contextConfig.
       * @param {Token} token
       * @param {SecurityContextConfig} contextConfig
       * @throws {ValidationError} if the token is not valid or could not be validated
      */
      async validateToken(token, contextConfig) {
        if (token.expired) {
          throw new ExpiredTokenError(token);
        }
        if (token.notYetValid) {
          throw new NotYetValidTokenError(token);
        }
        if (!this.acceptsTokenAudience(token)) {
          throw new WrongAudienceError(token, this);
        }
        await this.validateTokenSignature(token, contextConfig);
      }
      /**
       * Checks if the given token's signature is valid under the given contextConfig.
       * @param {Token} token
       * @param {SecurityContextConfig} contextConfig
       * @returns {Promise<void>} resolves when token signature is valid, otherwise error is thrown
       * @throws {ValidationError} if the token signature is not valid or could not be validated
       */
      async validateTokenSignature(token, contextConfig) {
        if (!token.header.kid) {
          throw new MissingKidError(token.header.kid, `Token header contained no kid.`);
        }
        const jwks = await this.getJwks(token, contextConfig);
        const jwk = jwks.get(token.header.kid);
        if (this.signatureCache) {
          jwk.validateSignature(token, this.signatureCache);
        } else {
          jwk.validateSignature(token);
        }
      }
      /**
       * @param {object} [requestOptions]
       * @param {string} [requestOptions.correlationId]
       */
      async getOpenIDConfiguration({ correlationId } = {}) {
        this.validateCredentials("fetch OIDC configuration", "url");
        const cacheKey = createCacheKey({ url: this.credentials.url });
        const buildRequest = () => {
          return (correlationId2) => this.fetchOpenIDConfiguration({ correlationId: correlationId2 });
        };
        return this.oidcCache.getOrRequest(cacheKey, buildRequest, { correlationId });
      }
      /**
       * @param {object} [requestOptions]
       * @param {string} [requestOptions.correlationId]
       */
      async fetchOpenIDConfiguration({ correlationId } = {}) {
        this.validateCredentials("fetch OIDC configuration", "url");
        const oidcUrl = new URL(this.endpoints.oidc_info, this.credentials.url);
        const request = this.buildRequest({
          method: "GET"
        });
        return jsonRequest(oidcUrl, request, { requestName: `${this.constructor.name}.fetchOpenIDConfiguration`, correlationId });
      }
      /**
       * Fetches a token from this service with this service's client credentials.
       * @param {TokenFetchOptions} options
       * @returns {Promise<TokenFetchResponse>} response
       */
      async fetchClientCredentialsToken(options = {}) {
        const grant_type = GRANTTYPE_CLIENTCREDENTIALS;
        const tokenUrl = await this.getTokenUrl(grant_type, options);
        const request = this.buildTokenRequest(grant_type, options);
        return jsonRequest(tokenUrl, request, { requestName: `${this.constructor.name}.fetchClientCredentialsToken`, correlationId: options.correlationId });
      }
      /**
       * Fetches a user token from this service with the given username and password.
       * @param {String} username
       * @param {String} password
       * @param {TokenFetchOptions} options
       * @returns {Promise<TokenFetchResponse>} response
       */
      async fetchPasswordToken(username, password, options = {}) {
        const grant_type = GRANTTYPE_PASSWORD;
        const tokenUrl = await this.getTokenUrl(grant_type, options);
        const request = this.buildTokenRequest(grant_type, options);
        request.body.append("username", username);
        request.body.append("password", password);
        return jsonRequest(tokenUrl, request, { requestName: `${this.constructor.name}.fetchPasswordToken`, correlationId: options.correlationId });
      }
      /**
       * Fetches a JWT bearer token from this service with the given user token as assertion.
       * @param {TokenFetchOptions} options - default timeout is 10 seconds as JWT bearer can be slow
       * @returns {Promise<TokenFetchResponse>} response
       */
      async fetchJwtBearerToken(assertion, options = {}) {
        const grant_type = GRANTTYPE_JWTBEARER;
        const tokenUrl = await this.getTokenUrl(grant_type, options);
        options.timeout ??= DEFAULT_JWT_BEARER_FETCH_TIMEOUT;
        const request = this.buildTokenRequest(grant_type, options);
        request.body.append("assertion", assertion);
        return jsonRequest(tokenUrl, request, { requestName: `${this.constructor.name}.fetchJwtBearerToken`, correlationId: options.correlationId });
      }
      /**
       * Builds a request for this service based on the service configuration and the given request options.
       * For example, the request will use the timeout value from the service configuration if not overridden in the request options.
       *
       * @internal
       * @param {import("node:https").RequestOptions} [requestOptions] - options for the request
       */
      buildRequest(requestOptions) {
        return {
          timeout: this.config.requests.timeout,
          retry: this.config.requests.retry,
          ...requestOptions
        };
      }
      /**
       * Builds a token request for this service with the given grant_type and options.
       *
       * @param {String} grant_type
       * @param {TokenFetchOptions} options
       */
      buildTokenRequest(grant_type, options) {
        const request = this.buildRequest({
          method: "POST",
          body: new URLSearchParams({
            grant_type
          })
        });
        this.addClientAuthentication(request, options);
        if (options.timeout) {
          request.timeout = options.timeout;
        }
        if (options.token_format) {
          request.body.append("token_format", options.token_format);
        }
        return request;
      }
      /**
       * Prepares the given request to use this service's client credentials for authentication.
       * Adds clientid and either clientsecret or an mTLS agent based on client certificate, depending on the type of credentials.
       * @param {RequestInit} request
       * @param {URLSearchParams} request.body
       * @param {TokenFetchOptions} options
       */
      addClientAuthentication(request, options = {}) {
        this.validateCredentials("fetch token", "clientid");
        request.body.append("client_id", this.credentials.clientid);
        if (this.credentials.clientsecret) {
          request.body.append("client_secret", this.credentials.clientsecret);
        } else if (this.credentials.key && this.credentials.certificate) {
          request.agent = new Agent({
            key: this.credentials.key,
            cert: this.credentials.certificate
          });
        } else {
          throw new InvalidCredentialsError("Service credentials contain neither a client secret nor certificate based authentication information.");
        }
      }
      /**
       * Updates the certificate and key in the service credentials for authentication of subsequent requests.
       * @param {String} cert PEM-encoded client certificate
       * @param {String} key PEM-encoded client key
       * @returns {void}
       */
      setCertificateAndKey(cert, key) {
        this.credentials.certificate = cert;
        this.credentials.key = key;
      }
      /**
       * Builds the configuration of this service based on the provided configuration and default values.
       * @param {ServiceConfig} config 
       */
      static buildServiceConfiguration(config) {
        config.endpoints ??= {};
        config.endpoints.oidc_info ??= "/.well-known/openid-configuration";
        config.validation ??= {};
        config.validation.jwks ??= {};
        config.validation.jwks.shared ??= false;
        config.validation.jwks.expirationTime ??= ResponseCache.DEFAULT_EXPIRATION_TIME;
        config.validation.jwks.refreshPeriod ??= ResponseCache.DEFAULT_REFRESH_PERIOD;
        config.validation.signatureCache ??= { enabled: false };
        if (config.validation.signatureCache.enabled === false || config.validation.signatureCache.size === 0) {
          config.validation.signatureCache = { enabled: false };
        } else if (config.validation.signatureCache.impl) {
          config.validation.signatureCache = { impl: config.validation.signatureCache.impl, enabled: true };
        } else {
          config.validation.signatureCache = { ..._Service.DEFAULT_SIGNATURE_CACHE_CONFIG, ...config.validation.signatureCache, enabled: true };
        }
        config.requests ??= {};
        config.requests.timeout = Math.min(MAX_TIMEOUT, config.requests.timeout ?? DEFAULT_TIMEOUT);
        if (config.requests.retry) {
          if (config.requests.retry === true) {
            config.requests.retry = { ..._Service.DEFAULT_RETRY_CONFIG };
          } else {
            config.requests.retry = { ..._Service.DEFAULT_RETRY_CONFIG, ...config.requests.retry };
          }
        }
        return config;
      }
      /**
       * Creates a new {@link SecurityContext} from this service with the given token.
       * @abstract
       * @param {String|Token} token as JWT or Token object
       * @param {SecurityContextConfig} contextConfig
       * @returns {Promise<SecurityContext>} securityContext
       */
      async createSecurityContext(token, contextConfig = {}) {
        throw new ConfigurationError("This abstract function MUST be called on a service-specific implementation.");
      }
      /**
       * Retrieves the JWKS (JSON Web Key Set) for the given token and context configuration.
       *
       * @param {string} token the token for which to retrieve the JWKS.
       * @param {SecurityContextConfig} contextConfig the context configuration object.
       * @returns {Promise<Jwks>} A promise that resolves to the JWKS (JSON Web Key Set) object.
       * @throws {Error} If an error occurs while retrieving the JWKS.
       */
      async getJwks(token, contextConfig) {
        throw new ConfigurationError("This abstract function MUST be called on a service-specific implementation.");
      }
      /**
       * Determines the URL that can be used for fetching tokens of given grant_type from this service.
       * @abstract
       * @param {GrantType} grant_type
       * @param {Object} options
       * @param {String} options.correlationId
       * @returns {Promise<URL>} URL of the service's token endpoint
       */
      async getTokenUrl(grant_type, options = {}) {
        throw new ConfigurationError("This abstract function MUST be called on a service-specific implementation.");
      }
    };
    module2.exports = Service;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/token/IdentityServiceToken.js
var require_IdentityServiceToken3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/token/IdentityServiceToken.js"(exports2, module2) {
    var Token = require_Token3();
    var IdentityServiceToken = class extends Token {
      /**
       * @param {string|null} jwt 
       * @param {object} [content] - optional parsed header and payload
       * @param {import('../util/Types').JwtHeader & { [key: string]: any }} [content.header] - parsed header
       * @param {import('../util/Types').JwtPayload & import('../util/Types').IdentityServiceJwtPayload & { [key: string]: any }} [content.payload] - parsed payload
       */
      constructor(jwt, { header, payload } = {}) {
        super(jwt, { header, payload });
      }
      /**
       * @returns {string} The ID of the caller's tenant within the SAP Cloud Identity Service application for which the token was fetched.
       */
      get appTid() {
        return this.payload.app_tid ?? this.payload.zone_uuid;
      }
      /**
       * Returns the SAP Cloud Identity Service APIs consumed by the caller (based on the token's 'ias_apis' claim).
       * @returns {string[]} The consumed APIs or [] if the caller does not consume any APIs.
       */
      get consumedApis() {
        return this.payload.ias_apis || [];
      }
      get customIssuer() {
        return this.payload.ias_iss ? this.payload.iss : null;
      }
      /** 
       * @returns {string} The issuer of the token.
       */
      get issuer() {
        return this.payload.ias_iss || this.payload.iss;
      }
      /**
       * Returns the SCIM id of the user.
       * @returns {string} The SCIM id or undefined if the token does not contain a SCIM id, e.g. because it is a technical user token.
       */
      get scimId() {
        return this.payload.scim_id;
      }
      // Methods for backward-compatibility
      getAppTID() {
        return this.appTid;
      }
      getCustomIssuer() {
        return this.customIssuer;
      }
      /**
       * @deprecated Access appTid instead
       */
      getZoneId() {
        return this.appTid;
      }
    };
    module2.exports = IdentityServiceToken;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/jwks/Jwk.js
var require_Jwk3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/jwks/Jwk.js"(exports2, module2) {
    var crypto6 = require("crypto");
    var UnsupportedAlgorithmError = require_UnsupportedAlgorithmError3();
    var InvalidTokenSignatureError = require_InvalidTokenSignatureError3();
    var availableHashes = crypto6.getHashes();
    var Jwk = class _Jwk {
      key;
      // key information from JWKS response
      pubKey;
      // Node.Js crypto public key
      nodeAlg;
      // alg as Node.Js crypto name, e.g. RSA-SHA256
      /**
       * Creates a JWK based on a jwk-formatted public key
       * @param {Object} key key information in jwk format
       */
      constructor(key) {
        this.key = key;
        this.pubKey = crypto6.createPublicKey({
          key,
          format: "jwk"
        });
      }
      /**
       * Creates a JWK based on a PEM-formatted public key
       * @param {String} pem public key in PEM format
       * @returns Jwk
       */
      static fromPEM(pem) {
        const cleanedUpPem = _Jwk.cleanUpPemKey(pem);
        const pubKey = crypto6.createPublicKey({
          key: cleanedUpPem,
          format: "pem"
        });
        const jwk = pubKey.export({ format: "jwk" });
        return new _Jwk(jwk);
      }
      /**
       * Validates if the token was signed with the private key that belongs to this public key.
       * If available, uses the signature cache to avoid validating the same signature again on subsequent requests.
       * @param {Token} token 
       * @param {import("../util/Types").Cache} [signatureCache] an optional cache for signature validation results
       * @returns void if the signature is valid
       * @throws {InvalidTokenSignatureError} when signature is invalid
       */
      validateSignature(token, signatureCache) {
        let validationResult = signatureCache?.get(token.jwt);
        if (validationResult == null) {
          validationResult = this.validateSignatureWithoutCache(token);
          signatureCache?.set(token.jwt, validationResult);
        }
        if (validationResult !== true) {
          throw new InvalidTokenSignatureError(token);
        }
      }
      /**
       * Validates if the token was signed with the private key that belongs to this public key without using a cache.
       * @param {Token} token 
       * @returns {boolean} true if the signature is valid, false otherwise
       */
      validateSignatureWithoutCache(token) {
        const nodeAlg = _Jwk.mapAlgToNodeAlg(token.header.alg);
        if (!availableHashes.includes(nodeAlg)) {
          throw new UnsupportedAlgorithmError(token, token.header.alg);
        }
        const [header, payload, signature] = token.jwt.split(".");
        const verifier = crypto6.createVerify(nodeAlg);
        verifier.update(`${header}.${payload}`);
        return verifier.verify(this.pubKey, signature, "base64");
      }
      static mapAlgToNodeAlg(alg) {
        switch (alg?.toUpperCase()) {
          case "RS256":
            return "RSA-SHA256";
          case "RS384":
            return "RSA-SHA384";
          case "RS512":
            return "RSA-SHA512";
          default:
            return null;
        }
      }
      /* 
      * Adds missing line breaks to malformed PEM keys.
      * For backward-compatibility, a specific kind of malformed PEM needs to be supported that is lacking line breaks around the header and footer.
      * This kind of PEM input can occur, for example, in old service bindings of XSA and is not always fixable by consumers of this library.
      */
      static cleanUpPemKey(pem = "") {
        if (!pem.includes("KEY-----\n")) {
          pem = pem.replace("KEY-----", "KEY-----\n");
        }
        if (!pem.includes("\n-----END")) {
          pem = pem.replace("-----END", "\n-----END");
        }
        return pem;
      }
    };
    module2.exports = Jwk;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/jwks/Jwks.js
var require_Jwks3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/jwks/Jwks.js"(exports2, module2) {
    var Jwk = require_Jwk3();
    var MissingKidError = require_MissingKidError3();
    var Jwks = class {
      constructor(keys = []) {
        this.keys = /* @__PURE__ */ Object.create(null);
        for (const k of keys) {
          this.keys[k.kid] = new Jwk(k);
        }
      }
      /**
       * Retrieves the JWK (JSON Web Key) associated with the specified key ID (kid).
       * @param {string} kid - The key ID (kid) of the JWK to retrieve.
       * @returns {Jwk} - The JWK associated with the specified key ID.
       * @throws {MissingKidError} - If the JWKS does not contain a key for the specified key ID.
       */
      get(kid) {
        const jwk = this.keys[kid];
        if (!jwk) throw new MissingKidError(kid, `JWKS does not contain a key for kid=${kid}`);
        return jwk;
      }
    };
    module2.exports = Jwks;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/service/IdentityService.js
var require_IdentityService3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/service/IdentityService.js"(exports2, module2) {
    "use strict";
    var Service = require_Service3();
    var SecurityContext = require_SecurityContext3();
    var IdentityServiceSecurityContext = require_IdentityServiceSecurityContext3();
    var IdentityServiceToken = require_IdentityServiceToken3();
    var Jwks = require_Jwks3();
    var { MissingClientCertificateError, MissingIssuerError, InvalidIssuerError, UntrustedIssuerError, X5tError, ConfigurationError, ResponseError, WrongAudienceError } = require_error3();
    var util = require_util5();
    var { createCacheKey, escapeStringForRegex } = require_util5();
    var { jsonRequest } = require_jsonRequest3();
    var { APP_TID_HEADER, AZP_HEADER, CLIENT_CERTIFICATE_HEADER, CLIENTID_HEADER, HTTPS_SCHEME, SERVICE_PLAN_HEADER, X5T_CNF_CLAIM } = require_constants4();
    var Token = require_Token3();
    var IdentityService = class _IdentityService extends Service {
      /**
       * @param {ServiceCredentials & IdentityServiceCredentials} credentials 
       * @param {ServiceConfig & IdentityServiceConfig} [serviceConfiguration={}]
       */
      constructor(credentials, serviceConfiguration) {
        super(credentials, serviceConfiguration);
      }
      /**
       * @override
       * @param {String|IdentityServiceToken} token token as JWT or IdentityServiceToken object
       * @param {SecurityContextConfig} contextConfig 
       * @returns {Promise<IdentityServiceSecurityContext>}
       */
      async createSecurityContext(token, contextConfig = {}) {
        if (typeof token === "string") {
          token = new IdentityServiceToken(token);
        } else if (token instanceof Token && !(token instanceof IdentityServiceToken)) {
          token = new IdentityServiceToken(token.jwt, { header: token.header, payload: token.payload });
        }
        SecurityContext.buildContextConfig(contextConfig);
        if (contextConfig.skipValidation !== true) {
          if (this.#proofTokenCheckRequired(token) || this.hasX5tEnabled()) {
            if (contextConfig.clientCertificatePem == null) {
              throw new MissingClientCertificateError();
            } else {
              contextConfig.clientCertificate = util.parsePemCertificate(contextConfig.clientCertificatePem);
            }
          }
          await this.validateToken(token, contextConfig);
        }
        const ctx = new IdentityServiceSecurityContext(this, token, contextConfig);
        for (let extension of this.config.context?.extensions || []) {
          await extension.extendSecurityContext(ctx);
        }
        return ctx;
      }
      /**
       * @override
       * @param {IdentityServiceToken} token 
       * @param {SecurityContextConfig} contextConfig 
       */
      async validateToken(token, contextConfig) {
        if (this.hasX5tEnabled()) {
          _IdentityService.validateTokenOwnership(token, contextConfig.clientCertificate);
        }
        await super.validateToken(token, contextConfig);
      }
      /**
       * Retrieves the JWKS (JSON Web Key Set) for the given token and context configuration.
       * 
       * @param {string} token - The token for which to retrieve the JWKS.
       * @param {SecurityContextConfig} contextConfig - The context configuration object.
       * @returns {Promise<Jwks>} - A promise that resolves to the JWKS (JSON Web Key Set) object.
       * @throws {WrongAudienceError} - if the online validation in the JWKS endpoint of the Identity Service instance responds with a 400 status code, indicating that the token should not be accepted by this service.
       * @throws {Error} - If an error occurs while retrieving the JWKS.
       */
      async getJwks(token, contextConfig) {
        this.validateCredentials("fetch JWKS", "clientid", "url");
        const issuerUrl = _IdentityService.getSafeUrlFromTokenIssuer(token, this.credentials.domains);
        const jwksParams = {
          clientid: this.credentials.clientid,
          app_tid: token.appTid,
          azp: token.azp
        };
        const keyParts = { url: issuerUrl, ...jwksParams };
        const proofTokenCheck = this.#proofTokenCheckRequired(token);
        if (proofTokenCheck) {
          keyParts.certSub = contextConfig.clientCertificate?.subject;
          jwksParams.clientCertificatePem = contextConfig.clientCertificatePem?.replaceAll("\\n", "").replaceAll("\n", "");
        }
        const cacheKey = createCacheKey(keyParts);
        const buildJwksRequest = () => {
          const issuerService = issuerUrl === this.credentials.url ? this : new _IdentityService({ url: issuerUrl, clientid: this.credentials.clientid });
          const extractHeaders = proofTokenCheck ? "headers" : null;
          return async (correlationId) => {
            const jwksResponse = await issuerService.fetchJwks(jwksParams, { correlationId, extractHeaders });
            return {
              jwks: new Jwks(jwksResponse.keys),
              servicePlans: proofTokenCheck ? jwksResponse.headers.get(SERVICE_PLAN_HEADER)?.split(",").map((plan) => plan.replaceAll('"', "")) : null
            };
          };
        };
        let cachedResponse;
        try {
          cachedResponse = await this.jwksCache.getOrRequest(cacheKey, buildJwksRequest, { correlationId: contextConfig.correlationId });
        } catch (error) {
          if (error instanceof ResponseError && error.responseCode === 400 && error.request.name === `${this.constructor.name}.fetchJwks`) {
            throw new WrongAudienceError(token, this, `The online validation in the JWKS endpoint of the Identity Service instance responded with 400: '${error.responseText}'. This indicates that the token should not be accepted by this service.`);
          }
          throw error;
        }
        const { jwks, servicePlans } = cachedResponse;
        if (proofTokenCheck) {
          contextConfig.servicePlans = servicePlans;
        }
        return jwks;
      }
      async fetchJwks({ clientid, app_tid, azp, clientCertificatePem }, { correlationId, extractHeaders }) {
        const openIDConfiguration = await this.getOpenIDConfiguration({ correlationId });
        const jwksUrl = openIDConfiguration.jwks_uri;
        const request = this.buildRequest({
          method: "GET",
          headers: {
            [CLIENTID_HEADER]: clientid
          }
        });
        if (app_tid != null) {
          request.headers[APP_TID_HEADER] = app_tid;
        }
        if (azp != null) {
          request.headers[AZP_HEADER] = azp;
        }
        if (clientCertificatePem != null) {
          request.headers[CLIENT_CERTIFICATE_HEADER] = clientCertificatePem;
        }
        return jsonRequest(jwksUrl, request, { requestName: `${this.constructor.name}.fetchJwks`, correlationId, extractHeaders });
      }
      // Re-declare JSDoc for token fetches with detailed options and return object properties
      /**
       * Fetches a token from this service with this service's client credentials.
       * @param {TokenFetchOptions & IdentityServiceTokenFetchOptions} options
       * @returns {Promise<TokenFetchResponse>}
       */
      async fetchClientCredentialsToken(options = {}) {
        return super.fetchClientCredentialsToken(options);
      }
      /**
       * Fetches a user token from this service with the given username and password.
       * @param {String} username
       * @param {String} password
       * @param {TokenFetchOptions & IdentityServiceTokenFetchOptions} options      
       * @returns {Promise<TokenFetchResponse & IdTokenFetchResponse & RefreshableTokenFetchResponse>}
       */
      async fetchPasswordToken(username, password, options = {}) {
        return super.fetchPasswordToken(username, password, options);
      }
      /**
       * Fetches a JWT bearer token from this service with the given user token as assertion.
       * @param {String} assertion JWT bearer token used as assertion   
       * @param {TokenFetchOptions & IdentityServiceTokenFetchOptions} options      
       * @returns {Promise<TokenFetchResponse & IdTokenFetchResponse & RefreshableTokenFetchResponse>}
       */
      async fetchJwtBearerToken(assertion, options = {}) {
        return super.fetchJwtBearerToken(assertion, options);
      }
      /** @override */
      buildTokenRequest(grant_type, options) {
        const request = super.buildTokenRequest(grant_type, options);
        if (options.resource) {
          [options.resource].flatMap((r) => r).forEach((resource) => request.body.append("resource", resource));
        }
        return request;
      }
      /**
       * Prepares the given formData and fetch options to use this service's client credentials for authentication.
       * Adds clientid, app_tid and either clientsecret or an mTLS agent based on client certificate, depending on the type of credentials.
       * @param {RequestInit} request 
       * @param {URLSearchParams} request.body
       * @param {TokenFetchOptions} options
       * @override
       */
      addClientAuthentication(request, options = {}) {
        super.addClientAuthentication(request, options);
        const app_tid = options.app_tid ?? this.credentials.app_tid;
        if (app_tid != null) {
          request.body.append("app_tid", app_tid);
        }
      }
      /**
       * @override
       * @inheritdoc
       */
      async getTokenUrl(grant_type, options = {}) {
        const { correlationId } = options;
        const openidConfiguration = await this.getOpenIDConfiguration({ correlationId });
        if (!openidConfiguration.grant_types_supported.includes(grant_type)) {
          throw new ConfigurationError(`This Identity Service instance does not support grant type ${grant_type} according to its openid-configuration.`);
        }
        return new URL(openidConfiguration.token_endpoint);
      }
      /** 
       * Returns whether proof token validation has been enabled via the service's configuration.
       * @returns {Boolean}
       */
      hasProofTokenEnabled() {
        return this.config.validation?.proofToken?.enabled;
      }
      /** 
       * Returns whether x5t proof of token ownership validation has been enabled via the service's configuration.
       * @returns {Boolean}
       */
      hasX5tEnabled() {
        return this.config.validation?.x5t?.enabled;
      }
      /**
       * Returns whether a proof token check has to be done for the given token.
       * The decision depends on the type of token.
       * Tokens with claim ias_api are App2App tokens for which a proof token check must not be done, even when enabled via the configuration.
       * @param {IdentityServiceToken} token 
       */
      #proofTokenCheckRequired(token) {
        return this.hasProofTokenEnabled() && token.payload.ias_apis == null;
      }
      /**
       * Returns an issuer URL based on the issuer of the token if it can be succesfully validated against a list of trusted domains.
       * @param {IdentityServiceToken} token token from which issuer is extracted
       * @param {Array<string>} trustedDomains a list of trusted domains
       * @returns {String} URL of issuer if its domain is either a trusted domain or a subdomain of a trusted domain
       * @throws {UntrustedIssuerError} if issuer is empty, not trusted or not a valid URL
       */
      static getSafeUrlFromTokenIssuer = function(token, trustedDomains = []) {
        const issuer = token?.issuer;
        if (!issuer) {
          throw new MissingIssuerError(token);
        }
        const issuerUrl = issuer.startsWith(HTTPS_SCHEME) ? issuer : `${HTTPS_SCHEME}${issuer}`;
        try {
          new URL(issuerUrl);
        } catch (e) {
          throw new InvalidIssuerError(token, e);
        }
        const issuerDomain = issuerUrl.substring(HTTPS_SCHEME.length);
        for (let d of trustedDomains) {
          const validSubdomainPattern = `^[a-zA-Z0-9-]{1,63}\\.${escapeStringForRegex(d)}$`;
          if (issuerDomain === d || issuerDomain.match(new RegExp(validSubdomainPattern))) {
            return issuerUrl;
          }
        }
        throw new UntrustedIssuerError(token);
      };
      /**
       * Validates that the client owning the given certificate is the owner of the token.
       * The validation is based on proof-of-posession via certificate binding of tokens as described in {@link https://datatracker.ietf.org/doc/html/rfc8705 RFC 8705}.
       * The validation is succesful if the token contains an base64url-encoded x5t thumbprint under claim {@link CNF_X5T_CLAIM cnf.x5t#S256} that matches the given certificate.
       * The client certificate against which the validation is performed, is typically extracted from the {@link FWD_CLIENT_CERT_HEADER x-forwarded-client-cert} request header where it is put by BTP after TLS termination.
       * @param {IdentityServiceToken} token 
       * @param {X509Certificate} cert client certificate parsed as X509Certificate
       */
      static validateTokenOwnership(token, cert) {
        const tokenX5t = token.payload.cnf?.[X5T_CNF_CLAIM];
        if (!tokenX5t) {
          throw new X5tError(token, cert, "X5t validation failed because x5t thumbprint could not be found in token.");
        }
        let certificateX5t;
        try {
          certificateX5t = Buffer.from(cert.fingerprint256.replaceAll(":", ""), "hex").toString("base64url");
        } catch (e) {
          throw new X5tError(token, cert, "x5t validation failed because x5t thumbprint could not be calculated from client certificate.");
        }
        if (tokenX5t !== certificateX5t) {
          throw new X5tError(token, cert, "x5t thumbprint did not match the thumbprint of the provided client certificate.");
        }
      }
    };
    module2.exports = IdentityService;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/token/XsuaaToken.js
var require_XsuaaToken3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/token/XsuaaToken.js"(exports2, module2) {
    var Token = require_Token3();
    var XsuaaToken = class extends Token {
      /**
       * @param {string|null} jwt 
       * @param {object} [content] - optional parsed header and payload
       * @param {import('../util/Types').JwtHeader & { [key: string]: any }} [content.header] - parsed header
       * @param {import('../util/Types').JwtPayload & import('../util/Types').XsuaaJwtPayload & { [key: string]: any }} [content.payload] - parsed payload
       */
      constructor(jwt, { header, payload } = {}) {
        super(jwt, { header, payload });
      }
      get azAttributes() {
        return this.payload.az_attr;
      }
      get extAttributes() {
        return this.payload.ext_attr;
      }
      get logonName() {
        return this.payload.user_name;
      }
      /**
       * @returns {string[]} the scopes of the token
       */
      get scopes() {
        return this.payload.scope ?? [];
      }
      get serviceInstanceId() {
        return this.payload.ext_attr?.serviceinstanceid;
      }
      get subAccountId() {
        return this.payload.ext_attr?.subaccountid || this.zid;
      }
      get userId() {
        return super.userId || this.payload.sub;
      }
      get xsUserAttributes() {
        return this.payload.ext_cxt?.["xs.user.attributes"] ?? this.payload["xs.user.attributes"];
      }
      get xsSystemAttributes() {
        return this.payload.ext_cxt?.["xs.system.attributes"] ?? this.payload["xs.system.attributes"];
      }
      /**
       * @returns {string} The zone id of the token.
       */
      get zid() {
        return this.payload.zid;
      }
      getXsUserAttribute(name) {
        return this.xsUserAttributes?.[name];
      }
      // Methods for backward-compatibility
      getAppTID() {
        return this.zid;
      }
      getCustomIssuer() {
        return this.issuer;
      }
      getZoneId() {
        return this.zid;
      }
    };
    module2.exports = XsuaaToken;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/service/XsuaaService.js
var require_XsuaaService3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/service/XsuaaService.js"(exports2, module2) {
    "use strict";
    var Service = require_Service3();
    var SecurityContext = require_SecurityContext3();
    var XsuaaSecurityContext = require_XsuaaSecurityContext3();
    var XsuaaToken = require_XsuaaToken3();
    var Jwks = require_Jwks3();
    var { jsonRequest } = require_jsonRequest3();
    var { HTTPS_SCHEME, ZID_QUERY_PARAMETER, ZID_HEADER } = require_constants4();
    var { createCacheKey } = require_util5();
    var { ResponseError, WrongAudienceError } = require_error3();
    var Token = require_Token3();
    var XsuaaService = class extends Service {
      #jwksBaseUrl;
      // base URL from which the JWKS is fetched
      /**
       * @param {ServiceCredentials & XsuaaServiceCredentials} credentials 
       * @param {ServiceConfig} [serviceConfig={}] 
       */
      constructor(credentials, serviceConfig) {
        serviceConfig ??= {};
        serviceConfig.endpoints ??= {};
        serviceConfig.endpoints.oidc_info ??= "/.well-known/openid-configuration";
        serviceConfig.endpoints.jwks ??= "/token_keys";
        serviceConfig.endpoints.token ??= "/oauth/token";
        super(credentials, serviceConfig);
      }
      /**
       * @overrides
       * @inheritdoc
       */
      acceptsTokenAudience(token) {
        this.validateCredentials("validate token audience", "clientid", "xsappname");
        if (!(token instanceof XsuaaToken)) {
          token = new XsuaaToken(null, { header: token.header, payload: token.payload });
        }
        let audiencesToConsider;
        if (token.audiences?.length > 0) {
          audiencesToConsider = [...token.audiences];
        } else if (token.scopes) {
          audiencesToConsider = [...token.scopes];
        } else {
          audiencesToConsider = [];
        }
        if (token.payload.cid) {
          audiencesToConsider.push(token.payload.cid);
        }
        return audiencesToConsider.some((a) => a === this.credentials.clientid || a.startsWith(`${this.credentials.clientid}.`)) || audiencesToConsider.some((a) => a === this.credentials.xsappname || a.startsWith(`${this.credentials.xsappname}.`)) || this.credentials.clientid.includes("!b") && audiencesToConsider.some((a) => a.endsWith(`|${this.credentials.xsappname}`));
      }
      /**
       * @override
       * @param {String|XsuaaToken} token as JWT or XsuaaToken object
       * @param {SecurityContextConfig} contextConfig 
       * @returns {Promise<XsuaaSecurityContext}
       */
      async createSecurityContext(token, contextConfig = {}) {
        if (typeof token === "string") {
          token = new XsuaaToken(token);
        } else if (token instanceof Token && !(token instanceof XsuaaToken)) {
          token = new XsuaaToken(token.jwt, { header: token.header, payload: token.payload });
        }
        SecurityContext.buildContextConfig(contextConfig);
        if (contextConfig.skipValidation !== true) {
          await this.validateToken(token, contextConfig);
        }
        const ctx = new XsuaaSecurityContext(this, token, contextConfig);
        for (let extension of this.config.context?.extensions || []) {
          await extension.extendSecurityContext(ctx);
        }
        return ctx;
      }
      async getJwks(token, contextConfig) {
        const jwksParams = {
          zid: token.zid
        };
        const keyParts = { url: this.jwksBaseUrl, ...jwksParams };
        const cacheKey = createCacheKey(keyParts);
        const buildJwksRequest = () => {
          return async (correlationId) => {
            const jwksResponse = await this.fetchJwks({ ...jwksParams, correlationId });
            return new Jwks(jwksResponse.keys);
          };
        };
        let jwks;
        try {
          jwks = await this.jwksCache.getOrRequest(cacheKey, buildJwksRequest, { correlationId: contextConfig.correlationId });
        } catch (error) {
          if (error instanceof ResponseError && error.responseCode === 400) {
            throw new WrongAudienceError(token, this, `The online validation in the JWKS endpoint of the XSUAA server responded with 400: '${error.responseText}'. This indicates that the token should not be accepted by this service.`);
          }
          throw error;
        }
        return jwks;
      }
      /**
       * @internal
       * Returns the base URL (https protocol + uaadomain from the credentials) that can be used for JWKS fetches.
       * @returns {String} base URL for JWKS fetches
       */
      get jwksBaseUrl() {
        if (!this.#jwksBaseUrl) {
          this.validateCredentials("fetch JWKS", "uaadomain");
          const { uaadomain } = this.credentials;
          if (uaadomain.startsWith(HTTPS_SCHEME)) {
            this.#jwksBaseUrl = uaadomain;
          } else {
            this.#jwksBaseUrl = `${HTTPS_SCHEME}${uaadomain}`;
          }
        }
        return this.#jwksBaseUrl;
      }
      async fetchJwks(jwksParams, correlationId) {
        const jwksUrl = new URL(this.jwksBaseUrl + this.endpoints.jwks);
        if (jwksParams.zid) {
          jwksUrl.searchParams.append(ZID_QUERY_PARAMETER, jwksParams.zid);
        }
        const request = this.buildRequest({
          method: "GET"
        });
        return jsonRequest(jwksUrl, request, { requestName: `${this.constructor.name}.fetchJwks`, correlationId });
      }
      // Re-declare JSDoc for token fetches with detailed options and return object properties
      /**
       * Fetches a token from this service with this service's client credentials.
       * @param {TokenFetchOptions & XsuaaTokenFetchOptions} options
       * @returns {Promise<TokenFetchResponse>} response
       */
      async fetchClientCredentialsToken(options = {}) {
        return super.fetchClientCredentialsToken(options);
      }
      /**
       * Fetches a user token from this service with the given username and password.
       * @param {String} username
       * @param {String} password
       * @param {TokenFetchOptions & XsuaaTokenFetchOptions} options
       * @returns {Promise<TokenFetchResponse & RefreshableTokenFetchResponse>} response
       */
      async fetchPasswordToken(username, password, options = {}) {
        return super.fetchPasswordToken(username, password, options);
      }
      /**
       * Fetches a JWT bearer token from this service with the given user token as assertion.
       * @param {String} assertion JWT bearer token used as assertion   
       * @param {TokenFetchOptions & XsuaaTokenFetchOptions} options
       * @returns {Promise<TokenFetchResponse & RefreshableTokenFetchResponse>} response
       */
      async fetchJwtBearerToken(assertion, options = {}) {
        return super.fetchJwtBearerToken(assertion, options);
      }
      /** @override */
      buildTokenRequest(grant_type, options) {
        const request = super.buildTokenRequest(grant_type, options);
        if (options.scope) {
          request.body.append("scope", options.scope);
        }
        if (options.authorities) {
          request.body.append("authorities", JSON.stringify({ az_attr: options.authorities }));
        }
        if (options.zid) {
          request.headers ??= {};
          request.headers[ZID_HEADER] = options.zid;
        }
        return request;
      }
      /**
       * Determines the URL that can be used for fetching tokens from this service, optionally adjusted for a tenant in the same subaccount.
       * @override
       * @inheritdoc
       * @param {GrantType} grant_type
       * @param {String} options.tenant
       */
      async getTokenUrl(grant_type, options = {}) {
        const { tenant } = options;
        let baseUrl;
        if (tenant) {
          this.validateCredentials("build token fetch URL for custom tenant subdomain", "uaadomain");
          const uaaDomain = this.credentials.certificate ? this.credentials.uaadomain.replace("authentication.", "authentication.cert.") : this.credentials.uaadomain;
          baseUrl = `${HTTPS_SCHEME}${tenant}.${uaaDomain}`;
        } else {
          if (this.credentials.certificate) {
            this.validateCredentials("fetch token via certificate authentication", "certurl");
            baseUrl = this.credentials.certurl;
          } else {
            this.validateCredentials("fetch token via client secret authentication", "url");
            baseUrl = this.credentials.url;
          }
        }
        return new URL(this.endpoints.token, baseUrl);
      }
    };
    module2.exports = XsuaaService;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/token/XsaToken.js
var require_XsaToken3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/token/XsaToken.js"(exports2, module2) {
    var XsuaaToken = require_XsuaaToken3();
    var XsaToken = class extends XsuaaToken {
    };
    module2.exports = XsaToken;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/service/XsaService.js
var require_XsaService3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/service/XsaService.js"(exports2, module2) {
    "use strict";
    var SecurityContext = require_SecurityContext3();
    var XsaSecurityContext = require_XsaSecurityContext3();
    var XsaToken = require_XsaToken3();
    var Jwk = require_Jwk3();
    var MissingKidError = require_MissingKidError3();
    var MissingVerificationKeyError = require_MissingVerificationKeyError3();
    var { getLogger } = require_logging3();
    var XsuaaService = require_XsuaaService3();
    var Token = require_Token3();
    var LOG = getLogger("XsaService.js");
    var XsaService = class extends XsuaaService {
      /**
       * @param {ServiceCredentials & XsaServiceCredentials} credentials 
       * @param {ServiceConfig} [serviceConfig={}]
       */
      constructor(credentials, serviceConfig) {
        super(credentials, serviceConfig);
      }
      /**
       * @override
       * @param {String|XsaToken} token token as JWT or XsaToken object
       * @param {SecurityContextConfig} contextConfig 
       * @returns {Promise<XsaSecurityContext>}
       */
      async createSecurityContext(token, contextConfig = {}) {
        if (typeof token === "string") {
          token = new XsaToken(token);
        } else if (token instanceof Token && !(token instanceof XsaToken)) {
          token = new XsaToken(token.jwt, { header: token.header, payload: token.payload });
        }
        SecurityContext.buildContextConfig(contextConfig);
        if (contextConfig.skipValidation !== true) {
          await this.validateToken(token, contextConfig);
        }
        const ctx = new XsaSecurityContext(this, token, contextConfig);
        for (let extension of this.config.context?.extensions || []) {
          await extension.extendSecurityContext(ctx);
        }
        return ctx;
      }
      async validateTokenSignature(token, contextConfig) {
        const pemKeyFromConfig = this.credentials.verificationkey;
        if (!token.header.jku || !token.header.kid || token.header.kid == "legacy-token-key") {
          LOG.info("Token header contained no JKU or KID or the KID was 'legacy-token-key'");
          return this.#validateTokenSignatureWithFallback(token, pemKeyFromConfig);
        }
        try {
          await super.validateTokenSignature(token, contextConfig);
        } catch (error) {
          if (error instanceof MissingKidError) {
            LOG.info("JWKS did not contain kid.");
            return this.#validateTokenSignatureWithFallback(token, pemKeyFromConfig);
          } else {
            throw error;
          }
        }
      }
      #validateTokenSignatureWithFallback(token, pemKeyFromConfig) {
        if (!pemKeyFromConfig) {
          throw new MissingVerificationKeyError();
        } else {
          LOG.info("Validating token signature with verificationkey from service configuration.");
          return Jwk.fromPEM(pemKeyFromConfig).validateSignature(token);
        }
      }
      /**
       * Fetches a token from this service with this service's client credentials.
       * @param {TokenFetchOptions} options
       * @returns {Promise<TokenFetchResponse>} response
       */
      async fetchClientCredentialsToken(options = {}) {
        return super.fetchClientCredentialsToken(options);
      }
      /**
       * Fetches a user token from this service with the given username and password.
       * @param {String} username
       * @param {String} password
       * @param {TokenFetchOptions} options
       * @returns {Promise<TokenFetchResponse & RefreshableTokenFetchResponse>} response
       */
      async fetchPasswordToken(username, password, options = {}) {
        return super.fetchPasswordToken(username, password, options);
      }
      /**
       * Fetches a JWT bearer token from this service with the given user token as assertion.
       * @param {String} assertion JWT bearer token used as assertion   
       * @param {TokenFetchOptions} options
       * @returns {Promise<TokenFetchResponse & RefreshableTokenFetchResponse>} response
       */
      async fetchJwtBearerToken(assertion, options = {}) {
        return super.fetchJwtBearerToken(assertion, options);
      }
      /**
       * Determines the URL that can be used for fetching tokens from this service.
       * @param {GrantType} grant_type
       */
      async getTokenUrl(grant_type) {
        let baseUrl;
        if (this.credentials.certificate) {
          this.validateCredentials("fetch token via certificate authentication", "certurl");
          baseUrl = this.credentials.certurl;
        } else {
          this.validateCredentials("fetch token via client secret authentication", "url");
          baseUrl = this.credentials.url;
        }
        return new URL(this.endpoints.token, baseUrl);
      }
      /**
       * @override
       * @inheritdoc
       */
      get jwksBaseUrl() {
        this.validateCredentials("fetch JWKS", "url");
        return this.credentials.url;
      }
    };
    module2.exports = XsaService;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/token/UaaToken.js
var require_UaaToken3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/token/UaaToken.js"(exports2, module2) {
    var XsuaaToken = require_XsuaaToken3();
    var UaaToken = class extends XsuaaToken {
    };
    module2.exports = UaaToken;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/service/UaaService.js
var require_UaaService3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/service/UaaService.js"(exports2, module2) {
    "use strict";
    var SecurityContext = require_SecurityContext3();
    var UaaSecurityContext = require_UaaSecurityContext3();
    var Token = require_Token3();
    var UaaToken = require_UaaToken3();
    var XsuaaService = require_XsuaaService3();
    var UaaService = class extends XsuaaService {
      /**
       * @param {ServiceCredentials | UaaServiceCredentials} credentials 
       * @param {ServiceConfig} [serviceConfig={}]
       */
      constructor(credentials, serviceConfig) {
        super(credentials, serviceConfig);
      }
      /**
       * @override
       * @param {String|UaaToken} token token as JWT or UaaToken object
       * @param {SecurityContextConfig} contextConfig 
       * @returns {Promise<UaaSecurityContext>}
       */
      async createSecurityContext(token, contextConfig = {}) {
        if (typeof token === "string") {
          token = new UaaToken(token);
        } else if (token instanceof Token && !(token instanceof UaaToken)) {
          token = new UaaToken(token.jwt, { header: token.header, payload: token.payload });
        }
        SecurityContext.buildContextConfig(contextConfig);
        if (contextConfig.skipValidation !== true) {
          await this.validateToken(token, contextConfig);
        }
        const ctx = new UaaSecurityContext(this, token, contextConfig);
        for (let extension of this.config.context?.extensions || []) {
          await extension.extendSecurityContext(ctx);
        }
        return ctx;
      }
      /**
      * @overrides
      * @inheritdoc
      */
      acceptsTokenAudience(token) {
        this.validateCredentials("validate token audience", "clientid");
        if (!(token instanceof UaaToken)) {
          token = new UaaToken(null, { header: token.header, payload: token.payload });
        }
        const tokenAudiences = token.audiences?.length > 0 ? token.audiences : token.scopes ?? [];
        if (token.payload.cid) {
          tokenAudiences.push(token.payload.cid);
        }
        return tokenAudiences.some((a) => a === this.credentials.clientid || a.startsWith(`${this.credentials.clientid}.`));
      }
    };
    module2.exports = UaaService;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/passport/XssecPassportStrategy.js
var require_XssecPassportStrategy3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/passport/XssecPassportStrategy.js"(exports2, module2) {
    var createSecurityContext = require_createSecurityContext3();
    var ConfigurationError = require_ConfigurationError3();
    var ValidationError = require_ValidationError3();
    var { getLogger } = require_logging3();
    var LOG = getLogger("XssecPassportStrategy.js");
    var XssecPassportStrategy = class _XssecPassportStrategy {
      /** @type {Service|Service[]} service(s) against which incoming JWTs are authenticated */
      services;
      /** @type {string|Symbol} the property on the req object where the SecurityContext is placed after authentication. */
      reqProperty;
      /**
       * Creates a new XssecPassportStrategy that uses the provided service(s) to create security contexts for incoming requests.
       * @param {Service|Service[]} services 
       * @param {string|Symbol} [reqProperty="securityContext"] the property (Default: "securityContext") on the req object where the SecurityContext is placed after authentication.
       */
      constructor(services, reqProperty = "securityContext") {
        this.name = "JWT";
        this.services = services;
        this.reqProperty = reqProperty;
      }
      async authenticate(req, passportOptions = {}) {
        try {
          const securityContext = await createSecurityContext(this.services, { req });
          if (passportOptions.scope) {
            if (!(typeof securityContext.checkScope === "function")) {
              return this.error(new ConfigurationError("XssecPassportStrategy was configured with scope but the authentication was performed via a Service whose SecurityContext does not support checkLocalScope."));
            }
            const hasScope = [passportOptions.scope].flatMap((s) => s).some((s) => securityContext.checkLocalScope(s));
            if (!hasScope) {
              return this.fail("Token is missing required scope.", 403);
            }
          }
          const passportUser = _XssecPassportStrategy.#buildPassportUser(securityContext.token);
          req[this.reqProperty] = securityContext;
          req.tokenInfo = securityContext.token;
          return this.success(passportUser, securityContext);
        } catch (error) {
          req.xssecError = error;
          if (error instanceof ValidationError) {
            LOG.debug("ValidationError:", error);
            return this.fail(401);
          } else {
            return this.error(error);
          }
        }
      }
      /**
       * @param {Token} token 
       */
      static #buildPassportUser(token) {
        return {
          id: token.logonName || token.userName,
          name: {
            givenName: token.givenName,
            familyName: token.familyName
          },
          emails: [
            {
              value: token.email
            }
          ]
        };
      }
    };
    module2.exports = XssecPassportStrategy;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/v3/createService.js
var require_createService3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/v3/createService.js"(exports2, module2) {
    var IdentityService = require_IdentityService3();
    var XsuaaService = require_XsuaaService3();
    var XsaService = require_XsaService3();
    var UaaService = require_UaaService3();
    module2.exports = createServiceFromCredentials;
    function createServiceFromCredentials(credentials, serviceConfiguration) {
      if (credentials.xsappname && credentials.uaadomain) {
        return new XsuaaService(credentials, serviceConfiguration);
      } else if (credentials.xsappname && credentials.uaadomain == null) {
        return new XsaService(credentials, serviceConfiguration);
      } else if (credentials.xsappname == null && credentials.uaadomain) {
        return new UaaService(credentials, serviceConfiguration);
      } else {
        return new IdentityService(credentials, serviceConfiguration);
      }
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/v3/createSecurityContextV3.js
var require_createSecurityContextV33 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/v3/createSecurityContextV3.js"(exports2, module2) {
    var createSecurityContext = require_createSecurityContext3();
    var ConfigurationError = require_ConfigurationError3();
    var { getLogger } = require_logging3();
    var XsuaaService = require_XsuaaService3();
    var IdentityService = require_IdentityService3();
    var UaaService = require_IdentityService3();
    var createServiceFromCredentials = require_createService3();
    var ValidationError = require_ValidationError3();
    var XsaService = require_XsaService3();
    var LOG = getLogger("createSecurityContextV3.js");
    async function createSecurityContextV3(jwt, configParameter, forceType, cb) {
      if (typeof forceType === "function") {
        cb = forceType;
        forceType = null;
      }
      if (cb == null || typeof cb !== "function") {
        throw new ConfigurationError("The callback parameter must be a function.");
      }
      let securityContext;
      try {
        if (configParameter == null) {
          throw new ConfigurationError("The configParameter parameter must not be null or undefined.");
        } else if (jwt == null) {
          throw new ConfigurationError("The jwt parameter must not be null or undefined.");
        }
        const contextConfig = buildContextConfig(configParameter, jwt);
        const serviceConfig = buildServiceConfig(configParameter);
        const services = buildServices(contextConfig.credentials, forceType, serviceConfig);
        securityContext = await createSecurityContext(services, contextConfig);
      } catch (error) {
        if (error instanceof ValidationError) {
          return cb(error, null, { isValid: () => false, getErrorObject: () => error });
        }
        return cb(error);
      }
      return cb(null, securityContext, securityContext.token);
    }
    function buildContextConfig(configParameter, jwt) {
      const contextConfig = configParameter.credentials ? configParameter : { credentials: configParameter };
      contextConfig.jwt = jwt;
      contextConfig.correlationId ??= contextConfig.credentials.correlationId;
      contextConfig.clientCertificatePem ??= contextConfig.x509Certificate ?? contextConfig.credentials.x509Certificate;
      return contextConfig;
    }
    function buildServiceConfig(configParameter) {
      const serviceConfig = {};
      serviceConfig.endpoints ??= configParameter.endpoints || {};
      serviceConfig.validation ??= configParameter.validation || {};
      serviceConfig.validation.x5t ??= {};
      serviceConfig.validation.x5t.enabled ??= configParameter.x5tValidation;
      serviceConfig.validation.jwks ??= configParameter.jwksCache || {};
      serviceConfig.validation.jwks.shared = true;
      if (configParameter.disableCache) {
        LOG.warn(`The 'disableCache' option to disable the JWKS cache is not supported by the v3 compatibility package. The cache is always enabled.`);
      }
      return serviceConfig;
    }
    function buildServices(credentials, forceType, serviceConfig) {
      const credentialsArray = Array.isArray(credentials) ? credentials : [credentials];
      insertXsAppnameFromEnv(credentialsArray);
      if (forceType) {
        LOG.info(`forceType === ${forceType}. Creating ${forceType} service(s) from credentials.`);
      }
      switch (forceType) {
        case "XSUAA":
          return credentialsArray.map((c) => new XsuaaService(c, serviceConfig));
        case "XSA":
          return credentialsArray.map((c) => new XsaService(c, serviceConfig));
        case "IAS":
          return credentialsArray.map((c) => new IdentityService(c, serviceConfig));
        case "UAA":
          return credentialsArray.map((c) => new UaaService(c, serviceConfig));
        case null:
        case void 0:
        default:
          return credentialsArray.map((c) => createServiceFromCredentials(c, serviceConfig));
      }
    }
    function insertXsAppnameFromEnv(credentials) {
      if (process.env.XSAPPNAME) {
        for (const c of credentials) {
          c.xsappname = process.env.XSAPPNAME;
        }
      }
    }
    module2.exports = createSecurityContextV3;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/v3/requestsV3.js
var require_requestsV33 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/v3/requestsV3.js"(exports2, module2) {
    var IdentityService = require_IdentityService3();
    var XsuaaService = require_XsuaaService3();
    async function requestClientCredentialsToken(subdomain, config, additionalAttributes, zoneId, cb) {
      if (typeof zoneId === "function") {
        cb = zoneId;
        zoneId = null;
      }
      const credentials = config.credentials ?? config;
      const service = config.type?.toUpperCase() === "IAS" ? new IdentityService(credentials) : new XsuaaService(credentials);
      const options = {
        authorities: additionalAttributes,
        correlationId: config.correlationId,
        resource: config.resource,
        scope: config.scopes,
        tenant: subdomain,
        timeout: config.timeout,
        app_tid: zoneId
      };
      try {
        const response = await service.fetchClientCredentialsToken(options);
        return cb(null, response.access_token, response);
      } catch (e) {
        return cb(e);
      }
    }
    async function requestPasswordUserToken(subdomain, config, additionalAttributes, cb) {
      const credentials = config.credentials ?? config;
      const service = config.type?.toUpperCase() === "IAS" ? new IdentityService(credentials) : new XsuaaService(credentials);
      const options = {
        authorities: additionalAttributes,
        correlationId: config.correlationId,
        resource: config.resource,
        scope: config.scopes,
        tenant: subdomain,
        timeout: config.timeout
      };
      try {
        const response = await service.fetchPasswordToken(config.username, config.password, options);
        return cb(null, config.type?.toUpperCase() === "IAS" ? response.id_token : response.access_token, response);
      } catch (e) {
        return cb(e);
      }
    }
    async function requestUserToken(appToken, config, additionalAttributes, scopes, subdomain, zoneId, cb) {
      if (typeof zoneId === "function") {
        cb = zoneId;
        zoneId = null;
      }
      const credentials = config.credentials ?? config;
      const service = config.type?.toUpperCase() === "IAS" ? new IdentityService(credentials) : new XsuaaService(credentials);
      const options = {
        authorities: additionalAttributes,
        correlationId: config.correlationId,
        resource: config.resource,
        scope: scopes ?? config.scopes,
        tenant: subdomain,
        timeout: config.timeout,
        app_tid: zoneId,
        zid: zoneId
      };
      try {
        const response = await service.fetchJwtBearerToken(appToken, options);
        return cb(null, config.type?.toUpperCase() === "IAS" ? response.id_token : response.access_token, response);
      } catch (e) {
        return cb(e);
      }
    }
    module2.exports = {
      requestClientCredentialsToken,
      requestPasswordUserToken,
      requestUserToken
    };
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/v3/constantsV3.js
var require_constantsV33 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/v3/constantsV3.js"(exports2) {
    Object.defineProperty(exports2, "XSAPPNAMEPREFIX", {
      value: "$XSAPPNAME.",
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "SYSTEM", {
      value: "System",
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "JOBSCHEDULER", {
      value: "JobScheduler",
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "HDB", {
      value: "HDB",
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "GRANTTYPE_AUTHCODE", {
      value: "authorization_code",
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "GRANTTYPE_PASSWORD", {
      value: "password",
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "GRANTTYPE_CLIENTCREDENTIAL", {
      value: "client_credentials",
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "GRANTTYPE_USERTOKEN", {
      value: "user_token",
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "GRANTTYPE_SAML2BEARER", {
      value: "urn:ietf:params:oauth:grant-type:saml2-bearer",
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "TYPE_USER_TOKEN", {
      value: 0,
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "TYPE_CLIENT_CREDENTIALS_TOKEN", {
      value: 1,
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "USER_AGENT", {
      value: "nodejs-xssec-3",
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "FWD_CLIENT_CERT_HEADER", {
      value: "x-forwarded-client-cert",
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "CNF_X5T_CLAIM", {
      value: "x5t#S256",
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "PEM_HEADER", {
      value: "-----BEGIN CERTIFICATE-----",
      enumerable: true,
      writable: false,
      configurable: false
    });
    Object.defineProperty(exports2, "PEM_FOOTER", {
      value: "-----END CERTIFICATE-----",
      enumerable: true,
      writable: false,
      configurable: false
    });
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/v3/XssecPassportStrategyV3.js
var require_XssecPassportStrategyV33 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/v3/XssecPassportStrategyV3.js"(exports2, module2) {
    "use strict";
    var createSecurityContext = require_createSecurityContextV33();
    var { getLogger } = require_logging3();
    var { FWD_CLIENT_CERT_HEADER } = require_constantsV33();
    var LOG = getLogger("XssecPassportStrategyV3.js");
    function JWTStrategy(options, forceType) {
      this.options = options;
      this.name = "JWT";
      this._forceType = forceType;
    }
    function SimpleError(errorStr) {
      const errobj = new Error(errorStr);
      this.getErrorObject = function() {
        return errobj;
      };
    }
    JWTStrategy.prototype.authenticate = function(req, passportOptions) {
      var authorization = req.headers.authorization;
      const authParams = passportOptions;
      if (!authorization) {
        LOG.debug("Missing Authorization header");
        req.tokenInfo = new SimpleError("Missing Authorization header");
        return this.fail(401);
      }
      var parts = authorization.split(" ");
      if (parts.length < 2) {
        LOG.debug("Invalid Authorization header format");
        req.tokenInfo = new SimpleError("Invalid Authorization header format");
        return this.fail(400);
      }
      var scheme = parts[0];
      var token = parts[1];
      if (scheme.toLowerCase() !== "bearer") {
        LOG.debug("Authorization header is not a Bearer token");
        req.tokenInfo = new SimpleError("Authorization header is not a Bearer token");
        return this.fail(401);
      }
      const correlationId = req.headers["x-correlationid"] || req.headers["x-vcap-request-id"];
      const x509Certificate = req.headers[FWD_CLIENT_CERT_HEADER];
      try {
        let callback = function(err, ctx, tokenInfo) {
          req.tokenInfo = tokenInfo;
          if (err) {
            if (!req.tokenInfo) {
              req.tokenInfo = new SimpleError(err.toString());
            }
            return err.statuscode ? self2.fail(err.statuscode, err) : self2.error(err);
          }
          if (authParams && authParams.scope) {
            var scopes = Array.isArray(authParams.scope) ? authParams.scope : [authParams.scope];
            for (var scope of scopes) {
              if (!ctx.checkScope(self2.options.xsappname + "." + scope)) {
                return self2.fail(403);
              }
            }
          }
          var jwtLogonName = ctx.getLogonName();
          var jwtGivenName = ctx.getGivenName();
          var jwtFamilyName = ctx.getFamilyName();
          var jwtEmail = ctx.getEmail();
          var user = !jwtLogonName ? {} : {
            id: jwtLogonName,
            name: {
              givenName: jwtGivenName,
              familyName: jwtFamilyName
            },
            emails: [{ value: jwtEmail }]
          };
          self2.success(user, ctx);
        };
        var self2 = this;
        var paramA = this._forceType ? this._forceType : callback;
        var paramB = this._forceType ? callback : void 0;
        const config = { ...passportOptions, credentials: this.options, correlationId };
        if (x509Certificate) {
          config.x509Certificate = x509Certificate;
        }
        createSecurityContext(token, config, paramA, paramB);
      } catch (err) {
        LOG.error("JWT verification error: ", err);
        this.error(err);
      }
    };
    JWTStrategy.JWTStrategy = JWTStrategy;
    module2.exports = JWTStrategy;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/v3/index.js
var require_v33 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/v3/index.js"(exports2, module2) {
    var createSecurityContext = require_createSecurityContextV33();
    var requests = require_requestsV33();
    var constants = require_constantsV33();
    var TokenInfo = require_Token3();
    var JWTStrategy = require_XssecPassportStrategyV33();
    module2.exports = {
      createSecurityContext,
      requests,
      constants,
      TokenInfo,
      JWTStrategy
    };
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/util/Types.js
var require_Types3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/util/Types.js"(exports2, module2) {
    module2.exports = {};
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/context/SecurityContextSymbol.js
var require_SecurityContextSymbol3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/context/SecurityContextSymbol.js"(exports2, module2) {
    var SECURITY_CONTEXT = Symbol("XSSEC_SECURITY_CONTEXT");
    module2.exports = SECURITY_CONTEXT;
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/index.js
var require_src4 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap/xssec/src/index.js"(exports2, module2) {
    var createSecurityContext = require_createSecurityContext3();
    var SecurityContext = require_SecurityContext3();
    var IdentityServiceSecurityContext = require_IdentityServiceSecurityContext3();
    var XsuaaSecurityContext = require_XsuaaSecurityContext3();
    var XsaSecurityContext = require_XsaSecurityContext3();
    var UaaSecurityContext = require_UaaSecurityContext3();
    var Service = require_Service3();
    var IdentityService = require_IdentityService3();
    var XsuaaService = require_XsuaaService3();
    var XsaService = require_XsaService3();
    var UaaService = require_UaaService3();
    var XssecPassportStrategy = require_XssecPassportStrategy3();
    var Token = require_Token3();
    var IdentityServiceToken = require_IdentityServiceToken3();
    var XsuaaToken = require_XsuaaToken3();
    var XsaToken = require_XsaToken3();
    var UaaToken = require_UaaToken3();
    var errors = require_error3();
    var constants = require_constants4();
    var v3 = require_v33();
    var Types = require_Types3();
    var SECURITY_CONTEXT = require_SecurityContextSymbol3();
    module2.exports = {
      createSecurityContext,
      SecurityContext,
      IdentityServiceSecurityContext,
      XsuaaSecurityContext,
      XsaSecurityContext,
      UaaSecurityContext,
      Service,
      IdentityService,
      XsuaaService,
      XsaService,
      UaaService,
      XssecPassportStrategy,
      Token,
      IdentityServiceToken,
      XsuaaToken,
      XsaToken,
      UaaToken,
      errors,
      constants,
      v3,
      Types,
      SECURITY_CONTEXT
    };
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/environment-accessor/xsuaa.js
var require_xsuaa3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/environment-accessor/xsuaa.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getXsuaaServiceCredentials = getXsuaaServiceCredentials;
    exports2.clearXsuaaServices = clearXsuaaServices;
    exports2.getXsuaaService = getXsuaaService;
    var xssec_1 = require_src4();
    var service_credentials_1 = require_service_credentials3();
    function getXsuaaServiceCredentials(token) {
      const credentials = (0, service_credentials_1.getServiceCredentials)("xsuaa", token);
      if (!credentials) {
        throw new Error(token ? "Could not find XSUAA service binding matching the token." : "Could not find XSUAA service binding.");
      }
      return credentials;
    }
    var xsuaaServices = {};
    function clearXsuaaServices() {
      Object.keys(xsuaaServices).forEach((key) => delete xsuaaServices[key]);
    }
    function getXsuaaService(options) {
      const credentials = options?.credentials || getXsuaaServiceCredentials(options?.jwt);
      const disableCache = !!options?.disableCache;
      const serviceConfig = disableCache ? {
        validation: {
          jwks: {
            expirationTime: 0,
            refreshPeriod: 0
          }
        }
      } : void 0;
      const cacheKey = `${credentials.clientid}:${disableCache}`;
      if (!xsuaaServices[cacheKey]) {
        xsuaaServices[cacheKey] = new xssec_1.XsuaaService(credentials, serviceConfig);
      }
      return xsuaaServices[cacheKey];
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/environment-accessor/index.js
var require_environment_accessor3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/environment-accessor/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_destination8(), exports2);
    __exportStar(require_service_bindings3(), exports2);
    __exportStar(require_environment_accessor_types3(), exports2);
    __exportStar(require_service_credentials3(), exports2);
    __exportStar(require_xsuaa3(), exports2);
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/jwt/binding.js
var require_binding3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/jwt/binding.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeOrMakeJwt = decodeOrMakeJwt;
    exports2.getTenantIdFromBinding = getTenantIdFromBinding;
    var environment_accessor_1 = require_environment_accessor3();
    var jwt_1 = require_jwt5();
    function decodeOrMakeJwt(jwt) {
      if (jwt) {
        const decodedJwt = typeof jwt === "string" ? (0, jwt_1.decodeJwt)(jwt) : jwt;
        if ((0, jwt_1.getTenantId)(decodedJwt)) {
          return decodedJwt;
        }
      }
      const providerTenantId = getTenantIdFromBinding();
      if (providerTenantId) {
        return { zid: providerTenantId };
      }
    }
    function getTenantIdFromBinding() {
      return (0, environment_accessor_1.getServiceCredentials)("xsuaa")?.tenantid || (0, environment_accessor_1.getServiceCredentials)("identity")?.app_tid || (0, environment_accessor_1.getServiceCredentials)("destination")?.tenantid;
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/jwt/verify.js
var require_verify4 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/jwt/verify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.verifyJwt = verifyJwt;
    var xssec_1 = require_src4();
    var util_1 = require_dist11();
    var environment_accessor_1 = require_environment_accessor3();
    async function verifyJwt(jwt, options) {
      const disableCache = !{ ...defaultVerifyJwtOptions, ...options }.cacheVerificationKeys;
      const xsuaaService = (0, environment_accessor_1.getXsuaaService)({ disableCache, jwt });
      const { token } = await (0, xssec_1.createSecurityContext)(xsuaaService, {
        jwt
      }).catch((e) => {
        throw new util_1.ErrorWithCause("Failed to verify JWT.", e);
      });
      return token.payload;
    }
    var defaultVerifyJwtOptions = {
      cacheVerificationKeys: true
    };
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/jwt/index.js
var require_jwt6 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/jwt/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_binding3(), exports2);
    __exportStar(require_jwt5(), exports2);
    __exportStar(require_verify4(), exports2);
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-cache.js
var require_destination_cache3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-cache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.destinationCache = exports2.DestinationCache = exports2.DefaultDestinationCache = void 0;
    exports2.getDestinationCacheKey = getDestinationCacheKey;
    exports2.setDestinationCache = setDestinationCache;
    exports2.getDefaultIsolationStrategy = getDefaultIsolationStrategy;
    var util_1 = require_dist11();
    var jwt_1 = require_jwt6();
    var async_cache_1 = require_async_cache3();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "destination-cache"
    });
    var DefaultDestinationCache = class extends async_cache_1.AsyncCache {
      constructor(defaultValidityTime = 0) {
        super(defaultValidityTime);
      }
    };
    exports2.DefaultDestinationCache = DefaultDestinationCache;
    var DestinationCache = (cache = new DefaultDestinationCache(3e5)) => ({
      retrieveDestinationFromCache: async (token, name, isolation) => cache.get(getDestinationCacheKey(token, name, isolation)),
      cacheRetrievedDestination: async (token, destination, isolation) => {
        cacheRetrievedDestination(token, destination, isolation, cache);
      },
      cacheRetrievedDestinations: async (token, retrievedDestinations, isolation) => {
        retrievedDestinations.subaccount.forEach((dest) => cacheRetrievedDestination(token, dest, isolation, cache));
        retrievedDestinations.instance.forEach((dest) => cacheRetrievedDestination(token, dest, isolation, cache));
      },
      clear: async () => {
        cache.clear();
      },
      getCacheInstance: () => cache
    });
    exports2.DestinationCache = DestinationCache;
    function getJwtForTenant(token) {
      return token?.serviceJwt?.decoded || token;
    }
    function getJwtForUser(token) {
      return token?.userJwt?.decoded || token;
    }
    function getDestinationCacheKey(token, destinationName, isolationStrategy = "tenant-user") {
      if (isolationStrategy === "tenant") {
        return getTenantCacheKey(destinationName, (0, jwt_1.getTenantId)(getJwtForTenant(token)));
      }
      if (isolationStrategy === "tenant-user") {
        return getTenantUserCacheKey(destinationName, (0, jwt_1.getTenantId)(getJwtForTenant(token)), (0, jwt_1.userId)(getJwtForUser(token)));
      }
      logger8.warn(`Could not build destination cache key. Isolation strategy '${isolationStrategy}' is not supported.`);
    }
    function getTenantCacheKey(destinationName, tenant) {
      if (tenant) {
        return `${tenant}::${destinationName}`;
      }
      logger8.warn("Could not build destination cache key. Isolation strategy 'tenant' is used, but tenant ID is undefined in JWT.");
    }
    function getTenantUserCacheKey(destinationName, tenant, user) {
      if (tenant && user) {
        return `${user}:${tenant}:${destinationName}`;
      }
      logger8.warn("Could not build destination cache key. Isolation strategy 'tenant-user' is used, but tenant id or user id is undefined in JWT.");
    }
    async function cacheRetrievedDestination(token, destination, isolation, cache) {
      if (!destination.name) {
        throw new Error("The destination name is undefined.");
      }
      const key = getDestinationCacheKey(token, destination.name, isolation);
      const expiresIn = (0, util_1.first)(destination.authTokens || [])?.expiresIn;
      const expirationTime = expiresIn ? Date.now() + parseInt(expiresIn) * 1e3 : void 0;
      cache.set(key, { entry: destination, expires: expirationTime });
    }
    function setDestinationCache(cache) {
      exports2.destinationCache = (0, exports2.DestinationCache)(cache);
    }
    exports2.destinationCache = (0, exports2.DestinationCache)();
    function getDefaultIsolationStrategy(jwt) {
      return jwt && (0, jwt_1.userId)(jwt) ? "tenant-user" : "tenant";
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/register-destination-cache.js
var require_register_destination_cache3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/register-destination-cache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.registerDestinationCache = exports2.RegisterDestinationCache = void 0;
    var promises_1 = require("fs/promises");
    var crypto_1 = require("crypto");
    var util_1 = require_dist11();
    var async_cache_1 = require_async_cache3();
    var destination_cache_1 = require_destination_cache3();
    var logger8 = (0, util_1.createLogger)("register-destination-cache");
    var DefaultMtlsCache = class extends async_cache_1.AsyncCache {
      constructor(defaultValidityTime = 3e5) {
        super(defaultValidityTime);
      }
    };
    var MtlsCache = (mtlsCache = new DefaultMtlsCache()) => {
      const that = {
        useMtlsCache: false,
        retrieveMtlsOptionsFromCache: async () => mtlsCache.get("mtlsOptions"),
        cacheMtlsOptions: async () => {
          const getCert = (0, promises_1.readFile)(process.env.CF_INSTANCE_CERT, "utf8");
          const getKey = (0, promises_1.readFile)(process.env.CF_INSTANCE_KEY, "utf8");
          const [cert, key] = await Promise.all([getCert, getKey]);
          mtlsCache.set("mtlsOptions", {
            entry: { cert, key },
            expires: getCertExpirationDate(cert)
          });
        },
        getMtlsOptions: async () => {
          let mtlsOptions = await that.retrieveMtlsOptionsFromCache();
          if (!mtlsOptions) {
            await that.cacheMtlsOptions();
            mtlsOptions = await that.retrieveMtlsOptionsFromCache();
            if (!mtlsOptions) {
              logger8.warn("Neither the previous nor the current mtls certificate is valid anymore.");
            }
          }
          return mtlsOptions || {};
        },
        clear: async () => mtlsCache.clear(),
        getCacheInstance: () => mtlsCache
      };
      return that;
    };
    function getCertExpirationDate(cert) {
      return Number(new crypto_1.X509Certificate(cert).validTo);
    }
    var RegisterDestinationCache = () => ({
      destination: (0, destination_cache_1.DestinationCache)(new destination_cache_1.DefaultDestinationCache(0)),
      mtls: MtlsCache()
    });
    exports2.RegisterDestinationCache = RegisterDestinationCache;
    exports2.registerDestinationCache = (0, exports2.RegisterDestinationCache)();
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/http-agent/http-agent.js
var require_http_agent5 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/http-agent/http-agent.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getAgentConfig = getAgentConfig;
    exports2.urlAndAgent = urlAndAgent;
    var promises_1 = require("fs/promises");
    var http_1 = __importDefault(require("http"));
    var https_1 = __importDefault(require("https"));
    var util_1 = require_dist11();
    var get_protocol_1 = require_get_protocol3();
    var http_proxy_util_1 = require_http_proxy_util3();
    var register_destination_cache_1 = require_register_destination_cache3();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "http-agent"
    });
    async function getAgentConfig(destination) {
      const certificateOptions = {
        ...getTrustStoreOptions(destination),
        ...getKeyStoreOptions(destination),
        ...await getMtlsOptions(destination)
      };
      return createAgent(destination, certificateOptions);
    }
    function getTrustStoreOptions(destination) {
      if ((0, get_protocol_1.getProtocolOrDefault)(destination) === "http") {
        if (destination.isTrustingAllCertificates) {
          logger8.warn('"isTrustingAllCertificates" is not available for HTTP.');
        }
        if (destination.trustStoreCertificate) {
          logger8.warn('"trustStore" is not available for HTTP.');
        }
        return {};
      }
      if (destination.isTrustingAllCertificates && destination.trustStoreCertificate) {
        logger8.warn(`Destination ${destination.name} contains the 'trustAll' and 'trustStoreLocation' property which is a redundant setup.`);
      }
      if (destination.isTrustingAllCertificates) {
        logger8.warn('"isTrustingAllCertificates" property in the provided destination is set to "true". This is highly discouraged in production.');
        return { rejectUnauthorized: !destination.isTrustingAllCertificates };
      }
      if (destination.trustStoreCertificate) {
        const decoded = Buffer.from(destination.trustStoreCertificate.content, "base64").toString("utf8");
        return {
          rejectUnauthorized: true,
          ca: [decoded]
        };
      }
      return { rejectUnauthorized: true };
    }
    function getKeyStoreOptions(destination) {
      if (
        // Only add certificates, when using ClientCertificateAuthentication (https://github.com/SAP/cloud-sdk-js/issues/3544)
        destination.authentication === "ClientCertificateAuthentication" && !mtlsIsEnabled(destination) && destination.keyStoreName
      ) {
        const certificate = selectCertificate(destination);
        validateFormat(certificate);
        logger8.debug(`Certificate with name "${certificate.name}" selected.`);
        if (!destination.keyStorePassword) {
          logger8.debug(`Destination '${destination.name}' does not have a keystore password.`);
        }
        const certBuffer = Buffer.from(certificate.content, "base64");
        if (getFormat(certificate) === "pem") {
          return {
            cert: certBuffer,
            key: certBuffer,
            passphrase: destination.keyStorePassword
          };
        }
        return {
          pfx: certBuffer,
          passphrase: destination.keyStorePassword
        };
      }
      return {};
    }
    async function getMtlsOptions(destination) {
      if (destination.mtls && !(process.env.CF_INSTANCE_CERT && process.env.CF_INSTANCE_KEY)) {
        logger8.warn(`Destination ${destination.name ? destination.name : ""} has mTLS enabled, but the required Cloud Foundry environment variables (CF_INSTANCE_CERT and CF_INSTANCE_KEY) are not defined. Note that 'inferMtls' only works on Cloud Foundry.`);
      }
      if (mtlsIsEnabled(destination)) {
        if (register_destination_cache_1.registerDestinationCache.mtls.useMtlsCache) {
          return register_destination_cache_1.registerDestinationCache.mtls.getMtlsOptions();
        }
        const getCert = (0, promises_1.readFile)(process.env.CF_INSTANCE_CERT, "utf8");
        const getKey = (0, promises_1.readFile)(process.env.CF_INSTANCE_KEY, "utf8");
        const [cert, key] = await Promise.all([getCert, getKey]);
        return {
          cert,
          key
        };
      }
      return {};
    }
    function mtlsIsEnabled(destination) {
      return destination.mtls && process.env.CF_INSTANCE_CERT && process.env.CF_INSTANCE_KEY;
    }
    var supportedCertificateFormats = ["p12", "pfx", "pem"];
    function isSupportedFormat(format) {
      return !!format && supportedCertificateFormats.includes(format);
    }
    function selectCertificate(destination) {
      const certificate = destination.certificates.find((c) => c.name === destination.keyStoreName);
      if (!certificate) {
        throw Error(`No certificate with name ${destination.keyStoreName} could be found on the destination!`);
      }
      return certificate;
    }
    function getFormat(certificate) {
      return (0, util_1.last)(certificate.name.split("."));
    }
    function validateFormat(certificate) {
      const format = getFormat(certificate);
      if (!isSupportedFormat(format)) {
        throw Error(`The format of the provided certificate '${certificate.name}' is not supported. Supported formats are: ${supportedCertificateFormats.join(", ")}. ${format && ["jks", "keystore"].includes(format) ? "You can convert Java Keystores (.jks, .keystore) into PKCS#12 keystores using the JVM's keytool CLI: keytool -importkeystore -srckeystore your-keystore.jks -destkeystore your-keystore.p12 -deststoretype pkcs12" : ""}`);
      }
    }
    function createAgent(destination, options) {
      return (0, get_protocol_1.getProtocolOrDefault)(destination) === "https" ? { httpsAgent: new https_1.default.Agent(options) } : { httpAgent: new http_1.default.Agent(options) };
    }
    async function urlAndAgent(targetUri) {
      let destination = { url: targetUri, proxyType: "Internet" };
      if ((0, http_proxy_util_1.proxyStrategy)(destination) === "internet") {
        destination = (0, http_proxy_util_1.addProxyConfigurationInternet)(destination);
      }
      return {
        baseURL: destination.url,
        ...await getAgentConfig(destination),
        proxy: (0, http_proxy_util_1.getProxyConfig)(destination)
      };
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/http-agent/index.js
var require_http_agent6 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/http-agent/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_agent_config3(), exports2);
    __exportStar(require_http_agent5(), exports2);
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/client-credentials-token-cache.js
var require_client_credentials_token_cache3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/client-credentials-token-cache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.clientCredentialsTokenCache = void 0;
    exports2.getCacheKey = getCacheKey2;
    var util_1 = require_dist11();
    var cache_1 = require_cache4();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "client-credentials-token-cache"
    });
    var ClientCredentialsTokenCache = (cache) => ({
      getToken: (tenantId, clientId) => cache.get(getCacheKey2(tenantId, clientId)),
      cacheToken: (tenantId, clientId, token) => {
        cache.set(getCacheKey2(tenantId, clientId), {
          entry: token,
          expires: token.expires_in ? Date.now() + token.expires_in * 1e3 : void 0
        });
      },
      clear: () => {
        cache.clear();
      },
      getCacheInstance: () => cache
    });
    function getCacheKey2(tenantId, clientId) {
      if (!tenantId) {
        logger8.warn("Cannot create cache key for client credentials token cache. The given tenant ID is undefined.");
        return;
      }
      if (!clientId) {
        logger8.warn("Cannot create cache key for client credentials token cache. The given client ID is undefined.");
        return;
      }
      return [tenantId, clientId].join(":");
    }
    exports2.clientCredentialsTokenCache = ClientCredentialsTokenCache(new cache_1.Cache(
      5 * 60 * 1e3
      /* 5 minutes in ms */
    ));
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/resilience/dist/timeout.js
var require_timeout3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/resilience/dist/timeout.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.timeout = timeout;
    var util_1 = require_dist11();
    var defaultTimeout = 1e4;
    var logger8 = (0, util_1.createLogger)({
      package: "resilience",
      messageContext: "timeout"
    });
    function timeout(timeoutValue = defaultTimeout) {
      if (timeoutValue <= 0) {
        throw new Error("Timeout must be greater than 0.");
      }
      if (timeoutValue < 10) {
        logger8.warn(`The timeout of ${timeoutValue} ms is too low. Make sure this is not intentional.`);
      }
      return function(options) {
        const message = `Request to URL: ${options.context.uri} ran into a timeout after ${timeoutValue}ms.`;
        return (arg) => wrapInTimeout(options.fn(arg), timeoutValue, message);
      };
    }
    function getTimeoutPromise(timeoutValue, message) {
      let timeoutNode;
      const promise = new Promise((resolve, reject) => {
        timeoutNode = setTimeout(() => reject(new Error(message)), timeoutValue);
      });
      return [promise, timeoutNode];
    }
    async function wrapInTimeout(promise, timeoutValue, message) {
      const [timeoutPromise, timeoutInstance] = getTimeoutPromise(timeoutValue, message);
      const withClearTimeout = promise.finally(() => {
        clearTimeout(timeoutInstance);
      });
      return Promise.race([withClearTimeout, timeoutPromise]);
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/resilience/dist/retry.js
var require_retry5 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/resilience/dist/retry.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.retry = retry;
    var util_1 = require_dist11();
    var asyncRetry = __importStar(require_lib());
    var logger8 = (0, util_1.createLogger)({
      package: "resilience",
      messageContext: "retry"
    });
    var defaultRetries = 3;
    function retry(retries = defaultRetries) {
      if (retries < 0) {
        throw new Error("Number of retries must be greater or equal to 0.");
      }
      return function(options) {
        return (arg) => asyncRetry.default(async (bail) => {
          try {
            return await options.fn(arg);
          } catch (error) {
            const status = error?.response?.status;
            if (!status) {
              logger8.debug("HTTP request failed but error did not contain a response status field as expected. Rethrowing error.");
            } else if (status.toString().startsWith("4")) {
              bail(new util_1.ErrorWithCause(`Request failed with status code ${status}`, error));
              return void 0;
            }
            throw error;
          }
        }, { retries });
      };
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/resilience/dist/middleware.js
var require_middleware3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/resilience/dist/middleware.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.executeWithMiddleware = executeWithMiddleware;
    function executeWithMiddleware(middlewares, { fn, context, fnArgument }) {
      if (!middlewares?.length) {
        return fn(fnArgument);
      }
      const initial = { context, fn };
      const functionWithMiddlewares = addMiddlewaresToInitialFunction(middlewares, initial);
      return functionWithMiddlewares(fnArgument);
    }
    function addMiddlewaresToInitialFunction(middlewares, initial) {
      const { context } = initial;
      const functionWithMiddlewares = middlewares.reduceRight((prev, curr) => ({ fn: curr(prev), context }), initial);
      return functionWithMiddlewares.fn;
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/resilience/dist/circuit-breaker.js
var require_circuit_breaker3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/resilience/dist/circuit-breaker.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.circuitBreakerDefaultOptions = exports2.circuitBreakers = void 0;
    exports2.circuitBreaker = circuitBreaker;
    var opossum_1 = __importDefault(require_opossum());
    exports2.circuitBreakers = {};
    exports2.circuitBreakerDefaultOptions = {
      timeout: false,
      errorThresholdPercentage: 50,
      volumeThreshold: 10,
      resetTimeout: 3e4,
      cache: false
    };
    function httpErrorFilter(error) {
      return !!error.response?.status && error.response.status.toString().startsWith("4");
    }
    function circuitBreakerKeyBuilder({ uri, tenantId = "tenant_id" }) {
      return `${uri}::${tenantId}`;
    }
    function circuitBreaker() {
      return circuitBreakerGeneric(circuitBreakerKeyBuilder, httpErrorFilter);
    }
    function circuitBreakerGeneric(keyBuilder, errorFilter) {
      return (options) => (fnArgument) => getCircuitBreaker(keyBuilder(options.context), errorFilter).fire(options.fn, fnArgument);
    }
    function getCircuitBreaker(key, errorFilter) {
      if (!exports2.circuitBreakers[key]) {
        exports2.circuitBreakers[key] = new opossum_1.default(executeFunction, {
          ...exports2.circuitBreakerDefaultOptions,
          errorFilter
        });
      }
      return exports2.circuitBreakers[key];
    }
    function executeFunction(fn, ...parameters) {
      return fn(...parameters);
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/resilience/dist/resilience.js
var require_resilience3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/resilience/dist/resilience.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resilience = resilience;
    var timeout_1 = require_timeout3();
    var retry_1 = require_retry5();
    var circuit_breaker_1 = require_circuit_breaker3();
    var defaultResilienceOptions = {
      retry: false,
      timeout: true,
      circuitBreaker: true
    };
    function resilience(options) {
      const resilienceOption = { ...defaultResilienceOptions, ...options };
      const middlewares = [];
      if (typeof resilienceOption.retry === "number") {
        middlewares.push((0, retry_1.retry)(resilienceOption.retry));
      } else if (resilienceOption.retry) {
        middlewares.push((0, retry_1.retry)());
      }
      if (resilienceOption.circuitBreaker) {
        middlewares.push((0, circuit_breaker_1.circuitBreaker)());
      }
      if (typeof resilienceOption.timeout === "number") {
        middlewares.push((0, timeout_1.timeout)(resilienceOption.timeout));
      } else if (resilienceOption.timeout) {
        middlewares.push((0, timeout_1.timeout)());
      }
      return middlewares;
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/resilience/dist/internal.js
var require_internal11 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/resilience/dist/internal.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_timeout3(), exports2);
    __exportStar(require_retry5(), exports2);
    __exportStar(require_middleware3(), exports2);
    __exportStar(require_circuit_breaker3(), exports2);
    __exportStar(require_resilience3(), exports2);
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/resilience/internal.js
var require_internal12 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/resilience/internal.js"(exports2) {
    "use strict";
    function __export2(m) {
      for (const p in m) {
        if (!exports2.hasOwnProperty(p)) {
          exports2[p] = m[p];
        }
      }
    }
    Object.defineProperty(exports2, "__esModule", { value: true });
    __export2(require_internal11());
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/resilience/dist/index.js
var require_dist12 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/resilience/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resilience = exports2.circuitBreaker = exports2.retry = exports2.timeout = void 0;
    var timeout_1 = require_timeout3();
    Object.defineProperty(exports2, "timeout", { enumerable: true, get: function() {
      return timeout_1.timeout;
    } });
    var retry_1 = require_retry5();
    Object.defineProperty(exports2, "retry", { enumerable: true, get: function() {
      return retry_1.retry;
    } });
    var circuit_breaker_1 = require_circuit_breaker3();
    Object.defineProperty(exports2, "circuitBreaker", { enumerable: true, get: function() {
      return circuit_breaker_1.circuitBreaker;
    } });
    var resilience_1 = require_resilience3();
    Object.defineProperty(exports2, "resilience", { enumerable: true, get: function() {
      return resilience_1.resilience;
    } });
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/xsuaa-service.js
var require_xsuaa_service3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/xsuaa-service.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getClientCredentialsToken = getClientCredentialsToken;
    exports2.getUserToken = getUserToken;
    var internal_1 = require_internal12();
    var resilience_1 = require_dist12();
    var environment_accessor_1 = require_environment_accessor3();
    var jwt_1 = require_jwt6();
    async function getClientCredentialsToken(service, jwt) {
      const decodedJwt = jwt ? (0, jwt_1.decodeJwt)(jwt) : {};
      const fnArgument = {
        subdomain: (0, jwt_1.getSubdomain)(decodedJwt),
        zoneId: (0, jwt_1.getTenantId)(decodedJwt),
        serviceCredentials: (0, environment_accessor_1.resolveServiceBinding)(service).credentials
      };
      const xssecPromise = function(arg) {
        const xsuaaService = (0, environment_accessor_1.getXsuaaService)({
          credentials: arg.serviceCredentials
        });
        return xsuaaService.fetchClientCredentialsToken({
          // tenant is the subdomain, not tenant ID
          tenant: arg.zoneId ? void 0 : arg.subdomain,
          zid: arg.zoneId
        });
      };
      return (0, internal_1.executeWithMiddleware)((0, resilience_1.resilience)(), {
        fn: xssecPromise,
        fnArgument,
        context: {
          uri: fnArgument.serviceCredentials.url,
          tenantId: fnArgument.zoneId ?? fnArgument.serviceCredentials.tenantid
        }
      }).catch((err) => {
        throw new Error(`Could not fetch client credentials token for service of type ${(0, environment_accessor_1.resolveServiceBinding)(service).label}: ${err.message}`);
      });
    }
    function getUserToken(service, userJwt) {
      const decodedUserJwt = (0, jwt_1.decodeJwt)(userJwt);
      const fnArgument = {
        subdomain: (0, jwt_1.getSubdomain)(decodedUserJwt),
        zoneId: (0, jwt_1.getTenantId)(decodedUserJwt),
        serviceCredentials: service.credentials,
        userJwt
      };
      const xssecPromise = function(arg) {
        const xsuaaService = (0, environment_accessor_1.getXsuaaService)({
          credentials: arg.serviceCredentials
        });
        return xsuaaService.fetchJwtBearerToken(arg.userJwt, {
          // tenant is the subdomain, not tenant ID
          tenant: arg.zoneId ? void 0 : arg.subdomain,
          zid: arg.zoneId
        }).then((token) => token.access_token);
      };
      return (0, internal_1.executeWithMiddleware)((0, resilience_1.resilience)(), {
        fn: xssecPromise,
        fnArgument,
        context: {
          uri: service.credentials.url,
          tenantId: fnArgument.zoneId ?? service.credentials.tenantid
        }
      }).catch((err) => {
        throw new Error(`Could not fetch JWT bearer token for service of type ${service.label}: ${err.message}`);
      });
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/token-accessor.js
var require_token_accessor3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/token-accessor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.serviceToken = serviceToken;
    exports2.jwtBearerToken = jwtBearerToken;
    var util_1 = require_dist11();
    var jwt_1 = require_jwt6();
    var client_credentials_token_cache_1 = require_client_credentials_token_cache3();
    var environment_accessor_1 = require_environment_accessor3();
    var xsuaa_service_1 = require_xsuaa_service3();
    async function serviceToken(service, options) {
      const opts = {
        useCache: true,
        enableCircuitBreaker: true,
        ...options
      };
      const serviceBinding = (0, environment_accessor_1.resolveServiceBinding)(service);
      const serviceCredentials = serviceBinding.credentials;
      const tenantForCaching = options?.jwt ? (0, jwt_1.getTenantId)(options.jwt) || (0, jwt_1.getSubdomain)(options.jwt) : (0, jwt_1.getTenantIdFromBinding)() || (0, jwt_1.getDefaultTenantId)();
      if (opts.useCache) {
        const cachedToken = client_credentials_token_cache_1.clientCredentialsTokenCache.getToken(tenantForCaching, serviceCredentials.clientid);
        if (cachedToken) {
          return cachedToken.access_token;
        }
      }
      try {
        const token = await (0, xsuaa_service_1.getClientCredentialsToken)(serviceBinding, options?.jwt);
        if (opts.useCache) {
          client_credentials_token_cache_1.clientCredentialsTokenCache.cacheToken(tenantForCaching, serviceCredentials.clientid, token);
        }
        return token.access_token;
      } catch (err) {
        throw new util_1.ErrorWithCause(`Could not fetch client credentials token for service of type "${serviceBinding.label}".`, err);
      }
    }
    async function jwtBearerToken(jwt, service) {
      const resolvedService = (0, environment_accessor_1.resolveServiceBinding)(service);
      return (0, xsuaa_service_1.getUserToken)(resolvedService, jwt);
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/identity-service.js
var require_identity_service3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/identity-service.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.exchangeToken = exchangeToken;
    exports2.shouldExchangeToken = shouldExchangeToken;
    var jwt_1 = require_jwt6();
    var token_accessor_1 = require_token_accessor3();
    async function exchangeToken(jwt) {
      return (0, token_accessor_1.jwtBearerToken)(jwt, "xsuaa");
    }
    function shouldExchangeToken(options) {
      return options.iasToXsuaaTokenExchange === true && !!options.jwt && !(0, jwt_1.isXsuaaToken)((0, jwt_1.decodeJwt)(options.jwt));
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/forward-auth-token.js
var require_forward_auth_token3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/forward-auth-token.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setForwardedAuthTokenIfNeeded = setForwardedAuthTokenIfNeeded;
    var util_1 = require_dist11();
    var jwt_1 = require_jwt6();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "forward-auth-token"
    });
    function buildDestinationAuthToken(token) {
      const decodedJwt = (0, jwt_1.decodeJwt)(token);
      return [
        {
          value: token,
          expiresIn: decodedJwt.exp?.toString(),
          error: null,
          http_header: { key: "Authorization", value: `Bearer ${token}` },
          type: "Bearer"
        }
      ];
    }
    function validateToken(token) {
      if (!token) {
        logger8.warn("Option 'forwardAuthToken' was set on destination but no token was provided to forward. This is most likely unintended and will lead to an authorization error on request execution.");
      }
      return !!token;
    }
    function setForwardedAuthTokenIfNeeded(destination, token) {
      if (destination.forwardAuthToken) {
        if (validateToken(token)) {
          logger8.debug("Option 'forwardAuthToken' enabled on destination. Using the given token for the destination.");
          destination.authTokens = buildDestinationAuthToken(token);
        }
      }
      return destination;
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-from-env.js
var require_destination_from_env3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-from-env.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getDestinationsFromEnv = getDestinationsFromEnv;
    exports2.getDestinationFromEnvByName = getDestinationFromEnvByName;
    exports2.getDestinationsEnvVariable = getDestinationsEnvVariable;
    exports2.searchEnvVariablesForDestination = searchEnvVariablesForDestination;
    exports2.validateNameAvailable = validateNameAvailable;
    exports2.setDestinationsInEnv = setDestinationsInEnv;
    var util_1 = require_dist11();
    var destination_1 = require_destination7();
    var http_proxy_util_1 = require_http_proxy_util3();
    var destination_service_types_1 = require_destination_service_types3();
    var forward_auth_token_1 = require_forward_auth_token3();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "env-destination-accessor"
    });
    function getDestinationsFromEnv() {
      const destinationsEnv = getDestinationsEnvVariable();
      logger8.debug(`The value for the destination environment variable is: ${destinationsEnv}`);
      if (destinationsEnv) {
        let destinations;
        try {
          destinations = JSON.parse(destinationsEnv);
        } catch (err) {
          throw new util_1.ErrorWithCause("Error in parsing the destinations from the environment variable.", err);
        }
        validateDestinations(destinations);
        return destinations.map((destination) => (0, destination_1.isDestinationConfiguration)(destination) ? (0, destination_1.parseDestination)(destination) : (0, destination_1.sanitizeDestination)(destination));
      }
      return [];
    }
    function getDestinationFromEnvByName(name) {
      const matchingDestinations = getDestinationsFromEnv().filter((dest) => dest.name === name);
      if (!matchingDestinations.length) {
        return null;
      }
      if (matchingDestinations.length > 1) {
        logger8.warn(`The 'destinations' env variable contains multiple destinations with the name '${name}'. Only the first entry will be considered.`);
      }
      return matchingDestinations[0];
    }
    function getDestinationsEnvVariable() {
      return process.env["destinations"];
    }
    function validateDestinations(destinations) {
      destinations.forEach((destination) => {
        if (typeof destination.name === "undefined" && typeof destination.Name === "undefined") {
          logger8.warn("Destination from 'destinations' env variable is missing 'name' or 'Name' property.");
        }
      });
    }
    function searchEnvVariablesForDestination(options) {
      logger8.debug("Attempting to retrieve destination from environment variable.");
      if (getDestinationsEnvVariable()) {
        try {
          const destination = getDestinationFromEnvByName(options.destinationName);
          if (destination) {
            logger8.info(`Successfully retrieved destination '${options.destinationName}' from environment variable.`);
            (0, forward_auth_token_1.setForwardedAuthTokenIfNeeded)(destination, options.jwt);
            return (0, destination_service_types_1.isHttpDestination)(destination) && ["internet", "private-link"].includes((0, http_proxy_util_1.proxyStrategy)(destination)) ? (0, http_proxy_util_1.addProxyConfigurationInternet)(destination) : destination;
          }
        } catch (error) {
          logger8.error(`Error in reading the given destinations from the environment variable ${error.message}.`);
        }
      }
      logger8.debug("No environment variable set.");
      return null;
    }
    function validateNameAvailable(destinationName, existingNames) {
      if (existingNames.has(destinationName)) {
        throw new Error(`Parsing destinations failed, destination with name "${destinationName}" already exists in the "destinations" environment variables.`);
      }
    }
    function setDestinationsInEnv(destinations) {
      process.env.destinations = JSON.stringify(destinations);
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/service-binding-to-destination.js
var require_service_binding_to_destination3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/service-binding-to-destination.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.serviceToDestinationTransformers = void 0;
    exports2.transformServiceBindingToDestination = transformServiceBindingToDestination2;
    exports2.transformServiceBindingToClientCredentialsDestination = transformServiceBindingToClientCredentialsDestination;
    var token_accessor_1 = require_token_accessor3();
    var jwt_1 = require_jwt6();
    exports2.serviceToDestinationTransformers = {
      "business-logging": businessLoggingBindingToDestination,
      "s4-hana-cloud": xfS4hanaCloudBindingToDestination,
      destination: destinationBindingToDestination,
      "saas-registry": saasRegistryBindingToDestination,
      workflow: workflowBindingToDestination,
      "service-manager": serviceManagerBindingToDestination,
      xsuaa: xsuaaToDestination,
      aicore: aicoreToDestination
    };
    async function transformServiceBindingToDestination2(serviceBinding, options) {
      if (exports2.serviceToDestinationTransformers[serviceBinding.label]) {
        return exports2.serviceToDestinationTransformers[serviceBinding.label](serviceBinding, options);
      }
      throw new Error(`The provided service binding of type ${serviceBinding.label} is not supported out of the box for destination transformation.`);
    }
    async function transformServiceBindingToClientCredentialsDestination(service, options) {
      const token = await (0, token_accessor_1.serviceToken)(service, options);
      return buildClientCredentialsDestination(token, options?.url ?? service.url, service.name);
    }
    async function aicoreToDestination(service, options) {
      const token = await (0, token_accessor_1.serviceToken)(service, options);
      return buildClientCredentialsDestination(token, service.credentials.serviceurls.AI_API_URL, service.name);
    }
    async function xsuaaToDestination(service, options) {
      const token = await (0, token_accessor_1.serviceToken)(service, options);
      return buildClientCredentialsDestination(token, service.credentials.apiurl, service.name);
    }
    async function serviceManagerBindingToDestination(service, options) {
      const token = await (0, token_accessor_1.serviceToken)(service, options);
      return buildClientCredentialsDestination(token, service.credentials.sm_url, service.name);
    }
    async function destinationBindingToDestination(service, options) {
      const token = await (0, token_accessor_1.serviceToken)(service, options);
      return buildClientCredentialsDestination(token, service.credentials.uri, service.name);
    }
    async function saasRegistryBindingToDestination(service, options) {
      const token = await (0, token_accessor_1.serviceToken)(service, options);
      return buildClientCredentialsDestination(token, service.credentials["saas_registry_url"], service.name);
    }
    async function businessLoggingBindingToDestination(service, options) {
      const transformedService = {
        ...service,
        credentials: { ...service.credentials.uaa }
      };
      const token = await (0, token_accessor_1.serviceToken)(transformedService, options);
      return buildClientCredentialsDestination(token, service.credentials.writeUrl, service.name);
    }
    async function workflowBindingToDestination(service, options) {
      const transformedService = {
        ...service,
        credentials: { ...service.credentials.uaa }
      };
      const token = await (0, token_accessor_1.serviceToken)(transformedService, options);
      return buildClientCredentialsDestination(token, service.credentials.endpoints.workflow_odata_url, service.name);
    }
    async function xfS4hanaCloudBindingToDestination(service) {
      return {
        url: service.credentials.URL,
        authentication: "BasicAuthentication",
        username: service.credentials.User,
        password: service.credentials.Password
      };
    }
    function buildClientCredentialsDestination(token, url, name) {
      const expirationTime = (0, jwt_1.decodeJwt)(token).exp;
      const expiresIn = expirationTime ? Math.floor((expirationTime * 1e3 - Date.now()) / 1e3).toString(10) : void 0;
      return {
        url,
        name,
        authentication: "OAuth2ClientCredentials",
        authTokens: [
          {
            value: token,
            type: "bearer",
            expiresIn,
            http_header: { key: "Authorization", value: `Bearer ${token}` },
            error: null
          }
        ]
      };
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-from-vcap.js
var require_destination_from_vcap3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-from-vcap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getDestinationFromServiceBinding = getDestinationFromServiceBinding;
    exports2.searchServiceBindingForDestination = searchServiceBindingForDestination;
    var util_1 = require_dist11();
    var jwt_1 = require_jwt6();
    var environment_accessor_1 = require_environment_accessor3();
    var http_proxy_util_1 = require_http_proxy_util3();
    var destination_service_types_1 = require_destination_service_types3();
    var service_binding_to_destination_1 = require_service_binding_to_destination3();
    var forward_auth_token_1 = require_forward_auth_token3();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "destination-accessor-vcap"
    });
    async function getDestinationFromServiceBinding(options) {
      const decodedJwt = options.iss ? { iss: options.iss } : options.jwt ? (0, jwt_1.decodeJwt)(options.jwt) : void 0;
      const retrievalOptions = { ...options, jwt: decodedJwt };
      const destination = await retrieveDestination(retrievalOptions);
      const destWithProxy = destination && (0, destination_service_types_1.isHttpDestination)(destination) && ["internet", "private-link"].includes((0, http_proxy_util_1.proxyStrategy)(destination)) ? (0, http_proxy_util_1.addProxyConfigurationInternet)(destination) : destination;
      if (destWithProxy) {
        (0, forward_auth_token_1.setForwardedAuthTokenIfNeeded)(destWithProxy, options.jwt);
      }
      return destWithProxy;
    }
    async function retrieveDestination({ useCache, jwt, destinationName, serviceBindingTransformFn }) {
      const service = (0, environment_accessor_1.getServiceBindingByInstanceName)(destinationName);
      const destination = await (serviceBindingTransformFn || transform)(service, {
        useCache,
        jwt
      });
      return { name: destinationName, ...destination };
    }
    async function transform(service, options) {
      if (!service_binding_to_destination_1.serviceToDestinationTransformers[service.label]) {
        throw serviceTypeNotSupportedError(service);
      }
      return service_binding_to_destination_1.serviceToDestinationTransformers[service.label](service, options);
    }
    function serviceTypeNotSupportedError(service) {
      return Error(`The service "${service.name}" is of type "${service.label}" which is not supported! Consider providing your own transformation function when calling \`getDestinationFromServiceBinding()\`, like this:
  destinationServiceForBinding(yourServiceName, { serviceBindingToDestination: yourTransformationFunction });`);
    }
    async function searchServiceBindingForDestination(options) {
      logger8.debug("Attempting to retrieve destination from service binding.");
      try {
        const destination = await getDestinationFromServiceBinding(options);
        logger8.info("Successfully retrieved destination from service binding.");
        return destination;
      } catch (error) {
        logger8.debug(`Could not retrieve destination from service binding. If you are not using SAP Extension Factory, this information probably does not concern you. ${error.message}`);
      }
      return null;
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/connectivity-service.js
var require_connectivity_service3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/connectivity-service.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addProxyConfigurationOnPrem = addProxyConfigurationOnPrem;
    exports2.httpProxyHostAndPort = httpProxyHostAndPort;
    exports2.socksProxyHostAndPort = socksProxyHostAndPort;
    var util_1 = require_dist11();
    var environment_accessor_1 = require_environment_accessor3();
    var token_accessor_1 = require_token_accessor3();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "connectivity-service"
    });
    async function addProxyConfigurationOnPrem(destination, subscriberToken) {
      if (destination.type === "MAIL") {
        return {
          ...destination,
          proxyConfiguration: await socksProxyHostAndPort(subscriberToken?.userJwt.decoded)
        };
      }
      const proxyConfiguration = {
        ...httpProxyHostAndPort(),
        headers: {
          ...await proxyHeaders(destination.authentication, subscriberToken)
        }
      };
      return { ...destination, proxyConfiguration };
    }
    function httpProxyHostAndPort() {
      const service = readConnectivityServiceBinding();
      return {
        host: service.credentials.onpremise_proxy_host,
        port: service.credentials.onpremise_proxy_http_port || service.credentials.onpremise_proxy_port,
        protocol: "http"
      };
    }
    async function socksProxyHostAndPort(userJwt) {
      const service = readConnectivityServiceBinding();
      const connectivityServiceToken = await (0, token_accessor_1.serviceToken)(service, {
        jwt: userJwt
      });
      return {
        host: service.credentials.onpremise_proxy_host,
        port: parseInt(service.credentials.onpremise_socks5_proxy_port),
        protocol: "socks",
        "proxy-authorization": connectivityServiceToken
      };
    }
    function readConnectivityServiceBinding() {
      const serviceBindings = (0, environment_accessor_1.getServiceBindings)("connectivity");
      if (!serviceBindings.length) {
        throw new Error("No binding to a connectivity service found! Please make sure to bind an instance of the connectivity service to your app if you want to connect to on-premise destinations.");
      }
      return serviceBindings[0];
    }
    async function proxyHeaders(authenticationType, subscriberToken) {
      const proxyAuthHeader = await proxyAuthorizationHeader(subscriberToken?.serviceJwt.encoded);
      const sapConnectivityHeader = sapConnectivityAuthenticationHeader(authenticationType, subscriberToken?.userJwt.encoded);
      return {
        ...proxyAuthHeader,
        ...sapConnectivityHeader
      };
    }
    async function proxyAuthorizationHeader(jwt) {
      try {
        const connServiceBinding = readConnectivityServiceBinding();
        const token = await (0, token_accessor_1.serviceToken)(connServiceBinding, { jwt });
        return { "Proxy-Authorization": `Bearer ${token}` };
      } catch (error) {
        throw new util_1.ErrorWithCause("Failed to add proxy authorization header - client credentials grant failed!", error);
      }
    }
    function sapConnectivityAuthenticationHeader(authenticationType, jwt) {
      if (authenticationType === "PrincipalPropagation") {
        if (jwt) {
          return {
            "SAP-Connectivity-Authentication": `Bearer ${jwt}`
          };
        }
        throw new Error(`Unable to create "SAP-Connectivity-Authentication" header: no JWT found on the current request.
     Connecting to on-premise systems via principle propagation is not possible.`);
      }
      if (authenticationType === "BasicAuthentication") {
        logger8.warn("You are connecting to an On-Premise system using basic authentication. For productive usage Principal propagation is recommended.");
      }
      return {};
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/tenant.js
var require_tenant3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/tenant.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isIdenticalTenant = isIdenticalTenant;
    var jwt_1 = require_jwt6();
    function isIdenticalTenant(userTokenPayload, providerTokenPayload) {
      return (0, jwt_1.getTenantId)(userTokenPayload) === (0, jwt_1.getTenantId)(providerTokenPayload);
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-selection-strategies.js
var require_destination_selection_strategies3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-selection-strategies.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DestinationSelectionStrategies = void 0;
    exports2.alwaysProvider = alwaysProvider;
    exports2.alwaysSubscriber = alwaysSubscriber;
    exports2.subscriberFirst = subscriberFirst;
    var util_1 = require_dist11();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "destination-selection-strategies"
    });
    function alwaysProvider(allDestinations, destinationName) {
      return findDestination(allDestinations.provider, destinationName) || null;
    }
    function alwaysSubscriber(allDestinations, destinationName) {
      return findDestination(allDestinations.subscriber, destinationName) || null;
    }
    function subscriberFirst(allDestinations, destinationName) {
      return findDestination(allDestinations.subscriber, destinationName) || findDestination(allDestinations.provider, destinationName) || null;
    }
    exports2.DestinationSelectionStrategies = {
      alwaysProvider,
      alwaysSubscriber,
      subscriberFirst
    };
    function findDestination(destinations, destinationName) {
      const isRequestedDestination = (destination) => destination.name === destinationName;
      const instanceDest = destinations.instance.find(isRequestedDestination);
      const subAccountDest = destinations.subaccount.find(isRequestedDestination);
      if (instanceDest && subAccountDest) {
        logger8.warn(`Found destinations named '${destinationName}' for both, the destination service instance and subaccount. Using instance destination.`);
      }
      return instanceDest || subAccountDest;
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-service-cache.js
var require_destination_service_cache3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-service-cache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.destinationServiceCache = void 0;
    var cache_1 = require_cache4();
    var destination_cache_1 = require_destination_cache3();
    var DestinationServiceCache = (cache) => ({
      retrieveDestinationsFromCache: (targetUrl, decodedJwt) => cache.get((0, destination_cache_1.getDestinationCacheKey)(decodedJwt, targetUrl, "tenant")),
      cacheRetrievedDestinations: (destinationServiceUri, decodedJwt, destinations) => {
        const key = (0, destination_cache_1.getDestinationCacheKey)(decodedJwt, destinationServiceUri, "tenant");
        cache.set(key, { entry: destinations });
      },
      clear: () => {
        cache.clear();
      },
      getCacheInstance: () => cache
    });
    exports2.destinationServiceCache = DestinationServiceCache(new cache_1.Cache(3e5));
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-service.js
var require_destination_service3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-service.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fetchDestinations = fetchDestinations;
    exports2.fetchDestinationWithoutTokenRetrieval = fetchDestinationWithoutTokenRetrieval;
    exports2.fetchCertificate = fetchCertificate;
    exports2.fetchDestinationWithTokenRetrieval = fetchDestinationWithTokenRetrieval;
    var util_1 = require_dist11();
    var axios_1 = __importDefault(require_axios());
    var internal_1 = require_internal12();
    var resilience_1 = require_dist12();
    var async_retry_1 = __importDefault(require_lib());
    var jwt_1 = require_jwt6();
    var http_agent_1 = require_http_agent6();
    var authorization_header_1 = require_authorization_header3();
    var destination_1 = require_destination7();
    var destination_service_cache_1 = require_destination_service_cache3();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "destination-service"
    });
    async function fetchDestinations(destinationServiceUri, serviceToken, type, options) {
      const targetUri = `${(0, util_1.removeTrailingSlashes)(destinationServiceUri)}/destination-configuration/v1/${type}Destinations`;
      if (options?.useCache) {
        const destinationsFromCache = destination_service_cache_1.destinationServiceCache.retrieveDestinationsFromCache(targetUri, (0, jwt_1.decodeJwt)(serviceToken));
        if (destinationsFromCache) {
          logger8.debug(`Destinations retrieved from cache. There were ${destinationsFromCache.length} destinations returned from the cache.`);
          return destinationsFromCache;
        }
      }
      const headers = (0, jwt_1.wrapJwtInHeader)(serviceToken).headers;
      return callDestinationEndpoint({ uri: targetUri, tenantId: getTenantIdFromTokens(serviceToken) }, headers).then((response) => {
        const destinations = response.data.map((destination) => (0, destination_1.parseDestination)(destination));
        if (options?.useCache) {
          destination_service_cache_1.destinationServiceCache.cacheRetrievedDestinations(targetUri, (0, jwt_1.decodeJwt)(serviceToken), destinations);
        }
        return destinations;
      }).catch((error) => {
        throw new util_1.ErrorWithCause(`Failed to fetch ${type} destinations.${errorMessageFromResponse(error)}`, error);
      });
    }
    async function fetchDestinationWithoutTokenRetrieval(destinationName, destinationServiceUri, serviceToken) {
      const targetUri = `${(0, util_1.removeTrailingSlashes)(destinationServiceUri)}/destination-configuration/v1/destinations/${destinationName}?$skipTokenRetrieval=true`;
      try {
        const response = await callDestinationEndpoint({ uri: targetUri, tenantId: getTenantIdFromTokens(serviceToken) }, { Authorization: `Bearer ${serviceToken}` });
        const destination = (0, destination_1.parseDestination)(response.data.destinationConfiguration);
        return {
          instance: response.data.owner?.InstanceId ? [destination] : [],
          subaccount: !response.data.owner?.InstanceId && response.data.owner?.SubaccountId ? [destination] : []
        };
      } catch (err) {
        if (err.response?.status === 404 && err.response?.data?.ErrorMessage === "Configuration with the specified name was not found") {
          return {
            instance: [],
            subaccount: []
          };
        }
        throw new util_1.ErrorWithCause(`Failed to fetch destination.${errorMessageFromResponse(err)}`, err);
      }
    }
    async function fetchCertificate(destinationServiceUri, token, certificateName) {
      const filetype = certificateName.split(".")[1];
      if (filetype.toLowerCase() !== "pem") {
        logger8.warn(`The provided truststore ${certificateName} is not in 'pem' format which is currently the only supported format. Truststore is ignored.`);
        return;
      }
      const accountUri = `${(0, util_1.removeTrailingSlashes)(destinationServiceUri)}/destination-configuration/v1/subaccountCertificates/${certificateName}`;
      const instanceUri = `${(0, util_1.removeTrailingSlashes)(destinationServiceUri)}/destination-configuration/v1/instanceCertificates/${certificateName}`;
      const header = (0, jwt_1.wrapJwtInHeader)(token).headers;
      try {
        const response = await callCertificateEndpoint({ uri: accountUri, tenantId: getTenantIdFromTokens(token) }, header).catch(() => callCertificateEndpoint({
          uri: instanceUri,
          tenantId: getTenantIdFromTokens(token)
        }, header));
        return (0, destination_1.parseCertificate)(response.data);
      } catch (err) {
        logger8.warn(`Failed to fetch truststore certificate ${certificateName} - Continuing without certificate. This may cause failing requests`, err);
      }
    }
    function getTenantIdFromTokens(token) {
      let tenant;
      if (typeof token === "string") {
        tenant = (0, jwt_1.getTenantId)(token);
      } else {
        tenant = // represents the tenant as string already see https://api.sap.com/api/SAP_CP_CF_Connectivity_Destination/resource
        token.exchangeTenant || (0, jwt_1.getTenantId)(token.exchangeHeaderJwt) || (0, jwt_1.getTenantId)(token.authHeaderJwt);
      }
      if (!tenant) {
        throw new Error("Could not obtain tenant identifier from JWT.");
      }
      return tenant;
    }
    async function fetchDestinationWithTokenRetrieval(destinationServiceUri, token, options) {
      const targetUri = `${(0, util_1.removeTrailingSlashes)(destinationServiceUri)}/destination-configuration/v1/destinations/${options.destinationName}`;
      token = typeof token === "string" ? { authHeaderJwt: token } : token;
      let authHeader = (0, jwt_1.wrapJwtInHeader)(token.authHeaderJwt).headers;
      authHeader = token.exchangeHeaderJwt ? { ...authHeader, "X-user-token": token.exchangeHeaderJwt } : authHeader;
      authHeader = token.exchangeTenant ? { ...authHeader, "X-tenant": token.exchangeTenant } : authHeader;
      authHeader = token.refreshToken ? { ...authHeader, "X-refresh-token": token.refreshToken } : authHeader;
      return callDestinationEndpoint({ uri: targetUri, tenantId: getTenantIdFromTokens(token) }, authHeader, options).then((response) => {
        const destination = (0, destination_1.parseDestination)(response.data);
        return destination;
      }).catch((error) => {
        {
          throw new util_1.ErrorWithCause(`Failed to fetch destination ${options.destinationName}.${errorMessageFromResponse(error)}`, error);
        }
      });
    }
    function errorMessageFromResponse(error) {
      return (0, util_1.propertyExists)(error, "response", "data", "ErrorMessage") ? ` ${error.response.data.ErrorMessage}` : "";
    }
    function retryDestination(destinationName) {
      return (options) => (arg) => {
        let retryCount = 1;
        return (0, async_retry_1.default)(async (bail) => {
          try {
            const destination = await options.fn(arg);
            if (retryCount < 3) {
              retryCount++;
              await (0, authorization_header_1.buildAuthorizationHeaders)((0, destination_1.parseDestination)(destination.data));
            }
            return destination;
          } catch (error) {
            const status = error?.response?.status;
            if (status.toString().startsWith("4")) {
              bail(new util_1.ErrorWithCause(`Request failed with status code ${status}`, error));
              return void 0;
            }
            throw error;
          }
        }, {
          retries: 3,
          onRetry: (err) => logger8.warn(`Failed to retrieve destination ${destinationName} - doing a retry. Original Error ${err.message}`)
        });
      };
    }
    async function callCertificateEndpoint(context, headers) {
      if (!context.uri.includes("Certificates")) {
        throw new Error(`callCertificateEndpoint was called with illegal argument: ${context.uri}. URL must be certificate endpoint of destination service.`);
      }
      return callDestinationService(context, headers);
    }
    async function callDestinationEndpoint(context, headers, options) {
      if (!context.uri.match(/[instance|subaccount]Destinations|v1\/destinations/)) {
        throw new Error(`callDestinationEndpoint was called with illegal argument: ${context.uri}. URL must be destination(s) endpoint of destination service.`);
      }
      return callDestinationService(context, headers, options);
    }
    async function callDestinationService(context, headers, options) {
      const { destinationName, retry } = options || {};
      const requestConfig = {
        ...await (0, http_agent_1.urlAndAgent)(context.uri),
        method: "get",
        headers
      };
      const resilienceMiddleware = (0, resilience_1.resilience)();
      if (destinationName && retry) {
        resilienceMiddleware.unshift(retryDestination(destinationName));
      }
      return (0, internal_1.executeWithMiddleware)(resilienceMiddleware, {
        context,
        fnArgument: requestConfig,
        fn: (config) => axios_1.default.request(config)
      });
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/get-provider-token.js
var require_get_provider_token3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/get-provider-token.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getProviderServiceToken = getProviderServiceToken;
    var jwt_1 = require_jwt6();
    var token_accessor_1 = require_token_accessor3();
    async function getProviderServiceToken(options) {
      const { jwt, ...optionsWithoutJwt } = options;
      const encoded = await (0, token_accessor_1.serviceToken)("destination", optionsWithoutJwt);
      return { encoded, decoded: (0, jwt_1.decodeJwt)(encoded) };
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/get-subscriber-token.js
var require_get_subscriber_token3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/get-subscriber-token.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isSubscriberToken = isSubscriberToken;
    exports2.getSubscriberToken = getSubscriberToken;
    exports2.getRequiredSubscriberToken = getRequiredSubscriberToken;
    exports2.hasTokens = hasTokens;
    exports2.getJwtForTenant = getJwtForTenant;
    exports2.getJwtForUser = getJwtForUser;
    var util_1 = require_dist11();
    var jwt_1 = require_jwt6();
    var token_accessor_1 = require_token_accessor3();
    var subdomain_replacer_1 = require_subdomain_replacer3();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "destination-accessor-service"
    });
    function isSubscriberToken(token) {
      return token.userJwt || token.serviceJwt;
    }
    async function getSubscriberToken(options) {
      const isXsuaaJwt = !!options.jwt && (0, jwt_1.isXsuaaToken)((0, jwt_1.decodeJwt)(options.jwt));
      const userJwt = await retrieveUserToken(options, isXsuaaJwt);
      const serviceJwt = await retrieveServiceToken(options, userJwt?.decoded);
      return { userJwt, serviceJwt };
    }
    async function retrieveUserToken(options, isXsuaaJwt) {
      if (options.jwt) {
        if (!options.iss && isXsuaaJwt) {
          await (0, jwt_1.verifyJwt)(options.jwt, options);
        }
        return (0, jwt_1.getJwtPair)(options.jwt);
      }
    }
    async function retrieveServiceToken(options, decodedUserJwt) {
      const jwt = getJwtForServiceToken(options.iss, decodedUserJwt);
      if (jwt) {
        try {
          return (0, jwt_1.getJwtPair)(await (0, token_accessor_1.serviceToken)("destination", {
            ...options,
            jwt
          }));
        } catch (err) {
          logger8.warn(`Failed to fetch subscriber service token for destination. This is only relevant if you are using subscriber destinations. Failure caused by: ${err.message}`);
        }
      }
    }
    function getJwtForServiceToken(iss, decodedUserJwt) {
      if (iss) {
        logger8.debug("Using `iss` option instead of a full JWT to fetch a destination. No validation is performed.");
        return { ext_attr: { zdn: (0, subdomain_replacer_1.getIssuerSubdomain)({ iss }) } };
      }
      if (decodedUserJwt?.zid || decodedUserJwt?.app_tid) {
        return decodedUserJwt;
      }
    }
    function getRequiredSubscriberToken(token) {
      if (token) {
        const { userJwt, serviceJwt } = token;
        const requiredToken = {
          userJwt: userJwt || serviceJwt,
          serviceJwt: serviceJwt || userJwt
        };
        if (isRequired(requiredToken)) {
          return requiredToken;
        }
      }
      throw new Error("Could not get subscriber token: Token value is undefined.");
    }
    function isRequired(token) {
      return !!(token?.userJwt && token.serviceJwt);
    }
    function hasTokens(token) {
      return !!token?.userJwt || !!token?.serviceJwt;
    }
    function getJwtForTenant(token) {
      return token.serviceJwt;
    }
    function getJwtForUser(token) {
      return token.userJwt;
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-from-service.js
var require_destination_from_service3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-from-service.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DestinationFromServiceRetriever = void 0;
    exports2.getDestinationFromDestinationService = getDestinationFromDestinationService;
    var util_1 = require_dist11();
    var connectivity_service_1 = require_connectivity_service3();
    var environment_accessor_1 = require_environment_accessor3();
    var identity_service_1 = require_identity_service3();
    var jwt_1 = require_jwt6();
    var tenant_1 = require_tenant3();
    var token_accessor_1 = require_token_accessor3();
    var destination_cache_1 = require_destination_cache3();
    var destination_selection_strategies_1 = require_destination_selection_strategies3();
    var destination_service_1 = require_destination_service3();
    var destination_service_types_1 = require_destination_service_types3();
    var get_provider_token_1 = require_get_provider_token3();
    var get_subscriber_token_1 = require_get_subscriber_token3();
    var http_proxy_util_1 = require_http_proxy_util3();
    var forward_auth_token_1 = require_forward_auth_token3();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "destination-accessor-service"
    });
    var emptyDestinationByType = {
      instance: [],
      subaccount: []
    };
    async function getDestinationFromDestinationService(options) {
      logger8.debug("Attempting to retrieve destination from destination service.");
      return DestinationFromServiceRetriever.getDestinationFromDestinationService(options);
    }
    var DestinationFromServiceRetriever = class _DestinationFromServiceRetriever {
      static async getDestinationFromDestinationService(options) {
        if ((0, identity_service_1.shouldExchangeToken)(options) && options.jwt) {
          options.jwt = await (0, identity_service_1.exchangeToken)(options.jwt);
        }
        const subscriberToken = await (0, get_subscriber_token_1.getSubscriberToken)(options);
        const providerToken = await (0, get_provider_token_1.getProviderServiceToken)(options);
        const da = new _DestinationFromServiceRetriever(options, subscriberToken, providerToken);
        const destinationResult = await da.searchDestinationWithSelectionStrategyAndCache();
        if (!destinationResult) {
          return null;
        }
        let { destination } = destinationResult;
        (0, forward_auth_token_1.setForwardedAuthTokenIfNeeded)(destination, options.jwt);
        if (destinationResult.fromCache) {
          return da.addProxyConfiguration(destination);
        }
        if (!destination.forwardAuthToken) {
          if (destination.authentication === "OAuth2UserTokenExchange" || destination.authentication === "OAuth2JWTBearer" || destination.authentication === "SAMLAssertion" || destination.authentication === "OAuth2SAMLBearerAssertion" && !da.usesSystemUser(destination)) {
            destination = await da.fetchDestinationWithUserExchangeFlows(destinationResult);
          }
          if (destination.authentication === "PrincipalPropagation") {
            if (!this.isUserJwt(da.subscriberToken)) {
              _DestinationFromServiceRetriever.throwUserTokenMissing(destination);
            }
          }
          if (destination.authentication === "OAuth2Password" || destination.authentication === "ClientCertificateAuthentication" || destination.authentication === "OAuth2ClientCredentials" || da.usesSystemUser(destination)) {
            destination = await da.fetchDestinationWithNonUserExchangeFlows(destinationResult);
          }
          if (destination.authentication === "OAuth2RefreshToken") {
            destination = await da.fetchDestinationWithRefreshTokenFlow(destinationResult);
          }
        }
        const withTrustStore = await da.addTrustStoreConfiguration(destination, destinationResult.origin);
        await da.updateDestinationCache(withTrustStore, destinationResult.origin);
        return da.addProxyConfiguration(withTrustStore);
      }
      static throwUserTokenMissing(destination) {
        throw Error(`No user token (JWT) has been provided. This is strictly necessary for '${destination.authentication}'.`);
      }
      static checkDestinationForCustomJwt(destination) {
        if (!destination.jwks && !destination.jwksUri) {
          throw new Error("Failed to verify the JWT with no JKU! Destination must have `x_user_token.jwks` or `x_user_token.jwks_uri` property.");
        }
      }
      static isUserJwt(token) {
        return !!token?.userJwt;
      }
      constructor(options, subscriberToken, providerServiceToken) {
        this.subscriberToken = subscriberToken;
        this.providerServiceToken = providerServiceToken;
        const defaultOptions2 = {
          isolationStrategy: (0, destination_cache_1.getDefaultIsolationStrategy)(subscriberToken?.userJwt?.decoded),
          selectionStrategy: destination_selection_strategies_1.subscriberFirst,
          useCache: true
        };
        this.options = { ...defaultOptions2, ...options };
      }
      async searchDestinationWithSelectionStrategyAndCache() {
        let destinationSearchResult;
        if (this.isSubscriberNeeded()) {
          destinationSearchResult = await this.searchSubscriberAccountForDestination();
        }
        if (this.isProviderNeeded(destinationSearchResult)) {
          destinationSearchResult = await this.searchProviderAccountForDestination();
        }
        if (destinationSearchResult) {
          if (destinationSearchResult.fromCache) {
            logger8.debug(`Successfully retrieved destination from destination service cache for ${destinationSearchResult.origin} destinations.`);
          } else {
            logger8.debug("Successfully retrieved destination from destination service.");
          }
        } else {
          logger8.debug("Could not retrieve destination from destination service.");
        }
        return destinationSearchResult;
      }
      getExchangeTenant(destination) {
        if (destination.authentication !== "OAuth2ClientCredentials") {
          return void 0;
        }
        if (destination.originalProperties?.["tokenServiceURLType"] !== "Common") {
          return void 0;
        }
        const subdomainSubscriber = (0, jwt_1.getSubdomain)(this.subscriberToken?.serviceJwt?.decoded) || (0, jwt_1.getSubdomain)(this.subscriberToken?.userJwt?.decoded);
        const subdomainProvider = (0, jwt_1.getSubdomain)(this.providerServiceToken?.decoded);
        return subdomainSubscriber || subdomainProvider || void 0;
      }
      async getAuthTokenForOAuth2ClientCredentials(destinationResult) {
        const { destination, origin } = destinationResult;
        const exchangeTenant = this.getExchangeTenant(destination);
        const authHeaderJwt = origin === "provider" ? this.providerServiceToken.encoded : this.subscriberToken?.serviceJwt?.encoded;
        if (!authHeaderJwt) {
          throw Error("Could not retrieve service token for the destination service.");
        }
        return { authHeaderJwt, exchangeTenant };
      }
      // This covers the two technical user propagation https://help.sap.com/viewer/cca91383641e40ffbe03bdc78f00f681/Cloud/en-US/3cb7b81115c44cf594e0e3631291af94.html
      usesSystemUser(destination) {
        if (destination.systemUser && destination.authentication === "OAuth2SAMLBearerAssertion") {
          logger8.debug(`System user found on destination: "${destination.name}". 
The property SystemUser has been deprecated. 
It is highly recommended that you stop using it.
Possible alternatives for such technical user authentication are BasicAuthentication, OAuth2ClientCredentials, or ClientCertificateAuthentication`);
          return true;
        }
        return false;
      }
      async getAuthTokenForOAuth2UserBasedTokenExchanges(destinationResult) {
        const { destination, origin } = destinationResult;
        const { destinationName } = this.options;
        if (!_DestinationFromServiceRetriever.isUserJwt(this.subscriberToken)) {
          throw _DestinationFromServiceRetriever.throwUserTokenMissing(destination);
        }
        const isXsuaaUserJwt = (0, jwt_1.isXsuaaToken)(this.subscriberToken.userJwt.decoded);
        if (!isXsuaaUserJwt) {
          _DestinationFromServiceRetriever.checkDestinationForCustomJwt(destination);
        }
        if (isXsuaaUserJwt && (0, tenant_1.isIdenticalTenant)(this.subscriberToken.userJwt.decoded, this.providerServiceToken.decoded)) {
          logger8.debug(`UserExchange flow started without user exchange token for destination ${destinationName} of the provider account.`);
          return {
            authHeaderJwt: await (0, token_accessor_1.jwtBearerToken)(this.subscriberToken.userJwt.encoded, getDestinationService())
          };
        }
        const serviceJwt = origin === "provider" ? this.providerServiceToken : (
          // on type level this could be undefined, but logically if the origin is subscriber, it must be defined.
          this.subscriberToken.serviceJwt
        );
        logger8.debug(`UserExchange flow started for destination ${destinationName} of the ${origin} account.`);
        return {
          authHeaderJwt: serviceJwt.encoded,
          // token to get destination from service
          exchangeHeaderJwt: this.subscriberToken.userJwt.encoded
          // token considered for user and tenant
        };
      }
      async getAuthTokenForOAuth2RefreshToken(destinationResult) {
        const { destination, origin } = destinationResult;
        const { refreshToken } = this.options;
        if (!refreshToken) {
          throw Error(`No refresh token has been provided. This is strictly necessary for '${destination.authentication}'.`);
        }
        const clientGrant = origin === "provider" ? this.providerServiceToken.encoded : this.subscriberToken.serviceJwt.encoded;
        return { authHeaderJwt: clientGrant, refreshToken };
      }
      /**
       * @internal
       * This method calls the 'find destination by name' endpoint of the destination service using a client credentials grant.
       * For the find by name endpoint, the destination service will take care of OAuth flows and include the token in the destination.
       * @param destinationResult - Result of the getDestinations call for which the exchange flow is triggered.
       * @returns Destination containing the auth token.
       */
      async fetchDestinationWithNonUserExchangeFlows(destinationResult) {
        const token = await this.getAuthTokenForOAuth2ClientCredentials(destinationResult);
        return (0, destination_service_1.fetchDestinationWithTokenRetrieval)((0, environment_accessor_1.getDestinationServiceCredentials)().uri, token, this.options);
      }
      async fetchDestinationWithUserExchangeFlows(destinationResult) {
        const token = await this.getAuthTokenForOAuth2UserBasedTokenExchanges(destinationResult);
        return (0, destination_service_1.fetchDestinationWithTokenRetrieval)((0, environment_accessor_1.getDestinationServiceCredentials)().uri, token, this.options);
      }
      async fetchDestinationWithRefreshTokenFlow(destinationResult) {
        const token = await this.getAuthTokenForOAuth2RefreshToken(destinationResult);
        return (0, destination_service_1.fetchDestinationWithTokenRetrieval)((0, environment_accessor_1.getDestinationServiceCredentials)().uri, token, this.options);
      }
      async addProxyConfiguration(destination) {
        switch ((0, http_proxy_util_1.proxyStrategy)(destination)) {
          case "on-premise":
            return (0, connectivity_service_1.addProxyConfigurationOnPrem)(destination, (0, get_subscriber_token_1.hasTokens)(this.subscriberToken) ? (0, get_subscriber_token_1.getRequiredSubscriberToken)(this.subscriberToken) : void 0);
          case "internet":
          case "private-link":
            (0, destination_service_types_1.assertHttpDestination)(destination);
            return (0, http_proxy_util_1.addProxyConfigurationInternet)(destination);
          case "no-proxy":
            return destination;
          default:
            throw new Error("Illegal argument: No valid proxy configuration found in the destination input to be added.");
        }
      }
      async updateDestinationCache(destination, destinationOrigin) {
        if (!this.options.useCache) {
          return destination;
        }
        await destination_cache_1.destinationCache.cacheRetrievedDestination(destinationOrigin === "subscriber" ? (0, get_subscriber_token_1.getRequiredSubscriberToken)(this.subscriberToken) : this.providerServiceToken.decoded, destination, this.options.isolationStrategy);
      }
      async getProviderDestinationService() {
        const providerDestination = await (0, destination_service_1.fetchDestinationWithoutTokenRetrieval)(this.options.destinationName, (0, environment_accessor_1.getDestinationServiceCredentials)().uri, this.providerServiceToken.encoded);
        const destination = this.options.selectionStrategy({
          subscriber: emptyDestinationByType,
          provider: providerDestination
        }, this.options.destinationName);
        if (destination) {
          return { destination, fromCache: false, origin: "provider" };
        }
      }
      async getProviderDestinationCache() {
        const destination = await destination_cache_1.destinationCache.retrieveDestinationFromCache(this.providerServiceToken.decoded, this.options.destinationName, this.options.isolationStrategy);
        if (destination) {
          return { destination, fromCache: true, origin: "provider" };
        }
      }
      async getSubscriberDestinationService() {
        if (!this.subscriberToken?.serviceJwt) {
          throw new Error("Try to get destinations from subscriber account but service JWT was not set.");
        }
        const subscriberDestination = await (0, destination_service_1.fetchDestinationWithoutTokenRetrieval)(this.options.destinationName, (0, environment_accessor_1.getDestinationServiceCredentials)().uri, this.subscriberToken.serviceJwt.encoded);
        const destination = this.options.selectionStrategy({
          subscriber: subscriberDestination,
          provider: emptyDestinationByType
        }, this.options.destinationName);
        if (destination) {
          return { destination, fromCache: false, origin: "subscriber" };
        }
      }
      async getSubscriberDestinationCache() {
        const destination = await destination_cache_1.destinationCache.retrieveDestinationFromCache((0, get_subscriber_token_1.getRequiredSubscriberToken)(this.subscriberToken), this.options.destinationName, this.options.isolationStrategy);
        if (destination) {
          return { destination, fromCache: true, origin: "subscriber" };
        }
      }
      isProviderNeeded(resultFromSubscriber) {
        if (this.options.selectionStrategy.toString() === destination_selection_strategies_1.alwaysSubscriber.toString()) {
          return false;
        }
        if (this.options.selectionStrategy.toString() === destination_selection_strategies_1.subscriberFirst.toString() && resultFromSubscriber) {
          return false;
        }
        return true;
      }
      isSubscriberNeeded() {
        if (!this.subscriberToken?.serviceJwt) {
          return false;
        }
        return this.options.selectionStrategy.toString() !== destination_selection_strategies_1.alwaysProvider.toString();
      }
      async searchProviderAccountForDestination() {
        return this.options.useCache && await this.getProviderDestinationCache() || this.getProviderDestinationService();
      }
      async searchSubscriberAccountForDestination() {
        return this.options.useCache && await this.getSubscriberDestinationCache() || this.getSubscriberDestinationService();
      }
      async addTrustStoreConfiguration(destination, origin) {
        if (destination.originalProperties?.TrustStoreLocation) {
          const trustStoreCertificate = await (0, destination_service_1.fetchCertificate)((0, environment_accessor_1.getDestinationServiceCredentials)().uri, origin === "provider" ? this.providerServiceToken.encoded : this.subscriberToken.serviceJwt.encoded, destination.originalProperties.TrustStoreLocation);
          destination.trustStoreCertificate = trustStoreCertificate;
        }
        return destination;
      }
    };
    exports2.DestinationFromServiceRetriever = DestinationFromServiceRetriever;
    function getDestinationService() {
      const destinationService = (0, environment_accessor_1.getServiceBinding)("destination");
      if (!destinationService) {
        throw Error("No binding to a destination service found.");
      }
      return destinationService;
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-from-registration.js
var require_destination_from_registration3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-from-registration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.registerDestination = registerDestination;
    exports2.searchRegisteredDestination = searchRegisteredDestination;
    var util_1 = require_dist11();
    var jwt_1 = require_jwt6();
    var destination_cache_1 = require_destination_cache3();
    var destination_service_types_1 = require_destination_service_types3();
    var http_proxy_util_1 = require_http_proxy_util3();
    var register_destination_cache_1 = require_register_destination_cache3();
    var forward_auth_token_1 = require_forward_auth_token3();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "register-destination"
    });
    async function registerDestination(destination, options) {
      if (!destination.name) {
        throw Error("Registering destinations requires a destination name.");
      }
      destination.mtls = !!options?.inferMtls;
      if (options?.useMtlsCache) {
        register_destination_cache_1.registerDestinationCache.mtls.useMtlsCache = true;
        await register_destination_cache_1.registerDestinationCache.mtls.cacheMtlsOptions();
      }
      await register_destination_cache_1.registerDestinationCache.destination.cacheRetrievedDestination(getJwtForCaching(options), destination, isolationStrategy(options));
    }
    function getJwtForCaching(options) {
      const jwt = (0, jwt_1.decodeOrMakeJwt)(options?.jwt);
      if (!(0, jwt_1.getTenantId)(jwt)) {
        if (options?.jwt) {
          throw Error("Could not determine tenant from JWT nor XSUAA, identity or destination service binding. Destination is registered without tenant information.");
        } else {
          logger8.debug("Could not determine tenant from XSUAA, identity or destination service binding. Destination is registered without tenant information.");
        }
        return { zid: jwt_1.defaultTenantId };
      }
      return jwt;
    }
    async function searchRegisteredDestination(options) {
      const destination = await register_destination_cache_1.registerDestinationCache.destination.retrieveDestinationFromCache(getJwtForCaching(options), options.destinationName, isolationStrategy(options));
      if (!destination) {
        logger8.debug(`Could not retrieve '${options.destinationName}' from registered destinations.`);
        return null;
      }
      logger8.info(`Successfully retrieved destination '${options.destinationName}' from registered destinations.`);
      (0, forward_auth_token_1.setForwardedAuthTokenIfNeeded)(destination, options.jwt);
      return (0, destination_service_types_1.isHttpDestination)(destination) && ["internet", "private-link"].includes((0, http_proxy_util_1.proxyStrategy)(destination)) ? (0, http_proxy_util_1.addProxyConfigurationInternet)(destination) : destination;
    }
    function isolationStrategy(options) {
      if (options?.isolationStrategy) {
        return options.isolationStrategy;
      }
      const decoded = options?.jwt ? (0, jwt_1.decodeJwt)(options.jwt) : void 0;
      return (0, destination_cache_1.getDefaultIsolationStrategy)(decoded);
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-accessor.js
var require_destination_accessor3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/destination-accessor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.useOrFetchDestination = useOrFetchDestination2;
    exports2.resolveDestination = resolveDestination;
    exports2.getDestination = getDestination;
    exports2.getAllDestinationsFromDestinationService = getAllDestinationsFromDestinationService;
    var util_1 = require_dist11();
    var identity_service_1 = require_identity_service3();
    var environment_accessor_1 = require_environment_accessor3();
    var jwt_1 = require_jwt6();
    var destination_1 = require_destination7();
    var destination_from_env_1 = require_destination_from_env3();
    var destination_from_vcap_1 = require_destination_from_vcap3();
    var destination_from_service_1 = require_destination_from_service3();
    var destination_accessor_types_1 = require_destination_accessor_types3();
    var destination_from_registration_1 = require_destination_from_registration3();
    var get_subscriber_token_1 = require_get_subscriber_token3();
    var get_provider_token_1 = require_get_provider_token3();
    var destination_service_1 = require_destination_service3();
    var logger8 = (0, util_1.createLogger)({
      package: "connectivity",
      messageContext: "destination-accessor"
    });
    async function useOrFetchDestination2(destination) {
      return (0, destination_accessor_types_1.isDestinationFetchOptions)(destination) ? getDestination(destination) : (0, destination_1.sanitizeDestination)(destination);
    }
    async function resolveDestination(destination) {
      const resolvedDestination = await useOrFetchDestination2(destination).catch((error) => {
        throw new util_1.ErrorWithCause("Failed to load destination.", error);
      });
      if (!resolvedDestination) {
        throw Error(`Failed to resolve the destination '${(0, destination_1.toDestinationNameUrl)(destination)}'.`);
      }
      return resolvedDestination;
    }
    async function getDestination(options) {
      const destination = (0, destination_from_env_1.searchEnvVariablesForDestination)(options) || await (0, destination_from_registration_1.searchRegisteredDestination)(options) || await (0, destination_from_vcap_1.searchServiceBindingForDestination)(options) || await (0, destination_from_service_1.getDestinationFromDestinationService)(options);
      return destination;
    }
    function createDestinationFetchLogs(origin, destinations) {
      return destinations.reduce((prevLogMessages, currentDestination) => prevLogMessages + `Retrieving ${origin} destination: ${currentDestination.name}.
`, "");
    }
    async function getAllDestinationsFromDestinationService(options = {}) {
      options = {
        ...options,
        // Enable caching by default
        useCache: options.useCache ?? true
      };
      logger8.debug("Attempting to retrieve all destinations from destination service.");
      if ((0, identity_service_1.shouldExchangeToken)(options) && options.jwt) {
        options.jwt = await (0, identity_service_1.exchangeToken)(options.jwt);
      }
      const token = (await (0, get_subscriber_token_1.getSubscriberToken)(options))?.serviceJwt || await (0, get_provider_token_1.getProviderServiceToken)(options);
      const destinationServiceUri = (0, environment_accessor_1.getDestinationServiceCredentials)().uri;
      const subdomain = (0, jwt_1.getSubdomain)(token.decoded);
      logger8.debug(`Retrieving all destinations for account: "${subdomain}" from destination service.`);
      const [instance, subaccount] = await Promise.all([
        (0, destination_service_1.fetchDestinations)(destinationServiceUri, token.encoded, "instance", options),
        (0, destination_service_1.fetchDestinations)(destinationServiceUri, token.encoded, "subaccount", options)
      ]);
      const loggerMessage = createDestinationFetchLogs("instance", instance) + createDestinationFetchLogs("subaccount", subaccount);
      logger8.debug(loggerMessage);
      const allDestinations = [...instance, ...subaccount];
      if (allDestinations?.length) {
        logger8.debug(`Successfully retrieved all destinations for account: "${subdomain}" from destination service.`);
      } else {
        logger8.debug("Didn't receive any destinations from destination service.");
        return [];
      }
      const allDestinationsWithoutToken = allDestinations.map((destination) => {
        delete destination.authTokens;
        return destination;
      });
      return allDestinationsWithoutToken;
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/index.js
var require_destination9 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/destination/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_destination_accessor3(), exports2);
    __exportStar(require_destination_accessor_types3(), exports2);
    __exportStar(require_destination_cache3(), exports2);
    __exportStar(require_destination_from_env3(), exports2);
    __exportStar(require_destination_from_service3(), exports2);
    __exportStar(require_destination_from_registration3(), exports2);
    __exportStar(require_destination_from_vcap3(), exports2);
    __exportStar(require_destination_selection_strategies3(), exports2);
    __exportStar(require_destination_service_cache3(), exports2);
    __exportStar(require_destination_service_types3(), exports2);
    __exportStar(require_destination_service3(), exports2);
    __exportStar(require_destination7(), exports2);
    __exportStar(require_forward_auth_token3(), exports2);
    __exportStar(require_get_subscriber_token3(), exports2);
    __exportStar(require_get_provider_token3(), exports2);
    __exportStar(require_http_proxy_util3(), exports2);
    __exportStar(require_service_binding_to_destination3(), exports2);
    __exportStar(require_register_destination_cache3(), exports2);
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/connectivity-service-types.js
var require_connectivity_service_types3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/connectivity-service-types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/header-builder-for-destination.js
var require_header_builder_for_destination3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/header-builder-for-destination.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildHeadersForDestination = buildHeadersForDestination;
    var util_1 = require_dist11();
    var authorization_header_1 = require_authorization_header3();
    async function buildHeadersForDestination(destination) {
      const authHeaders = await (0, authorization_header_1.buildAuthorizationHeaders)(destination);
      const sapHeaders = getSapHeaders(destination);
      return (0, util_1.mergeIgnoreCase)(destination.headers, {
        ...authHeaders,
        ...sapHeaders
      });
    }
    function getSapHeaders(destination) {
      const defaultHeaders = (0, util_1.pickNonNullish)({
        "sap-client": destination.sapClient,
        "SAP-Connectivity-SCC-Location_ID": destination.cloudConnectorLocationId
      });
      return (0, util_1.mergeLeftIgnoreCase)(defaultHeaders, destination.headers);
    }
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/jsonwebtoken-type.js
var require_jsonwebtoken_type3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/jsonwebtoken-type.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/xsuaa-service-types.js
var require_xsuaa_service_types3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/xsuaa-service-types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/index.js
var require_scp_cf3 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/scp-cf/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_destination9(), exports2);
    __exportStar(require_authorization_header3(), exports2);
    __exportStar(require_cache4(), exports2);
    __exportStar(require_client_credentials_token_cache3(), exports2);
    __exportStar(require_connectivity_service3(), exports2);
    __exportStar(require_connectivity_service_types3(), exports2);
    __exportStar(require_environment_accessor3(), exports2);
    __exportStar(require_get_protocol3(), exports2);
    __exportStar(require_header_builder_for_destination3(), exports2);
    __exportStar(require_identity_service3(), exports2);
    __exportStar(require_jsonwebtoken_type3(), exports2);
    __exportStar(require_jwt6(), exports2);
    __exportStar(require_protocol3(), exports2);
    __exportStar(require_subdomain_replacer3(), exports2);
    __exportStar(require_tenant3(), exports2);
    __exportStar(require_token_accessor3(), exports2);
    __exportStar(require_xsuaa_service_types3(), exports2);
    __exportStar(require_xsuaa_service3(), exports2);
    __exportStar(require_async_cache3(), exports2);
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/internal.js
var require_internal13 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/dist/internal.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_http_agent6(), exports2);
    __exportStar(require_scp_cf3(), exports2);
  }
});

// node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/internal.js
var require_internal14 = __commonJS({
  "node_modules/@sap-ai-sdk/ai-api/node_modules/@sap-cloud-sdk/connectivity/internal.js"(exports2) {
    "use strict";
    function __export2(m) {
      for (const p in m) {
        if (!exports2.hasOwnProperty(p)) {
          exports2[p] = m[p];
        }
      }
    }
    Object.defineProperty(exports2, "__esModule", { value: true });
    __export2(require_internal13());
  }
});

// node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/array.js
var require_array5 = __commonJS({
  "node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/array.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.flatten = void 0;
    exports2.flat = flat;
    exports2.unique = unique;
    exports2.last = last;
    exports2.first = first;
    exports2.splitInChunks = splitInChunks;
    exports2.transformVariadicArgumentToArray = transformVariadicArgumentToArray;
    exports2.zip = zip;
    exports2.partition = partition2;
    exports2.filterDuplicates = filterDuplicates;
    exports2.filterDuplicatesRight = filterDuplicatesRight;
    function flat(arr2) {
      return arr2.reduce((flattened, subArr) => [...flattened, ...subArr], []);
    }
    function unique(arr2) {
      return Array.from(new Set(arr2));
    }
    function last(arr2) {
      return arr2.length ? arr2[arr2.length - 1] : void 0;
    }
    function first(arr2) {
      return arr2[0];
    }
    function splitInChunks(arr2, chunkSize) {
      const chunks = [];
      if (arr2) {
        for (let i = 0; i < arr2.length; i += chunkSize) {
          chunks.push(arr2.slice(i, i + chunkSize));
        }
      }
      return chunks;
    }
    function transformVariadicArgumentToArray(firstOrArray, rest) {
      if (Array.isArray(firstOrArray)) {
        return [...firstOrArray, ...rest];
      }
      return firstOrArray ? [firstOrArray, ...rest] : [...rest];
    }
    var flatten = (input) => {
      const flatResult = [];
      const stack = [...input];
      while (stack.length > 0) {
        const current = stack.pop();
        if (!Array.isArray(current)) {
          flatResult.push(current);
        } else {
          stack.push(...current);
        }
      }
      return flatResult.reverse();
    };
    exports2.flatten = flatten;
    function zip(left, right) {
      const longerArr = left.length > right.length ? left : right;
      return longerArr.reduce((zipped, _, i) => {
        const currentZipped = [];
        if (left.length > i) {
          currentZipped.push(left[i]);
        }
        if (right.length > i) {
          currentZipped.push(right[i]);
        }
        return [...zipped, ...currentZipped];
      }, []);
    }
    function partition2(arr2, condition) {
      return arr2.reduce(([conditionTrue, conditionFalse], item) => condition(item) ? [[...conditionTrue, item], conditionFalse] : [conditionTrue, [...conditionFalse, item]], [[], []]);
    }
    function filterDuplicates(arr2, comparator = (left, right) => left === right) {
      return arr2.filter((item, index) => !arr2.slice(0, index).find((filteredItem) => comparator(item, filteredItem)));
    }
    function filterDuplicatesRight(arr2, comparator = (left, right) => left === right) {
      return filterDuplicates(arr2.reverse(), comparator).reverse();
    }
  }
});

// node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/string-formatter.js
var require_string_formatter5 = __commonJS({
  "node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/string-formatter.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.webEOL = exports2.unixEOL = void 0;
    exports2.upperCaseSnakeCase = upperCaseSnakeCase;
    exports2.camelCase = camelCase2;
    exports2.titleFormat = titleFormat;
    exports2.pascalCase = pascalCase;
    exports2.kebabCase = kebabCase;
    exports2.formatJson = formatJson;
    var voca_1 = __importDefault(require_voca());
    exports2.unixEOL = "\n";
    exports2.webEOL = "\r\n";
    function upperCaseSnakeCase(str) {
      return voca_1.default.upperCase(voca_1.default.snakeCase(str));
    }
    function camelCase2(str) {
      return voca_1.default.camelCase(str);
    }
    function titleFormat(str) {
      return voca_1.default.titleCase(voca_1.default.words(str).join(" "));
    }
    function pascalCase(str) {
      return voca_1.default.words(str).map((word) => voca_1.default.capitalize(word)).join("");
    }
    function kebabCase(str) {
      return voca_1.default.kebabCase(str);
    }
    function formatJson(json2) {
      return JSON.stringify(json2, null, 2) + exports2.unixEOL;
    }
  }
});

// node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/string.js
var require_string5 = __commonJS({
  "node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/string.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encodeBase64 = encodeBase64;
    exports2.trimLeft = trimLeft;
    exports2.trimRight = trimRight;
    exports2.trim = trim;
    exports2.removeFileExtension = removeFileExtension;
    var string_formatter_1 = require_string_formatter5();
    function encodeBase64(str) {
      return Buffer.from(str).toString("base64");
    }
    function trimLeft(string) {
      const subStrings = string.split(string_formatter_1.unixEOL);
      const leftTrimmed = subStrings[0].trimStart();
      if (!leftTrimmed) {
        subStrings.shift();
      } else {
        subStrings[0] = leftTrimmed;
      }
      return subStrings.join(string_formatter_1.unixEOL);
    }
    function trimRight(string) {
      const subStrings = string.split(string_formatter_1.unixEOL);
      const rightTrimmed = subStrings[subStrings.length - 1].trimEnd();
      if (!rightTrimmed) {
        subStrings.pop();
      } else {
        subStrings[subStrings.length - 1] = rightTrimmed;
      }
      return subStrings.join(string_formatter_1.unixEOL);
    }
    function trim(string) {
      return trimRight(trimLeft(string));
    }
    function removeFileExtension(fileName) {
      return fileName.includes(".") ? fileName.split(".").slice(0, -1).join(".") : fileName;
    }
  }
});

// node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/code-block.js
var require_code_block5 = __commonJS({
  "node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/code-block.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.codeBlock = codeBlock;
    var string_formatter_1 = require_string_formatter5();
    var array_1 = require_array5();
    var string_1 = require_string5();
    function codeBlock(strings, ...args) {
      const pre = strings.slice(0, -1).map((string) => {
        const trimmed = trimRightNewlines(string);
        return trimmed.length === string.length ? string : trimmed + string_formatter_1.unixEOL;
      });
      pre.push(strings[strings.length - 1]);
      const indents = strings.slice(0, -1).map((s) => {
        const indentation = s.split(string_formatter_1.unixEOL).pop();
        return !indentation.trim() ? indentation : "";
      });
      const post = args.map((arg, i) => ("" + arg).split(string_formatter_1.unixEOL).map((subArg) => indents[i] + subArg).join(string_formatter_1.unixEOL));
      const zipped = (0, array_1.zip)(pre, post);
      return (0, string_1.trim)(zipped.join(""));
    }
    function trimRightNewlines(string) {
      let subStrings = string.split(string_formatter_1.unixEOL);
      if (!subStrings[subStrings.length - 1].trim()) {
        subStrings = subStrings.slice(0, -1);
      }
      return subStrings.join(string_formatter_1.unixEOL);
    }
  }
});

// node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/logger/format/local.js
var require_local5 = __commonJS({
  "node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/logger/format/local.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.local = void 0;
    exports2.getMessageOrStack = getMessageOrStack;
    var chalk_1 = __importDefault(require_source());
    var winston_1 = require_winston();
    var { combine, timestamp, cli, printf, errors } = winston_1.format;
    exports2.local = combine(errors({ stack: true }), timestamp(), (0, winston_1.format)(localTransformer)(), cli(), printf((info) => {
      const messageContext = info.custom_fields && typeof info.custom_fields === "object" && "messageContext" in info.custom_fields ? `${chalk_1.default.blue(`(${info.custom_fields.messageContext})`)}: ` : "";
      const message = typeof info.message === "string" ? info.message : "";
      const trimmedMessage = message.replace(/^\s*/, "");
      const paddingLength = message.length - trimmedMessage.length + messageContext.length;
      if (info.error) {
        info.level = chalk_1.default.inverse(info.level);
      }
      return `${chalk_1.default.gray(`[${info.timestamp}]`)} ${info.level} ${messageContext.padStart(paddingLength, " ")}${trimmedMessage}`;
    }));
    function getMessageOrStack(info) {
      const isString = (value) => typeof value === "string";
      const hasStackTrace = info.stack && info.level === "error";
      if (hasStackTrace && isString(info.stack)) {
        return info.stack;
      }
      if (isString(info.message)) {
        return info.message;
      }
      return "";
    }
    function localTransformer(info) {
      return {
        ...info,
        level: info.level.toUpperCase(),
        message: getMessageOrStack(info)
      };
    }
  }
});

// node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/logger/format/kibana.js
var require_kibana5 = __commonJS({
  "node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/logger/format/kibana.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.kibana = void 0;
    var winston_1 = require_winston();
    var local_1 = require_local5();
    var { combine, timestamp, json: json2, errors } = winston_1.format;
    exports2.kibana = combine(errors({ stack: true }), timestamp(), (0, winston_1.format)(kibanaTransformer)(), json2());
    function kibanaTransformer(info) {
      return {
        ...info,
        msg: (0, local_1.getMessageOrStack)(info),
        written_ts: new Date(info.timestamp).getTime(),
        written_at: info.timestamp
      };
    }
  }
});

// node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/logger/format/index.js
var require_format6 = __commonJS({
  "node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/logger/format/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_kibana5(), exports2);
    __exportStar(require_local5(), exports2);
  }
});

// node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/logger/cloud-sdk-logger.js
var require_cloud_sdk_logger5 = __commonJS({
  "node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/logger/cloud-sdk-logger.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.cloudSdkExceptionLogger = exports2.logFormat = void 0;
    exports2.muteLoggers = muteLoggers;
    exports2.unmuteLoggers = unmuteLoggers;
    exports2.disableExceptionLogger = disableExceptionLogger;
    exports2.enableExceptionLogger = enableExceptionLogger;
    exports2.createLogger = createLogger8;
    exports2.getLogger = getLogger;
    exports2.setLogLevel = setLogLevel;
    exports2.setGlobalLogLevel = setGlobalLogLevel;
    exports2.getGlobalLogLevel = getGlobalLogLevel;
    exports2.setGlobalTransports = setGlobalTransports;
    exports2.setLogFormat = setLogFormat;
    exports2.setGlobalLogFormat = setGlobalLogFormat;
    exports2.getGlobalLogFormat = getGlobalLogFormat;
    exports2.sanitizeRecord = sanitizeRecord;
    exports2.resetCustomLogLevels = resetCustomLogLevels;
    exports2.resetCustomLogFormats = resetCustomLogFormats;
    var winston_1 = require_winston();
    var format_1 = require_format6();
    var loggerReference = "sap-cloud-sdk-logger";
    var exceptionLoggerId = "sap-cloud-sdk-exception-logger";
    var container = new winston_1.Container();
    exports2.logFormat = {
      kibana: format_1.kibana,
      local: format_1.local
    };
    container.options.format = process.env.NODE_ENV === "production" ? exports2.logFormat.kibana : exports2.logFormat.local;
    var exceptionTransport = new winston_1.transports.Console();
    var customLogLevels = {};
    var customLogFormats = {};
    var DEFAULT_LOGGER__MESSAGE_CONTEXT = "__DEFAULT_LOGGER__MESSAGE_CONTEXT";
    var silent = false;
    var moduleLogger = createLogger8({
      package: "util",
      messageContext: "cloud-sdk-logger"
    });
    function toggleMuteLoggers(silence) {
      silent = silence;
      container.loggers.forEach((logger8) => toggleSilenceTransports(logger8, silence));
    }
    function toggleSilenceTransports(logger8, silence) {
      logger8.transports.forEach((transport) => transport.silent = silence);
    }
    function muteLoggers() {
      toggleMuteLoggers(true);
    }
    function unmuteLoggers() {
      toggleMuteLoggers(false);
    }
    exports2.cloudSdkExceptionLogger = container.get(exceptionLoggerId, {
      defaultMeta: { logger: loggerReference, test: "exception" },
      format: container.options.format,
      exceptionHandlers: [exceptionTransport]
    });
    function disableExceptionLogger() {
      exports2.cloudSdkExceptionLogger.exceptions.unhandle();
    }
    function enableExceptionLogger() {
      disableExceptionLogger();
      exports2.cloudSdkExceptionLogger.exceptions.handle(exceptionTransport);
    }
    function createLogger8(messageContext) {
      const customFields = typeof messageContext === "string" ? { messageContext } : { ...messageContext };
      const logger8 = container.get(customFields.messageContext, {
        level: process.env.SAP_CLOUD_SDK_LOG_LEVEL || customLogLevels[customFields.messageContext] || customFields.level || container.options.level || "info",
        defaultMeta: {
          ...Object.entries(customFields).length && {
            custom_fields: customFields
          },
          logger: customFields.logger || loggerReference
        },
        format: customLogFormats[customFields.messageContext] || customFields.format || container.options.format || exports2.logFormat.local,
        transports: [new winston_1.transports.Console()]
      });
      toggleSilenceTransports(logger8, silent);
      return logger8;
    }
    function getLogger(messageContext = DEFAULT_LOGGER__MESSAGE_CONTEXT) {
      if (container.has(messageContext)) {
        return container.get(messageContext);
      }
    }
    function setLogLevel(level, messageContextOrLogger = DEFAULT_LOGGER__MESSAGE_CONTEXT) {
      const messageContext = typeof messageContextOrLogger === "string" ? messageContextOrLogger : getMessageContext(messageContextOrLogger);
      if (messageContext) {
        customLogLevels[messageContext] = level;
        if (container.has(messageContext)) {
          const logger8 = container.get(messageContext);
          logger8.level = level;
        }
      } else if (typeof messageContextOrLogger !== "string") {
        moduleLogger.warn("Setting log level for logger with unknown message context");
        messageContextOrLogger.level = level;
      }
    }
    function setGlobalLogLevel(level) {
      container.options.level = level;
      container.loggers.forEach((logger8) => {
        logger8.level = level;
      });
    }
    function getGlobalLogLevel() {
      return container.options.level;
    }
    function setGlobalTransports(customTransports) {
      container.options.transports = customTransports;
      container.loggers.forEach((logger8) => {
        logger8.clear();
        return Array.isArray(customTransports) ? customTransports.forEach((transport) => logger8.add(transport)) : logger8.add(customTransports);
      });
    }
    function setLogFormat(format, messageContextOrLogger = DEFAULT_LOGGER__MESSAGE_CONTEXT) {
      const messageContext = typeof messageContextOrLogger === "string" ? messageContextOrLogger : getMessageContext(messageContextOrLogger);
      if (messageContext) {
        customLogFormats[messageContext] = format;
        if (container.has(messageContext)) {
          const logger8 = container.get(messageContext);
          logger8.format = format;
        }
      } else if (typeof messageContextOrLogger !== "string") {
        moduleLogger.warn("Setting log format for logger with unknown message context");
        messageContextOrLogger.format = format;
      }
    }
    function setGlobalLogFormat(format) {
      container.options.format = format;
      container.loggers.forEach((logger8) => {
        logger8.format = format;
      });
    }
    function getGlobalLogFormat() {
      return container.options.format;
    }
    var defaultSensitiveKeys = [
      "access_token",
      "authentication",
      "authorization",
      "apiKey",
      "credentials",
      "csrf",
      "xsrf",
      "secret",
      "password",
      "JTENANT",
      "JSESSION"
    ];
    function isSensitive(inputKey, value, sensitiveKeys) {
      const normalizedKeys = sensitiveKeys.map((key) => key.toLowerCase());
      const input = isCookieHeader(inputKey, value) ? value : inputKey;
      return normalizedKeys.some((normalizedKey) => input.toLowerCase().includes(normalizedKey));
    }
    function isCookieHeader(inputKey, value) {
      return inputKey.toLowerCase() === "cookie" && typeof value === "string";
    }
    function sanitizeRecord(input, replacementString = "<DATA NOT LOGGED TO PREVENT LEAKING SENSITIVE DATA>", sensitiveKeys = defaultSensitiveKeys) {
      return Object.fromEntries(Object.entries(input).map(([inputKey, value]) => isSensitive(inputKey, value, sensitiveKeys) ? [inputKey, replacementString] : [inputKey, value]));
    }
    function getMessageContext(logger8) {
      const loggerOptions = logger8;
      if (loggerOptions && loggerOptions.defaultMeta && loggerOptions.defaultMeta.custom_fields) {
        return loggerOptions.defaultMeta.custom_fields.messageContext;
      }
    }
    function resetCustomLogLevels() {
      Object.keys(customLogLevels).forEach((key) => delete customLogLevels[key]);
    }
    function resetCustomLogFormats() {
      Object.keys(customLogFormats).forEach((key) => delete customLogFormats[key]);
    }
  }
});

// node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/logger/index.js
var require_logger6 = __commonJS({
  "node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/logger/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_cloud_sdk_logger5(), exports2);
    __exportStar(require_format6(), exports2);
  }
});

// node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/documentation-block.js
var require_documentation_block5 = __commonJS({
  "node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/documentation-block.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.documentationBlock = documentationBlock;
    var array_1 = require_array5();
    var logger_1 = require_logger6();
    var string_formatter_1 = require_string_formatter5();
    var logger8 = (0, logger_1.createLogger)("documentation-block");
    function documentationBlock(strings, ...args) {
      const firstLineTrimmed = removeLeadingEmptyLines(strings.raw[0]);
      const textIndentation = getIndentation(firstLineTrimmed);
      const argsWithIndentation = addIndentationToArguments(args, textIndentation);
      let content = (0, array_1.zip)([firstLineTrimmed, ...strings.raw.slice(1)], argsWithIndentation).join("");
      if (!content.match(/\w/)) {
        return "";
      }
      content = maskProblematicCharacters(content);
      let lines = content.split(string_formatter_1.unixEOL);
      lines = adjustIndentation(lines, textIndentation);
      content = lines.join(`${string_formatter_1.unixEOL} * `);
      const result = ["/**", ` * ${content}`, " */"].join(string_formatter_1.unixEOL);
      return result;
    }
    function removeLeadingEmptyLines(firstLine) {
      const lines = firstLine.split(string_formatter_1.unixEOL);
      const indexFirstNonEmpty = lines.findIndex((str) => str.match(/\w/)) || 0;
      return lines.splice(indexFirstNonEmpty).join(string_formatter_1.unixEOL);
    }
    function addIndentationToArguments(args, textIndentation) {
      const argsWithIndentation = args.map((arg) => arg.replace(/\n/g, string_formatter_1.unixEOL + " ".repeat(textIndentation)));
      return argsWithIndentation;
    }
    function adjustIndentation(lines, textIndentation) {
      return lines.map((str) => str.slice(textIndentation));
    }
    function getIndentation(firstLine) {
      const removeStarting = firstLine?.replace(/^\n*/g, "");
      const countEmptySpaces = removeStarting?.search(/\S/);
      return countEmptySpaces > 0 ? countEmptySpaces : 0;
    }
    function maskProblematicCharacters(str) {
      if (str.includes("*/")) {
        logger8.warn(`The documentation block ${str}'
      )} contained */ in the text will be masked as \\*\\/.`);
      }
      return str.replace(/\*\//g, "\\*\\/");
    }
  }
});

// node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/nullish.js
var require_nullish5 = __commonJS({
  "node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/nullish.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isNullish = isNullish;
    function isNullish(val) {
      return val === null || val === void 0;
    }
  }
});

// node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/equal.js
var require_equal5 = __commonJS({
  "node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/equal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.equalObjects = equalObjects;
    exports2.equal = equal;
    exports2.equalArrays = equalArrays;
    var nullish_1 = require_nullish5();
    function equalObjects(obj1, obj2) {
      const keys1 = Object.keys(obj1);
      return Object.keys(obj1).length === Object.keys(obj2).length && keys1.every((key) => equal(obj1[key], obj2[key]));
    }
    function equal(item1, item2) {
      if (Array.isArray(item1) && Array.isArray(item2)) {
        return equalArrays(item1, item2);
      }
      if (typeof item1 === "object" && typeof item2 === "object" && !(0, nullish_1.isNullish)(item1) && !(0, nullish_1.isNullish)(item2)) {
        return equalObjects(item1, item2);
      }
      return item1 === item2;
    }
    function equalArrays(arr1, arr2) {
      return arr1.length === arr2.length && arr1.every((item1, i) => equal(item1, arr2[i]));
    }
  }
});

// node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/error-with-cause.js
var require_error_with_cause5 = __commonJS({
  "node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/error-with-cause.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ErrorWithCause = void 0;
    exports2.isErrorWithCause = isErrorWithCause;
    var string_formatter_1 = require_string_formatter5();
    var logger_1 = require_logger6();
    var logger8 = (0, logger_1.createLogger)({
      package: "util",
      messageContext: "error-with-cause"
    });
    var ErrorWithCause3 = class extends Error {
      /**
       * Create an instance of ErrorWithCause.
       * @param message - Error message.
       * @param cause - Original error, causing this error.
       */
      constructor(message, cause) {
        super(message);
        this.cause = cause;
        Object.setPrototypeOf(this, new.target.prototype);
        this.name = "ErrorWithCause";
        this.addStack(cause);
      }
      isAxiosError(err) {
        return err["isAxiosError"] === true;
      }
      addStack(cause) {
        if (this.isAxiosError(cause)) {
          let response = "";
          if (cause.response?.data) {
            try {
              response = `${string_formatter_1.unixEOL}${JSON.stringify(cause.response?.data, null, 2)}`;
            } catch (error) {
              logger8.warn(`Failed to stringify response data: ${error.message}`);
              response = `${string_formatter_1.unixEOL}${cause.response?.data}`;
            }
          }
          this.stack = `${this.stack}${string_formatter_1.unixEOL}Caused by:${string_formatter_1.unixEOL}HTTP Response: ${cause.message}${response}`;
        } else if (this.stack && cause?.stack) {
          this.stack = `${this.stack}${string_formatter_1.unixEOL}Caused by:${string_formatter_1.unixEOL}${cause.stack}`;
        }
      }
      /**
       * Root cause of the error.
       * If there are multiple errors caused one by another, the root cause is the first error that occurred.
       * In case there is no root cause.
       * @returns The root cause.
       */
      get rootCause() {
        return isErrorWithCause(this.cause) ? this.cause.rootCause : this.cause;
      }
    };
    exports2.ErrorWithCause = ErrorWithCause3;
    function isErrorWithCause(err) {
      return err?.name === "ErrorWithCause";
    }
  }
});

// node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/fs.js
var require_fs5 = __commonJS({
  "node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.findProjectRoot = findProjectRoot;
    exports2.readJSON = readJSON;
    var fs_1 = require("fs");
    var path_1 = require("path");
    var logger_1 = require_logger6();
    var logger8 = (0, logger_1.createLogger)({
      package: "util",
      messageContext: "fs"
    });
    function findProjectRoot(path, lastPath = path) {
      if (!path) {
        return lastPath;
      }
      const inProject = (0, fs_1.readdirSync)(path).includes("package.json") || (0, fs_1.readdirSync)(path).includes("node_modules") || path.includes("node_modules");
      if (!inProject) {
        return lastPath;
      }
      return findProjectRoot((0, path_1.resolve)(path, ".."), path);
    }
    function readJSON(path) {
      if ((0, fs_1.existsSync)(path)) {
        return JSON.parse((0, fs_1.readFileSync)(path, "utf8"));
      }
      logger8.warn(`File "${path}" does not exist, return empty object.`);
      return {};
    }
  }
});

// node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/object.js
var require_object5 = __commonJS({
  "node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/object.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.exclude = exports2.pick = exports2.renameKeys = void 0;
    exports2.propertyExists = propertyExists;
    exports2.toSanitizedObject = toSanitizedObject;
    exports2.pickIgnoreCase = pickIgnoreCase;
    exports2.pickValueIgnoreCase = pickValueIgnoreCase;
    exports2.pickNonNullish = pickNonNullish;
    exports2.mergeLeftIgnoreCase = mergeLeftIgnoreCase;
    exports2.mergeIgnoreCase = mergeIgnoreCase2;
    var nullish_1 = require_nullish5();
    function propertyExists(obj, ...properties) {
      if (!properties.length) {
        return true;
      }
      if (obj && obj.hasOwnProperty(properties[0])) {
        return propertyExists(obj[properties[0]], ...properties.slice(1));
      }
      return false;
    }
    var renameKeys = (keyMapping, obj) => {
      const unchangedEntries = Object.keys(obj).filter((k) => !Object.keys(keyMapping).includes(k)).reduce((newObj, key) => ({ ...newObj, [key]: obj[key] }), {});
      return Object.entries(keyMapping).reduce((newObj, [oldKey, newKey]) => ({ ...newObj, [newKey]: obj[oldKey] }), unchangedEntries);
    };
    exports2.renameKeys = renameKeys;
    var pick = (keys, obj) => {
      const result = {};
      keys.forEach((key) => {
        const value = obj[key];
        if (Object.keys(obj).includes(key)) {
          result[key] = value;
        }
      });
      return result;
    };
    exports2.pick = pick;
    var exclude = (keys, obj) => {
      const result = {};
      Object.keys(obj).forEach((key) => {
        const value = obj[key];
        if (!keys.includes(key)) {
          result[key] = value;
        }
      });
      return result;
    };
    exports2.exclude = exclude;
    function toSanitizedObject(key, value) {
      return (0, nullish_1.isNullish)(key) || (0, nullish_1.isNullish)(value) ? {} : { [key]: value };
    }
    function pickIgnoreCase(obj = {}, ...keys) {
      return keys.reduce((filteredHeaders, providedKey) => {
        const originalKey = Object.keys(obj).find((objKey) => objKey.toLowerCase() === providedKey.toLowerCase());
        return {
          ...filteredHeaders,
          ...originalKey && { [originalKey]: obj[originalKey] }
        };
      }, {});
    }
    function pickValueIgnoreCase(obj = {}, key) {
      return Object.values(pickIgnoreCase(obj, key))[0];
    }
    function pickNonNullish(obj = {}) {
      return Object.entries(obj).filter(([key, value]) => !(0, nullish_1.isNullish)(key) && !(0, nullish_1.isNullish)(value)).reduce((filtered, [key, value]) => ({ ...filtered, [key]: value }), {});
    }
    function mergeLeftIgnoreCase(left = {}, right = {}) {
      return Object.entries(left).map(([key, value]) => pickValueIgnoreCase(right, key) ? pickIgnoreCase(right, key) : { [key]: value }).reduce((replaced, obj) => ({ ...replaced, ...obj }), {});
    }
    function mergeIgnoreCase2(left = {}, right = {}) {
      return {
        ...mergeLeftIgnoreCase(left, right),
        ...right
      };
    }
  }
});

// node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/pipe.js
var require_pipe5 = __commonJS({
  "node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/pipe.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.identity = identity;
    function identity(value) {
      return value;
    }
  }
});

// node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/promise.js
var require_promise5 = __commonJS({
  "node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/promise.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.finishAll = finishAll;
    async function finishAll(promises, errorMessage) {
      const settledPromises = await Promise.allSettled(promises);
      const rejectedPromises = settledPromises.filter((promise) => promise.status === "rejected");
      if (rejectedPromises.length) {
        const reasons = rejectedPromises.map((promise) => `	${promise.reason}`).join("\n");
        const message = errorMessage ? `${errorMessage} ` : "";
        throw new Error(`${message}Errors: [
${reasons}
]`);
      }
    }
  }
});

// node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/remove-slashes.js
var require_remove_slashes5 = __commonJS({
  "node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/remove-slashes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.removeSlashes = removeSlashes;
    exports2.removeTrailingSlashes = removeTrailingSlashes2;
    exports2.removeLeadingSlashes = removeLeadingSlashes2;
    function removeSlashes(path) {
      path = removeLeadingSlashes2(path);
      path = removeTrailingSlashes2(path);
      return path;
    }
    function removeTrailingSlashes2(path) {
      return path.endsWith("/") ? path.slice(0, -1) : path;
    }
    function removeLeadingSlashes2(path) {
      return path.startsWith("/") ? path.slice(1) : path;
    }
  }
});

// node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/types.js
var require_types5 = __commonJS({
  "node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.caps = caps;
    function caps(oDataVersion) {
      return oDataVersion ? oDataVersion.toUpperCase() : "V2";
    }
  }
});

// node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/unique-name-generator.js
var require_unique_name_generator5 = __commonJS({
  "node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/unique-name-generator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UniqueNameGenerator = void 0;
    var UniqueNameGenerator = class _UniqueNameGenerator {
      static getNameForComparison(name, caseSensitive) {
        return caseSensitive ? name : name.toLowerCase();
      }
      /**
       * Creates an instance of UniqueNameGenerator.
       * @param indexSeparator - The separator to be used when adding an index.
       * @param usedNames - Sets the already used names considered in the finding process.
       */
      constructor(indexSeparator = "_", usedNames = []) {
        this.indexSeparator = indexSeparator;
        this.usedNames = [];
        this.addToUsedNames(...usedNames);
      }
      /**
       * Adds the name(s) to the already used names.
       * @param names - Names to be added.
       */
      addToUsedNames(...names) {
        this.usedNames.push(...names);
      }
      /**
       * Generate a unique name by appending an index separated by the `indexSeparator` if necessary, e.g. if `MyName` is already taken `MyName_1` will be found by default.
       * If the name is already unique nothing is appended.
       * @param name - The name to get a unique name from.
       * @param caseSensitive - Whether to check the already used names in a case sensitive manner.
       * @returns A unique name.
       */
      generateUniqueName(name, caseSensitive = true) {
        return this.generateUniqueNamesWithSuffixes(name, [], caseSensitive)[0];
      }
      /**
       * Generate a unique name by appending an index separated by the `indexSeparator` if necessary, e.g. if `MyName` is already taken `MyName_1` will be found by default.
       * The generated name is added to the used names.
       * If the name is already unique nothing is appended.
       * @param name - The name to get a unique name from.
       * @param caseSensitive - Whether to check the already used names in a case sensitive manner.
       * @returns A unique name.
       */
      generateAndSaveUniqueName(name, caseSensitive = true) {
        const uniqueName = this.generateUniqueName(name, caseSensitive);
        this.addToUsedNames(uniqueName);
        return uniqueName;
      }
      /**
       * Generate unique names by appending an index separated by the `indexSeparator` if necessary, while respecting the given suffixes.
       * If the name is already unique nothing is appended.
       * Each given suffix is appended to the unique name in the result.
       * The resulting names are also checked for uniqueness.
       * All names in the result have the same number suffix.
       * @example if `MyName` and `MyName_1MySuffix` is already taken, `[MyName_2, MyName_2MySuffix]` will be generated by default.
       * @param name - The name to get a unique name from.
       * @param suffixes - Additional name of suffixes to be considered for the finding process, as well as the output.
       * @param caseSensitive - Whether to check the already used names in a case sensitive manner.
       * @returns A list of unique names. The length of this array is one plus the number of suffixes provided. The first entry corresponds to the given name.
       */
      generateUniqueNamesWithSuffixes(name, suffixes, caseSensitive = true) {
        const relevantUsedNames = this.getUsedNamesStartingWith(name, caseSensitive);
        const namesWithSuffixes = this.generateNamesWithSuffixes(name, suffixes);
        if (!this.areNamesUsed(namesWithSuffixes, relevantUsedNames, caseSensitive)) {
          return [name, ...namesWithSuffixes];
        }
        const index = this.getUniqueIndex(name, relevantUsedNames, suffixes, caseSensitive);
        return this.generateNamesWithIndexAndSuffixes(name, index, suffixes);
      }
      /**
       * Generate unique names by appending an index separated by the `indexSeparator` if necessary, while respecting the given suffixes.
       * If the name is already unique nothing is appended.
       * The generated names are added to the used names.
       * Each given suffix is appended to the unique name in the result.
       * The resulting names are also checked for uniqueness.
       * All names in the result have the same number suffix.
       * @example if `MyName` and `MyName_1MySuffix` is already taken, `[MyName_2, MyName_2MySuffix]` will be generated by default.
       * @param name - The name to get a unique name from.
       * @param suffixes - Additional name of suffixes to be considered for the finding process, as well as the output.
       * @param caseSensitive - Whether to check the already used names in a case sensitive manner.
       * @returns A list of unique names. The length of this array is one plus the number of suffixes provided. The first entry corresponds to the given name.
       */
      generateAndSaveUniqueNamesWithSuffixes(name, suffixes, caseSensitive = true) {
        const uniqueNames = this.generateUniqueNamesWithSuffixes(name, suffixes, caseSensitive);
        this.addToUsedNames(...uniqueNames);
        return uniqueNames;
      }
      getUsedNamesForComparison(caseSensitive) {
        return this.usedNames.map((name) => _UniqueNameGenerator.getNameForComparison(name, caseSensitive));
      }
      areNamesUsed(names, usedNames, caseSensitive) {
        return names.some((name) => usedNames.map((usedName) => _UniqueNameGenerator.getNameForComparison(usedName, caseSensitive)).includes(_UniqueNameGenerator.getNameForComparison(name, caseSensitive)));
      }
      generateNamesWithIndexAndSuffixes(name, index, suffixes) {
        const nameWithoutIndex = this.getNameWithoutIndex(name);
        return this.generateNamesWithSuffixes(`${nameWithoutIndex}${this.indexSeparator}${index}`, suffixes);
      }
      generateNamesWithSuffixes(name, suffixes) {
        return [name, ...suffixes.map((nameSuffix) => `${name}${nameSuffix}`)];
      }
      getUsedNamesStartingWith(name, caseSensitive) {
        const modifiedName = this.getNameWithoutIndex(name);
        return this.getUsedNamesForComparison(caseSensitive).filter((used) => used.startsWith(_UniqueNameGenerator.getNameForComparison(modifiedName, caseSensitive)));
      }
      getUniqueIndex(name, usedNames, suffixes, caseSensitive) {
        let index = 1;
        while (index < _UniqueNameGenerator.MAXIMUM_NUMBER_OF_SUFFIX) {
          const newNames = this.generateNamesWithIndexAndSuffixes(name, index, suffixes);
          if (!this.areNamesUsed(newNames, usedNames, caseSensitive)) {
            return index;
          }
          index++;
        }
        throw new Error(`Unable to find a unique name for ${name} within the range of ${_UniqueNameGenerator.MAXIMUM_NUMBER_OF_SUFFIX} suffixes.`);
      }
      getNameWithoutIndex(name) {
        return name.replace(new RegExp(`${this.indexSeparator}\\d+$`), "");
      }
    };
    exports2.UniqueNameGenerator = UniqueNameGenerator;
    UniqueNameGenerator.MAXIMUM_NUMBER_OF_SUFFIX = 1e3;
  }
});

// node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/url.js
var require_url5 = __commonJS({
  "node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/url.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkUrlExists = checkUrlExists;
    var axios_1 = __importDefault(require_axios());
    async function checkUrlExists(url) {
      return axios_1.default.request({ url, method: "HEAD" }).then((response) => response.status);
    }
  }
});

// node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/index.js
var require_dist13 = __commonJS({
  "node_modules/@sap-ai-sdk/foundation-models/node_modules/@sap-cloud-sdk/util/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_array5(), exports2);
    __exportStar(require_code_block5(), exports2);
    __exportStar(require_documentation_block5(), exports2);
    __exportStar(require_equal5(), exports2);
    __exportStar(require_error_with_cause5(), exports2);
    __exportStar(require_fs5(), exports2);
    __exportStar(require_logger6(), exports2);
    __exportStar(require_nullish5(), exports2);
    __exportStar(require_object5(), exports2);
    __exportStar(require_pipe5(), exports2);
    __exportStar(require_promise5(), exports2);
    __exportStar(require_remove_slashes5(), exports2);
    __exportStar(require_string5(), exports2);
    __exportStar(require_string_formatter5(), exports2);
    __exportStar(require_types5(), exports2);
    __exportStar(require_unique_name_generator5(), exports2);
    __exportStar(require_url5(), exports2);
  }
});

// node_modules/decamelize/index.js
var require_decamelize = __commonJS({
  "node_modules/decamelize/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(str, sep) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      sep = typeof sep === "undefined" ? "_" : sep;
      return str.replace(/([a-z\d])([A-Z])/g, "$1" + sep + "$2").replace(/([A-Z]+)([A-Z][a-z\d]+)/g, "$1" + sep + "$2").toLowerCase();
    };
  }
});

// node_modules/camelcase/index.js
var require_camelcase = __commonJS({
  "node_modules/camelcase/index.js"(exports2, module2) {
    "use strict";
    var UPPERCASE = /[\p{Lu}]/u;
    var LOWERCASE = /[\p{Ll}]/u;
    var LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu;
    var IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u;
    var SEPARATORS = /[_.\- ]+/;
    var LEADING_SEPARATORS = new RegExp("^" + SEPARATORS.source);
    var SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, "gu");
    var NUMBERS_AND_IDENTIFIER = new RegExp("\\d+" + IDENTIFIER.source, "gu");
    var preserveCamelCase = (string, toLowerCase, toUpperCase) => {
      let isLastCharLower = false;
      let isLastCharUpper = false;
      let isLastLastCharUpper = false;
      for (let i = 0; i < string.length; i++) {
        const character = string[i];
        if (isLastCharLower && UPPERCASE.test(character)) {
          string = string.slice(0, i) + "-" + string.slice(i);
          isLastCharLower = false;
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = true;
          i++;
        } else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character)) {
          string = string.slice(0, i - 1) + "-" + string.slice(i - 1);
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = false;
          isLastCharLower = true;
        } else {
          isLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;
        }
      }
      return string;
    };
    var preserveConsecutiveUppercase = (input, toLowerCase) => {
      LEADING_CAPITAL.lastIndex = 0;
      return input.replace(LEADING_CAPITAL, (m1) => toLowerCase(m1));
    };
    var postProcess = (input, toUpperCase) => {
      SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
      NUMBERS_AND_IDENTIFIER.lastIndex = 0;
      return input.replace(SEPARATORS_AND_IDENTIFIER, (_, identifier) => toUpperCase(identifier)).replace(NUMBERS_AND_IDENTIFIER, (m) => toUpperCase(m));
    };
    var camelCase2 = (input, options) => {
      if (!(typeof input === "string" || Array.isArray(input))) {
        throw new TypeError("Expected the input to be `string | string[]`");
      }
      options = {
        pascalCase: false,
        preserveConsecutiveUppercase: false,
        ...options
      };
      if (Array.isArray(input)) {
        input = input.map((x) => x.trim()).filter((x) => x.length).join("-");
      } else {
        input = input.trim();
      }
      if (input.length === 0) {
        return "";
      }
      const toLowerCase = options.locale === false ? (string) => string.toLowerCase() : (string) => string.toLocaleLowerCase(options.locale);
      const toUpperCase = options.locale === false ? (string) => string.toUpperCase() : (string) => string.toLocaleUpperCase(options.locale);
      if (input.length === 1) {
        return options.pascalCase ? toUpperCase(input) : toLowerCase(input);
      }
      const hasUpperCase = input !== toLowerCase(input);
      if (hasUpperCase) {
        input = preserveCamelCase(input, toLowerCase, toUpperCase);
      }
      input = input.replace(LEADING_SEPARATORS, "");
      if (options.preserveConsecutiveUppercase) {
        input = preserveConsecutiveUppercase(input, toLowerCase);
      } else {
        input = toLowerCase(input);
      }
      if (options.pascalCase) {
        input = toUpperCase(input.charAt(0)) + input.slice(1);
      }
      return postProcess(input, toUpperCase);
    };
    module2.exports = camelCase2;
    module2.exports.default = camelCase2;
  }
});

// node_modules/p-retry/index.js
var require_p_retry = __commonJS({
  "node_modules/p-retry/index.js"(exports2, module2) {
    "use strict";
    var retry = require_retry2();
    var networkErrorMsgs = [
      "Failed to fetch",
      // Chrome
      "NetworkError when attempting to fetch resource.",
      // Firefox
      "The Internet connection appears to be offline.",
      // Safari
      "Network request failed"
      // `cross-fetch`
    ];
    var AbortError = class extends Error {
      constructor(message) {
        super();
        if (message instanceof Error) {
          this.originalError = message;
          ({ message } = message);
        } else {
          this.originalError = new Error(message);
          this.originalError.stack = this.stack;
        }
        this.name = "AbortError";
        this.message = message;
      }
    };
    var decorateErrorWithCounts = (error, attemptNumber, options) => {
      const retriesLeft = options.retries - (attemptNumber - 1);
      error.attemptNumber = attemptNumber;
      error.retriesLeft = retriesLeft;
      return error;
    };
    var isNetworkError = (errorMessage) => networkErrorMsgs.includes(errorMessage);
    var pRetry4 = (input, options) => new Promise((resolve, reject) => {
      options = {
        onFailedAttempt: () => {
        },
        retries: 10,
        ...options
      };
      const operation = retry.operation(options);
      operation.attempt(async (attemptNumber) => {
        try {
          resolve(await input(attemptNumber));
        } catch (error) {
          if (!(error instanceof Error)) {
            reject(new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`));
            return;
          }
          if (error instanceof AbortError) {
            operation.stop();
            reject(error.originalError);
          } else if (error instanceof TypeError && !isNetworkError(error.message)) {
            operation.stop();
            reject(error);
          } else {
            decorateErrorWithCounts(error, attemptNumber, options);
            try {
              await options.onFailedAttempt(error);
            } catch (error2) {
              reject(error2);
              return;
            }
            if (!operation.retry(error)) {
              reject(operation.mainError());
            }
          }
        }
      });
    });
    module2.exports = pRetry4;
    module2.exports.default = pRetry4;
    module2.exports.AbortError = AbortError;
  }
});

// node_modules/@sap-ai-sdk/langchain/node_modules/ansi-styles/index.js
var require_ansi_styles2 = __commonJS({
  "node_modules/@sap-ai-sdk/langchain/node_modules/ansi-styles/index.js"(exports2, module2) {
    "use strict";
    var ANSI_BACKGROUND_OFFSET = 10;
    var wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`;
    var wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`;
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles2 = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          overline: [53, 55],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles2.color.gray = styles2.color.blackBright;
      styles2.bgColor.bgGray = styles2.bgColor.bgBlackBright;
      styles2.color.grey = styles2.color.blackBright;
      styles2.bgColor.bgGrey = styles2.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles2)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles2[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles2[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles2, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles2, "codes", {
        value: codes,
        enumerable: false
      });
      styles2.color.close = "\x1B[39m";
      styles2.bgColor.close = "\x1B[49m";
      styles2.color.ansi256 = wrapAnsi256();
      styles2.color.ansi16m = wrapAnsi16m();
      styles2.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
      styles2.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
      Object.defineProperties(styles2, {
        rgbToAnsi256: {
          value: (red, green, blue) => {
            if (red === green && green === blue) {
              if (red < 8) {
                return 16;
              }
              if (red > 248) {
                return 231;
              }
              return Math.round((red - 8) / 247 * 24) + 232;
            }
            return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
          },
          enumerable: false
        },
        hexToRgb: {
          value: (hex) => {
            const matches = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(hex.toString(16));
            if (!matches) {
              return [0, 0, 0];
            }
            let { colorString } = matches.groups;
            if (colorString.length === 3) {
              colorString = colorString.split("").map((character) => character + character).join("");
            }
            const integer = Number.parseInt(colorString, 16);
            return [
              integer >> 16 & 255,
              integer >> 8 & 255,
              integer & 255
            ];
          },
          enumerable: false
        },
        hexToAnsi256: {
          value: (hex) => styles2.rgbToAnsi256(...styles2.hexToRgb(hex)),
          enumerable: false
        }
      });
      return styles2;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports2, module2) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;
    EventEmitter.prefixed = prefix;
    EventEmitter.EventEmitter = EventEmitter;
    if ("undefined" !== typeof module2) {
      module2.exports = EventEmitter;
    }
  }
});

// node_modules/p-finally/index.js
var require_p_finally = __commonJS({
  "node_modules/p-finally/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (promise, onFinally) => {
      onFinally = onFinally || (() => {
      });
      return promise.then(
        (val) => new Promise((resolve) => {
          resolve(onFinally());
        }).then(() => val),
        (err) => new Promise((resolve) => {
          resolve(onFinally());
        }).then(() => {
          throw err;
        })
      );
    };
  }
});

// node_modules/p-timeout/index.js
var require_p_timeout = __commonJS({
  "node_modules/p-timeout/index.js"(exports2, module2) {
    "use strict";
    var pFinally = require_p_finally();
    var TimeoutError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "TimeoutError";
      }
    };
    var pTimeout = (promise, milliseconds, fallback) => new Promise((resolve, reject) => {
      if (typeof milliseconds !== "number" || milliseconds < 0) {
        throw new TypeError("Expected `milliseconds` to be a positive number");
      }
      if (milliseconds === Infinity) {
        resolve(promise);
        return;
      }
      const timer = setTimeout(() => {
        if (typeof fallback === "function") {
          try {
            resolve(fallback());
          } catch (error) {
            reject(error);
          }
          return;
        }
        const message = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
        const timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);
        if (typeof promise.cancel === "function") {
          promise.cancel();
        }
        reject(timeoutError);
      }, milliseconds);
      pFinally(
        // eslint-disable-next-line promise/prefer-await-to-then
        promise.then(resolve, reject),
        () => {
          clearTimeout(timer);
        }
      );
    });
    module2.exports = pTimeout;
    module2.exports.default = pTimeout;
    module2.exports.TimeoutError = TimeoutError;
  }
});

// node_modules/p-queue/dist/lower-bound.js
var require_lower_bound = __commonJS({
  "node_modules/p-queue/dist/lower-bound.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function lowerBound(array, value, comparator) {
      let first = 0;
      let count = array.length;
      while (count > 0) {
        const step = count / 2 | 0;
        let it = first + step;
        if (comparator(array[it], value) <= 0) {
          first = ++it;
          count -= step + 1;
        } else {
          count = step;
        }
      }
      return first;
    }
    exports2.default = lowerBound;
  }
});

// node_modules/p-queue/dist/priority-queue.js
var require_priority_queue = __commonJS({
  "node_modules/p-queue/dist/priority-queue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var lower_bound_1 = require_lower_bound();
    var PriorityQueue = class {
      constructor() {
        this._queue = [];
      }
      enqueue(run, options) {
        options = Object.assign({ priority: 0 }, options);
        const element = {
          priority: options.priority,
          run
        };
        if (this.size && this._queue[this.size - 1].priority >= options.priority) {
          this._queue.push(element);
          return;
        }
        const index = lower_bound_1.default(this._queue, element, (a, b) => b.priority - a.priority);
        this._queue.splice(index, 0, element);
      }
      dequeue() {
        const item = this._queue.shift();
        return item === null || item === void 0 ? void 0 : item.run;
      }
      filter(options) {
        return this._queue.filter((element) => element.priority === options.priority).map((element) => element.run);
      }
      get size() {
        return this._queue.length;
      }
    };
    exports2.default = PriorityQueue;
  }
});

// node_modules/p-queue/dist/index.js
var require_dist14 = __commonJS({
  "node_modules/p-queue/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var EventEmitter = require_eventemitter3();
    var p_timeout_1 = require_p_timeout();
    var priority_queue_1 = require_priority_queue();
    var empty = () => {
    };
    var timeoutError = new p_timeout_1.TimeoutError();
    var PQueue = class extends EventEmitter {
      constructor(options) {
        var _a, _b, _c, _d;
        super();
        this._intervalCount = 0;
        this._intervalEnd = 0;
        this._pendingCount = 0;
        this._resolveEmpty = empty;
        this._resolveIdle = empty;
        options = Object.assign({ carryoverConcurrencyCount: false, intervalCap: Infinity, interval: 0, concurrency: Infinity, autoStart: true, queueClass: priority_queue_1.default }, options);
        if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
          throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : ""}\` (${typeof options.intervalCap})`);
        }
        if (options.interval === void 0 || !(Number.isFinite(options.interval) && options.interval >= 0)) {
          throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""}\` (${typeof options.interval})`);
        }
        this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;
        this._isIntervalIgnored = options.intervalCap === Infinity || options.interval === 0;
        this._intervalCap = options.intervalCap;
        this._interval = options.interval;
        this._queue = new options.queueClass();
        this._queueClass = options.queueClass;
        this.concurrency = options.concurrency;
        this._timeout = options.timeout;
        this._throwOnTimeout = options.throwOnTimeout === true;
        this._isPaused = options.autoStart === false;
      }
      get _doesIntervalAllowAnother() {
        return this._isIntervalIgnored || this._intervalCount < this._intervalCap;
      }
      get _doesConcurrentAllowAnother() {
        return this._pendingCount < this._concurrency;
      }
      _next() {
        this._pendingCount--;
        this._tryToStartAnother();
        this.emit("next");
      }
      _resolvePromises() {
        this._resolveEmpty();
        this._resolveEmpty = empty;
        if (this._pendingCount === 0) {
          this._resolveIdle();
          this._resolveIdle = empty;
          this.emit("idle");
        }
      }
      _onResumeInterval() {
        this._onInterval();
        this._initializeIntervalIfNeeded();
        this._timeoutId = void 0;
      }
      _isIntervalPaused() {
        const now = Date.now();
        if (this._intervalId === void 0) {
          const delay = this._intervalEnd - now;
          if (delay < 0) {
            this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
          } else {
            if (this._timeoutId === void 0) {
              this._timeoutId = setTimeout(() => {
                this._onResumeInterval();
              }, delay);
            }
            return true;
          }
        }
        return false;
      }
      _tryToStartAnother() {
        if (this._queue.size === 0) {
          if (this._intervalId) {
            clearInterval(this._intervalId);
          }
          this._intervalId = void 0;
          this._resolvePromises();
          return false;
        }
        if (!this._isPaused) {
          const canInitializeInterval = !this._isIntervalPaused();
          if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {
            const job = this._queue.dequeue();
            if (!job) {
              return false;
            }
            this.emit("active");
            job();
            if (canInitializeInterval) {
              this._initializeIntervalIfNeeded();
            }
            return true;
          }
        }
        return false;
      }
      _initializeIntervalIfNeeded() {
        if (this._isIntervalIgnored || this._intervalId !== void 0) {
          return;
        }
        this._intervalId = setInterval(() => {
          this._onInterval();
        }, this._interval);
        this._intervalEnd = Date.now() + this._interval;
      }
      _onInterval() {
        if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {
          clearInterval(this._intervalId);
          this._intervalId = void 0;
        }
        this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
        this._processQueue();
      }
      /**
      Executes all queued functions until it reaches the limit.
      */
      _processQueue() {
        while (this._tryToStartAnother()) {
        }
      }
      get concurrency() {
        return this._concurrency;
      }
      set concurrency(newConcurrency) {
        if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
          throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
        }
        this._concurrency = newConcurrency;
        this._processQueue();
      }
      /**
      Adds a sync or async task to the queue. Always returns a promise.
      */
      async add(fn, options = {}) {
        return new Promise((resolve, reject) => {
          const run = async () => {
            this._pendingCount++;
            this._intervalCount++;
            try {
              const operation = this._timeout === void 0 && options.timeout === void 0 ? fn() : p_timeout_1.default(Promise.resolve(fn()), options.timeout === void 0 ? this._timeout : options.timeout, () => {
                if (options.throwOnTimeout === void 0 ? this._throwOnTimeout : options.throwOnTimeout) {
                  reject(timeoutError);
                }
                return void 0;
              });
              resolve(await operation);
            } catch (error) {
              reject(error);
            }
            this._next();
          };
          this._queue.enqueue(run, options);
          this._tryToStartAnother();
          this.emit("add");
        });
      }
      /**
          Same as `.add()`, but accepts an array of sync or async functions.
      
          @returns A promise that resolves when all functions are resolved.
          */
      async addAll(functions, options) {
        return Promise.all(functions.map(async (function_) => this.add(function_, options)));
      }
      /**
      Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
      */
      start() {
        if (!this._isPaused) {
          return this;
        }
        this._isPaused = false;
        this._processQueue();
        return this;
      }
      /**
      Put queue execution on hold.
      */
      pause() {
        this._isPaused = true;
      }
      /**
      Clear the queue.
      */
      clear() {
        this._queue = new this._queueClass();
      }
      /**
          Can be called multiple times. Useful if you for example add additional items at a later time.
      
          @returns A promise that settles when the queue becomes empty.
          */
      async onEmpty() {
        if (this._queue.size === 0) {
          return;
        }
        return new Promise((resolve) => {
          const existingResolve = this._resolveEmpty;
          this._resolveEmpty = () => {
            existingResolve();
            resolve();
          };
        });
      }
      /**
          The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
      
          @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
          */
      async onIdle() {
        if (this._pendingCount === 0 && this._queue.size === 0) {
          return;
        }
        return new Promise((resolve) => {
          const existingResolve = this._resolveIdle;
          this._resolveIdle = () => {
            existingResolve();
            resolve();
          };
        });
      }
      /**
      Size of the queue.
      */
      get size() {
        return this._queue.size;
      }
      /**
          Size of the queue, filtered by the given options.
      
          For example, this can be used to find the number of items remaining in the queue with a specific priority level.
          */
      sizeBy(options) {
        return this._queue.filter(options).length;
      }
      /**
      Number of pending promises.
      */
      get pending() {
        return this._pendingCount;
      }
      /**
      Whether the queue is currently paused.
      */
      get isPaused() {
        return this._isPaused;
      }
      get timeout() {
        return this._timeout;
      }
      /**
      Set the timeout for future operations.
      */
      set timeout(milliseconds) {
        this._timeout = milliseconds;
      }
    };
    exports2.default = PQueue;
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports2) {
    "use strict";
    exports2.byteLength = byteLength;
    exports2.toByteArray = toByteArray;
    exports2.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr2 = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr2[curByte++] = tmp >> 16 & 255;
        arr2[curByte++] = tmp >> 8 & 255;
        arr2[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr2[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr2[curByte++] = tmp >> 8 & 255;
        arr2[curByte++] = tmp & 255;
      }
      return arr2;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// srv/esm/index.js
var index_exports = {};
__export(index_exports, {
  AzureOpenAiEmbeddingClient: () => AzureOpenAiEmbeddingClient2,
  OrchestrationClient: () => OrchestrationClient,
  buildAzureContentSafetyFilter: () => buildAzureContentSafetyFilter
});
module.exports = __toCommonJS(index_exports);

// node_modules/@sap-ai-sdk/orchestration/dist/orchestration-stream-response.js
var OrchestrationStreamResponse = class {
  _usage;
  /**
   * Finish reasons for all choices.
   */
  _finishReasons = /* @__PURE__ */ new Map();
  _stream;
  getTokenUsage() {
    return this._usage;
  }
  /**
   * @internal
   */
  _setTokenUsage(usage) {
    this._usage = usage;
  }
  getFinishReason(choiceIndex = 0) {
    return this._finishReasons.get(choiceIndex);
  }
  /**
   * @internal
   */
  _getFinishReasons() {
    return this._finishReasons;
  }
  /**
   * @internal
   */
  _setFinishReasons(finishReasons) {
    this._finishReasons = finishReasons;
  }
  get stream() {
    if (!this._stream) {
      throw new Error("Response stream is undefined.");
    }
    return this._stream;
  }
  /**
   * @internal
   */
  set stream(stream) {
    this._stream = stream;
  }
};

// node_modules/@sap-ai-sdk/orchestration/dist/orchestration-stream-chunk-response.js
var OrchestrationStreamChunkResponse = class {
  data;
  constructor(data) {
    this.data = data;
    this.data = data;
  }
  /**
   * Usage of tokens in the chunk response.
   * @returns Token usage.
   */
  getTokenUsage() {
    return this.data.orchestration_result?.usage;
  }
  /**
   * Reason for stopping the completion stream chunk.
   * @param choiceIndex - The index of the choice to parse.
   * @returns The finish reason.
   */
  getFinishReason(choiceIndex = 0) {
    return this.getChoices()?.find((c) => c.index === choiceIndex)?.finish_reason;
  }
  /**
   * Parses the chunk response and returns the delta content.
   * @param choiceIndex - The index of the choice to parse.
   * @returns The message delta content.
   */
  getDeltaContent(choiceIndex = 0) {
    return this.getChoices()?.find((c) => c.index === choiceIndex)?.delta.content;
  }
  getChoices() {
    return this.data.orchestration_result?.choices;
  }
};

// node_modules/@sap-ai-sdk/orchestration/dist/orchestration-stream.js
var import_util4 = __toESM(require_dist(), 1);

// node_modules/@sap-ai-sdk/core/dist/http-client.js
var import_node_stream = require("node:stream");
var import_consumers = require("node:stream/consumers");
var import_util2 = __toESM(require_dist2(), 1);
var import_http_client = __toESM(require_dist5(), 1);

// node_modules/@sap-ai-sdk/core/dist/context.js
var import_util = __toESM(require_dist2(), 1);
var import_connectivity = __toESM(require_dist4(), 1);
var logger = (0, import_util.createLogger)({
  package: "core",
  messageContext: "context"
});
var aiCoreServiceBinding;
async function getAiCoreDestination(destination) {
  if (destination) {
    if (destination.destinationName !== void 0 && destination.useCache === void 0) {
      destination.useCache = true;
    }
    const resolvedDestination = await (0, import_connectivity.useOrFetchDestination)(destination);
    if (!resolvedDestination) {
      throw new Error("Could not resolve destination.");
    }
    (0, import_connectivity.assertHttpDestination)(resolvedDestination);
    return resolvedDestination;
  }
  if (!aiCoreServiceBinding) {
    aiCoreServiceBinding = getAiCoreServiceKeyFromEnv() || (0, import_connectivity.getServiceBinding)("aicore");
    if (!aiCoreServiceBinding) {
      throw new Error("Could not find service credentials for AI Core. Please check the service binding.");
    }
  }
  const aiCoreDestination = await (0, import_connectivity.transformServiceBindingToDestination)(aiCoreServiceBinding, {
    useCache: true
  });
  return aiCoreDestination;
}
function getAiCoreServiceKeyFromEnv() {
  const credentials = parseServiceKeyFromEnv(process.env["AICORE_SERVICE_KEY"]);
  if (credentials) {
    logger.info('Found a service key in environment variable "AICORE_SERVICE_KEY". Using a service key is recommended for local testing only. Bind the AI Core service to the application for productive usage.');
    return {
      credentials,
      label: "aicore",
      name: "aicore",
      tags: ["aicore"]
    };
  }
}
function parseServiceKeyFromEnv(aiCoreEnv) {
  if (aiCoreEnv) {
    try {
      return JSON.parse(aiCoreEnv);
    } catch (err) {
      throw new Error('Error in parsing service key from the "AICORE_SERVICE_KEY" environment variable.', { cause: err });
    }
  }
}

// node_modules/@sap-ai-sdk/core/dist/http-client.js
async function executeRequest(endpointOptions, data, requestConfig, destination) {
  const aiCoreDestination = await getAiCoreDestination(destination);
  const { url, apiVersion: apiVersion2, resourceGroup = "default" } = endpointOptions;
  const mergedRequestConfig = {
    ...mergeWithDefaultRequestConfig(apiVersion2, resourceGroup, requestConfig),
    data: JSON.stringify(data)
  };
  try {
    const response = await (0, import_http_client.executeHttpRequest)({ ...aiCoreDestination, url: getTargetUrl(aiCoreDestination.url, url) }, mergedRequestConfig, {
      fetchCsrfToken: false
    });
    return response;
  } catch (error) {
    await handleStreamError(error);
    throw new import_util2.ErrorWithCause(`Request failed with status code ${error.status}.`, error);
  }
}
async function handleStreamError(error) {
  if (error.response?.data && error.config.responseType === "stream") {
    const readable = import_node_stream.Readable.from(error.response.data);
    error.response.data = await (0, import_consumers.json)(readable);
  }
}
function mergeWithDefaultRequestConfig(apiVersion2, resourceGroup, requestConfig) {
  const defaultConfig = {
    method: "post",
    headers: {
      "content-type": "application/json",
      "ai-resource-group": resourceGroup,
      "ai-client-type": "AI SDK JavaScript"
    },
    params: apiVersion2 ? { "api-version": apiVersion2 } : {}
  };
  return {
    ...defaultConfig,
    ...requestConfig,
    headers: (0, import_util2.mergeIgnoreCase)(defaultConfig.headers, requestConfig?.headers),
    params: (0, import_util2.mergeIgnoreCase)(defaultConfig.params, requestConfig?.params)
  };
}
function getTargetUrl(url, endpointPath) {
  url = (0, import_util2.removeTrailingSlashes)(url);
  endpointPath = (0, import_util2.removeLeadingSlashes)(endpointPath);
  const urlObj = new URL(url);
  if (urlObj.pathname === "/") {
    return url + "/v2/" + endpointPath;
  }
  return url + "/" + endpointPath;
}

// node_modules/@sap-ai-sdk/core/dist/openapi-request-builder.js
var import_openapi = __toESM(require_dist10(), 1);
var OpenApiRequestBuilder = class extends import_openapi.OpenApiRequestBuilder {
  constructor(method, pathPattern, parameters, basePath) {
    super(method, pathPattern, parameters, basePath);
  }
  /**
   * Execute request and get the response data. Use this to conveniently access the data of a service without technical information about the response.
   * @param destination - The destination to execute the request against.
   * @returns A promise resolving to an HttpResponse.
   */
  async executeRaw(destination) {
    const { url, data, ...rest } = await this.requestConfig();
    return executeRequest({ url }, data, {
      ...rest,
      headers: {
        ...rest.headers?.requestConfig,
        ...rest.headers?.custom
      },
      params: {
        ...rest.params?.requestConfig,
        ...rest.params?.custom
      }
    }, destination);
  }
  /**
   * Execute request and get the response data. Use this to conveniently access the data of a service without technical information about the response.
   * @param destination - The destination to execute the request against.
   * @returns A promise resolving to the requested return type.
   */
  async execute(destination) {
    const response = await this.executeRaw(destination);
    if ("data" in response) {
      return response.data;
    }
    throw new Error("Could not access response data. Response was not an axios response.");
  }
};

// node_modules/@sap-ai-sdk/core/dist/stream/sse-stream.js
var import_util3 = __toESM(require_dist2(), 1);

// node_modules/@sap-ai-sdk/core/dist/stream/line-decoder.js
var LineDecoder = class _LineDecoder {
  // prettier-ignore
  static NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r"]);
  static NEWLINE_REGEXP = /\r\n|[\n\r]/g;
  buffer;
  trailingCR;
  textDecoder;
  // TextDecoder found in browsers; not typed to avoid pulling in either "dom" or "node" types.
  constructor() {
    this.buffer = [];
    this.trailingCR = false;
  }
  decode(chunk) {
    let text = this.decodeText(chunk);
    if (this.trailingCR) {
      text = "\r" + text;
      this.trailingCR = false;
    }
    if (text.endsWith("\r")) {
      this.trailingCR = true;
      text = text.slice(0, -1);
    }
    if (!text) {
      return [];
    }
    const trailingNewline = _LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || "");
    let lines = text.split(_LineDecoder.NEWLINE_REGEXP);
    if (trailingNewline) {
      lines.pop();
    }
    if (lines.length === 1 && !trailingNewline) {
      this.buffer.push(lines[0]);
      return [];
    }
    if (this.buffer.length) {
      lines = [this.buffer.join("") + lines[0], ...lines.slice(1)];
      this.buffer = [];
    }
    if (!trailingNewline) {
      this.buffer = [lines.pop() || ""];
    }
    return lines;
  }
  decodeText(bytes) {
    if (bytes == null) {
      return "";
    }
    if (typeof bytes === "string") {
      return bytes;
    }
    if (typeof Buffer !== "undefined") {
      if (bytes instanceof Buffer) {
        return bytes.toString();
      }
      if (bytes instanceof Uint8Array) {
        return Buffer.from(bytes).toString();
      }
      throw new Error(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`);
    }
    throw new Error("Unexpected: Buffer is not available as globals. Please report this error.");
  }
  flush() {
    if (!this.buffer.length && !this.trailingCR) {
      return [];
    }
    const lines = [this.buffer.join("")];
    this.buffer = [];
    this.trailingCR = false;
    return lines;
  }
};

// node_modules/@sap-ai-sdk/core/dist/stream/sse-decoder.js
var SSEDecoder = class {
  data;
  event;
  chunks;
  constructor() {
    this.event = null;
    this.data = [];
    this.chunks = [];
  }
  /**
   * Decode the line into structured server sent event.
   * @param line - Line to decode.
   * @returns Server sent event if the line is empty meaning the end of the received event, or null if there are more lines to come.
   */
  decode(line) {
    if (line.endsWith("\r")) {
      line = line.substring(0, line.length - 1);
    }
    if (!line) {
      if (!this.event && !this.data.length) {
        return null;
      }
      const sse = {
        event: this.event,
        data: this.data.join("\n"),
        raw: this.chunks
      };
      this.event = null;
      this.data = [];
      this.chunks = [];
      return sse;
    }
    this.chunks.push(line);
    if (line.startsWith(":")) {
      return null;
    }
    const [fieldname, _, value] = partition(line, ":");
    const trimedValue = value.startsWith(" ") ? value.substring(1) : value;
    if (fieldname === "event") {
      this.event = trimedValue;
    } else if (fieldname === "data") {
      this.data.push(trimedValue);
    } else {
      throw new Error(`Invalid SSE payload: ${line}`);
    }
    return null;
  }
};
function partition(str, delimiter) {
  const index = str.indexOf(delimiter);
  if (index !== -1) {
    return [
      str.substring(0, index),
      delimiter,
      str.substring(index + delimiter.length)
    ];
  }
  return [str, "", ""];
}

// node_modules/@sap-ai-sdk/core/dist/stream/sse-stream.js
var logger2 = (0, import_util3.createLogger)({
  package: "foundation-models",
  messageContext: "azure-openai-sse-stream"
});
var SseStream = class _SseStream {
  iterator;
  static transformToSseStream(response, controller) {
    let consumed = false;
    async function* iterator() {
      if (consumed) {
        throw new Error("Cannot iterate over a consumed stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const sse of _iterSseMessages(response, controller)) {
          if (done) {
            continue;
          }
          if (sse.data.startsWith("[DONE]")) {
            done = true;
            continue;
          }
          try {
            const data = JSON.parse(sse.data);
            if (data?.error) {
              throw new Error(data.error);
            }
            yield sse.event === null ? data : { event: sse.event, data };
          } catch (e) {
            logger2.error(`Could not parse message into JSON: ${sse.data}`);
            logger2.error(`From chunk: ${sse.raw}`);
            throw e;
          }
        }
        done = true;
      } catch (e) {
        if (e instanceof Error && e.name === "CanceledError") {
          return;
        }
        logger2.error("Error while iterating over SSE stream:", e);
      } finally {
        if (!done) {
          controller.abort();
        }
      }
    }
    return new _SseStream(iterator, controller);
  }
  controller;
  constructor(iterator, controller) {
    this.iterator = iterator;
    this.controller = controller;
  }
  [Symbol.asyncIterator]() {
    return this.iterator();
  }
};
async function* _iterSseMessages(response, controller) {
  if (!response.data) {
    controller.abort();
    throw new Error("Attempted to iterate over a response with no body");
  }
  const sseDecoder = new SSEDecoder();
  const lineDecoder = new LineDecoder();
  const iter = response.data;
  for await (const sseChunk of iterSseChunks(iter)) {
    for (const line of lineDecoder.decode(sseChunk)) {
      const sse = sseDecoder.decode(line);
      if (sse) {
        yield sse;
      }
    }
  }
  for (const line of lineDecoder.flush()) {
    const sse = sseDecoder.decode(line);
    if (sse) {
      yield sse;
    }
  }
}
async function* iterSseChunks(iterator) {
  let data = new Uint8Array();
  for await (const chunk of iterator) {
    if (chunk == null) {
      continue;
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? new TextEncoder().encode(chunk) : chunk;
    const newData = new Uint8Array(data.length + binaryChunk.length);
    newData.set(data);
    newData.set(binaryChunk, data.length);
    data = newData;
    let patternIndex;
    while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {
      yield data.slice(0, patternIndex);
      data = data.slice(patternIndex);
    }
  }
  if (data.length) {
    yield data;
  }
}
function findDoubleNewlineIndex(buffer) {
  const newline = 10;
  const carriage = 13;
  for (let i = 0; i < buffer.length - 2; i++) {
    if (buffer[i] === newline && buffer[i + 1] === newline) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === carriage) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === newline && i + 3 < buffer.length && buffer[i + 2] === carriage && buffer[i + 3] === newline) {
      return i + 4;
    }
  }
  return -1;
}

// node_modules/@sap-ai-sdk/orchestration/dist/orchestration-stream.js
var logger3 = (0, import_util4.createLogger)({
  package: "orchestration",
  messageContext: "orchestration-chat-completion-stream"
});
var OrchestrationStream = class _OrchestrationStream extends SseStream {
  iterator;
  /**
   * Create an orchestration stream based on the http response.
   * @param response - Http response.
   * @returns An orchestration stream.
   * @internal
   */
  static _create(response, controller) {
    const stream = SseStream.transformToSseStream(response, controller);
    return new _OrchestrationStream(stream.iterator, controller);
  }
  /**
   * Wrap raw chunk data with chunk response class to provide helper functions.
   * @param stream - Orchestration stream.
   * @internal
   */
  static async *_processChunk(stream) {
    for await (const chunk of stream) {
      yield new OrchestrationStreamChunkResponse(chunk);
    }
  }
  /**
   * @internal
   */
  static async *_processFinishReason(stream, response) {
    for await (const chunk of stream) {
      chunk.data.orchestration_result?.choices.forEach((choice) => {
        const choiceIndex = choice.index;
        if (choiceIndex >= 0) {
          const finishReason = chunk.getFinishReason(choiceIndex);
          if (finishReason) {
            if (response) {
              response._getFinishReasons().set(choiceIndex, finishReason);
            }
            switch (finishReason) {
              case "content_filter":
                logger3.error(`Choice ${choiceIndex}: Stream finished with content filter hit.`);
                break;
              case "length":
                logger3.error(`Choice ${choiceIndex}: Stream finished with token length exceeded.`);
                break;
              case "stop":
                logger3.debug(`Choice ${choiceIndex}: Stream finished.`);
                break;
              case "tool_calls":
                logger3.error(`Choice ${choiceIndex}: Stream finished with tool calls exceeded.`);
                break;
              case "function_call":
                logger3.error(`Choice ${choiceIndex}: Stream finished with function call exceeded.`);
                break;
              default:
                logger3.error(`Choice ${choiceIndex}: Stream finished with unknown reason '${finishReason}'.`);
            }
          }
        }
      });
      yield chunk;
    }
  }
  /**
   * @internal
   */
  static async *_processTokenUsage(stream, response) {
    for await (const chunk of stream) {
      const usage = chunk.getTokenUsage();
      if (usage) {
        if (response) {
          response._setTokenUsage(usage);
        }
        logger3.debug(`Token usage: ${JSON.stringify(usage)}`);
      }
      yield chunk;
    }
  }
  /**
   * Transform a stream of chunks into a stream of content strings.
   * @param stream - Orchestration stream.
   * @param choiceIndex - The index of the choice to parse.
   * @internal
   */
  static async *_processContentStream(stream) {
    for await (const chunk of stream) {
      const deltaContent = chunk.getDeltaContent();
      if (!deltaContent) {
        continue;
      }
      yield deltaContent;
    }
  }
  constructor(iterator, controller) {
    super(iterator, controller);
    this.iterator = iterator;
  }
  /**
   * Pipe the stream through a processing function.
   * @param processFn - The function to process the input stream.
   * @param response - The `OrchestrationStreamResponse` object for process function to store finish reason, token usage, etc.
   * @returns The output stream containing processed items.
   * @internal
   */
  _pipe(processFn, response) {
    if (response) {
      return new _OrchestrationStream(() => processFn(this, response), this.controller);
    }
    return new _OrchestrationStream(() => processFn(this), this.controller);
  }
  /**
   * Transform the stream of chunks into a stream of content strings.
   * @param this - Orchestration stream.
   * @returns A stream of content strings.
   */
  toContentStream() {
    return new _OrchestrationStream(() => _OrchestrationStream._processContentStream(this), this.controller);
  }
};

// node_modules/@sap-ai-sdk/ai-api/dist/utils/deployment-resolver.js
var import_util5 = __toESM(require_dist11(), 1);

// node_modules/@sap-ai-sdk/ai-api/dist/client/AI_CORE_API/deployment-api.js
var DeploymentApi = {
  _defaultBasePath: void 0,
  /**
   * Retrieve a list of deployments that match the specified filter criteria.
   * Filter criteria include a list of executableIds, a scenarioId, a configurationId, or a deployment status.
   * With top/skip parameters it is possible to paginate the result list.
   * With select parameter it is possible to select only status.
   *
   * @param queryParameters - Object containing the following keys: executableIds, configurationId, scenarioId, status, $top, $skip, $select.
   * @param headerParameters - Object containing the following keys: AI-Resource-Group.
   * @returns The request builder, use the `execute()` method to trigger the request.
   */
  deploymentQuery: (queryParameters, headerParameters) => new OpenApiRequestBuilder("get", "/lm/deployments", {
    queryParameters,
    headerParameters
  }, DeploymentApi._defaultBasePath),
  /**
   * Create a deployment using the configuration specified by configurationId after synchronously checking the
   * correctness of the configuration.
   *
   * @param body - Request body.
   * @param headerParameters - Object containing the following keys: AI-Resource-Group.
   * @returns The request builder, use the `execute()` method to trigger the request.
   */
  deploymentCreate: (body, headerParameters) => new OpenApiRequestBuilder("post", "/lm/deployments", {
    body,
    headerParameters
  }, DeploymentApi._defaultBasePath),
  /**
   * Update status of multiple deployments. stop or delete multiple deployments.
   * @param body - Request body.
   * @param headerParameters - Object containing the following keys: AI-Resource-Group.
   * @returns The request builder, use the `execute()` method to trigger the request.
   */
  deploymentBatchModify: (body, headerParameters) => new OpenApiRequestBuilder("patch", "/lm/deployments", {
    body,
    headerParameters
  }, DeploymentApi._defaultBasePath),
  /**
   * Retrieve details for execution with deploymentId.
   * @param deploymentId - Deployment identifier
   * @param queryParameters - Object containing the following keys: $select.
   * @param headerParameters - Object containing the following keys: AI-Resource-Group.
   * @returns The request builder, use the `execute()` method to trigger the request.
   */
  deploymentGet: (deploymentId, queryParameters, headerParameters) => new OpenApiRequestBuilder("get", "/lm/deployments/{deploymentId}", {
    pathParameters: { deploymentId },
    queryParameters,
    headerParameters
  }, DeploymentApi._defaultBasePath),
  /**
   * Update target status of a deployment to stop a deployment or change the configuration to be used by the
   * deployment after synchronously checking the correctness of the configuration. A change of configuration is only
   * allowed for RUNNING and PENDING deployments.
   *
   * @param deploymentId - Deployment identifier
   * @param body - Request body.
   * @param headerParameters - Object containing the following keys: AI-Resource-Group.
   * @returns The request builder, use the `execute()` method to trigger the request.
   */
  deploymentModify: (deploymentId, body, headerParameters) => new OpenApiRequestBuilder("patch", "/lm/deployments/{deploymentId}", {
    pathParameters: { deploymentId },
    body,
    headerParameters
  }, DeploymentApi._defaultBasePath),
  /**
   * Mark deployment with deploymentId as deleted.
   * @param deploymentId - Deployment identifier
   * @param headerParameters - Object containing the following keys: AI-Resource-Group.
   * @returns The request builder, use the `execute()` method to trigger the request.
   */
  deploymentDelete: (deploymentId, headerParameters) => new OpenApiRequestBuilder("delete", "/lm/deployments/{deploymentId}", {
    pathParameters: { deploymentId },
    headerParameters
  }, DeploymentApi._defaultBasePath),
  /**
   * Retrieve the number of available deployments. The number can be filtered by
   * scenarioId, configurationId, executableIdsList or by deployment status.
   *
   * @param queryParameters - Object containing the following keys: executableIds, configurationId, scenarioId, status.
   * @param headerParameters - Object containing the following keys: AI-Resource-Group.
   * @returns The request builder, use the `execute()` method to trigger the request.
   */
  deploymentCount: (queryParameters, headerParameters) => new OpenApiRequestBuilder("get", "/lm/deployments/$count", {
    queryParameters,
    headerParameters
  }, DeploymentApi._defaultBasePath),
  /**
   * Retrieve logs of a deployment for getting insight into the deployment results or failures.
   * @param deploymentId - Deployment identifier
   * @param queryParameters - Object containing the following keys: $top, start, end, $order.
   * @param headerParameters - Object containing the following keys: Authorization.
   * @returns The request builder, use the `execute()` method to trigger the request.
   */
  kubesubmitV4DeploymentsGetLogs: (deploymentId, queryParameters, headerParameters) => new OpenApiRequestBuilder("get", "/lm/deployments/{deploymentId}/logs", {
    pathParameters: { deploymentId },
    queryParameters,
    headerParameters
  }, DeploymentApi._defaultBasePath)
};

// node_modules/@sap-ai-sdk/ai-api/dist/utils/deployment-cache.js
var import_internal = __toESM(require_internal14(), 1);

// node_modules/@sap-ai-sdk/ai-api/dist/utils/model.js
function isFoundationModel(model) {
  return typeof model === "object" && "name" in model;
}
function extractModel(deployment) {
  const model = deployment.details?.resources?.backendDetails?.model;
  if (isFoundationModel(model)) {
    return model;
  }
}

// node_modules/@sap-ai-sdk/ai-api/dist/utils/deployment-cache.js
function getCacheKey({ scenarioId, executableId = "", model, resourceGroup = "default" }) {
  return `${scenarioId}:${executableId}:${model?.name ?? ""}:${model?.version ?? ""}:${resourceGroup}`;
}
function createDeploymentCache(cache) {
  return {
    /**
     * Get a deployment from the cache.
     * @param opts - Deployment resolution options to get the cached deployment for.
     * @returns The cached deployment or undefined if not found.
     */
    get: (opts) => cache.get(getCacheKey(opts)),
    /**
     * Store a deployment in the cache.
     * @param opts - Deployment resolution options to set the deployment for.
     * @param deployment - Deployment to cache.
     */
    set: (opts, deployment) => {
      cache.set(getCacheKey(opts), {
        entry: transformDeploymentForCache(deployment)
      });
    },
    /**
     * Store multiple deployments in the cache, based on the model from the respective AI deployments.
     * @param opts - Deployment resolution options to set the deployments for. Model information in the deployment resolution options are ignored.
     * @param deployments - Deployments to retrieve the IDs and models from.
     */
    setAll: (opts, deployments) => {
      [...deployments].reverse().map((deployment) => transformDeploymentForCache(deployment)).flatMap((entry) => [
        entry,
        { id: entry.id },
        ...entry.model ? [{ id: entry.id, model: { name: entry.model.name } }] : []
      ]).forEach((entry) => {
        cache.set(getCacheKey({ ...opts, model: entry.model }), {
          entry
        });
      });
    },
    clear: () => cache.clear()
  };
}
function transformDeploymentForCache(deployment) {
  return {
    id: deployment.id,
    model: extractModel(deployment)
  };
}
var deploymentCache = createDeploymentCache(
  new import_internal.Cache(5 * 60 * 1e3)
  // 5 minutes
);

// node_modules/@sap-ai-sdk/ai-api/dist/utils/deployment-resolver.js
function getResourceGroup(modelDeployment) {
  return typeof modelDeployment === "object" ? modelDeployment.resourceGroup : void 0;
}
function isDeploymentIdConfig(modelDeployment) {
  return typeof modelDeployment === "object" && "deploymentId" in modelDeployment;
}
async function resolveDeploymentId(opts) {
  const { model } = opts;
  const cachedDeployment = deploymentCache.get(opts);
  if (cachedDeployment?.id) {
    return cachedDeployment.id;
  }
  let deployments = await getAllDeployments(opts);
  if (model) {
    deployments = deployments.filter((deployment) => extractModel(deployment)?.name === model.name);
    if (model.version) {
      deployments = deployments.filter((deployment) => extractModel(deployment)?.version === model.version);
    }
  }
  if (!deployments.length) {
    throw new Error(`No deployment matched the given criteria: ${JSON.stringify(opts)}. Make sure the deployment is successful, as it is a prerequisite before consuming orchestration or foundation models.`);
  }
  return deployments[0].id;
}
async function getAllDeployments(opts) {
  const { destination, scenarioId, executableId, resourceGroup = "default" } = opts;
  try {
    const { resources } = await DeploymentApi.deploymentQuery({
      scenarioId,
      status: "RUNNING",
      ...executableId && { executableIds: [executableId] }
    }, { "AI-Resource-Group": resourceGroup }).execute(destination);
    deploymentCache.setAll(opts, resources);
    return resources;
  } catch (error) {
    throw new import_util5.ErrorWithCause("Failed to fetch the list of deployments.", error);
  }
}
async function getDeploymentId(modelDeployment, executableId, destination) {
  if (isDeploymentIdConfig(modelDeployment)) {
    return modelDeployment.deploymentId;
  }
  const model = typeof modelDeployment === "string" ? { modelName: modelDeployment } : modelDeployment;
  return resolveDeploymentId({
    scenarioId: "foundation-models",
    executableId,
    model: translateToFoundationModel(model),
    resourceGroup: model.resourceGroup,
    destination
  });
}
function translateToFoundationModel(modelConfig) {
  if (typeof modelConfig === "string") {
    return { name: modelConfig };
  }
  return {
    name: modelConfig.modelName,
    ...modelConfig.modelVersion && { version: modelConfig.modelVersion }
  };
}

// node_modules/@sap-ai-sdk/orchestration/dist/orchestration-client.js
var import_util7 = __toESM(require_dist(), 1);

// node_modules/@sap-ai-sdk/orchestration/dist/orchestration-response.js
var OrchestrationResponse = class {
  rawResponse;
  /**
   * The completion post response.
   */
  data;
  constructor(rawResponse) {
    this.rawResponse = rawResponse;
    this.data = rawResponse.data;
  }
  /**
   * Usage of tokens in the response.
   * @returns Token usage.
   */
  getTokenUsage() {
    return this.data.orchestration_result.usage;
  }
  /**
   * Reason for stopping the completion.
   * @param choiceIndex - The index of the choice to parse.
   * @returns The finish reason.
   */
  getFinishReason(choiceIndex = 0) {
    return this.getChoices().find((c) => c.index === choiceIndex)?.finish_reason;
  }
  /**
   * Parses the orchestration response and returns the content.
   * If the response was filtered, an error is thrown.
   * @param choiceIndex - The index of the choice to parse.
   * @returns The message content.
   */
  getContent(choiceIndex = 0) {
    const choice = this.getChoices().find((c) => c.index === choiceIndex);
    if (choice?.message?.content === "" && choice?.finish_reason === "content_filter") {
      throw new Error("Content generated by the LLM was filtered by the output filter. Please try again with a different prompt or filter configuration.");
    }
    return choice?.message?.content;
  }
  getChoices() {
    return this.data.orchestration_result.choices;
  }
};

// node_modules/@sap-ai-sdk/orchestration/dist/orchestration-types.js
var supportedAzureFilterThresholds = {
  ALLOW_SAFE: 0,
  ALLOW_SAFE_LOW: 2,
  ALLOW_SAFE_LOW_MEDIUM: 4,
  ALLOW_ALL: 6
};

// node_modules/@sap-ai-sdk/orchestration/dist/util/filtering.js
function buildAzureContentSafetyFilter(config) {
  if (config && !Object.keys(config).length) {
    throw new Error("Filtering configuration cannot be an empty object");
  }
  return {
    type: "azure_content_safety",
    ...config && {
      config: {
        ...Object.fromEntries(Object.entries(config).map(([key, value]) => [
          key,
          supportedAzureFilterThresholds[value]
        ]))
      }
    }
  };
}

// node_modules/@sap-ai-sdk/orchestration/dist/util/module-config.js
var import_util6 = __toESM(require_dist(), 1);
var logger4 = (0, import_util6.createLogger)({
  package: "orchestration",
  messageContext: "orchestration-utils"
});
function constructCompletionPostRequestFromJsonModuleConfig(config, prompt, stream) {
  const orchestration_config = { ...config };
  if (stream) {
    orchestration_config.stream = true;
  } else {
    delete orchestration_config.stream;
  }
  return {
    messages_history: prompt?.messagesHistory || [],
    input_params: prompt?.inputParams || {},
    orchestration_config
  };
}
function addStreamOptionsToLlmModuleConfig(llmModuleConfig, streamOptions) {
  if (streamOptions?.llm === null) {
    return llmModuleConfig;
  }
  return {
    ...llmModuleConfig,
    model_params: {
      ...llmModuleConfig.model_params,
      ...streamOptions?.llm !== null && {
        stream_options: {
          include_usage: true,
          ...llmModuleConfig.model_params?.stream_options || {},
          ...streamOptions?.llm || {}
        }
      }
    }
  };
}
function addStreamOptionsToOutputFilteringConfig(outputFilteringConfig, filteringStreamOptions) {
  return {
    ...outputFilteringConfig,
    stream_options: {
      ...outputFilteringConfig.stream_options || {},
      ...filteringStreamOptions
    }
  };
}
function addStreamOptions(moduleConfigs, streamOptions) {
  const { llm_module_config, filtering_module_config } = moduleConfigs;
  const outputFiltering = streamOptions?.outputFiltering;
  const globalOptions = streamOptions?.global;
  if (!moduleConfigs?.filtering_module_config?.output && outputFiltering) {
    logger4.warn("Output filter stream options are not applied because filtering module is not configured.");
  }
  return {
    stream: true,
    ...globalOptions && { stream_options: globalOptions },
    module_configurations: {
      ...moduleConfigs,
      llm_module_config: addStreamOptionsToLlmModuleConfig(llm_module_config, streamOptions),
      ...outputFiltering && filtering_module_config?.output && {
        filtering_module_config: {
          ...filtering_module_config,
          output: addStreamOptionsToOutputFilteringConfig(filtering_module_config.output, outputFiltering)
        }
      }
    }
  };
}
function constructCompletionPostRequest(config, prompt, stream, streamOptions) {
  const moduleConfigurations = {
    templating_module_config: config.templating,
    llm_module_config: config.llm,
    ...config?.filtering && Object.keys(config.filtering).length && {
      filtering_module_config: config.filtering
    },
    ...config?.masking && Object.keys(config.masking).length && {
      masking_module_config: config.masking
    },
    ...config?.grounding && Object.keys(config.grounding).length && {
      grounding_module_config: config.grounding
    }
  };
  return {
    orchestration_config: stream ? addStreamOptions(moduleConfigurations, mergeStreamOptions(config.streaming, streamOptions)) : { module_configurations: moduleConfigurations },
    ...prompt?.inputParams && {
      input_params: prompt.inputParams
    },
    ...prompt?.messagesHistory && {
      messages_history: prompt.messagesHistory
    }
  };
}
function mergeStreamOptions(globalOptions, streamOptions) {
  return {
    ...streamOptions,
    ...(globalOptions || streamOptions?.global) && {
      global: {
        ...globalOptions,
        ...streamOptions?.global
      }
    }
  };
}

// node_modules/@sap-ai-sdk/orchestration/dist/orchestration-client.js
var logger5 = (0, import_util7.createLogger)({
  package: "orchestration",
  messageContext: "orchestration-client"
});
var OrchestrationClient = class {
  config;
  deploymentConfig;
  destination;
  /**
   * Creates an instance of the orchestration client.
   * @param config - Orchestration module configuration. This can either be an `OrchestrationModuleConfig` object or a JSON string obtained from AI Launchpad.
   * @param deploymentConfig - Deployment configuration.
   * @param destination - The destination to use for the request.
   */
  constructor(config, deploymentConfig, destination) {
    this.config = config;
    this.deploymentConfig = deploymentConfig;
    this.destination = destination;
    try {
      if (typeof config === "string") {
        JSON.parse(config);
      }
    } catch (error) {
      throw new Error(`Could not parse JSON: ${error}`);
    }
  }
  async chatCompletion(prompt, requestConfig) {
    const response = await this.executeRequest({
      prompt,
      requestConfig,
      stream: false
    });
    return new OrchestrationResponse(response);
  }
  async stream(prompt, controller = new AbortController(), options, requestConfig) {
    if (typeof this.config === "string" && options) {
      logger5.warn("Stream options are not supported when using a JSON module config.");
    }
    return this.createStreamResponse({
      prompt,
      requestConfig,
      stream: true,
      streamOptions: options
    }, controller);
  }
  async executeRequest(options) {
    const { prompt, requestConfig, stream, streamOptions } = options;
    const body = typeof this.config === "string" ? constructCompletionPostRequestFromJsonModuleConfig(JSON.parse(this.config), prompt, stream) : constructCompletionPostRequest(this.config, prompt, stream, streamOptions);
    const deploymentId = await resolveDeploymentId({
      scenarioId: "orchestration",
      ...this.deploymentConfig ?? {},
      destination: this.destination
    });
    return executeRequest({
      url: `/inference/deployments/${deploymentId}/completion`,
      ...this.deploymentConfig ?? {}
    }, body, requestConfig, this.destination);
  }
  async createStreamResponse(options, controller) {
    const response = new OrchestrationStreamResponse();
    const streamResponse = await this.executeRequest({
      ...options,
      requestConfig: {
        ...options.requestConfig,
        responseType: "stream",
        signal: controller.signal
      }
    });
    const stream = OrchestrationStream._create(streamResponse, controller);
    response.stream = stream._pipe(OrchestrationStream._processChunk)._pipe(OrchestrationStream._processFinishReason, response)._pipe(OrchestrationStream._processTokenUsage, response);
    return response;
  }
};

// node_modules/@sap-ai-sdk/foundation-models/dist/azure-openai/model-types.js
var apiVersion = "2024-10-21";

// node_modules/@sap-ai-sdk/foundation-models/dist/azure-openai/azure-openai-chat-completion-stream.js
var import_util10 = __toESM(require_dist13(), 1);
var logger6 = (0, import_util10.createLogger)({
  package: "foundation-models",
  messageContext: "azure-openai-chat-completion-stream"
});

// node_modules/@sap-ai-sdk/foundation-models/dist/azure-openai/azure-openai-embedding-response.js
var import_util11 = __toESM(require_dist13(), 1);
var logger7 = (0, import_util11.createLogger)({
  package: "foundation-models",
  messageContext: "azure-openai-embedding-response"
});
var AzureOpenAiEmbeddingResponse = class {
  rawResponse;
  /**
   * The embedding response.
   */
  data;
  constructor(rawResponse) {
    this.rawResponse = rawResponse;
    this.data = rawResponse.data;
  }
  /**
   * Parses the Azure OpenAI response and returns the embedding.
   * @param dataIndex - The index of the data to parse.
   * @returns The embedding vector.
   */
  getEmbedding(dataIndex = 0) {
    this.logInvalidDataIndex(dataIndex);
    return this.data.data[dataIndex]?.embedding;
  }
  /**
   * Parses the Azure OpenAI response and returns all embeddings.
   * @returns The embedding vectors.
   */
  getEmbeddings() {
    return this.data.data.map(({ embedding }) => embedding);
  }
  logInvalidDataIndex(dataIndex) {
    if (dataIndex < 0 || dataIndex >= this.data.data.length) {
      logger7.error(`Data index ${dataIndex} is out of bounds.`);
    }
  }
};

// node_modules/@sap-ai-sdk/foundation-models/dist/azure-openai/azure-openai-embedding-client.js
var AzureOpenAiEmbeddingClient = class {
  modelDeployment;
  destination;
  /**
   * Creates an instance of the Azure OpenAI embedding client.
   * @param modelDeployment - This configuration is used to retrieve a deployment. Depending on the configuration use either the given deployment ID or the model name to retrieve matching deployments. If model and deployment ID are given, the model is verified against the deployment.
   */
  constructor(modelDeployment, destination) {
    this.modelDeployment = modelDeployment;
    this.destination = destination;
  }
  /**
   * Creates an embedding vector representing the given text.
   * @param data - The text to embed.
   * @param requestConfig - The request configuration.
   * @returns The completion result.
   */
  async run(data, requestConfig) {
    const deploymentId = await getDeploymentId(this.modelDeployment, "azure-openai", this.destination);
    const resourceGroup = getResourceGroup(this.modelDeployment);
    const response = await executeRequest({
      url: `/inference/deployments/${deploymentId}/embeddings`,
      apiVersion,
      resourceGroup
    }, data, requestConfig, this.destination);
    return new AzureOpenAiEmbeddingResponse(response);
  }
};

// node_modules/zod-to-json-schema/dist/esm/Options.js
var ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");

// node_modules/zod-to-json-schema/dist/esm/parsers/string.js
var ALPHA_NUMERIC = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");

// node_modules/@sap-ai-sdk/langchain/node_modules/@langchain/core/dist/load/map_keys.js
var import_decamelize = __toESM(require_decamelize(), 1);
var import_camelcase = __toESM(require_camelcase(), 1);
function keyToJson(key, map) {
  return map?.[key] || (0, import_decamelize.default)(key);
}
function mapKeys(fields, mapper, map) {
  const mapped = {};
  for (const key in fields) {
    if (Object.hasOwn(fields, key)) {
      mapped[mapper(key, map)] = fields[key];
    }
  }
  return mapped;
}

// node_modules/@sap-ai-sdk/langchain/node_modules/@langchain/core/dist/load/serializable.js
function shallowCopy(obj) {
  return Array.isArray(obj) ? [...obj] : { ...obj };
}
function replaceSecrets(root2, secretsMap) {
  const result = shallowCopy(root2);
  for (const [path, secretId] of Object.entries(secretsMap)) {
    const [last, ...partsReverse] = path.split(".").reverse();
    let current = result;
    for (const part of partsReverse.reverse()) {
      if (current[part] === void 0) {
        break;
      }
      current[part] = shallowCopy(current[part]);
      current = current[part];
    }
    if (current[last] !== void 0) {
      current[last] = {
        lc: 1,
        type: "secret",
        id: [secretId]
      };
    }
  }
  return result;
}
function get_lc_unique_name(serializableClass) {
  const parentClass = Object.getPrototypeOf(serializableClass);
  const lcNameIsSubclassed = typeof serializableClass.lc_name === "function" && (typeof parentClass.lc_name !== "function" || serializableClass.lc_name() !== parentClass.lc_name());
  if (lcNameIsSubclassed) {
    return serializableClass.lc_name();
  } else {
    return serializableClass.name;
  }
}
var Serializable = class _Serializable {
  /**
   * The name of the serializable. Override to provide an alias or
   * to preserve the serialized module name in minified environments.
   *
   * Implemented as a static method to support loading logic.
   */
  static lc_name() {
    return this.name;
  }
  /**
   * The final serialized identifier for the module.
   */
  get lc_id() {
    return [
      ...this.lc_namespace,
      get_lc_unique_name(this.constructor)
    ];
  }
  /**
   * A map of secrets, which will be omitted from serialization.
   * Keys are paths to the secret in constructor args, e.g. "foo.bar.baz".
   * Values are the secret ids, which will be used when deserializing.
   */
  get lc_secrets() {
    return void 0;
  }
  /**
   * A map of additional attributes to merge with constructor args.
   * Keys are the attribute names, e.g. "foo".
   * Values are the attribute values, which will be serialized.
   * These attributes need to be accepted by the constructor as arguments.
   */
  get lc_attributes() {
    return void 0;
  }
  /**
   * A map of aliases for constructor args.
   * Keys are the attribute names, e.g. "foo".
   * Values are the alias that will replace the key in serialization.
   * This is used to eg. make argument names match Python.
   */
  get lc_aliases() {
    return void 0;
  }
  /**
   * A manual list of keys that should be serialized.
   * If not overridden, all fields passed into the constructor will be serialized.
   */
  get lc_serializable_keys() {
    return void 0;
  }
  constructor(kwargs, ..._args) {
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "lc_kwargs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    if (this.lc_serializable_keys !== void 0) {
      this.lc_kwargs = Object.fromEntries(Object.entries(kwargs || {}).filter(([key]) => this.lc_serializable_keys?.includes(key)));
    } else {
      this.lc_kwargs = kwargs ?? {};
    }
  }
  toJSON() {
    if (!this.lc_serializable) {
      return this.toJSONNotImplemented();
    }
    if (
      // eslint-disable-next-line no-instanceof/no-instanceof
      this.lc_kwargs instanceof _Serializable || typeof this.lc_kwargs !== "object" || Array.isArray(this.lc_kwargs)
    ) {
      return this.toJSONNotImplemented();
    }
    const aliases = {};
    const secrets = {};
    const kwargs = Object.keys(this.lc_kwargs).reduce((acc, key) => {
      acc[key] = key in this ? this[key] : this.lc_kwargs[key];
      return acc;
    }, {});
    for (let current = Object.getPrototypeOf(this); current; current = Object.getPrototypeOf(current)) {
      Object.assign(aliases, Reflect.get(current, "lc_aliases", this));
      Object.assign(secrets, Reflect.get(current, "lc_secrets", this));
      Object.assign(kwargs, Reflect.get(current, "lc_attributes", this));
    }
    Object.keys(secrets).forEach((keyPath) => {
      let read = this;
      let write = kwargs;
      const [last, ...partsReverse] = keyPath.split(".").reverse();
      for (const key of partsReverse.reverse()) {
        if (!(key in read) || read[key] === void 0)
          return;
        if (!(key in write) || write[key] === void 0) {
          if (typeof read[key] === "object" && read[key] != null) {
            write[key] = {};
          } else if (Array.isArray(read[key])) {
            write[key] = [];
          }
        }
        read = read[key];
        write = write[key];
      }
      if (last in read && read[last] !== void 0) {
        write[last] = write[last] || read[last];
      }
    });
    return {
      lc: 1,
      type: "constructor",
      id: this.lc_id,
      kwargs: mapKeys(Object.keys(secrets).length ? replaceSecrets(kwargs, secrets) : kwargs, keyToJson, aliases)
    };
  }
  toJSONNotImplemented() {
    return {
      lc: 1,
      type: "not_implemented",
      id: this.lc_id
    };
  }
};

// node_modules/@sap-ai-sdk/langchain/node_modules/@langchain/core/dist/messages/base.js
function stringifyWithDepthLimit(obj, depthLimit) {
  function helper(obj2, currentDepth) {
    if (typeof obj2 !== "object" || obj2 === null || obj2 === void 0) {
      return obj2;
    }
    if (currentDepth >= depthLimit) {
      if (Array.isArray(obj2)) {
        return "[Array]";
      }
      return "[Object]";
    }
    if (Array.isArray(obj2)) {
      return obj2.map((item) => helper(item, currentDepth + 1));
    }
    const result = {};
    for (const key of Object.keys(obj2)) {
      result[key] = helper(obj2[key], currentDepth + 1);
    }
    return result;
  }
  return JSON.stringify(helper(obj, 0), null, 2);
}
var BaseMessage = class extends Serializable {
  get lc_aliases() {
    return {
      additional_kwargs: "additional_kwargs",
      response_metadata: "response_metadata"
    };
  }
  /**
   * @deprecated
   * Use {@link BaseMessage.content} instead.
   */
  get text() {
    return typeof this.content === "string" ? this.content : "";
  }
  /** The type of the message. */
  getType() {
    return this._getType();
  }
  constructor(fields, kwargs) {
    if (typeof fields === "string") {
      fields = {
        content: fields,
        additional_kwargs: kwargs,
        response_metadata: {}
      };
    }
    if (!fields.additional_kwargs) {
      fields.additional_kwargs = {};
    }
    if (!fields.response_metadata) {
      fields.response_metadata = {};
    }
    super(fields);
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain_core", "messages"]
    });
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "content", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "additional_kwargs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "response_metadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "id", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.name = fields.name;
    this.content = fields.content;
    this.additional_kwargs = fields.additional_kwargs;
    this.response_metadata = fields.response_metadata;
    this.id = fields.id;
  }
  toDict() {
    return {
      type: this._getType(),
      data: this.toJSON().kwargs
    };
  }
  static lc_name() {
    return "BaseMessage";
  }
  // Can't be protected for silly reasons
  get _printableFields() {
    return {
      id: this.id,
      content: this.content,
      name: this.name,
      additional_kwargs: this.additional_kwargs,
      response_metadata: this.response_metadata
    };
  }
  // this private method is used to update the ID for the runtime
  // value as well as in lc_kwargs for serialisation
  _updateId(value) {
    this.id = value;
    this.lc_kwargs.id = value;
  }
  get [Symbol.toStringTag]() {
    return this.constructor.lc_name();
  }
  // Override the default behavior of console.log
  [Symbol.for("nodejs.util.inspect.custom")](depth) {
    if (depth === null) {
      return this;
    }
    const printable = stringifyWithDepthLimit(this._printableFields, Math.max(4, depth));
    return `${this.constructor.lc_name()} ${printable}`;
  }
};

// node_modules/@sap-ai-sdk/langchain/node_modules/@langchain/core/dist/messages/utils.js
function getBufferString(messages, humanPrefix = "Human", aiPrefix = "AI") {
  const string_messages = [];
  for (const m of messages) {
    let role;
    if (m._getType() === "human") {
      role = humanPrefix;
    } else if (m._getType() === "ai") {
      role = aiPrefix;
    } else if (m._getType() === "system") {
      role = "System";
    } else if (m._getType() === "function") {
      role = "Function";
    } else if (m._getType() === "tool") {
      role = "Tool";
    } else if (m._getType() === "generic") {
      role = m.role;
    } else {
      throw new Error(`Got unsupported message type: ${m._getType()}`);
    }
    const nameStr = m.name ? `${m.name}, ` : "";
    const readableContent = typeof m.content === "string" ? m.content : JSON.stringify(m.content, null, 2);
    string_messages.push(`${role}: ${nameStr}${readableContent}`);
  }
  return string_messages.join("\n");
}

// node_modules/@sap-ai-sdk/langchain/node_modules/@langchain/core/dist/runnables/base.js
var import_p_retry3 = __toESM(require_p_retry(), 1);

// node_modules/@sap-ai-sdk/langchain/node_modules/@langchain/core/node_modules/uuid/dist/esm-node/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr2, offset = 0) {
  return (byteToHex[arr2[offset + 0]] + byteToHex[arr2[offset + 1]] + byteToHex[arr2[offset + 2]] + byteToHex[arr2[offset + 3]] + "-" + byteToHex[arr2[offset + 4]] + byteToHex[arr2[offset + 5]] + "-" + byteToHex[arr2[offset + 6]] + byteToHex[arr2[offset + 7]] + "-" + byteToHex[arr2[offset + 8]] + byteToHex[arr2[offset + 9]] + "-" + byteToHex[arr2[offset + 10]] + byteToHex[arr2[offset + 11]] + byteToHex[arr2[offset + 12]] + byteToHex[arr2[offset + 13]] + byteToHex[arr2[offset + 14]] + byteToHex[arr2[offset + 15]]).toLowerCase();
}

// node_modules/@sap-ai-sdk/langchain/node_modules/@langchain/core/node_modules/uuid/dist/esm-node/rng.js
var import_node_crypto = __toESM(require("node:crypto"));
var rnds8Pool = new Uint8Array(256);
var poolPtr = rnds8Pool.length;
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    import_node_crypto.default.randomFillSync(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}

// node_modules/@sap-ai-sdk/langchain/node_modules/@langchain/core/node_modules/uuid/dist/esm-node/native.js
var import_node_crypto2 = __toESM(require("node:crypto"));
var native_default = {
  randomUUID: import_node_crypto2.default.randomUUID
};

// node_modules/@sap-ai-sdk/langchain/node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// node_modules/langsmith/dist/singletons/traceable.js
var MockAsyncLocalStorage = class {
  getStore() {
    return void 0;
  }
  run(_, callback) {
    return callback();
  }
};
var TRACING_ALS_KEY = Symbol.for("ls:tracing_async_local_storage");
var mockAsyncLocalStorage = new MockAsyncLocalStorage();
var AsyncLocalStorageProvider = class {
  getInstance() {
    return globalThis[TRACING_ALS_KEY] ?? mockAsyncLocalStorage;
  }
  initializeGlobalInstance(instance) {
    if (globalThis[TRACING_ALS_KEY] === void 0) {
      globalThis[TRACING_ALS_KEY] = instance;
    }
  }
};
var AsyncLocalStorageProviderSingleton = new AsyncLocalStorageProvider();
function getCurrentRunTree(permitAbsentRunTree = false) {
  const runTree = AsyncLocalStorageProviderSingleton.getInstance().getStore();
  if (!permitAbsentRunTree && runTree === void 0) {
    throw new Error("Could not get the current run tree.\n\nPlease make sure you are calling this method within a traceable function and that tracing is enabled.");
  }
  return runTree;
}
var ROOT = Symbol.for("langsmith:traceable:root");

// node_modules/@sap-ai-sdk/langchain/node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.js
var core_exports = {};
__export(core_exports, {
  JsonPatchError: () => JsonPatchError,
  _areEquals: () => _areEquals,
  applyOperation: () => applyOperation,
  applyPatch: () => applyPatch,
  applyReducer: () => applyReducer,
  deepClone: () => deepClone,
  getValueByPointer: () => getValueByPointer,
  validate: () => validate,
  validator: () => validator
});

// node_modules/@sap-ai-sdk/langchain/node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.js
var _hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwnProperty(obj, key) {
  return _hasOwnProperty.call(obj, key);
}
function _objectKeys(obj) {
  if (Array.isArray(obj)) {
    const keys2 = new Array(obj.length);
    for (let k = 0; k < keys2.length; k++) {
      keys2[k] = "" + k;
    }
    return keys2;
  }
  if (Object.keys) {
    return Object.keys(obj);
  }
  let keys = [];
  for (let i in obj) {
    if (hasOwnProperty(obj, i)) {
      keys.push(i);
    }
  }
  return keys;
}
function _deepClone(obj) {
  switch (typeof obj) {
    case "object":
      return JSON.parse(JSON.stringify(obj));
    //Faster than ES5 clone - http://jsperf.com/deep-cloning-of-objects/5
    case "undefined":
      return null;
    //this is how JSON.stringify behaves for array items
    default:
      return obj;
  }
}
function isInteger(str) {
  let i = 0;
  const len = str.length;
  let charCode;
  while (i < len) {
    charCode = str.charCodeAt(i);
    if (charCode >= 48 && charCode <= 57) {
      i++;
      continue;
    }
    return false;
  }
  return true;
}
function escapePathComponent(path) {
  if (path.indexOf("/") === -1 && path.indexOf("~") === -1)
    return path;
  return path.replace(/~/g, "~0").replace(/\//g, "~1");
}
function unescapePathComponent(path) {
  return path.replace(/~1/g, "/").replace(/~0/g, "~");
}
function hasUndefined(obj) {
  if (obj === void 0) {
    return true;
  }
  if (obj) {
    if (Array.isArray(obj)) {
      for (let i2 = 0, len = obj.length; i2 < len; i2++) {
        if (hasUndefined(obj[i2])) {
          return true;
        }
      }
    } else if (typeof obj === "object") {
      const objKeys = _objectKeys(obj);
      const objKeysLength = objKeys.length;
      for (var i = 0; i < objKeysLength; i++) {
        if (hasUndefined(obj[objKeys[i]])) {
          return true;
        }
      }
    }
  }
  return false;
}
function patchErrorMessageFormatter(message, args) {
  const messageParts = [message];
  for (const key in args) {
    const value = typeof args[key] === "object" ? JSON.stringify(args[key], null, 2) : args[key];
    if (typeof value !== "undefined") {
      messageParts.push(`${key}: ${value}`);
    }
  }
  return messageParts.join("\n");
}
var PatchError = class extends Error {
  constructor(message, name, index, operation, tree) {
    super(patchErrorMessageFormatter(message, { name, index, operation, tree }));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: name
    });
    Object.defineProperty(this, "index", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: index
    });
    Object.defineProperty(this, "operation", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: operation
    });
    Object.defineProperty(this, "tree", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: tree
    });
    Object.setPrototypeOf(this, new.target.prototype);
    this.message = patchErrorMessageFormatter(message, {
      name,
      index,
      operation,
      tree
    });
  }
};

// node_modules/@sap-ai-sdk/langchain/node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.js
var JsonPatchError = PatchError;
var deepClone = _deepClone;
var objOps = {
  add: function(obj, key, document2) {
    obj[key] = this.value;
    return { newDocument: document2 };
  },
  remove: function(obj, key, document2) {
    var removed = obj[key];
    delete obj[key];
    return { newDocument: document2, removed };
  },
  replace: function(obj, key, document2) {
    var removed = obj[key];
    obj[key] = this.value;
    return { newDocument: document2, removed };
  },
  move: function(obj, key, document2) {
    let removed = getValueByPointer(document2, this.path);
    if (removed) {
      removed = _deepClone(removed);
    }
    const originalValue = applyOperation(document2, {
      op: "remove",
      path: this.from
    }).removed;
    applyOperation(document2, {
      op: "add",
      path: this.path,
      value: originalValue
    });
    return { newDocument: document2, removed };
  },
  copy: function(obj, key, document2) {
    const valueToCopy = getValueByPointer(document2, this.from);
    applyOperation(document2, {
      op: "add",
      path: this.path,
      value: _deepClone(valueToCopy)
    });
    return { newDocument: document2 };
  },
  test: function(obj, key, document2) {
    return { newDocument: document2, test: _areEquals(obj[key], this.value) };
  },
  _get: function(obj, key, document2) {
    this.value = obj[key];
    return { newDocument: document2 };
  }
};
var arrOps = {
  add: function(arr2, i, document2) {
    if (isInteger(i)) {
      arr2.splice(i, 0, this.value);
    } else {
      arr2[i] = this.value;
    }
    return { newDocument: document2, index: i };
  },
  remove: function(arr2, i, document2) {
    var removedList = arr2.splice(i, 1);
    return { newDocument: document2, removed: removedList[0] };
  },
  replace: function(arr2, i, document2) {
    var removed = arr2[i];
    arr2[i] = this.value;
    return { newDocument: document2, removed };
  },
  move: objOps.move,
  copy: objOps.copy,
  test: objOps.test,
  _get: objOps._get
};
function getValueByPointer(document2, pointer) {
  if (pointer == "") {
    return document2;
  }
  var getOriginalDestination = { op: "_get", path: pointer };
  applyOperation(document2, getOriginalDestination);
  return getOriginalDestination.value;
}
function applyOperation(document2, operation, validateOperation = false, mutateDocument = true, banPrototypeModifications = true, index = 0) {
  if (validateOperation) {
    if (typeof validateOperation == "function") {
      validateOperation(operation, 0, document2, operation.path);
    } else {
      validator(operation, 0);
    }
  }
  if (operation.path === "") {
    let returnValue = { newDocument: document2 };
    if (operation.op === "add") {
      returnValue.newDocument = operation.value;
      return returnValue;
    } else if (operation.op === "replace") {
      returnValue.newDocument = operation.value;
      returnValue.removed = document2;
      return returnValue;
    } else if (operation.op === "move" || operation.op === "copy") {
      returnValue.newDocument = getValueByPointer(document2, operation.from);
      if (operation.op === "move") {
        returnValue.removed = document2;
      }
      return returnValue;
    } else if (operation.op === "test") {
      returnValue.test = _areEquals(document2, operation.value);
      if (returnValue.test === false) {
        throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document2);
      }
      returnValue.newDocument = document2;
      return returnValue;
    } else if (operation.op === "remove") {
      returnValue.removed = document2;
      returnValue.newDocument = null;
      return returnValue;
    } else if (operation.op === "_get") {
      operation.value = document2;
      return returnValue;
    } else {
      if (validateOperation) {
        throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index, operation, document2);
      } else {
        return returnValue;
      }
    }
  } else {
    if (!mutateDocument) {
      document2 = _deepClone(document2);
    }
    const path = operation.path || "";
    const keys = path.split("/");
    let obj = document2;
    let t = 1;
    let len = keys.length;
    let existingPathFragment = void 0;
    let key;
    let validateFunction;
    if (typeof validateOperation == "function") {
      validateFunction = validateOperation;
    } else {
      validateFunction = validator;
    }
    while (true) {
      key = keys[t];
      if (key && key.indexOf("~") != -1) {
        key = unescapePathComponent(key);
      }
      if (banPrototypeModifications && (key == "__proto__" || key == "prototype" && t > 0 && keys[t - 1] == "constructor")) {
        throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
      }
      if (validateOperation) {
        if (existingPathFragment === void 0) {
          if (obj[key] === void 0) {
            existingPathFragment = keys.slice(0, t).join("/");
          } else if (t == len - 1) {
            existingPathFragment = operation.path;
          }
          if (existingPathFragment !== void 0) {
            validateFunction(operation, 0, document2, existingPathFragment);
          }
        }
      }
      t++;
      if (Array.isArray(obj)) {
        if (key === "-") {
          key = obj.length;
        } else {
          if (validateOperation && !isInteger(key)) {
            throw new JsonPatchError("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", index, operation, document2);
          } else if (isInteger(key)) {
            key = ~~key;
          }
        }
        if (t >= len) {
          if (validateOperation && operation.op === "add" && key > obj.length) {
            throw new JsonPatchError("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", index, operation, document2);
          }
          const returnValue = arrOps[operation.op].call(operation, obj, key, document2);
          if (returnValue.test === false) {
            throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document2);
          }
          return returnValue;
        }
      } else {
        if (t >= len) {
          const returnValue = objOps[operation.op].call(operation, obj, key, document2);
          if (returnValue.test === false) {
            throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document2);
          }
          return returnValue;
        }
      }
      obj = obj[key];
      if (validateOperation && t < len && (!obj || typeof obj !== "object")) {
        throw new JsonPatchError("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", index, operation, document2);
      }
    }
  }
}
function applyPatch(document2, patch, validateOperation, mutateDocument = true, banPrototypeModifications = true) {
  if (validateOperation) {
    if (!Array.isArray(patch)) {
      throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    }
  }
  if (!mutateDocument) {
    document2 = _deepClone(document2);
  }
  const results = new Array(patch.length);
  for (let i = 0, length = patch.length; i < length; i++) {
    results[i] = applyOperation(document2, patch[i], validateOperation, true, banPrototypeModifications, i);
    document2 = results[i].newDocument;
  }
  results.newDocument = document2;
  return results;
}
function applyReducer(document2, operation, index) {
  const operationResult = applyOperation(document2, operation);
  if (operationResult.test === false) {
    throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document2);
  }
  return operationResult.newDocument;
}
function validator(operation, index, document2, existingPathFragment) {
  if (typeof operation !== "object" || operation === null || Array.isArray(operation)) {
    throw new JsonPatchError("Operation is not an object", "OPERATION_NOT_AN_OBJECT", index, operation, document2);
  } else if (!objOps[operation.op]) {
    throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index, operation, document2);
  } else if (typeof operation.path !== "string") {
    throw new JsonPatchError("Operation `path` property is not a string", "OPERATION_PATH_INVALID", index, operation, document2);
  } else if (operation.path.indexOf("/") !== 0 && operation.path.length > 0) {
    throw new JsonPatchError('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", index, operation, document2);
  } else if ((operation.op === "move" || operation.op === "copy") && typeof operation.from !== "string") {
    throw new JsonPatchError("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", index, operation, document2);
  } else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && operation.value === void 0) {
    throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", index, operation, document2);
  } else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && hasUndefined(operation.value)) {
    throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", index, operation, document2);
  } else if (document2) {
    if (operation.op == "add") {
      var pathLen = operation.path.split("/").length;
      var existingPathLen = existingPathFragment.split("/").length;
      if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {
        throw new JsonPatchError("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", index, operation, document2);
      }
    } else if (operation.op === "replace" || operation.op === "remove" || operation.op === "_get") {
      if (operation.path !== existingPathFragment) {
        throw new JsonPatchError("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", index, operation, document2);
      }
    } else if (operation.op === "move" || operation.op === "copy") {
      var existingValue = {
        op: "_get",
        path: operation.from,
        value: void 0
      };
      var error = validate([existingValue], document2);
      if (error && error.name === "OPERATION_PATH_UNRESOLVABLE") {
        throw new JsonPatchError("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", index, operation, document2);
      }
    }
  }
}
function validate(sequence, document2, externalValidator) {
  try {
    if (!Array.isArray(sequence)) {
      throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    }
    if (document2) {
      applyPatch(_deepClone(document2), _deepClone(sequence), externalValidator || true);
    } else {
      externalValidator = externalValidator || validator;
      for (var i = 0; i < sequence.length; i++) {
        externalValidator(sequence[i], i, document2, void 0);
      }
    }
  } catch (e) {
    if (e instanceof JsonPatchError) {
      return e;
    } else {
      throw e;
    }
  }
}
function _areEquals(a, b) {
  if (a === b)
    return true;
  if (a && b && typeof a == "object" && typeof b == "object") {
    var arrA = Array.isArray(a), arrB = Array.isArray(b), i, length, key;
    if (arrA && arrB) {
      length = a.length;
      if (length != b.length)
        return false;
      for (i = length; i-- !== 0; )
        if (!_areEquals(a[i], b[i]))
          return false;
      return true;
    }
    if (arrA != arrB)
      return false;
    var keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length)
      return false;
    for (i = length; i-- !== 0; )
      if (!b.hasOwnProperty(keys[i]))
        return false;
    for (i = length; i-- !== 0; ) {
      key = keys[i];
      if (!_areEquals(a[key], b[key]))
        return false;
    }
    return true;
  }
  return a !== a && b !== b;
}

// node_modules/@sap-ai-sdk/langchain/node_modules/@langchain/core/dist/utils/fast-json-patch/index.js
var fast_json_patch_default = {
  ...core_exports,
  // ...duplex,
  JsonPatchError: PatchError,
  deepClone: _deepClone,
  escapePathComponent,
  unescapePathComponent
};

// node_modules/@sap-ai-sdk/langchain/node_modules/@langchain/core/dist/utils/env.js
var isBrowser = () => typeof window !== "undefined" && typeof window.document !== "undefined";
var isWebWorker = () => typeof globalThis === "object" && globalThis.constructor && globalThis.constructor.name === "DedicatedWorkerGlobalScope";
var isJsDom = () => typeof window !== "undefined" && window.name === "nodejs" || typeof navigator !== "undefined" && (navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom"));
var isDeno = () => typeof Deno !== "undefined";
var isNode = () => typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined" && !isDeno();
var getEnv = () => {
  let env;
  if (isBrowser()) {
    env = "browser";
  } else if (isNode()) {
    env = "node";
  } else if (isWebWorker()) {
    env = "webworker";
  } else if (isJsDom()) {
    env = "jsdom";
  } else if (isDeno()) {
    env = "deno";
  } else {
    env = "other";
  }
  return env;
};
var runtimeEnvironment;
async function getRuntimeEnvironment() {
  if (runtimeEnvironment === void 0) {
    const env = getEnv();
    runtimeEnvironment = {
      library: "langchain-js",
      runtime: env
    };
  }
  return runtimeEnvironment;
}
function getEnvironmentVariable(name) {
  try {
    if (typeof process !== "undefined") {
      return process.env?.[name];
    } else if (isDeno()) {
      return Deno?.env.get(name);
    } else {
      return void 0;
    }
  } catch (e) {
    return void 0;
  }
}

// node_modules/@sap-ai-sdk/langchain/node_modules/@langchain/core/dist/callbacks/base.js
var BaseCallbackHandlerMethodsClass = class {
};
var BaseCallbackHandler = class _BaseCallbackHandler extends BaseCallbackHandlerMethodsClass {
  get lc_namespace() {
    return ["langchain_core", "callbacks", this.name];
  }
  get lc_secrets() {
    return void 0;
  }
  get lc_attributes() {
    return void 0;
  }
  get lc_aliases() {
    return void 0;
  }
  get lc_serializable_keys() {
    return void 0;
  }
  /**
   * The name of the serializable. Override to provide an alias or
   * to preserve the serialized module name in minified environments.
   *
   * Implemented as a static method to support loading logic.
   */
  static lc_name() {
    return this.name;
  }
  /**
   * The final serialized identifier for the module.
   */
  get lc_id() {
    return [
      ...this.lc_namespace,
      get_lc_unique_name(this.constructor)
    ];
  }
  constructor(input) {
    super();
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "lc_kwargs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "ignoreLLM", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "ignoreChain", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "ignoreAgent", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "ignoreRetriever", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "ignoreCustomEvent", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "raiseError", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "awaitHandlers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: getEnvironmentVariable("LANGCHAIN_CALLBACKS_BACKGROUND") === "false"
    });
    this.lc_kwargs = input || {};
    if (input) {
      this.ignoreLLM = input.ignoreLLM ?? this.ignoreLLM;
      this.ignoreChain = input.ignoreChain ?? this.ignoreChain;
      this.ignoreAgent = input.ignoreAgent ?? this.ignoreAgent;
      this.ignoreRetriever = input.ignoreRetriever ?? this.ignoreRetriever;
      this.ignoreCustomEvent = input.ignoreCustomEvent ?? this.ignoreCustomEvent;
      this.raiseError = input.raiseError ?? this.raiseError;
      this.awaitHandlers = this.raiseError || (input._awaitHandler ?? this.awaitHandlers);
    }
  }
  copy() {
    return new this.constructor(this);
  }
  toJSON() {
    return Serializable.prototype.toJSON.call(this);
  }
  toJSONNotImplemented() {
    return Serializable.prototype.toJSONNotImplemented.call(this);
  }
  static fromMethods(methods) {
    class Handler extends _BaseCallbackHandler {
      constructor() {
        super();
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: v4_default()
        });
        Object.assign(this, methods);
      }
    }
    return new Handler();
  }
};
var isBaseCallbackHandler = (x) => {
  const callbackHandler = x;
  return callbackHandler !== void 0 && typeof callbackHandler.copy === "function" && typeof callbackHandler.name === "string" && typeof callbackHandler.awaitHandlers === "boolean";
};

// node_modules/@sap-ai-sdk/langchain/node_modules/@langchain/core/dist/tracers/base.js
function _coerceToDict(value, defaultKey) {
  return value && !Array.isArray(value) && typeof value === "object" ? value : { [defaultKey]: value };
}
function stripNonAlphanumeric(input) {
  return input.replace(/[-:.]/g, "");
}
function convertToDottedOrderFormat(epoch, runId, executionOrder) {
  const paddedOrder = executionOrder.toFixed(0).slice(0, 3).padStart(3, "0");
  return stripNonAlphanumeric(`${new Date(epoch).toISOString().slice(0, -1)}${paddedOrder}Z`) + runId;
}
function isBaseTracer(x) {
  return typeof x._addRunToRunMap === "function";
}
var BaseTracer = class extends BaseCallbackHandler {
  constructor(_fields) {
    super(...arguments);
    Object.defineProperty(this, "runMap", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /* @__PURE__ */ new Map()
    });
  }
  copy() {
    return this;
  }
  stringifyError(error) {
    if (error instanceof Error) {
      return error.message + (error?.stack ? `

${error.stack}` : "");
    }
    if (typeof error === "string") {
      return error;
    }
    return `${error}`;
  }
  _addChildRun(parentRun, childRun) {
    parentRun.child_runs.push(childRun);
  }
  _addRunToRunMap(run) {
    const currentDottedOrder = convertToDottedOrderFormat(run.start_time, run.id, run.execution_order);
    const storedRun = { ...run };
    if (storedRun.parent_run_id !== void 0) {
      const parentRun = this.runMap.get(storedRun.parent_run_id);
      if (parentRun) {
        this._addChildRun(parentRun, storedRun);
        parentRun.child_execution_order = Math.max(parentRun.child_execution_order, storedRun.child_execution_order);
        storedRun.trace_id = parentRun.trace_id;
        if (parentRun.dotted_order !== void 0) {
          storedRun.dotted_order = [
            parentRun.dotted_order,
            currentDottedOrder
          ].join(".");
        } else {
        }
      } else {
      }
    } else {
      storedRun.trace_id = storedRun.id;
      storedRun.dotted_order = currentDottedOrder;
    }
    this.runMap.set(storedRun.id, storedRun);
    return storedRun;
  }
  async _endTrace(run) {
    const parentRun = run.parent_run_id !== void 0 && this.runMap.get(run.parent_run_id);
    if (parentRun) {
      parentRun.child_execution_order = Math.max(parentRun.child_execution_order, run.child_execution_order);
    } else {
      await this.persistRun(run);
    }
    this.runMap.delete(run.id);
    await this.onRunUpdate?.(run);
  }
  _getExecutionOrder(parentRunId) {
    const parentRun = parentRunId !== void 0 && this.runMap.get(parentRunId);
    if (!parentRun) {
      return 1;
    }
    return parentRun.child_execution_order + 1;
  }
  /**
   * Create and add a run to the run map for LLM start events.
   * This must sometimes be done synchronously to avoid race conditions
   * when callbacks are backgrounded, so we expose it as a separate method here.
   */
  _createRunForLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name) {
    const execution_order = this._getExecutionOrder(parentRunId);
    const start_time = Date.now();
    const finalExtraParams = metadata ? { ...extraParams, metadata } : extraParams;
    const run = {
      id: runId,
      name: name ?? llm.id[llm.id.length - 1],
      parent_run_id: parentRunId,
      start_time,
      serialized: llm,
      events: [
        {
          name: "start",
          time: new Date(start_time).toISOString()
        }
      ],
      inputs: { prompts },
      execution_order,
      child_runs: [],
      child_execution_order: execution_order,
      run_type: "llm",
      extra: finalExtraParams ?? {},
      tags: tags || []
    };
    return this._addRunToRunMap(run);
  }
  async handleLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name) {
    const run = this.runMap.get(runId) ?? this._createRunForLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name);
    await this.onRunCreate?.(run);
    await this.onLLMStart?.(run);
    return run;
  }
  /**
   * Create and add a run to the run map for chat model start events.
   * This must sometimes be done synchronously to avoid race conditions
   * when callbacks are backgrounded, so we expose it as a separate method here.
   */
  _createRunForChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {
    const execution_order = this._getExecutionOrder(parentRunId);
    const start_time = Date.now();
    const finalExtraParams = metadata ? { ...extraParams, metadata } : extraParams;
    const run = {
      id: runId,
      name: name ?? llm.id[llm.id.length - 1],
      parent_run_id: parentRunId,
      start_time,
      serialized: llm,
      events: [
        {
          name: "start",
          time: new Date(start_time).toISOString()
        }
      ],
      inputs: { messages },
      execution_order,
      child_runs: [],
      child_execution_order: execution_order,
      run_type: "llm",
      extra: finalExtraParams ?? {},
      tags: tags || []
    };
    return this._addRunToRunMap(run);
  }
  async handleChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {
    const run = this.runMap.get(runId) ?? this._createRunForChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name);
    await this.onRunCreate?.(run);
    await this.onLLMStart?.(run);
    return run;
  }
  async handleLLMEnd(output, runId, _parentRunId, _tags, extraParams) {
    const run = this.runMap.get(runId);
    if (!run || run?.run_type !== "llm") {
      throw new Error("No LLM run to end.");
    }
    run.end_time = Date.now();
    run.outputs = output;
    run.events.push({
      name: "end",
      time: new Date(run.end_time).toISOString()
    });
    run.extra = { ...run.extra, ...extraParams };
    await this.onLLMEnd?.(run);
    await this._endTrace(run);
    return run;
  }
  async handleLLMError(error, runId, _parentRunId, _tags, extraParams) {
    const run = this.runMap.get(runId);
    if (!run || run?.run_type !== "llm") {
      throw new Error("No LLM run to end.");
    }
    run.end_time = Date.now();
    run.error = this.stringifyError(error);
    run.events.push({
      name: "error",
      time: new Date(run.end_time).toISOString()
    });
    run.extra = { ...run.extra, ...extraParams };
    await this.onLLMError?.(run);
    await this._endTrace(run);
    return run;
  }
  /**
   * Create and add a run to the run map for chain start events.
   * This must sometimes be done synchronously to avoid race conditions
   * when callbacks are backgrounded, so we expose it as a separate method here.
   */
  _createRunForChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name) {
    const execution_order = this._getExecutionOrder(parentRunId);
    const start_time = Date.now();
    const run = {
      id: runId,
      name: name ?? chain.id[chain.id.length - 1],
      parent_run_id: parentRunId,
      start_time,
      serialized: chain,
      events: [
        {
          name: "start",
          time: new Date(start_time).toISOString()
        }
      ],
      inputs,
      execution_order,
      child_execution_order: execution_order,
      run_type: runType ?? "chain",
      child_runs: [],
      extra: metadata ? { metadata } : {},
      tags: tags || []
    };
    return this._addRunToRunMap(run);
  }
  async handleChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name) {
    const run = this.runMap.get(runId) ?? this._createRunForChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name);
    await this.onRunCreate?.(run);
    await this.onChainStart?.(run);
    return run;
  }
  async handleChainEnd(outputs, runId, _parentRunId, _tags, kwargs) {
    const run = this.runMap.get(runId);
    if (!run) {
      throw new Error("No chain run to end.");
    }
    run.end_time = Date.now();
    run.outputs = _coerceToDict(outputs, "output");
    run.events.push({
      name: "end",
      time: new Date(run.end_time).toISOString()
    });
    if (kwargs?.inputs !== void 0) {
      run.inputs = _coerceToDict(kwargs.inputs, "input");
    }
    await this.onChainEnd?.(run);
    await this._endTrace(run);
    return run;
  }
  async handleChainError(error, runId, _parentRunId, _tags, kwargs) {
    const run = this.runMap.get(runId);
    if (!run) {
      throw new Error("No chain run to end.");
    }
    run.end_time = Date.now();
    run.error = this.stringifyError(error);
    run.events.push({
      name: "error",
      time: new Date(run.end_time).toISOString()
    });
    if (kwargs?.inputs !== void 0) {
      run.inputs = _coerceToDict(kwargs.inputs, "input");
    }
    await this.onChainError?.(run);
    await this._endTrace(run);
    return run;
  }
  /**
   * Create and add a run to the run map for tool start events.
   * This must sometimes be done synchronously to avoid race conditions
   * when callbacks are backgrounded, so we expose it as a separate method here.
   */
  _createRunForToolStart(tool, input, runId, parentRunId, tags, metadata, name) {
    const execution_order = this._getExecutionOrder(parentRunId);
    const start_time = Date.now();
    const run = {
      id: runId,
      name: name ?? tool.id[tool.id.length - 1],
      parent_run_id: parentRunId,
      start_time,
      serialized: tool,
      events: [
        {
          name: "start",
          time: new Date(start_time).toISOString()
        }
      ],
      inputs: { input },
      execution_order,
      child_execution_order: execution_order,
      run_type: "tool",
      child_runs: [],
      extra: metadata ? { metadata } : {},
      tags: tags || []
    };
    return this._addRunToRunMap(run);
  }
  async handleToolStart(tool, input, runId, parentRunId, tags, metadata, name) {
    const run = this.runMap.get(runId) ?? this._createRunForToolStart(tool, input, runId, parentRunId, tags, metadata, name);
    await this.onRunCreate?.(run);
    await this.onToolStart?.(run);
    return run;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async handleToolEnd(output, runId) {
    const run = this.runMap.get(runId);
    if (!run || run?.run_type !== "tool") {
      throw new Error("No tool run to end");
    }
    run.end_time = Date.now();
    run.outputs = { output };
    run.events.push({
      name: "end",
      time: new Date(run.end_time).toISOString()
    });
    await this.onToolEnd?.(run);
    await this._endTrace(run);
    return run;
  }
  async handleToolError(error, runId) {
    const run = this.runMap.get(runId);
    if (!run || run?.run_type !== "tool") {
      throw new Error("No tool run to end");
    }
    run.end_time = Date.now();
    run.error = this.stringifyError(error);
    run.events.push({
      name: "error",
      time: new Date(run.end_time).toISOString()
    });
    await this.onToolError?.(run);
    await this._endTrace(run);
    return run;
  }
  async handleAgentAction(action, runId) {
    const run = this.runMap.get(runId);
    if (!run || run?.run_type !== "chain") {
      return;
    }
    const agentRun = run;
    agentRun.actions = agentRun.actions || [];
    agentRun.actions.push(action);
    agentRun.events.push({
      name: "agent_action",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      kwargs: { action }
    });
    await this.onAgentAction?.(run);
  }
  async handleAgentEnd(action, runId) {
    const run = this.runMap.get(runId);
    if (!run || run?.run_type !== "chain") {
      return;
    }
    run.events.push({
      name: "agent_end",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      kwargs: { action }
    });
    await this.onAgentEnd?.(run);
  }
  /**
   * Create and add a run to the run map for retriever start events.
   * This must sometimes be done synchronously to avoid race conditions
   * when callbacks are backgrounded, so we expose it as a separate method here.
   */
  _createRunForRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {
    const execution_order = this._getExecutionOrder(parentRunId);
    const start_time = Date.now();
    const run = {
      id: runId,
      name: name ?? retriever.id[retriever.id.length - 1],
      parent_run_id: parentRunId,
      start_time,
      serialized: retriever,
      events: [
        {
          name: "start",
          time: new Date(start_time).toISOString()
        }
      ],
      inputs: { query },
      execution_order,
      child_execution_order: execution_order,
      run_type: "retriever",
      child_runs: [],
      extra: metadata ? { metadata } : {},
      tags: tags || []
    };
    return this._addRunToRunMap(run);
  }
  async handleRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {
    const run = this.runMap.get(runId) ?? this._createRunForRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name);
    await this.onRunCreate?.(run);
    await this.onRetrieverStart?.(run);
    return run;
  }
  async handleRetrieverEnd(documents, runId) {
    const run = this.runMap.get(runId);
    if (!run || run?.run_type !== "retriever") {
      throw new Error("No retriever run to end");
    }
    run.end_time = Date.now();
    run.outputs = { documents };
    run.events.push({
      name: "end",
      time: new Date(run.end_time).toISOString()
    });
    await this.onRetrieverEnd?.(run);
    await this._endTrace(run);
    return run;
  }
  async handleRetrieverError(error, runId) {
    const run = this.runMap.get(runId);
    if (!run || run?.run_type !== "retriever") {
      throw new Error("No retriever run to end");
    }
    run.end_time = Date.now();
    run.error = this.stringifyError(error);
    run.events.push({
      name: "error",
      time: new Date(run.end_time).toISOString()
    });
    await this.onRetrieverError?.(run);
    await this._endTrace(run);
    return run;
  }
  async handleText(text, runId) {
    const run = this.runMap.get(runId);
    if (!run || run?.run_type !== "chain") {
      return;
    }
    run.events.push({
      name: "text",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      kwargs: { text }
    });
    await this.onText?.(run);
  }
  async handleLLMNewToken(token, idx, runId, _parentRunId, _tags, fields) {
    const run = this.runMap.get(runId);
    if (!run || run?.run_type !== "llm") {
      throw new Error(`Invalid "runId" provided to "handleLLMNewToken" callback.`);
    }
    run.events.push({
      name: "new_token",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      kwargs: { token, idx, chunk: fields?.chunk }
    });
    await this.onLLMNewToken?.(run, token, { chunk: fields?.chunk });
    return run;
  }
};

// node_modules/@sap-ai-sdk/langchain/node_modules/@langchain/core/dist/tracers/console.js
var import_ansi_styles = __toESM(require_ansi_styles2(), 1);
function wrap(style, text) {
  return `${style.open}${text}${style.close}`;
}
function tryJsonStringify(obj, fallback) {
  try {
    return JSON.stringify(obj, null, 2);
  } catch (err) {
    return fallback;
  }
}
function formatKVMapItem(value) {
  if (typeof value === "string") {
    return value.trim();
  }
  if (value === null || value === void 0) {
    return value;
  }
  return tryJsonStringify(value, value.toString());
}
function elapsed(run) {
  if (!run.end_time)
    return "";
  const elapsed2 = run.end_time - run.start_time;
  if (elapsed2 < 1e3) {
    return `${elapsed2}ms`;
  }
  return `${(elapsed2 / 1e3).toFixed(2)}s`;
}
var { color } = import_ansi_styles.default;
var ConsoleCallbackHandler = class extends BaseTracer {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "console_callback_handler"
    });
  }
  /**
   * Method used to persist the run. In this case, it simply returns a
   * resolved promise as there's no persistence logic.
   * @param _run The run to persist.
   * @returns A resolved promise.
   */
  persistRun(_run) {
    return Promise.resolve();
  }
  // utility methods
  /**
   * Method used to get all the parent runs of a given run.
   * @param run The run whose parents are to be retrieved.
   * @returns An array of parent runs.
   */
  getParents(run) {
    const parents = [];
    let currentRun = run;
    while (currentRun.parent_run_id) {
      const parent = this.runMap.get(currentRun.parent_run_id);
      if (parent) {
        parents.push(parent);
        currentRun = parent;
      } else {
        break;
      }
    }
    return parents;
  }
  /**
   * Method used to get a string representation of the run's lineage, which
   * is used in logging.
   * @param run The run whose lineage is to be retrieved.
   * @returns A string representation of the run's lineage.
   */
  getBreadcrumbs(run) {
    const parents = this.getParents(run).reverse();
    const string = [...parents, run].map((parent, i, arr2) => {
      const name = `${parent.execution_order}:${parent.run_type}:${parent.name}`;
      return i === arr2.length - 1 ? wrap(import_ansi_styles.default.bold, name) : name;
    }).join(" > ");
    return wrap(color.grey, string);
  }
  // logging methods
  /**
   * Method used to log the start of a chain run.
   * @param run The chain run that has started.
   * @returns void
   */
  onChainStart(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.green, "[chain/start]")} [${crumbs}] Entering Chain run with input: ${tryJsonStringify(run.inputs, "[inputs]")}`);
  }
  /**
   * Method used to log the end of a chain run.
   * @param run The chain run that has ended.
   * @returns void
   */
  onChainEnd(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.cyan, "[chain/end]")} [${crumbs}] [${elapsed(run)}] Exiting Chain run with output: ${tryJsonStringify(run.outputs, "[outputs]")}`);
  }
  /**
   * Method used to log any errors of a chain run.
   * @param run The chain run that has errored.
   * @returns void
   */
  onChainError(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.red, "[chain/error]")} [${crumbs}] [${elapsed(run)}] Chain run errored with error: ${tryJsonStringify(run.error, "[error]")}`);
  }
  /**
   * Method used to log the start of an LLM run.
   * @param run The LLM run that has started.
   * @returns void
   */
  onLLMStart(run) {
    const crumbs = this.getBreadcrumbs(run);
    const inputs = "prompts" in run.inputs ? { prompts: run.inputs.prompts.map((p) => p.trim()) } : run.inputs;
    console.log(`${wrap(color.green, "[llm/start]")} [${crumbs}] Entering LLM run with input: ${tryJsonStringify(inputs, "[inputs]")}`);
  }
  /**
   * Method used to log the end of an LLM run.
   * @param run The LLM run that has ended.
   * @returns void
   */
  onLLMEnd(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.cyan, "[llm/end]")} [${crumbs}] [${elapsed(run)}] Exiting LLM run with output: ${tryJsonStringify(run.outputs, "[response]")}`);
  }
  /**
   * Method used to log any errors of an LLM run.
   * @param run The LLM run that has errored.
   * @returns void
   */
  onLLMError(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.red, "[llm/error]")} [${crumbs}] [${elapsed(run)}] LLM run errored with error: ${tryJsonStringify(run.error, "[error]")}`);
  }
  /**
   * Method used to log the start of a tool run.
   * @param run The tool run that has started.
   * @returns void
   */
  onToolStart(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.green, "[tool/start]")} [${crumbs}] Entering Tool run with input: "${formatKVMapItem(run.inputs.input)}"`);
  }
  /**
   * Method used to log the end of a tool run.
   * @param run The tool run that has ended.
   * @returns void
   */
  onToolEnd(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.cyan, "[tool/end]")} [${crumbs}] [${elapsed(run)}] Exiting Tool run with output: "${formatKVMapItem(run.outputs?.output)}"`);
  }
  /**
   * Method used to log any errors of a tool run.
   * @param run The tool run that has errored.
   * @returns void
   */
  onToolError(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.red, "[tool/error]")} [${crumbs}] [${elapsed(run)}] Tool run errored with error: ${tryJsonStringify(run.error, "[error]")}`);
  }
  /**
   * Method used to log the start of a retriever run.
   * @param run The retriever run that has started.
   * @returns void
   */
  onRetrieverStart(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.green, "[retriever/start]")} [${crumbs}] Entering Retriever run with input: ${tryJsonStringify(run.inputs, "[inputs]")}`);
  }
  /**
   * Method used to log the end of a retriever run.
   * @param run The retriever run that has ended.
   * @returns void
   */
  onRetrieverEnd(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.cyan, "[retriever/end]")} [${crumbs}] [${elapsed(run)}] Exiting Retriever run with output: ${tryJsonStringify(run.outputs, "[outputs]")}`);
  }
  /**
   * Method used to log any errors of a retriever run.
   * @param run The retriever run that has errored.
   * @returns void
   */
  onRetrieverError(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.red, "[retriever/error]")} [${crumbs}] [${elapsed(run)}] Retriever run errored with error: ${tryJsonStringify(run.error, "[error]")}`);
  }
  /**
   * Method used to log the action selected by the agent.
   * @param run The run in which the agent action occurred.
   * @returns void
   */
  onAgentAction(run) {
    const agentRun = run;
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.blue, "[agent/action]")} [${crumbs}] Agent selected action: ${tryJsonStringify(agentRun.actions[agentRun.actions.length - 1], "[action]")}`);
  }
};

// node_modules/langsmith/node_modules/uuid/dist/esm-node/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;

// node_modules/langsmith/node_modules/uuid/dist/esm-node/validate.js
function validate2(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate2;

// node_modules/langsmith/node_modules/uuid/dist/esm-node/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  const arr2 = new Uint8Array(16);
  arr2[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr2[1] = v >>> 16 & 255;
  arr2[2] = v >>> 8 & 255;
  arr2[3] = v & 255;
  arr2[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr2[5] = v & 255;
  arr2[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr2[7] = v & 255;
  arr2[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr2[9] = v & 255;
  arr2[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr2[11] = v / 4294967296 & 255;
  arr2[12] = v >>> 24 & 255;
  arr2[13] = v >>> 16 & 255;
  arr2[14] = v >>> 8 & 255;
  arr2[15] = v & 255;
  return arr2;
}
var parse_default = parse;

// node_modules/langsmith/node_modules/uuid/dist/esm-node/stringify.js
var byteToHex2 = [];
for (let i = 0; i < 256; ++i) {
  byteToHex2.push((i + 256).toString(16).slice(1));
}
function unsafeStringify2(arr2, offset = 0) {
  return (byteToHex2[arr2[offset + 0]] + byteToHex2[arr2[offset + 1]] + byteToHex2[arr2[offset + 2]] + byteToHex2[arr2[offset + 3]] + "-" + byteToHex2[arr2[offset + 4]] + byteToHex2[arr2[offset + 5]] + "-" + byteToHex2[arr2[offset + 6]] + byteToHex2[arr2[offset + 7]] + "-" + byteToHex2[arr2[offset + 8]] + byteToHex2[arr2[offset + 9]] + "-" + byteToHex2[arr2[offset + 10]] + byteToHex2[arr2[offset + 11]] + byteToHex2[arr2[offset + 12]] + byteToHex2[arr2[offset + 13]] + byteToHex2[arr2[offset + 14]] + byteToHex2[arr2[offset + 15]]).toLowerCase();
}

// node_modules/langsmith/node_modules/uuid/dist/esm-node/rng.js
var import_node_crypto3 = __toESM(require("node:crypto"));
var rnds8Pool2 = new Uint8Array(256);
var poolPtr2 = rnds8Pool2.length;
function rng2() {
  if (poolPtr2 > rnds8Pool2.length - 16) {
    import_node_crypto3.default.randomFillSync(rnds8Pool2);
    poolPtr2 = 0;
  }
  return rnds8Pool2.slice(poolPtr2, poolPtr2 += 16);
}

// node_modules/langsmith/node_modules/uuid/dist/esm-node/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = [];
  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return unsafeStringify2(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}

// node_modules/langsmith/node_modules/uuid/dist/esm-node/native.js
var import_node_crypto4 = __toESM(require("node:crypto"));
var native_default2 = {
  randomUUID: import_node_crypto4.default.randomUUID
};

// node_modules/langsmith/node_modules/uuid/dist/esm-node/v4.js
function v42(options, buf, offset) {
  if (native_default2.randomUUID && !buf && !options) {
    return native_default2.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng2)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify2(rnds);
}
var v4_default2 = v42;

// node_modules/langsmith/node_modules/uuid/dist/esm-node/sha1.js
var import_node_crypto5 = __toESM(require("node:crypto"));
function sha1(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === "string") {
    bytes = Buffer.from(bytes, "utf8");
  }
  return import_node_crypto5.default.createHash("sha1").update(bytes).digest();
}
var sha1_default = sha1;

// node_modules/langsmith/node_modules/uuid/dist/esm-node/v5.js
var v5 = v35("v5", 80, sha1_default);
var v5_default = v5;

// node_modules/langsmith/dist/experimental/otel/constants.js
var GEN_AI_OPERATION_NAME = "gen_ai.operation.name";
var GEN_AI_SYSTEM = "gen_ai.system";
var GEN_AI_REQUEST_MODEL = "gen_ai.request.model";
var GEN_AI_RESPONSE_MODEL = "gen_ai.response.model";
var GEN_AI_USAGE_INPUT_TOKENS = "gen_ai.usage.input_tokens";
var GEN_AI_USAGE_OUTPUT_TOKENS = "gen_ai.usage.output_tokens";
var GEN_AI_USAGE_TOTAL_TOKENS = "gen_ai.usage.total_tokens";
var GEN_AI_REQUEST_MAX_TOKENS = "gen_ai.request.max_tokens";
var GEN_AI_REQUEST_TEMPERATURE = "gen_ai.request.temperature";
var GEN_AI_REQUEST_TOP_P = "gen_ai.request.top_p";
var GEN_AI_REQUEST_FREQUENCY_PENALTY = "gen_ai.request.frequency_penalty";
var GEN_AI_REQUEST_PRESENCE_PENALTY = "gen_ai.request.presence_penalty";
var GEN_AI_RESPONSE_FINISH_REASONS = "gen_ai.response.finish_reasons";
var GENAI_PROMPT = "gen_ai.prompt";
var GENAI_COMPLETION = "gen_ai.completion";
var GEN_AI_REQUEST_EXTRA_QUERY = "gen_ai.request.extra_query";
var GEN_AI_REQUEST_EXTRA_BODY = "gen_ai.request.extra_body";
var GEN_AI_SERIALIZED_NAME = "gen_ai.serialized.name";
var GEN_AI_SERIALIZED_SIGNATURE = "gen_ai.serialized.signature";
var GEN_AI_SERIALIZED_DOC = "gen_ai.serialized.doc";
var GEN_AI_RESPONSE_ID = "gen_ai.response.id";
var GEN_AI_RESPONSE_SERVICE_TIER = "gen_ai.response.service_tier";
var GEN_AI_RESPONSE_SYSTEM_FINGERPRINT = "gen_ai.response.system_fingerprint";
var GEN_AI_USAGE_INPUT_TOKEN_DETAILS = "gen_ai.usage.input_token_details";
var GEN_AI_USAGE_OUTPUT_TOKEN_DETAILS = "gen_ai.usage.output_token_details";
var LANGSMITH_SESSION_ID = "langsmith.trace.session_id";
var LANGSMITH_SESSION_NAME = "langsmith.trace.session_name";
var LANGSMITH_RUN_TYPE = "langsmith.span.kind";
var LANGSMITH_NAME = "langsmith.trace.name";
var LANGSMITH_METADATA = "langsmith.metadata";
var LANGSMITH_TAGS = "langsmith.span.tags";
var LANGSMITH_REQUEST_STREAMING = "langsmith.request.streaming";
var LANGSMITH_REQUEST_HEADERS = "langsmith.request.headers";

// node_modules/langsmith/dist/singletons/fetch.js
var DEFAULT_FETCH_IMPLEMENTATION = (...args) => fetch(...args);
var LANGSMITH_FETCH_IMPLEMENTATION_KEY = Symbol.for("ls:fetch_implementation");
var _globalFetchImplementationIsNodeFetch = () => {
  const fetchImpl = globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY];
  if (!fetchImpl)
    return false;
  return typeof fetchImpl === "function" && "Headers" in fetchImpl && "Request" in fetchImpl && "Response" in fetchImpl;
};
var _getFetchImplementation = (debug) => {
  return async (...args) => {
    if (debug || getLangSmithEnvironmentVariable("DEBUG") === "true") {
      const [url, options] = args;
      console.log(`\u2192 ${options?.method || "GET"} ${url}`);
    }
    const res = await (globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY] ?? DEFAULT_FETCH_IMPLEMENTATION)(...args);
    if (debug || getLangSmithEnvironmentVariable("DEBUG") === "true") {
      console.log(`\u2190 ${res.status} ${res.statusText} ${res.url}`);
    }
    return res;
  };
};

// node_modules/langsmith/dist/utils/project.js
var getDefaultProjectName = () => {
  return getLangSmithEnvironmentVariable("PROJECT") ?? getEnvironmentVariable2("LANGCHAIN_SESSION") ?? // TODO: Deprecate
  "default";
};

// node_modules/langsmith/dist/index.js
var __version__ = "0.3.39";

// node_modules/langsmith/dist/utils/env.js
var globalEnv;
var isBrowser2 = () => typeof window !== "undefined" && typeof window.document !== "undefined";
var isWebWorker2 = () => typeof globalThis === "object" && globalThis.constructor && globalThis.constructor.name === "DedicatedWorkerGlobalScope";
var isJsDom2 = () => typeof window !== "undefined" && window.name === "nodejs" || typeof navigator !== "undefined" && navigator.userAgent.includes("jsdom");
var isDeno2 = () => typeof Deno !== "undefined";
var isNode2 = () => typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined" && !isDeno2();
var getEnv2 = () => {
  if (globalEnv) {
    return globalEnv;
  }
  if (isBrowser2()) {
    globalEnv = "browser";
  } else if (isNode2()) {
    globalEnv = "node";
  } else if (isWebWorker2()) {
    globalEnv = "webworker";
  } else if (isJsDom2()) {
    globalEnv = "jsdom";
  } else if (isDeno2()) {
    globalEnv = "deno";
  } else {
    globalEnv = "other";
  }
  return globalEnv;
};
var runtimeEnvironment2;
function getRuntimeEnvironment2() {
  if (runtimeEnvironment2 === void 0) {
    const env = getEnv2();
    const releaseEnv = getShas();
    runtimeEnvironment2 = {
      library: "langsmith",
      runtime: env,
      sdk: "langsmith-js",
      sdk_version: __version__,
      ...releaseEnv
    };
  }
  return runtimeEnvironment2;
}
function getLangChainEnvVarsMetadata() {
  const allEnvVars = getEnvironmentVariables() || {};
  const envVars = {};
  const excluded = [
    "LANGCHAIN_API_KEY",
    "LANGCHAIN_ENDPOINT",
    "LANGCHAIN_TRACING_V2",
    "LANGCHAIN_PROJECT",
    "LANGCHAIN_SESSION",
    "LANGSMITH_API_KEY",
    "LANGSMITH_ENDPOINT",
    "LANGSMITH_TRACING_V2",
    "LANGSMITH_PROJECT",
    "LANGSMITH_SESSION"
  ];
  for (const [key, value] of Object.entries(allEnvVars)) {
    if ((key.startsWith("LANGCHAIN_") || key.startsWith("LANGSMITH_")) && typeof value === "string" && !excluded.includes(key) && !key.toLowerCase().includes("key") && !key.toLowerCase().includes("secret") && !key.toLowerCase().includes("token")) {
      if (key === "LANGCHAIN_REVISION_ID") {
        envVars["revision_id"] = value;
      } else {
        envVars[key] = value;
      }
    }
  }
  return envVars;
}
function getEnvironmentVariables() {
  try {
    if (typeof process !== "undefined" && process.env) {
      return Object.entries(process.env).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {});
    }
    return void 0;
  } catch (e) {
    return void 0;
  }
}
function getEnvironmentVariable2(name) {
  try {
    return typeof process !== "undefined" ? (
      // eslint-disable-next-line no-process-env
      process.env?.[name]
    ) : void 0;
  } catch (e) {
    return void 0;
  }
}
function getLangSmithEnvironmentVariable(name) {
  return getEnvironmentVariable2(`LANGSMITH_${name}`) || getEnvironmentVariable2(`LANGCHAIN_${name}`);
}
var cachedCommitSHAs;
function getShas() {
  if (cachedCommitSHAs !== void 0) {
    return cachedCommitSHAs;
  }
  const common_release_envs = [
    "VERCEL_GIT_COMMIT_SHA",
    "NEXT_PUBLIC_VERCEL_GIT_COMMIT_SHA",
    "COMMIT_REF",
    "RENDER_GIT_COMMIT",
    "CI_COMMIT_SHA",
    "CIRCLE_SHA1",
    "CF_PAGES_COMMIT_SHA",
    "REACT_APP_GIT_SHA",
    "SOURCE_VERSION",
    "GITHUB_SHA",
    "TRAVIS_COMMIT",
    "GIT_COMMIT",
    "BUILD_VCS_NUMBER",
    "bamboo_planRepository_revision",
    "Build.SourceVersion",
    "BITBUCKET_COMMIT",
    "DRONE_COMMIT_SHA",
    "SEMAPHORE_GIT_SHA",
    "BUILDKITE_COMMIT"
  ];
  const shas = {};
  for (const env of common_release_envs) {
    const envVar = getEnvironmentVariable2(env);
    if (envVar !== void 0) {
      shas[env] = envVar;
    }
  }
  cachedCommitSHAs = shas;
  return shas;
}

// node_modules/langsmith/dist/singletons/otel.js
var MockTracer = class {
  constructor() {
    Object.defineProperty(this, "hasWarned", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
  }
  startActiveSpan(_name, ...args) {
    if (!this.hasWarned && getEnvironmentVariable2("OTEL_ENABLED") === "true") {
      console.warn('You have enabled OTEL export via the `OTEL_ENABLED` environment variable, but have not initialized the required OTEL instances. Please add:\n```\nimport { initializeOTEL } from "langsmith/experimental/otel/setup";\ninitializeOTEL();\n```\nat the beginning of your code.');
      this.hasWarned = true;
    }
    let fn;
    if (args.length === 1 && typeof args[0] === "function") {
      fn = args[0];
    } else if (args.length === 2 && typeof args[1] === "function") {
      fn = args[1];
    } else if (args.length === 3 && typeof args[2] === "function") {
      fn = args[2];
    }
    if (typeof fn === "function") {
      return fn();
    }
    return void 0;
  }
};
var MockOTELTrace = class {
  constructor() {
    Object.defineProperty(this, "mockTracer", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new MockTracer()
    });
  }
  getTracer(_name, _version) {
    return this.mockTracer;
  }
  getActiveSpan() {
    return void 0;
  }
  setSpan(context, _span) {
    return context;
  }
  getSpan(_context) {
    return void 0;
  }
  setSpanContext(context, _spanContext) {
    return context;
  }
  getTracerProvider() {
    return void 0;
  }
  setGlobalTracerProvider(_tracerProvider) {
    return false;
  }
};
var MockOTELContext = class {
  active() {
    return {};
  }
  with(_context, fn) {
    return fn();
  }
};
var OTEL_TRACE_KEY = Symbol.for("ls:otel_trace");
var OTEL_CONTEXT_KEY = Symbol.for("ls:otel_context");
var OTEL_GET_DEFAULT_OTLP_TRACER_PROVIDER_KEY = Symbol.for("ls:otel_get_default_otlp_tracer_provider");
var mockOTELTrace = new MockOTELTrace();
var mockOTELContext = new MockOTELContext();
var OTELProvider = class {
  getTraceInstance() {
    return globalThis[OTEL_TRACE_KEY] ?? mockOTELTrace;
  }
  getContextInstance() {
    return globalThis[OTEL_CONTEXT_KEY] ?? mockOTELContext;
  }
  initializeGlobalInstances(otel) {
    if (globalThis[OTEL_TRACE_KEY] === void 0) {
      globalThis[OTEL_TRACE_KEY] = otel.trace;
    }
    if (globalThis[OTEL_CONTEXT_KEY] === void 0) {
      globalThis[OTEL_CONTEXT_KEY] = otel.context;
    }
  }
  setDefaultOTLPTracerComponents(components) {
    globalThis[OTEL_GET_DEFAULT_OTLP_TRACER_PROVIDER_KEY] = components;
  }
  getDefaultOTLPTracerComponents() {
    return globalThis[OTEL_GET_DEFAULT_OTLP_TRACER_PROVIDER_KEY] ?? void 0;
  }
};
var OTELProviderSingleton = new OTELProvider();
function getOTELTrace() {
  return OTELProviderSingleton.getTraceInstance();
}
function getOTELContext() {
  return OTELProviderSingleton.getContextInstance();
}
function getDefaultOTLPTracerComponents() {
  return OTELProviderSingleton.getDefaultOTLPTracerComponents();
}

// node_modules/langsmith/dist/experimental/otel/translator.js
var WELL_KNOWN_OPERATION_NAMES = {
  llm: "chat",
  tool: "execute_tool",
  retriever: "embeddings",
  embedding: "embeddings",
  prompt: "chat"
};
function getOperationName(runType) {
  return WELL_KNOWN_OPERATION_NAMES[runType] || runType;
}
var LangSmithToOTELTranslator = class {
  constructor() {
    Object.defineProperty(this, "spans", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /* @__PURE__ */ new Map()
    });
  }
  exportBatch(operations, otelContextMap) {
    for (const op of operations) {
      try {
        if (!op.run) {
          continue;
        }
        if (op.operation === "post") {
          const span = this.createSpanForRun(op, op.run, otelContextMap.get(op.id));
          if (span && !op.run.end_time) {
            this.spans.set(op.id, span);
          }
        } else {
          this.updateSpanForRun(op, op.run);
        }
      } catch (e) {
        console.error(`Error processing operation ${op.id}:`, e);
      }
    }
  }
  createSpanForRun(op, runInfo, otelContext) {
    const activeSpan = otelContext && getOTELTrace().getSpan(otelContext);
    if (!activeSpan) {
      return;
    }
    try {
      return this.finishSpanSetup(activeSpan, runInfo, op);
    } catch (e) {
      console.error(`Failed to create span for run ${op.id}:`, e);
      return void 0;
    }
  }
  finishSpanSetup(span, runInfo, op) {
    this.setSpanAttributes(span, runInfo, op);
    if (runInfo.error) {
      span.setStatus({ code: 2 });
      span.recordException(new Error(runInfo.error));
    } else {
      span.setStatus({ code: 1 });
    }
    if (runInfo.end_time) {
      span.end(runInfo.end_time);
    }
    return span;
  }
  updateSpanForRun(op, runInfo) {
    try {
      const span = this.spans.get(op.id);
      if (!span) {
        console.debug(`No span found for run ${op.id} during update`);
        return;
      }
      this.setSpanAttributes(span, runInfo, op);
      if (runInfo.error) {
        span.setStatus({ code: 2 });
        span.recordException(new Error(runInfo.error));
      } else {
        span.setStatus({ code: 1 });
      }
      const endTime = runInfo.end_time;
      if (endTime) {
        span.end(endTime);
        this.spans.delete(op.id);
      }
    } catch (e) {
      console.error(`Failed to update span for run ${op.id}:`, e);
    }
  }
  extractModelName(runInfo) {
    if (runInfo.extra?.metadata) {
      const metadata = runInfo.extra.metadata;
      if (metadata.ls_model_name) {
        return metadata.ls_model_name;
      }
      if (metadata.invocation_params) {
        const invocationParams = metadata.invocation_params;
        if (invocationParams.model) {
          return invocationParams.model;
        } else if (invocationParams.model_name) {
          return invocationParams.model_name;
        }
      }
    }
    return;
  }
  setSpanAttributes(span, runInfo, op) {
    if ("run_type" in runInfo && runInfo.run_type) {
      span.setAttribute(LANGSMITH_RUN_TYPE, runInfo.run_type);
      const operationName = getOperationName(runInfo.run_type || "chain");
      span.setAttribute(GEN_AI_OPERATION_NAME, operationName);
    }
    if ("name" in runInfo && runInfo.name) {
      span.setAttribute(LANGSMITH_NAME, runInfo.name);
    }
    if ("session_id" in runInfo && runInfo.session_id) {
      span.setAttribute(LANGSMITH_SESSION_ID, runInfo.session_id);
    }
    if ("session_name" in runInfo && runInfo.session_name) {
      span.setAttribute(LANGSMITH_SESSION_NAME, runInfo.session_name);
    }
    this.setGenAiSystem(span, runInfo);
    const modelName = this.extractModelName(runInfo);
    if (modelName) {
      span.setAttribute(GEN_AI_REQUEST_MODEL, modelName);
    }
    if ("prompt_tokens" in runInfo && typeof runInfo.prompt_tokens === "number") {
      span.setAttribute(GEN_AI_USAGE_INPUT_TOKENS, runInfo.prompt_tokens);
    }
    if ("completion_tokens" in runInfo && typeof runInfo.completion_tokens === "number") {
      span.setAttribute(GEN_AI_USAGE_OUTPUT_TOKENS, runInfo.completion_tokens);
    }
    if ("total_tokens" in runInfo && typeof runInfo.total_tokens === "number") {
      span.setAttribute(GEN_AI_USAGE_TOTAL_TOKENS, runInfo.total_tokens);
    }
    this.setInvocationParameters(span, runInfo);
    const metadata = runInfo.extra?.metadata || {};
    for (const [key, value] of Object.entries(metadata)) {
      if (value !== null && value !== void 0) {
        span.setAttribute(`${LANGSMITH_METADATA}.${key}`, String(value));
      }
    }
    const tags = runInfo.tags;
    if (tags && Array.isArray(tags)) {
      span.setAttribute(LANGSMITH_TAGS, tags.join(", "));
    } else if (tags) {
      span.setAttribute(LANGSMITH_TAGS, String(tags));
    }
    if ("serialized" in runInfo && typeof runInfo.serialized === "object") {
      const serialized = runInfo.serialized;
      if (serialized.name) {
        span.setAttribute(GEN_AI_SERIALIZED_NAME, String(serialized.name));
      }
      if (serialized.signature) {
        span.setAttribute(GEN_AI_SERIALIZED_SIGNATURE, String(serialized.signature));
      }
      if (serialized.doc) {
        span.setAttribute(GEN_AI_SERIALIZED_DOC, String(serialized.doc));
      }
    }
    this.setIOAttributes(span, op);
  }
  setGenAiSystem(span, runInfo) {
    let system = "langchain";
    const modelName = this.extractModelName(runInfo);
    if (modelName) {
      const modelLower = modelName.toLowerCase();
      if (modelLower.includes("anthropic") || modelLower.startsWith("claude")) {
        system = "anthropic";
      } else if (modelLower.includes("bedrock")) {
        system = "aws.bedrock";
      } else if (modelLower.includes("azure") && modelLower.includes("openai")) {
        system = "az.ai.openai";
      } else if (modelLower.includes("azure") && modelLower.includes("inference")) {
        system = "az.ai.inference";
      } else if (modelLower.includes("cohere")) {
        system = "cohere";
      } else if (modelLower.includes("deepseek")) {
        system = "deepseek";
      } else if (modelLower.includes("gemini")) {
        system = "gemini";
      } else if (modelLower.includes("groq")) {
        system = "groq";
      } else if (modelLower.includes("watson") || modelLower.includes("ibm")) {
        system = "ibm.watsonx.ai";
      } else if (modelLower.includes("mistral")) {
        system = "mistral_ai";
      } else if (modelLower.includes("gpt") || modelLower.includes("openai")) {
        system = "openai";
      } else if (modelLower.includes("perplexity") || modelLower.includes("sonar")) {
        system = "perplexity";
      } else if (modelLower.includes("vertex")) {
        system = "vertex_ai";
      } else if (modelLower.includes("xai") || modelLower.includes("grok")) {
        system = "xai";
      }
    }
    span.setAttribute(GEN_AI_SYSTEM, system);
  }
  setInvocationParameters(span, runInfo) {
    if (!runInfo.extra?.metadata?.invocation_params) {
      return;
    }
    const invocationParams = runInfo.extra.metadata.invocation_params;
    if (invocationParams.max_tokens !== void 0) {
      span.setAttribute(GEN_AI_REQUEST_MAX_TOKENS, invocationParams.max_tokens);
    }
    if (invocationParams.temperature !== void 0) {
      span.setAttribute(GEN_AI_REQUEST_TEMPERATURE, invocationParams.temperature);
    }
    if (invocationParams.top_p !== void 0) {
      span.setAttribute(GEN_AI_REQUEST_TOP_P, invocationParams.top_p);
    }
    if (invocationParams.frequency_penalty !== void 0) {
      span.setAttribute(GEN_AI_REQUEST_FREQUENCY_PENALTY, invocationParams.frequency_penalty);
    }
    if (invocationParams.presence_penalty !== void 0) {
      span.setAttribute(GEN_AI_REQUEST_PRESENCE_PENALTY, invocationParams.presence_penalty);
    }
  }
  setIOAttributes(span, op) {
    if (op.run.inputs) {
      try {
        const inputs = op.run.inputs;
        if (typeof inputs === "object" && inputs !== null) {
          if (inputs.model && Array.isArray(inputs.messages)) {
            span.setAttribute(GEN_AI_REQUEST_MODEL, inputs.model);
          }
          if (inputs.stream !== void 0) {
            span.setAttribute(LANGSMITH_REQUEST_STREAMING, inputs.stream);
          }
          if (inputs.extra_headers) {
            span.setAttribute(LANGSMITH_REQUEST_HEADERS, JSON.stringify(inputs.extra_headers));
          }
          if (inputs.extra_query) {
            span.setAttribute(GEN_AI_REQUEST_EXTRA_QUERY, JSON.stringify(inputs.extra_query));
          }
          if (inputs.extra_body) {
            span.setAttribute(GEN_AI_REQUEST_EXTRA_BODY, JSON.stringify(inputs.extra_body));
          }
        }
        span.setAttribute(GENAI_PROMPT, JSON.stringify(inputs));
      } catch (e) {
        console.debug(`Failed to process inputs for run ${op.id}`, e);
      }
    }
    if (op.run.outputs) {
      try {
        const outputs = op.run.outputs;
        const tokenUsage = this.getUnifiedRunTokens(outputs);
        if (tokenUsage) {
          span.setAttribute(GEN_AI_USAGE_INPUT_TOKENS, tokenUsage[0]);
          span.setAttribute(GEN_AI_USAGE_OUTPUT_TOKENS, tokenUsage[1]);
          span.setAttribute(GEN_AI_USAGE_TOTAL_TOKENS, tokenUsage[0] + tokenUsage[1]);
        }
        if (outputs && typeof outputs === "object") {
          if (outputs.model) {
            span.setAttribute(GEN_AI_RESPONSE_MODEL, String(outputs.model));
          }
          if (outputs.id) {
            span.setAttribute(GEN_AI_RESPONSE_ID, outputs.id);
          }
          if (outputs.choices && Array.isArray(outputs.choices)) {
            const finishReasons = outputs.choices.map((choice) => choice.finish_reason).filter((reason) => reason).map(String);
            if (finishReasons.length > 0) {
              span.setAttribute(GEN_AI_RESPONSE_FINISH_REASONS, finishReasons.join(", "));
            }
          }
          if (outputs.service_tier) {
            span.setAttribute(GEN_AI_RESPONSE_SERVICE_TIER, outputs.service_tier);
          }
          if (outputs.system_fingerprint) {
            span.setAttribute(GEN_AI_RESPONSE_SYSTEM_FINGERPRINT, outputs.system_fingerprint);
          }
          if (outputs.usage_metadata && typeof outputs.usage_metadata === "object") {
            const usageMetadata = outputs.usage_metadata;
            if (usageMetadata.input_token_details) {
              span.setAttribute(GEN_AI_USAGE_INPUT_TOKEN_DETAILS, JSON.stringify(usageMetadata.input_token_details));
            }
            if (usageMetadata.output_token_details) {
              span.setAttribute(GEN_AI_USAGE_OUTPUT_TOKEN_DETAILS, JSON.stringify(usageMetadata.output_token_details));
            }
          }
        }
        span.setAttribute(GENAI_COMPLETION, JSON.stringify(outputs));
      } catch (e) {
        console.debug(`Failed to process outputs for run ${op.id}`, e);
      }
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  getUnifiedRunTokens(outputs) {
    if (!outputs) {
      return null;
    }
    let tokenUsage = this.extractUnifiedRunTokens(outputs.usage_metadata);
    if (tokenUsage) {
      return tokenUsage;
    }
    const keys = Object.keys(outputs);
    for (const key of keys) {
      const haystack = outputs[key];
      if (!haystack || typeof haystack !== "object") {
        continue;
      }
      tokenUsage = this.extractUnifiedRunTokens(haystack.usage_metadata);
      if (tokenUsage) {
        return tokenUsage;
      }
      if (haystack.lc === 1 && haystack.kwargs && typeof haystack.kwargs === "object") {
        tokenUsage = this.extractUnifiedRunTokens(haystack.kwargs.usage_metadata);
        if (tokenUsage) {
          return tokenUsage;
        }
      }
    }
    const generations = outputs.generations || [];
    if (!Array.isArray(generations)) {
      return null;
    }
    const flatGenerations = Array.isArray(generations[0]) ? generations.flat() : generations;
    for (const generation of flatGenerations) {
      if (typeof generation === "object" && generation.message && typeof generation.message === "object" && generation.message.kwargs && typeof generation.message.kwargs === "object") {
        tokenUsage = this.extractUnifiedRunTokens(generation.message.kwargs.usage_metadata);
        if (tokenUsage) {
          return tokenUsage;
        }
      }
    }
    return null;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  extractUnifiedRunTokens(outputs) {
    if (!outputs || typeof outputs !== "object") {
      return null;
    }
    if (typeof outputs.input_tokens !== "number" || typeof outputs.output_tokens !== "number") {
      return null;
    }
    return [outputs.input_tokens, outputs.output_tokens];
  }
};

// node_modules/langsmith/dist/utils/async_caller.js
var import_p_retry = __toESM(require_p_retry(), 1);
var import_p_queue = __toESM(require_dist14(), 1);
var STATUS_NO_RETRY = [
  400,
  // Bad Request
  401,
  // Unauthorized
  403,
  // Forbidden
  404,
  // Not Found
  405,
  // Method Not Allowed
  406,
  // Not Acceptable
  407,
  // Proxy Authentication Required
  408
  // Request Timeout
];
var STATUS_IGNORE = [
  409
  // Conflict
];
var AsyncCaller = class {
  constructor(params) {
    Object.defineProperty(this, "maxConcurrency", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "maxRetries", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "queue", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "onFailedResponseHook", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "debug", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.maxConcurrency = params.maxConcurrency ?? Infinity;
    this.maxRetries = params.maxRetries ?? 6;
    this.debug = params.debug;
    if ("default" in import_p_queue.default) {
      this.queue = new import_p_queue.default.default({
        concurrency: this.maxConcurrency
      });
    } else {
      this.queue = new import_p_queue.default({ concurrency: this.maxConcurrency });
    }
    this.onFailedResponseHook = params?.onFailedResponseHook;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  call(callable, ...args) {
    const onFailedResponseHook = this.onFailedResponseHook;
    return this.queue.add(() => (0, import_p_retry.default)(() => callable(...args).catch((error) => {
      if (error instanceof Error) {
        throw error;
      } else {
        throw new Error(error);
      }
    }), {
      async onFailedAttempt(error) {
        if (error.message.startsWith("Cancel") || error.message.startsWith("TimeoutError") || error.message.startsWith("AbortError")) {
          throw error;
        }
        if (error?.code === "ECONNABORTED") {
          throw error;
        }
        const response = error?.response;
        const status = response?.status;
        if (status) {
          if (STATUS_NO_RETRY.includes(+status)) {
            throw error;
          } else if (STATUS_IGNORE.includes(+status)) {
            return;
          }
          if (onFailedResponseHook) {
            await onFailedResponseHook(response);
          }
        }
      },
      // If needed we can change some of the defaults here,
      // but they're quite sensible.
      retries: this.maxRetries,
      randomize: true
    }), { throwOnTimeout: true });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  callWithOptions(options, callable, ...args) {
    if (options.signal) {
      return Promise.race([
        this.call(callable, ...args),
        new Promise((_, reject) => {
          options.signal?.addEventListener("abort", () => {
            reject(new Error("AbortError"));
          });
        })
      ]);
    }
    return this.call(callable, ...args);
  }
  fetch(...args) {
    return this.call(() => _getFetchImplementation(this.debug)(...args).then((res) => res.ok ? res : Promise.reject(res)));
  }
};

// node_modules/langsmith/dist/utils/messages.js
function isLangChainMessage(message) {
  return typeof message?._getType === "function";
}
function convertLangChainMessageToExample(message) {
  const converted = {
    type: message._getType(),
    data: { content: message.content }
  };
  if (message?.additional_kwargs && Object.keys(message.additional_kwargs).length > 0) {
    converted.data.additional_kwargs = { ...message.additional_kwargs };
  }
  return converted;
}

// node_modules/langsmith/dist/utils/_uuid.js
var UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
function assertUuid(str, which) {
  if (!UUID_REGEX.test(str)) {
    const msg = which !== void 0 ? `Invalid UUID for ${which}: ${str}` : `Invalid UUID: ${str}`;
    throw new Error(msg);
  }
  return str;
}

// node_modules/langsmith/dist/utils/warn.js
var warnedMessages = {};
function warnOnce(message) {
  if (!warnedMessages[message]) {
    console.warn(message);
    warnedMessages[message] = true;
  }
}

// node_modules/langsmith/dist/utils/prompts.js
var import_semver = __toESM(require_semver2(), 1);
function parsePromptIdentifier(identifier) {
  if (!identifier || identifier.split("/").length > 2 || identifier.startsWith("/") || identifier.endsWith("/") || identifier.split(":").length > 2) {
    throw new Error(`Invalid identifier format: ${identifier}`);
  }
  const [ownerNamePart, commitPart] = identifier.split(":");
  const commit = commitPart || "latest";
  if (ownerNamePart.includes("/")) {
    const [owner, name] = ownerNamePart.split("/", 2);
    if (!owner || !name) {
      throw new Error(`Invalid identifier format: ${identifier}`);
    }
    return [owner, name, commit];
  } else {
    if (!ownerNamePart) {
      throw new Error(`Invalid identifier format: ${identifier}`);
    }
    return ["-", ownerNamePart, commit];
  }
}

// node_modules/langsmith/dist/utils/error.js
var LangSmithConflictError = class extends Error {
  constructor(message) {
    super(message);
    Object.defineProperty(this, "status", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.name = "LangSmithConflictError";
    this.status = 409;
  }
};
async function raiseForStatus(response, context, consume) {
  let errorBody;
  if (response.ok) {
    if (consume) {
      errorBody = await response.text();
    }
    return;
  }
  errorBody = await response.text();
  const fullMessage = `Failed to ${context}. Received status [${response.status}]: ${response.statusText}. Server response: ${errorBody}`;
  if (response.status === 409) {
    throw new LangSmithConflictError(fullMessage);
  }
  const err = new Error(fullMessage);
  err.status = response.status;
  throw err;
}

// node_modules/langsmith/dist/utils/fast-safe-stringify/index.js
var LIMIT_REPLACE_NODE = "[...]";
var CIRCULAR_REPLACE_NODE = { result: "[Circular]" };
var arr = [];
var replacerStack = [];
var encoder = new TextEncoder();
function defaultOptions() {
  return {
    depthLimit: Number.MAX_SAFE_INTEGER,
    edgesLimit: Number.MAX_SAFE_INTEGER
  };
}
function encodeString(str) {
  return encoder.encode(str);
}
function serialize(obj, errorContext, replacer, spacer, options) {
  try {
    const str = JSON.stringify(obj, replacer, spacer);
    return encodeString(str);
  } catch (e) {
    if (!e.message?.includes("Converting circular structure to JSON")) {
      console.warn(`[WARNING]: LangSmith received unserializable value.${errorContext ? `
Context: ${errorContext}` : ""}`);
      return encodeString("[Unserializable]");
    }
    getLangSmithEnvironmentVariable("SUPPRESS_CIRCULAR_JSON_WARNINGS") !== "true" && console.warn(`[WARNING]: LangSmith received circular JSON. This will decrease tracer performance. ${errorContext ? `
Context: ${errorContext}` : ""}`);
    if (typeof options === "undefined") {
      options = defaultOptions();
    }
    decirc(obj, "", 0, [], void 0, 0, options);
    let res;
    try {
      if (replacerStack.length === 0) {
        res = JSON.stringify(obj, replacer, spacer);
      } else {
        res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
      }
    } catch (_) {
      return encodeString("[unable to serialize, circular reference is too complex to analyze]");
    } finally {
      while (arr.length !== 0) {
        const part = arr.pop();
        if (part.length === 4) {
          Object.defineProperty(part[0], part[1], part[3]);
        } else {
          part[0][part[1]] = part[2];
        }
      }
    }
    return encodeString(res);
  }
}
function setReplace(replace, val, k, parent) {
  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
  if (propertyDescriptor.get !== void 0) {
    if (propertyDescriptor.configurable) {
      Object.defineProperty(parent, k, { value: replace });
      arr.push([parent, k, val, propertyDescriptor]);
    } else {
      replacerStack.push([val, k, replace]);
    }
  } else {
    parent[k] = replace;
    arr.push([parent, k, val]);
  }
}
function decirc(val, k, edgeIndex, stack, parent, depth, options) {
  depth += 1;
  var i;
  if (typeof val === "object" && val !== null) {
    for (i = 0; i < stack.length; i++) {
      if (stack[i] === val) {
        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
        return;
      }
    }
    if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent);
      return;
    }
    if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent);
      return;
    }
    stack.push(val);
    if (Array.isArray(val)) {
      for (i = 0; i < val.length; i++) {
        decirc(val[i], i, i, stack, val, depth, options);
      }
    } else {
      var keys = Object.keys(val);
      for (i = 0; i < keys.length; i++) {
        var key = keys[i];
        decirc(val[key], key, i, stack, val, depth, options);
      }
    }
    stack.pop();
  }
}
function replaceGetterValues(replacer) {
  replacer = typeof replacer !== "undefined" ? replacer : function(k, v) {
    return v;
  };
  return function(key, val) {
    if (replacerStack.length > 0) {
      for (var i = 0; i < replacerStack.length; i++) {
        var part = replacerStack[i];
        if (part[1] === key && part[0] === val) {
          val = part[2];
          replacerStack.splice(i, 1);
          break;
        }
      }
    }
    return replacer.call(this, key, val);
  };
}

// node_modules/langsmith/dist/client.js
function mergeRuntimeEnvIntoRunCreate(run) {
  const runtimeEnv = getRuntimeEnvironment2();
  const envVars = getLangChainEnvVarsMetadata();
  const extra = run.extra ?? {};
  const metadata = extra.metadata;
  run.extra = {
    ...extra,
    runtime: {
      ...runtimeEnv,
      ...extra?.runtime
    },
    metadata: {
      ...envVars,
      ...envVars.revision_id || run.revision_id ? { revision_id: run.revision_id ?? envVars.revision_id } : {},
      ...metadata
    }
  };
  return run;
}
var getTracingSamplingRate = (configRate) => {
  const samplingRateStr = configRate?.toString() ?? getLangSmithEnvironmentVariable("TRACING_SAMPLING_RATE");
  if (samplingRateStr === void 0) {
    return void 0;
  }
  const samplingRate = parseFloat(samplingRateStr);
  if (samplingRate < 0 || samplingRate > 1) {
    throw new Error(`LANGSMITH_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${samplingRate}`);
  }
  return samplingRate;
};
var isLocalhost = (url) => {
  const strippedUrl = url.replace("http://", "").replace("https://", "");
  const hostname = strippedUrl.split("/")[0].split(":")[0];
  return hostname === "localhost" || hostname === "127.0.0.1" || hostname === "::1";
};
async function toArray(iterable) {
  const result = [];
  for await (const item of iterable) {
    result.push(item);
  }
  return result;
}
function trimQuotes(str) {
  if (str === void 0) {
    return void 0;
  }
  return str.trim().replace(/^"(.*)"$/, "$1").replace(/^'(.*)'$/, "$1");
}
var handle429 = async (response) => {
  if (response?.status === 429) {
    const retryAfter = parseInt(response.headers.get("retry-after") ?? "30", 10) * 1e3;
    if (retryAfter > 0) {
      await new Promise((resolve) => setTimeout(resolve, retryAfter));
      return true;
    }
  }
  return false;
};
function _formatFeedbackScore(score) {
  if (typeof score === "number") {
    return Number(score.toFixed(4));
  }
  return score;
}
var AutoBatchQueue = class {
  constructor() {
    Object.defineProperty(this, "items", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "sizeBytes", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 0
    });
  }
  peek() {
    return this.items[0];
  }
  push(item) {
    let itemPromiseResolve;
    const itemPromise = new Promise((resolve) => {
      itemPromiseResolve = resolve;
    });
    const size = serialize(item.item, `Serializing run with id: ${item.item.id}`).length;
    this.items.push({
      action: item.action,
      payload: item.item,
      otelContext: item.otelContext,
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      itemPromiseResolve,
      itemPromise,
      size
    });
    this.sizeBytes += size;
    return itemPromise;
  }
  pop(upToSizeBytes) {
    if (upToSizeBytes < 1) {
      throw new Error("Number of bytes to pop off may not be less than 1.");
    }
    const popped = [];
    let poppedSizeBytes = 0;
    while (poppedSizeBytes + (this.peek()?.size ?? 0) < upToSizeBytes && this.items.length > 0) {
      const item = this.items.shift();
      if (item) {
        popped.push(item);
        poppedSizeBytes += item.size;
        this.sizeBytes -= item.size;
      }
    }
    if (popped.length === 0 && this.items.length > 0) {
      const item = this.items.shift();
      popped.push(item);
      poppedSizeBytes += item.size;
      this.sizeBytes -= item.size;
    }
    return [
      popped.map((it) => ({
        action: it.action,
        item: it.payload,
        otelContext: it.otelContext
      })),
      () => popped.forEach((it) => it.itemPromiseResolve())
    ];
  }
};
var DEFAULT_BATCH_SIZE_LIMIT_BYTES = 20971520;
var SERVER_INFO_REQUEST_TIMEOUT = 2500;
var Client = class _Client {
  constructor(config = {}) {
    Object.defineProperty(this, "apiKey", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "apiUrl", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "webUrl", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "caller", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "batchIngestCaller", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "timeout_ms", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_tenantId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: null
    });
    Object.defineProperty(this, "hideInputs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "hideOutputs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "tracingSampleRate", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "filteredPostUuids", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /* @__PURE__ */ new Set()
    });
    Object.defineProperty(this, "autoBatchTracing", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "autoBatchQueue", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new AutoBatchQueue()
    });
    Object.defineProperty(this, "autoBatchTimeout", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "autoBatchAggregationDelayMs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 250
    });
    Object.defineProperty(this, "batchSizeBytesLimit", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "fetchOptions", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "settings", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "blockOnRootRunFinalization", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: getEnvironmentVariable2("LANGSMITH_TRACING_BACKGROUND") === "false"
    });
    Object.defineProperty(this, "traceBatchConcurrency", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 5
    });
    Object.defineProperty(this, "_serverInfo", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_getServerInfoPromise", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "manualFlushMode", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "langSmithToOTELTranslator", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "debug", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: getEnvironmentVariable2("LANGSMITH_DEBUG") === "true"
    });
    const defaultConfig = _Client.getDefaultClientConfig();
    this.tracingSampleRate = getTracingSamplingRate(config.tracingSamplingRate);
    this.apiUrl = trimQuotes(config.apiUrl ?? defaultConfig.apiUrl) ?? "";
    if (this.apiUrl.endsWith("/")) {
      this.apiUrl = this.apiUrl.slice(0, -1);
    }
    this.apiKey = trimQuotes(config.apiKey ?? defaultConfig.apiKey);
    this.webUrl = trimQuotes(config.webUrl ?? defaultConfig.webUrl);
    if (this.webUrl?.endsWith("/")) {
      this.webUrl = this.webUrl.slice(0, -1);
    }
    this.timeout_ms = config.timeout_ms ?? 9e4;
    this.caller = new AsyncCaller({
      ...config.callerOptions ?? {},
      debug: config.debug ?? this.debug
    });
    this.traceBatchConcurrency = config.traceBatchConcurrency ?? this.traceBatchConcurrency;
    if (this.traceBatchConcurrency < 1) {
      throw new Error("Trace batch concurrency must be positive.");
    }
    this.debug = config.debug ?? this.debug;
    this.batchIngestCaller = new AsyncCaller({
      maxRetries: 2,
      maxConcurrency: this.traceBatchConcurrency,
      ...config.callerOptions ?? {},
      onFailedResponseHook: handle429,
      debug: config.debug ?? this.debug
    });
    this.hideInputs = config.hideInputs ?? config.anonymizer ?? defaultConfig.hideInputs;
    this.hideOutputs = config.hideOutputs ?? config.anonymizer ?? defaultConfig.hideOutputs;
    this.autoBatchTracing = config.autoBatchTracing ?? this.autoBatchTracing;
    this.blockOnRootRunFinalization = config.blockOnRootRunFinalization ?? this.blockOnRootRunFinalization;
    this.batchSizeBytesLimit = config.batchSizeBytesLimit;
    this.fetchOptions = config.fetchOptions || {};
    this.manualFlushMode = config.manualFlushMode ?? this.manualFlushMode;
    if (getEnvironmentVariable2("OTEL_ENABLED") === "true") {
      this.langSmithToOTELTranslator = new LangSmithToOTELTranslator();
    }
  }
  static getDefaultClientConfig() {
    const apiKey = getLangSmithEnvironmentVariable("API_KEY");
    const apiUrl = getLangSmithEnvironmentVariable("ENDPOINT") ?? "https://api.smith.langchain.com";
    const hideInputs = getLangSmithEnvironmentVariable("HIDE_INPUTS") === "true";
    const hideOutputs = getLangSmithEnvironmentVariable("HIDE_OUTPUTS") === "true";
    return {
      apiUrl,
      apiKey,
      webUrl: void 0,
      hideInputs,
      hideOutputs
    };
  }
  getHostUrl() {
    if (this.webUrl) {
      return this.webUrl;
    } else if (isLocalhost(this.apiUrl)) {
      this.webUrl = "http://localhost:3000";
      return this.webUrl;
    } else if (this.apiUrl.endsWith("/api/v1")) {
      this.webUrl = this.apiUrl.replace("/api/v1", "");
      return this.webUrl;
    } else if (this.apiUrl.includes("/api") && !this.apiUrl.split(".", 1)[0].endsWith("api")) {
      this.webUrl = this.apiUrl.replace("/api", "");
      return this.webUrl;
    } else if (this.apiUrl.split(".", 1)[0].includes("dev")) {
      this.webUrl = "https://dev.smith.langchain.com";
      return this.webUrl;
    } else if (this.apiUrl.split(".", 1)[0].includes("eu")) {
      this.webUrl = "https://eu.smith.langchain.com";
      return this.webUrl;
    } else if (this.apiUrl.split(".", 1)[0].includes("beta")) {
      this.webUrl = "https://beta.smith.langchain.com";
      return this.webUrl;
    } else {
      this.webUrl = "https://smith.langchain.com";
      return this.webUrl;
    }
  }
  get headers() {
    const headers = {
      "User-Agent": `langsmith-js/${__version__}`
    };
    if (this.apiKey) {
      headers["x-api-key"] = `${this.apiKey}`;
    }
    return headers;
  }
  async processInputs(inputs) {
    if (this.hideInputs === false) {
      return inputs;
    }
    if (this.hideInputs === true) {
      return {};
    }
    if (typeof this.hideInputs === "function") {
      return this.hideInputs(inputs);
    }
    return inputs;
  }
  async processOutputs(outputs) {
    if (this.hideOutputs === false) {
      return outputs;
    }
    if (this.hideOutputs === true) {
      return {};
    }
    if (typeof this.hideOutputs === "function") {
      return this.hideOutputs(outputs);
    }
    return outputs;
  }
  async prepareRunCreateOrUpdateInputs(run) {
    const runParams = { ...run };
    if (runParams.inputs !== void 0) {
      runParams.inputs = await this.processInputs(runParams.inputs);
    }
    if (runParams.outputs !== void 0) {
      runParams.outputs = await this.processOutputs(runParams.outputs);
    }
    return runParams;
  }
  async _getResponse(path, queryParams) {
    const paramsString = queryParams?.toString() ?? "";
    const url = `${this.apiUrl}${path}?${paramsString}`;
    const response = await this.caller.call(_getFetchImplementation(this.debug), url, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, `Failed to fetch ${path}`);
    return response;
  }
  async _get(path, queryParams) {
    const response = await this._getResponse(path, queryParams);
    return response.json();
  }
  async *_getPaginated(path, queryParams = new URLSearchParams(), transform) {
    let offset = Number(queryParams.get("offset")) || 0;
    const limit = Number(queryParams.get("limit")) || 100;
    while (true) {
      queryParams.set("offset", String(offset));
      queryParams.set("limit", String(limit));
      const url = `${this.apiUrl}${path}?${queryParams}`;
      const response = await this.caller.call(_getFetchImplementation(this.debug), url, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, `Failed to fetch ${path}`);
      const items = transform ? transform(await response.json()) : await response.json();
      if (items.length === 0) {
        break;
      }
      yield items;
      if (items.length < limit) {
        break;
      }
      offset += items.length;
    }
  }
  async *_getCursorPaginatedList(path, body = null, requestMethod = "POST", dataKey = "runs") {
    const bodyParams = body ? { ...body } : {};
    while (true) {
      const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}${path}`, {
        method: requestMethod,
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: JSON.stringify(bodyParams)
      });
      const responseBody = await response.json();
      if (!responseBody) {
        break;
      }
      if (!responseBody[dataKey]) {
        break;
      }
      yield responseBody[dataKey];
      const cursors = responseBody.cursors;
      if (!cursors) {
        break;
      }
      if (!cursors.next) {
        break;
      }
      bodyParams.cursor = cursors.next;
    }
  }
  // Allows mocking for tests
  _shouldSample() {
    if (this.tracingSampleRate === void 0) {
      return true;
    }
    return Math.random() < this.tracingSampleRate;
  }
  _filterForSampling(runs, patch = false) {
    if (this.tracingSampleRate === void 0) {
      return runs;
    }
    if (patch) {
      const sampled = [];
      for (const run of runs) {
        if (!this.filteredPostUuids.has(run.id)) {
          sampled.push(run);
        } else {
          this.filteredPostUuids.delete(run.id);
        }
      }
      return sampled;
    } else {
      const sampled = [];
      for (const run of runs) {
        const traceId = run.trace_id ?? run.id;
        if (this.filteredPostUuids.has(traceId)) {
          continue;
        }
        if (run.id === traceId) {
          if (this._shouldSample()) {
            sampled.push(run);
          } else {
            this.filteredPostUuids.add(traceId);
          }
        } else {
          sampled.push(run);
        }
      }
      return sampled;
    }
  }
  async _getBatchSizeLimitBytes() {
    const serverInfo = await this._ensureServerInfo();
    return this.batchSizeBytesLimit ?? serverInfo.batch_ingest_config?.size_limit_bytes ?? DEFAULT_BATCH_SIZE_LIMIT_BYTES;
  }
  async _getMultiPartSupport() {
    const serverInfo = await this._ensureServerInfo();
    return serverInfo.instance_flags?.dataset_examples_multipart_enabled ?? false;
  }
  drainAutoBatchQueue(batchSizeLimit) {
    const promises = [];
    while (this.autoBatchQueue.items.length > 0) {
      const [batch, done] = this.autoBatchQueue.pop(batchSizeLimit);
      if (!batch.length) {
        done();
        break;
      }
      const batchPromise = this._processBatch(batch, done).catch(console.error);
      promises.push(batchPromise);
    }
    return Promise.all(promises);
  }
  async _processBatch(batch, done) {
    if (!batch.length) {
      done();
      return;
    }
    try {
      if (this.langSmithToOTELTranslator !== void 0) {
        this._sendBatchToOTELTranslator(batch);
      } else {
        const ingestParams = {
          runCreates: batch.filter((item) => item.action === "create").map((item) => item.item),
          runUpdates: batch.filter((item) => item.action === "update").map((item) => item.item)
        };
        const serverInfo = await this._ensureServerInfo();
        if (serverInfo?.batch_ingest_config?.use_multipart_endpoint) {
          await this.multipartIngestRuns(ingestParams);
        } else {
          await this.batchIngestRuns(ingestParams);
        }
      }
    } catch (e) {
      console.error("Error exporting batch:", e);
    } finally {
      done();
    }
  }
  _sendBatchToOTELTranslator(batch) {
    if (this.langSmithToOTELTranslator !== void 0) {
      const otelContextMap = /* @__PURE__ */ new Map();
      const operations = [];
      for (const item of batch) {
        if (item.item.id && item.otelContext) {
          otelContextMap.set(item.item.id, item.otelContext);
          if (item.action === "create") {
            operations.push({
              operation: "post",
              id: item.item.id,
              trace_id: item.item.trace_id ?? item.item.id,
              run: item.item
            });
          } else {
            operations.push({
              operation: "patch",
              id: item.item.id,
              trace_id: item.item.trace_id ?? item.item.id,
              run: item.item
            });
          }
        }
      }
      this.langSmithToOTELTranslator.exportBatch(operations, otelContextMap);
    }
  }
  async processRunOperation(item) {
    clearTimeout(this.autoBatchTimeout);
    this.autoBatchTimeout = void 0;
    if (item.action === "create") {
      item.item = mergeRuntimeEnvIntoRunCreate(item.item);
    }
    const itemPromise = this.autoBatchQueue.push(item);
    if (this.manualFlushMode) {
      return itemPromise;
    }
    const sizeLimitBytes = await this._getBatchSizeLimitBytes();
    if (this.autoBatchQueue.sizeBytes > sizeLimitBytes) {
      void this.drainAutoBatchQueue(sizeLimitBytes);
    }
    if (this.autoBatchQueue.items.length > 0) {
      this.autoBatchTimeout = setTimeout(() => {
        this.autoBatchTimeout = void 0;
        void this.drainAutoBatchQueue(sizeLimitBytes);
      }, this.autoBatchAggregationDelayMs);
    }
    return itemPromise;
  }
  async _getServerInfo() {
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/info`, {
      method: "GET",
      headers: { Accept: "application/json" },
      signal: AbortSignal.timeout(SERVER_INFO_REQUEST_TIMEOUT),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "get server info");
    const json2 = await response.json();
    if (this.debug) {
      console.log("\n=== LangSmith Server Configuration ===\n" + JSON.stringify(json2, null, 2) + "\n");
    }
    return json2;
  }
  async _ensureServerInfo() {
    if (this._getServerInfoPromise === void 0) {
      this._getServerInfoPromise = (async () => {
        if (this._serverInfo === void 0) {
          try {
            this._serverInfo = await this._getServerInfo();
          } catch (e) {
            console.warn(`[WARNING]: LangSmith failed to fetch info on supported operations with status code ${e.status}. Falling back to batch operations and default limits.`);
          }
        }
        return this._serverInfo ?? {};
      })();
    }
    return this._getServerInfoPromise.then((serverInfo) => {
      if (this._serverInfo === void 0) {
        this._getServerInfoPromise = void 0;
      }
      return serverInfo;
    });
  }
  async _getSettings() {
    if (!this.settings) {
      this.settings = this._get("/settings");
    }
    return await this.settings;
  }
  /**
   * Flushes current queued traces.
   */
  async flush() {
    const sizeLimitBytes = await this._getBatchSizeLimitBytes();
    await this.drainAutoBatchQueue(sizeLimitBytes);
  }
  _cloneCurrentOTELContext() {
    const otel_trace = getOTELTrace();
    const otel_context = getOTELContext();
    if (this.langSmithToOTELTranslator !== void 0) {
      const currentSpan = otel_trace.getActiveSpan();
      if (currentSpan) {
        return otel_trace.setSpan(otel_context.active(), currentSpan);
      }
    }
    return void 0;
  }
  async createRun(run) {
    if (!this._filterForSampling([run]).length) {
      return;
    }
    const headers = { ...this.headers, "Content-Type": "application/json" };
    const session_name = run.project_name;
    delete run.project_name;
    const runCreate = await this.prepareRunCreateOrUpdateInputs({
      session_name,
      ...run,
      start_time: run.start_time ?? Date.now()
    });
    if (this.autoBatchTracing && runCreate.trace_id !== void 0 && runCreate.dotted_order !== void 0) {
      const otelContext = this._cloneCurrentOTELContext();
      void this.processRunOperation({
        action: "create",
        item: runCreate,
        otelContext
      }).catch(console.error);
      return;
    }
    const mergedRunCreateParam = mergeRuntimeEnvIntoRunCreate(runCreate);
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/runs`, {
      method: "POST",
      headers,
      body: serialize(mergedRunCreateParam, `Creating run with id: ${mergedRunCreateParam.id}`),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "create run", true);
  }
  /**
   * Batch ingest/upsert multiple runs in the Langsmith system.
   * @param runs
   */
  async batchIngestRuns({ runCreates, runUpdates }) {
    if (runCreates === void 0 && runUpdates === void 0) {
      return;
    }
    let preparedCreateParams = await Promise.all(runCreates?.map((create) => this.prepareRunCreateOrUpdateInputs(create)) ?? []);
    let preparedUpdateParams = await Promise.all(runUpdates?.map((update) => this.prepareRunCreateOrUpdateInputs(update)) ?? []);
    if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {
      const createById = preparedCreateParams.reduce((params, run) => {
        if (!run.id) {
          return params;
        }
        params[run.id] = run;
        return params;
      }, {});
      const standaloneUpdates = [];
      for (const updateParam of preparedUpdateParams) {
        if (updateParam.id !== void 0 && createById[updateParam.id]) {
          createById[updateParam.id] = {
            ...createById[updateParam.id],
            ...updateParam
          };
        } else {
          standaloneUpdates.push(updateParam);
        }
      }
      preparedCreateParams = Object.values(createById);
      preparedUpdateParams = standaloneUpdates;
    }
    const rawBatch = {
      post: preparedCreateParams,
      patch: preparedUpdateParams
    };
    if (!rawBatch.post.length && !rawBatch.patch.length) {
      return;
    }
    const batchChunks = {
      post: [],
      patch: []
    };
    for (const k of ["post", "patch"]) {
      const key = k;
      const batchItems = rawBatch[key].reverse();
      let batchItem = batchItems.pop();
      while (batchItem !== void 0) {
        batchChunks[key].push(batchItem);
        batchItem = batchItems.pop();
      }
    }
    if (batchChunks.post.length > 0 || batchChunks.patch.length > 0) {
      const runIds = batchChunks.post.map((item) => item.id).concat(batchChunks.patch.map((item) => item.id)).join(",");
      await this._postBatchIngestRuns(serialize(batchChunks, `Ingesting runs with ids: ${runIds}`));
    }
  }
  async _postBatchIngestRuns(body) {
    const headers = {
      ...this.headers,
      "Content-Type": "application/json",
      Accept: "application/json"
    };
    const response = await this.batchIngestCaller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/runs/batch`, {
      method: "POST",
      headers,
      body,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "batch create run", true);
  }
  /**
   * Batch ingest/upsert multiple runs in the Langsmith system.
   * @param runs
   */
  async multipartIngestRuns({ runCreates, runUpdates }) {
    if (runCreates === void 0 && runUpdates === void 0) {
      return;
    }
    const allAttachments = {};
    let preparedCreateParams = [];
    for (const create of runCreates ?? []) {
      const preparedCreate = await this.prepareRunCreateOrUpdateInputs(create);
      if (preparedCreate.id !== void 0 && preparedCreate.attachments !== void 0) {
        allAttachments[preparedCreate.id] = preparedCreate.attachments;
      }
      delete preparedCreate.attachments;
      preparedCreateParams.push(preparedCreate);
    }
    let preparedUpdateParams = [];
    for (const update of runUpdates ?? []) {
      preparedUpdateParams.push(await this.prepareRunCreateOrUpdateInputs(update));
    }
    const invalidRunCreate = preparedCreateParams.find((runCreate) => {
      return runCreate.trace_id === void 0 || runCreate.dotted_order === void 0;
    });
    if (invalidRunCreate !== void 0) {
      throw new Error(`Multipart ingest requires "trace_id" and "dotted_order" to be set when creating a run`);
    }
    const invalidRunUpdate = preparedUpdateParams.find((runUpdate) => {
      return runUpdate.trace_id === void 0 || runUpdate.dotted_order === void 0;
    });
    if (invalidRunUpdate !== void 0) {
      throw new Error(`Multipart ingest requires "trace_id" and "dotted_order" to be set when updating a run`);
    }
    if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {
      const createById = preparedCreateParams.reduce((params, run) => {
        if (!run.id) {
          return params;
        }
        params[run.id] = run;
        return params;
      }, {});
      const standaloneUpdates = [];
      for (const updateParam of preparedUpdateParams) {
        if (updateParam.id !== void 0 && createById[updateParam.id]) {
          createById[updateParam.id] = {
            ...createById[updateParam.id],
            ...updateParam
          };
        } else {
          standaloneUpdates.push(updateParam);
        }
      }
      preparedCreateParams = Object.values(createById);
      preparedUpdateParams = standaloneUpdates;
    }
    if (preparedCreateParams.length === 0 && preparedUpdateParams.length === 0) {
      return;
    }
    const accumulatedContext = [];
    const accumulatedParts = [];
    for (const [method, payloads] of [
      ["post", preparedCreateParams],
      ["patch", preparedUpdateParams]
    ]) {
      for (const originalPayload of payloads) {
        const { inputs, outputs, events, attachments, ...payload } = originalPayload;
        const fields = { inputs, outputs, events };
        const stringifiedPayload = serialize(payload, `Serializing for multipart ingestion of run with id: ${payload.id}`);
        accumulatedParts.push({
          name: `${method}.${payload.id}`,
          payload: new Blob([stringifiedPayload], {
            type: `application/json; length=${stringifiedPayload.length}`
            // encoding=gzip
          })
        });
        for (const [key, value] of Object.entries(fields)) {
          if (value === void 0) {
            continue;
          }
          const stringifiedValue = serialize(value, `Serializing ${key} for multipart ingestion of run with id: ${payload.id}`);
          accumulatedParts.push({
            name: `${method}.${payload.id}.${key}`,
            payload: new Blob([stringifiedValue], {
              type: `application/json; length=${stringifiedValue.length}`
            })
          });
        }
        if (payload.id !== void 0) {
          const attachments2 = allAttachments[payload.id];
          if (attachments2) {
            delete allAttachments[payload.id];
            for (const [name, attachment] of Object.entries(attachments2)) {
              let contentType;
              let content;
              if (Array.isArray(attachment)) {
                [contentType, content] = attachment;
              } else {
                contentType = attachment.mimeType;
                content = attachment.data;
              }
              if (name.includes(".")) {
                console.warn(`Skipping attachment '${name}' for run ${payload.id}: Invalid attachment name. Attachment names must not contain periods ('.'). Please rename the attachment and try again.`);
                continue;
              }
              accumulatedParts.push({
                name: `attachment.${payload.id}.${name}`,
                payload: new Blob([content], {
                  type: `${contentType}; length=${content.byteLength}`
                })
              });
            }
          }
        }
        accumulatedContext.push(`trace=${payload.trace_id},id=${payload.id}`);
      }
    }
    await this._sendMultipartRequest(accumulatedParts, accumulatedContext.join("; "));
  }
  async _createNodeFetchBody(parts, boundary) {
    const chunks = [];
    for (const part of parts) {
      chunks.push(new Blob([`--${boundary}\r
`]));
      chunks.push(new Blob([
        `Content-Disposition: form-data; name="${part.name}"\r
`,
        `Content-Type: ${part.payload.type}\r
\r
`
      ]));
      chunks.push(part.payload);
      chunks.push(new Blob(["\r\n"]));
    }
    chunks.push(new Blob([`--${boundary}--\r
`]));
    const body = new Blob(chunks);
    const arrayBuffer = await body.arrayBuffer();
    return arrayBuffer;
  }
  async _createMultipartStream(parts, boundary) {
    const encoder2 = new TextEncoder();
    const stream = new ReadableStream({
      async start(controller) {
        const writeChunk = async (chunk) => {
          if (typeof chunk === "string") {
            controller.enqueue(encoder2.encode(chunk));
          } else {
            controller.enqueue(chunk);
          }
        };
        for (const part of parts) {
          await writeChunk(`--${boundary}\r
`);
          await writeChunk(`Content-Disposition: form-data; name="${part.name}"\r
`);
          await writeChunk(`Content-Type: ${part.payload.type}\r
\r
`);
          const payloadStream = part.payload.stream();
          const reader = payloadStream.getReader();
          try {
            let result;
            while (!(result = await reader.read()).done) {
              controller.enqueue(result.value);
            }
          } finally {
            reader.releaseLock();
          }
          await writeChunk("\r\n");
        }
        await writeChunk(`--${boundary}--\r
`);
        controller.close();
      }
    });
    return stream;
  }
  async _sendMultipartRequest(parts, context) {
    try {
      const boundary = "----LangSmithFormBoundary" + Math.random().toString(36).slice(2);
      const body = await (_globalFetchImplementationIsNodeFetch() ? this._createNodeFetchBody(parts, boundary) : this._createMultipartStream(parts, boundary));
      const res = await this.batchIngestCaller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/runs/multipart`, {
        method: "POST",
        headers: {
          ...this.headers,
          "Content-Type": `multipart/form-data; boundary=${boundary}`
        },
        body,
        duplex: "half",
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, "ingest multipart runs", true);
    } catch (e) {
      console.warn(`${e.message.trim()}

Context: ${context}`);
    }
  }
  async updateRun(runId, run) {
    assertUuid(runId);
    if (run.inputs) {
      run.inputs = await this.processInputs(run.inputs);
    }
    if (run.outputs) {
      run.outputs = await this.processOutputs(run.outputs);
    }
    const data = { ...run, id: runId };
    if (!this._filterForSampling([data], true).length) {
      return;
    }
    if (this.autoBatchTracing && data.trace_id !== void 0 && data.dotted_order !== void 0) {
      const otelContext = this._cloneCurrentOTELContext();
      if (run.end_time !== void 0 && data.parent_run_id === void 0 && this.blockOnRootRunFinalization && !this.manualFlushMode) {
        await this.processRunOperation({
          action: "update",
          item: data,
          otelContext
        }).catch(console.error);
        return;
      } else {
        void this.processRunOperation({
          action: "update",
          item: data,
          otelContext
        }).catch(console.error);
      }
      return;
    }
    const headers = { ...this.headers, "Content-Type": "application/json" };
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/runs/${runId}`, {
      method: "PATCH",
      headers,
      body: serialize(run, `Serializing payload to update run with id: ${runId}`),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "update run", true);
  }
  async readRun(runId, { loadChildRuns } = { loadChildRuns: false }) {
    assertUuid(runId);
    let run = await this._get(`/runs/${runId}`);
    if (loadChildRuns) {
      run = await this._loadChildRuns(run);
    }
    return run;
  }
  async getRunUrl({ runId, run, projectOpts }) {
    if (run !== void 0) {
      let sessionId;
      if (run.session_id) {
        sessionId = run.session_id;
      } else if (projectOpts?.projectName) {
        sessionId = (await this.readProject({ projectName: projectOpts?.projectName })).id;
      } else if (projectOpts?.projectId) {
        sessionId = projectOpts?.projectId;
      } else {
        const project = await this.readProject({
          projectName: getLangSmithEnvironmentVariable("PROJECT") || "default"
        });
        sessionId = project.id;
      }
      const tenantId = await this._getTenantId();
      return `${this.getHostUrl()}/o/${tenantId}/projects/p/${sessionId}/r/${run.id}?poll=true`;
    } else if (runId !== void 0) {
      const run_ = await this.readRun(runId);
      if (!run_.app_path) {
        throw new Error(`Run ${runId} has no app_path`);
      }
      const baseUrl = this.getHostUrl();
      return `${baseUrl}${run_.app_path}`;
    } else {
      throw new Error("Must provide either runId or run");
    }
  }
  async _loadChildRuns(run) {
    const childRuns = await toArray(this.listRuns({
      isRoot: false,
      projectId: run.session_id,
      traceId: run.trace_id
    }));
    const treemap = {};
    const runs = {};
    childRuns.sort((a, b) => (a?.dotted_order ?? "").localeCompare(b?.dotted_order ?? ""));
    for (const childRun of childRuns) {
      if (childRun.parent_run_id === null || childRun.parent_run_id === void 0) {
        throw new Error(`Child run ${childRun.id} has no parent`);
      }
      if (childRun.dotted_order?.startsWith(run.dotted_order ?? "") && childRun.id !== run.id) {
        if (!(childRun.parent_run_id in treemap)) {
          treemap[childRun.parent_run_id] = [];
        }
        treemap[childRun.parent_run_id].push(childRun);
        runs[childRun.id] = childRun;
      }
    }
    run.child_runs = treemap[run.id] || [];
    for (const runId in treemap) {
      if (runId !== run.id) {
        runs[runId].child_runs = treemap[runId];
      }
    }
    return run;
  }
  /**
   * List runs from the LangSmith server.
   * @param projectId - The ID of the project to filter by.
   * @param projectName - The name of the project to filter by.
   * @param parentRunId - The ID of the parent run to filter by.
   * @param traceId - The ID of the trace to filter by.
   * @param referenceExampleId - The ID of the reference example to filter by.
   * @param startTime - The start time to filter by.
   * @param isRoot - Indicates whether to only return root runs.
   * @param runType - The run type to filter by.
   * @param error - Indicates whether to filter by error runs.
   * @param id - The ID of the run to filter by.
   * @param query - The query string to filter by.
   * @param filter - The filter string to apply to the run spans.
   * @param traceFilter - The filter string to apply on the root run of the trace.
   * @param treeFilter - The filter string to apply on other runs in the trace.
   * @param limit - The maximum number of runs to retrieve.
   * @returns {AsyncIterable<Run>} - The runs.
   *
   * @example
   * // List all runs in a project
   * const projectRuns = client.listRuns({ projectName: "<your_project>" });
   *
   * @example
   * // List LLM and Chat runs in the last 24 hours
   * const todaysLLMRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   start_time: new Date(Date.now() - 24 * 60 * 60 * 1000),
   *   run_type: "llm",
   * });
   *
   * @example
   * // List traces in a project
   * const rootRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   execution_order: 1,
   * });
   *
   * @example
   * // List runs without errors
   * const correctRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   error: false,
   * });
   *
   * @example
   * // List runs by run ID
   * const runIds = [
   *   "a36092d2-4ad5-4fb4-9c0d-0dba9a2ed836",
   *   "9398e6be-964f-4aa4-8ae9-ad78cd4b7074",
   * ];
   * const selectedRuns = client.listRuns({ run_ids: runIds });
   *
   * @example
   * // List all "chain" type runs that took more than 10 seconds and had `total_tokens` greater than 5000
   * const chainRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   filter: 'and(eq(run_type, "chain"), gt(latency, 10), gt(total_tokens, 5000))',
   * });
   *
   * @example
   * // List all runs called "extractor" whose root of the trace was assigned feedback "user_score" score of 1
   * const goodExtractorRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   filter: 'eq(name, "extractor")',
   *   traceFilter: 'and(eq(feedback_key, "user_score"), eq(feedback_score, 1))',
   * });
   *
   * @example
   * // List all runs that started after a specific timestamp and either have "error" not equal to null or a "Correctness" feedback score equal to 0
   * const complexRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   filter: 'and(gt(start_time, "2023-07-15T12:34:56Z"), or(neq(error, null), and(eq(feedback_key, "Correctness"), eq(feedback_score, 0.0))))',
   * });
   *
   * @example
   * // List all runs where `tags` include "experimental" or "beta" and `latency` is greater than 2 seconds
   * const taggedRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   filter: 'and(or(has(tags, "experimental"), has(tags, "beta")), gt(latency, 2))',
   * });
   */
  async *listRuns(props) {
    const { projectId, projectName, parentRunId, traceId, referenceExampleId, startTime, executionOrder, isRoot, runType, error, id, query, filter, traceFilter, treeFilter, limit, select, order } = props;
    let projectIds = [];
    if (projectId) {
      projectIds = Array.isArray(projectId) ? projectId : [projectId];
    }
    if (projectName) {
      const projectNames = Array.isArray(projectName) ? projectName : [projectName];
      const projectIds_ = await Promise.all(projectNames.map((name) => this.readProject({ projectName: name }).then((project) => project.id)));
      projectIds.push(...projectIds_);
    }
    const default_select = [
      "app_path",
      "completion_cost",
      "completion_tokens",
      "dotted_order",
      "end_time",
      "error",
      "events",
      "extra",
      "feedback_stats",
      "first_token_time",
      "id",
      "inputs",
      "name",
      "outputs",
      "parent_run_id",
      "parent_run_ids",
      "prompt_cost",
      "prompt_tokens",
      "reference_example_id",
      "run_type",
      "session_id",
      "start_time",
      "status",
      "tags",
      "total_cost",
      "total_tokens",
      "trace_id"
    ];
    const body = {
      session: projectIds.length ? projectIds : null,
      run_type: runType,
      reference_example: referenceExampleId,
      query,
      filter,
      trace_filter: traceFilter,
      tree_filter: treeFilter,
      execution_order: executionOrder,
      parent_run: parentRunId,
      start_time: startTime ? startTime.toISOString() : null,
      error,
      id,
      limit,
      trace: traceId,
      select: select ? select : default_select,
      is_root: isRoot,
      order
    };
    let runsYielded = 0;
    for await (const runs of this._getCursorPaginatedList("/runs/query", body)) {
      if (limit) {
        if (runsYielded >= limit) {
          break;
        }
        if (runs.length + runsYielded > limit) {
          const newRuns = runs.slice(0, limit - runsYielded);
          yield* newRuns;
          break;
        }
        runsYielded += runs.length;
        yield* runs;
      } else {
        yield* runs;
      }
    }
  }
  async *listGroupRuns(props) {
    const { projectId, projectName, groupBy, filter, startTime, endTime, limit, offset } = props;
    const sessionId = projectId || (await this.readProject({ projectName })).id;
    const baseBody = {
      session_id: sessionId,
      group_by: groupBy,
      filter,
      start_time: startTime ? startTime.toISOString() : null,
      end_time: endTime ? endTime.toISOString() : null,
      limit: Number(limit) || 100
    };
    let currentOffset = Number(offset) || 0;
    const path = "/runs/group";
    const url = `${this.apiUrl}${path}`;
    while (true) {
      const currentBody = {
        ...baseBody,
        offset: currentOffset
      };
      const filteredPayload = Object.fromEntries(Object.entries(currentBody).filter(([_, value]) => value !== void 0));
      const response = await this.caller.call(_getFetchImplementation(), url, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        body: JSON.stringify(filteredPayload),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, `Failed to fetch ${path}`);
      const items = await response.json();
      const { groups, total } = items;
      if (groups.length === 0) {
        break;
      }
      for (const thread of groups) {
        yield thread;
      }
      currentOffset += groups.length;
      if (currentOffset >= total) {
        break;
      }
    }
  }
  async getRunStats({ id, trace, parentRun, runType, projectNames, projectIds, referenceExampleIds, startTime, endTime, error, query, filter, traceFilter, treeFilter, isRoot, dataSourceType }) {
    let projectIds_ = projectIds || [];
    if (projectNames) {
      projectIds_ = [
        ...projectIds || [],
        ...await Promise.all(projectNames.map((name) => this.readProject({ projectName: name }).then((project) => project.id)))
      ];
    }
    const payload = {
      id,
      trace,
      parent_run: parentRun,
      run_type: runType,
      session: projectIds_,
      reference_example: referenceExampleIds,
      start_time: startTime,
      end_time: endTime,
      error,
      query,
      filter,
      trace_filter: traceFilter,
      tree_filter: treeFilter,
      is_root: isRoot,
      data_source_type: dataSourceType
    };
    const filteredPayload = Object.fromEntries(Object.entries(payload).filter(([_, value]) => value !== void 0));
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/runs/stats`, {
      method: "POST",
      headers: this.headers,
      body: JSON.stringify(filteredPayload),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    const result = await response.json();
    return result;
  }
  async shareRun(runId, { shareId } = {}) {
    const data = {
      run_id: runId,
      share_token: shareId || v4_default2()
    };
    assertUuid(runId);
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/runs/${runId}/share`, {
      method: "PUT",
      headers: this.headers,
      body: JSON.stringify(data),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    const result = await response.json();
    if (result === null || !("share_token" in result)) {
      throw new Error("Invalid response from server");
    }
    return `${this.getHostUrl()}/public/${result["share_token"]}/r`;
  }
  async unshareRun(runId) {
    assertUuid(runId);
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/runs/${runId}/share`, {
      method: "DELETE",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "unshare run", true);
  }
  async readRunSharedLink(runId) {
    assertUuid(runId);
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/runs/${runId}/share`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    const result = await response.json();
    if (result === null || !("share_token" in result)) {
      return void 0;
    }
    return `${this.getHostUrl()}/public/${result["share_token"]}/r`;
  }
  async listSharedRuns(shareToken, { runIds } = {}) {
    const queryParams = new URLSearchParams({
      share_token: shareToken
    });
    if (runIds !== void 0) {
      for (const runId of runIds) {
        queryParams.append("id", runId);
      }
    }
    assertUuid(shareToken);
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/public/${shareToken}/runs${queryParams}`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    const runs = await response.json();
    return runs;
  }
  async readDatasetSharedSchema(datasetId, datasetName) {
    if (!datasetId && !datasetName) {
      throw new Error("Either datasetId or datasetName must be given");
    }
    if (!datasetId) {
      const dataset = await this.readDataset({ datasetName });
      datasetId = dataset.id;
    }
    assertUuid(datasetId);
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets/${datasetId}/share`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    const shareSchema = await response.json();
    shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;
    return shareSchema;
  }
  async shareDataset(datasetId, datasetName) {
    if (!datasetId && !datasetName) {
      throw new Error("Either datasetId or datasetName must be given");
    }
    if (!datasetId) {
      const dataset = await this.readDataset({ datasetName });
      datasetId = dataset.id;
    }
    const data = {
      dataset_id: datasetId
    };
    assertUuid(datasetId);
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets/${datasetId}/share`, {
      method: "PUT",
      headers: this.headers,
      body: JSON.stringify(data),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    const shareSchema = await response.json();
    shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;
    return shareSchema;
  }
  async unshareDataset(datasetId) {
    assertUuid(datasetId);
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets/${datasetId}/share`, {
      method: "DELETE",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "unshare dataset", true);
  }
  async readSharedDataset(shareToken) {
    assertUuid(shareToken);
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/public/${shareToken}/datasets`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    const dataset = await response.json();
    return dataset;
  }
  /**
   * Get shared examples.
   *
   * @param {string} shareToken The share token to get examples for. A share token is the UUID (or LangSmith URL, including UUID) generated when explicitly marking an example as public.
   * @param {Object} [options] Additional options for listing the examples.
   * @param {string[] | undefined} [options.exampleIds] A list of example IDs to filter by.
   * @returns {Promise<Example[]>} The shared examples.
   */
  async listSharedExamples(shareToken, options) {
    const params = {};
    if (options?.exampleIds) {
      params.id = options.exampleIds;
    }
    const urlParams = new URLSearchParams();
    Object.entries(params).forEach(([key, value]) => {
      if (Array.isArray(value)) {
        value.forEach((v) => urlParams.append(key, v));
      } else {
        urlParams.append(key, value);
      }
    });
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/public/${shareToken}/examples?${urlParams.toString()}`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    const result = await response.json();
    if (!response.ok) {
      if ("detail" in result) {
        throw new Error(`Failed to list shared examples.
Status: ${response.status}
Message: ${Array.isArray(result.detail) ? result.detail.join("\n") : "Unspecified error"}`);
      }
      throw new Error(`Failed to list shared examples: ${response.status} ${response.statusText}`);
    }
    return result.map((example) => ({
      ...example,
      _hostUrl: this.getHostUrl()
    }));
  }
  async createProject({ projectName, description = null, metadata = null, upsert = false, projectExtra = null, referenceDatasetId = null }) {
    const upsert_ = upsert ? `?upsert=true` : "";
    const endpoint = `${this.apiUrl}/sessions${upsert_}`;
    const extra = projectExtra || {};
    if (metadata) {
      extra["metadata"] = metadata;
    }
    const body = {
      name: projectName,
      extra,
      description
    };
    if (referenceDatasetId !== null) {
      body["reference_dataset_id"] = referenceDatasetId;
    }
    const response = await this.caller.call(_getFetchImplementation(this.debug), endpoint, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(body),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "create project");
    const result = await response.json();
    return result;
  }
  async updateProject(projectId, { name = null, description = null, metadata = null, projectExtra = null, endTime = null }) {
    const endpoint = `${this.apiUrl}/sessions/${projectId}`;
    let extra = projectExtra;
    if (metadata) {
      extra = { ...extra || {}, metadata };
    }
    const body = {
      name,
      extra,
      description,
      end_time: endTime ? new Date(endTime).toISOString() : null
    };
    const response = await this.caller.call(_getFetchImplementation(this.debug), endpoint, {
      method: "PATCH",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(body),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "update project");
    const result = await response.json();
    return result;
  }
  async hasProject({ projectId, projectName }) {
    let path = "/sessions";
    const params = new URLSearchParams();
    if (projectId !== void 0 && projectName !== void 0) {
      throw new Error("Must provide either projectName or projectId, not both");
    } else if (projectId !== void 0) {
      assertUuid(projectId);
      path += `/${projectId}`;
    } else if (projectName !== void 0) {
      params.append("name", projectName);
    } else {
      throw new Error("Must provide projectName or projectId");
    }
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}${path}?${params}`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    try {
      const result = await response.json();
      if (!response.ok) {
        return false;
      }
      if (Array.isArray(result)) {
        return result.length > 0;
      }
      return true;
    } catch (e) {
      return false;
    }
  }
  async readProject({ projectId, projectName, includeStats }) {
    let path = "/sessions";
    const params = new URLSearchParams();
    if (projectId !== void 0 && projectName !== void 0) {
      throw new Error("Must provide either projectName or projectId, not both");
    } else if (projectId !== void 0) {
      assertUuid(projectId);
      path += `/${projectId}`;
    } else if (projectName !== void 0) {
      params.append("name", projectName);
    } else {
      throw new Error("Must provide projectName or projectId");
    }
    if (includeStats !== void 0) {
      params.append("include_stats", includeStats.toString());
    }
    const response = await this._get(path, params);
    let result;
    if (Array.isArray(response)) {
      if (response.length === 0) {
        throw new Error(`Project[id=${projectId}, name=${projectName}] not found`);
      }
      result = response[0];
    } else {
      result = response;
    }
    return result;
  }
  async getProjectUrl({ projectId, projectName }) {
    if (projectId === void 0 && projectName === void 0) {
      throw new Error("Must provide either projectName or projectId");
    }
    const project = await this.readProject({ projectId, projectName });
    const tenantId = await this._getTenantId();
    return `${this.getHostUrl()}/o/${tenantId}/projects/p/${project.id}`;
  }
  async getDatasetUrl({ datasetId, datasetName }) {
    if (datasetId === void 0 && datasetName === void 0) {
      throw new Error("Must provide either datasetName or datasetId");
    }
    const dataset = await this.readDataset({ datasetId, datasetName });
    const tenantId = await this._getTenantId();
    return `${this.getHostUrl()}/o/${tenantId}/datasets/${dataset.id}`;
  }
  async _getTenantId() {
    if (this._tenantId !== null) {
      return this._tenantId;
    }
    const queryParams = new URLSearchParams({ limit: "1" });
    for await (const projects of this._getPaginated("/sessions", queryParams)) {
      this._tenantId = projects[0].tenant_id;
      return projects[0].tenant_id;
    }
    throw new Error("No projects found to resolve tenant.");
  }
  async *listProjects({ projectIds, name, nameContains, referenceDatasetId, referenceDatasetName, referenceFree, metadata } = {}) {
    const params = new URLSearchParams();
    if (projectIds !== void 0) {
      for (const projectId of projectIds) {
        params.append("id", projectId);
      }
    }
    if (name !== void 0) {
      params.append("name", name);
    }
    if (nameContains !== void 0) {
      params.append("name_contains", nameContains);
    }
    if (referenceDatasetId !== void 0) {
      params.append("reference_dataset", referenceDatasetId);
    } else if (referenceDatasetName !== void 0) {
      const dataset = await this.readDataset({
        datasetName: referenceDatasetName
      });
      params.append("reference_dataset", dataset.id);
    }
    if (referenceFree !== void 0) {
      params.append("reference_free", referenceFree.toString());
    }
    if (metadata !== void 0) {
      params.append("metadata", JSON.stringify(metadata));
    }
    for await (const projects of this._getPaginated("/sessions", params)) {
      yield* projects;
    }
  }
  async deleteProject({ projectId, projectName }) {
    let projectId_;
    if (projectId === void 0 && projectName === void 0) {
      throw new Error("Must provide projectName or projectId");
    } else if (projectId !== void 0 && projectName !== void 0) {
      throw new Error("Must provide either projectName or projectId, not both");
    } else if (projectId === void 0) {
      projectId_ = (await this.readProject({ projectName })).id;
    } else {
      projectId_ = projectId;
    }
    assertUuid(projectId_);
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/sessions/${projectId_}`, {
      method: "DELETE",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, `delete session ${projectId_} (${projectName})`, true);
  }
  async uploadCsv({ csvFile, fileName, inputKeys, outputKeys, description, dataType, name }) {
    const url = `${this.apiUrl}/datasets/upload`;
    const formData = new FormData();
    formData.append("file", csvFile, fileName);
    inputKeys.forEach((key) => {
      formData.append("input_keys", key);
    });
    outputKeys.forEach((key) => {
      formData.append("output_keys", key);
    });
    if (description) {
      formData.append("description", description);
    }
    if (dataType) {
      formData.append("data_type", dataType);
    }
    if (name) {
      formData.append("name", name);
    }
    const response = await this.caller.call(_getFetchImplementation(this.debug), url, {
      method: "POST",
      headers: this.headers,
      body: formData,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "upload CSV");
    const result = await response.json();
    return result;
  }
  async createDataset(name, { description, dataType, inputsSchema, outputsSchema, metadata } = {}) {
    const body = {
      name,
      description,
      extra: metadata ? { metadata } : void 0
    };
    if (dataType) {
      body.data_type = dataType;
    }
    if (inputsSchema) {
      body.inputs_schema_definition = inputsSchema;
    }
    if (outputsSchema) {
      body.outputs_schema_definition = outputsSchema;
    }
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets`, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(body),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "create dataset");
    const result = await response.json();
    return result;
  }
  async readDataset({ datasetId, datasetName }) {
    let path = "/datasets";
    const params = new URLSearchParams({ limit: "1" });
    if (datasetId !== void 0 && datasetName !== void 0) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (datasetId !== void 0) {
      assertUuid(datasetId);
      path += `/${datasetId}`;
    } else if (datasetName !== void 0) {
      params.append("name", datasetName);
    } else {
      throw new Error("Must provide datasetName or datasetId");
    }
    const response = await this._get(path, params);
    let result;
    if (Array.isArray(response)) {
      if (response.length === 0) {
        throw new Error(`Dataset[id=${datasetId}, name=${datasetName}] not found`);
      }
      result = response[0];
    } else {
      result = response;
    }
    return result;
  }
  async hasDataset({ datasetId, datasetName }) {
    try {
      await this.readDataset({ datasetId, datasetName });
      return true;
    } catch (e) {
      if (
        // eslint-disable-next-line no-instanceof/no-instanceof
        e instanceof Error && e.message.toLocaleLowerCase().includes("not found")
      ) {
        return false;
      }
      throw e;
    }
  }
  async diffDatasetVersions({ datasetId, datasetName, fromVersion, toVersion }) {
    let datasetId_ = datasetId;
    if (datasetId_ === void 0 && datasetName === void 0) {
      throw new Error("Must provide either datasetName or datasetId");
    } else if (datasetId_ !== void 0 && datasetName !== void 0) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (datasetId_ === void 0) {
      const dataset = await this.readDataset({ datasetName });
      datasetId_ = dataset.id;
    }
    const urlParams = new URLSearchParams({
      from_version: typeof fromVersion === "string" ? fromVersion : fromVersion.toISOString(),
      to_version: typeof toVersion === "string" ? toVersion : toVersion.toISOString()
    });
    const response = await this._get(`/datasets/${datasetId_}/versions/diff`, urlParams);
    return response;
  }
  async readDatasetOpenaiFinetuning({ datasetId, datasetName }) {
    const path = "/datasets";
    if (datasetId !== void 0) {
    } else if (datasetName !== void 0) {
      datasetId = (await this.readDataset({ datasetName })).id;
    } else {
      throw new Error("Must provide either datasetName or datasetId");
    }
    const response = await this._getResponse(`${path}/${datasetId}/openai_ft`);
    const datasetText = await response.text();
    const dataset = datasetText.trim().split("\n").map((line) => JSON.parse(line));
    return dataset;
  }
  async *listDatasets({ limit = 100, offset = 0, datasetIds, datasetName, datasetNameContains, metadata } = {}) {
    const path = "/datasets";
    const params = new URLSearchParams({
      limit: limit.toString(),
      offset: offset.toString()
    });
    if (datasetIds !== void 0) {
      for (const id_ of datasetIds) {
        params.append("id", id_);
      }
    }
    if (datasetName !== void 0) {
      params.append("name", datasetName);
    }
    if (datasetNameContains !== void 0) {
      params.append("name_contains", datasetNameContains);
    }
    if (metadata !== void 0) {
      params.append("metadata", JSON.stringify(metadata));
    }
    for await (const datasets of this._getPaginated(path, params)) {
      yield* datasets;
    }
  }
  /**
   * Update a dataset
   * @param props The dataset details to update
   * @returns The updated dataset
   */
  async updateDataset(props) {
    const { datasetId, datasetName, ...update } = props;
    if (!datasetId && !datasetName) {
      throw new Error("Must provide either datasetName or datasetId");
    }
    const _datasetId = datasetId ?? (await this.readDataset({ datasetName })).id;
    assertUuid(_datasetId);
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets/${_datasetId}`, {
      method: "PATCH",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(update),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "update dataset");
    return await response.json();
  }
  /**
   * Updates a tag on a dataset.
   *
   * If the tag is already assigned to a different version of this dataset,
   * the tag will be moved to the new version. The as_of parameter is used to
   * determine which version of the dataset to apply the new tags to.
   *
   * It must be an exact version of the dataset to succeed. You can
   * use the "readDatasetVersion" method to find the exact version
   * to apply the tags to.
   * @param params.datasetId The ID of the dataset to update. Must be provided if "datasetName" is not provided.
   * @param params.datasetName The name of the dataset to update. Must be provided if "datasetId" is not provided.
   * @param params.asOf The timestamp of the dataset to apply the new tags to.
   * @param params.tag The new tag to apply to the dataset.
   */
  async updateDatasetTag(props) {
    const { datasetId, datasetName, asOf, tag } = props;
    if (!datasetId && !datasetName) {
      throw new Error("Must provide either datasetName or datasetId");
    }
    const _datasetId = datasetId ?? (await this.readDataset({ datasetName })).id;
    assertUuid(_datasetId);
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets/${_datasetId}/tags`, {
      method: "PUT",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify({
        as_of: typeof asOf === "string" ? asOf : asOf.toISOString(),
        tag
      }),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "update dataset tags");
  }
  async deleteDataset({ datasetId, datasetName }) {
    let path = "/datasets";
    let datasetId_ = datasetId;
    if (datasetId !== void 0 && datasetName !== void 0) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (datasetName !== void 0) {
      const dataset = await this.readDataset({ datasetName });
      datasetId_ = dataset.id;
    }
    if (datasetId_ !== void 0) {
      assertUuid(datasetId_);
      path += `/${datasetId_}`;
    } else {
      throw new Error("Must provide datasetName or datasetId");
    }
    const response = await this.caller.call(_getFetchImplementation(this.debug), this.apiUrl + path, {
      method: "DELETE",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, `delete ${path}`);
    await response.json();
  }
  async indexDataset({ datasetId, datasetName, tag }) {
    let datasetId_ = datasetId;
    if (!datasetId_ && !datasetName) {
      throw new Error("Must provide either datasetName or datasetId");
    } else if (datasetId_ && datasetName) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (!datasetId_) {
      const dataset = await this.readDataset({ datasetName });
      datasetId_ = dataset.id;
    }
    assertUuid(datasetId_);
    const data = {
      tag
    };
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets/${datasetId_}/index`, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(data),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "index dataset");
    await response.json();
  }
  /**
   * Lets you run a similarity search query on a dataset.
   *
   * Requires the dataset to be indexed. Please see the `indexDataset` method to set up indexing.
   *
   * @param inputs      The input on which to run the similarity search. Must have the
   *                    same schema as the dataset.
   *
   * @param datasetId   The dataset to search for similar examples.
   *
   * @param limit       The maximum number of examples to return. Will return the top `limit` most
   *                    similar examples in order of most similar to least similar. If no similar
   *                    examples are found, random examples will be returned.
   *
   * @param filter      A filter string to apply to the search. Only examples will be returned that
   *                    match the filter string. Some examples of filters
   *
   *                    - eq(metadata.mykey, "value")
   *                    - and(neq(metadata.my.nested.key, "value"), neq(metadata.mykey, "value"))
   *                    - or(eq(metadata.mykey, "value"), eq(metadata.mykey, "othervalue"))
   *
   * @returns           A list of similar examples.
   *
   *
   * @example
   * dataset_id = "123e4567-e89b-12d3-a456-426614174000"
   * inputs = {"text": "How many people live in Berlin?"}
   * limit = 5
   * examples = await client.similarExamples(inputs, dataset_id, limit)
   */
  async similarExamples(inputs, datasetId, limit, { filter } = {}) {
    const data = {
      limit,
      inputs
    };
    if (filter !== void 0) {
      data["filter"] = filter;
    }
    assertUuid(datasetId);
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets/${datasetId}/search`, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(data),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "fetch similar examples");
    const result = await response.json();
    return result["examples"];
  }
  async createExample(inputsOrUpdate, outputs, options) {
    if (isExampleCreate(inputsOrUpdate)) {
      if (outputs !== void 0 || options !== void 0) {
        throw new Error("Cannot provide outputs or options when using ExampleCreate object");
      }
    }
    let datasetId_ = outputs ? options?.datasetId : inputsOrUpdate.dataset_id;
    const datasetName_ = outputs ? options?.datasetName : inputsOrUpdate.dataset_name;
    if (datasetId_ === void 0 && datasetName_ === void 0) {
      throw new Error("Must provide either datasetName or datasetId");
    } else if (datasetId_ !== void 0 && datasetName_ !== void 0) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (datasetId_ === void 0) {
      const dataset = await this.readDataset({ datasetName: datasetName_ });
      datasetId_ = dataset.id;
    }
    const createdAt_ = (outputs ? options?.createdAt : inputsOrUpdate.created_at) || /* @__PURE__ */ new Date();
    let data;
    if (!isExampleCreate(inputsOrUpdate)) {
      data = {
        inputs: inputsOrUpdate,
        outputs,
        created_at: createdAt_?.toISOString(),
        id: options?.exampleId,
        metadata: options?.metadata,
        split: options?.split,
        source_run_id: options?.sourceRunId,
        use_source_run_io: options?.useSourceRunIO,
        use_source_run_attachments: options?.useSourceRunAttachments,
        attachments: options?.attachments
      };
    } else {
      data = inputsOrUpdate;
    }
    const response = await this._uploadExamplesMultipart(datasetId_, [data]);
    const example = await this.readExample(response.example_ids?.[0] ?? v4_default2());
    return example;
  }
  async createExamples(propsOrUploads) {
    if (Array.isArray(propsOrUploads)) {
      if (propsOrUploads.length === 0) {
        return [];
      }
      const uploads = propsOrUploads;
      let datasetId_2 = uploads[0].dataset_id;
      const datasetName_2 = uploads[0].dataset_name;
      if (datasetId_2 === void 0 && datasetName_2 === void 0) {
        throw new Error("Must provide either datasetName or datasetId");
      } else if (datasetId_2 !== void 0 && datasetName_2 !== void 0) {
        throw new Error("Must provide either datasetName or datasetId, not both");
      } else if (datasetId_2 === void 0) {
        const dataset = await this.readDataset({ datasetName: datasetName_2 });
        datasetId_2 = dataset.id;
      }
      const response2 = await this._uploadExamplesMultipart(datasetId_2, uploads);
      const examples2 = await Promise.all(response2.example_ids.map((id) => this.readExample(id)));
      return examples2;
    }
    const { inputs, outputs, metadata, splits, sourceRunIds, useSourceRunIOs, useSourceRunAttachments, attachments, exampleIds, datasetId, datasetName } = propsOrUploads;
    if (inputs === void 0) {
      throw new Error("Must provide inputs when using legacy parameters");
    }
    let datasetId_ = datasetId;
    const datasetName_ = datasetName;
    if (datasetId_ === void 0 && datasetName_ === void 0) {
      throw new Error("Must provide either datasetName or datasetId");
    } else if (datasetId_ !== void 0 && datasetName_ !== void 0) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (datasetId_ === void 0) {
      const dataset = await this.readDataset({ datasetName: datasetName_ });
      datasetId_ = dataset.id;
    }
    const formattedExamples = inputs.map((input, idx) => {
      return {
        dataset_id: datasetId_,
        inputs: input,
        outputs: outputs?.[idx],
        metadata: metadata?.[idx],
        split: splits?.[idx],
        id: exampleIds?.[idx],
        attachments: attachments?.[idx],
        source_run_id: sourceRunIds?.[idx],
        use_source_run_io: useSourceRunIOs?.[idx],
        use_source_run_attachments: useSourceRunAttachments?.[idx]
      };
    });
    const response = await this._uploadExamplesMultipart(datasetId_, formattedExamples);
    const examples = await Promise.all(response.example_ids.map((id) => this.readExample(id)));
    return examples;
  }
  async createLLMExample(input, generation, options) {
    return this.createExample({ input }, { output: generation }, options);
  }
  async createChatExample(input, generations, options) {
    const finalInput = input.map((message) => {
      if (isLangChainMessage(message)) {
        return convertLangChainMessageToExample(message);
      }
      return message;
    });
    const finalOutput = isLangChainMessage(generations) ? convertLangChainMessageToExample(generations) : generations;
    return this.createExample({ input: finalInput }, { output: finalOutput }, options);
  }
  async readExample(exampleId) {
    assertUuid(exampleId);
    const path = `/examples/${exampleId}`;
    const rawExample = await this._get(path);
    const { attachment_urls, ...rest } = rawExample;
    const example = rest;
    if (attachment_urls) {
      example.attachments = Object.entries(attachment_urls).reduce((acc, [key, value]) => {
        acc[key.slice("attachment.".length)] = {
          presigned_url: value.presigned_url,
          mime_type: value.mime_type
        };
        return acc;
      }, {});
    }
    return example;
  }
  async *listExamples({ datasetId, datasetName, exampleIds, asOf, splits, inlineS3Urls, metadata, limit, offset, filter, includeAttachments } = {}) {
    let datasetId_;
    if (datasetId !== void 0 && datasetName !== void 0) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (datasetId !== void 0) {
      datasetId_ = datasetId;
    } else if (datasetName !== void 0) {
      const dataset = await this.readDataset({ datasetName });
      datasetId_ = dataset.id;
    } else {
      throw new Error("Must provide a datasetName or datasetId");
    }
    const params = new URLSearchParams({ dataset: datasetId_ });
    const dataset_version = asOf ? typeof asOf === "string" ? asOf : asOf?.toISOString() : void 0;
    if (dataset_version) {
      params.append("as_of", dataset_version);
    }
    const inlineS3Urls_ = inlineS3Urls ?? true;
    params.append("inline_s3_urls", inlineS3Urls_.toString());
    if (exampleIds !== void 0) {
      for (const id_ of exampleIds) {
        params.append("id", id_);
      }
    }
    if (splits !== void 0) {
      for (const split of splits) {
        params.append("splits", split);
      }
    }
    if (metadata !== void 0) {
      const serializedMetadata = JSON.stringify(metadata);
      params.append("metadata", serializedMetadata);
    }
    if (limit !== void 0) {
      params.append("limit", limit.toString());
    }
    if (offset !== void 0) {
      params.append("offset", offset.toString());
    }
    if (filter !== void 0) {
      params.append("filter", filter);
    }
    if (includeAttachments === true) {
      ["attachment_urls", "outputs", "metadata"].forEach((field) => params.append("select", field));
    }
    let i = 0;
    for await (const rawExamples of this._getPaginated("/examples", params)) {
      for (const rawExample of rawExamples) {
        const { attachment_urls, ...rest } = rawExample;
        const example = rest;
        if (attachment_urls) {
          example.attachments = Object.entries(attachment_urls).reduce((acc, [key, value]) => {
            acc[key.slice("attachment.".length)] = {
              presigned_url: value.presigned_url,
              mime_type: value.mime_type || void 0
            };
            return acc;
          }, {});
        }
        yield example;
        i++;
      }
      if (limit !== void 0 && i >= limit) {
        break;
      }
    }
  }
  async deleteExample(exampleId) {
    assertUuid(exampleId);
    const path = `/examples/${exampleId}`;
    const response = await this.caller.call(_getFetchImplementation(this.debug), this.apiUrl + path, {
      method: "DELETE",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, `delete ${path}`);
    await response.json();
  }
  async updateExample(exampleIdOrUpdate, update) {
    let exampleId;
    if (update) {
      exampleId = exampleIdOrUpdate;
    } else {
      exampleId = exampleIdOrUpdate.id;
    }
    assertUuid(exampleId);
    let updateToUse;
    if (update) {
      updateToUse = { id: exampleId, ...update };
    } else {
      updateToUse = exampleIdOrUpdate;
    }
    let datasetId;
    if (updateToUse.dataset_id !== void 0) {
      datasetId = updateToUse.dataset_id;
    } else {
      const example = await this.readExample(exampleId);
      datasetId = example.dataset_id;
    }
    return this._updateExamplesMultipart(datasetId, [updateToUse]);
  }
  async updateExamples(update) {
    let datasetId;
    if (update[0].dataset_id === void 0) {
      const example = await this.readExample(update[0].id);
      datasetId = example.dataset_id;
    } else {
      datasetId = update[0].dataset_id;
    }
    return this._updateExamplesMultipart(datasetId, update);
  }
  /**
   * Get dataset version by closest date or exact tag.
   *
   * Use this to resolve the nearest version to a given timestamp or for a given tag.
   *
   * @param options The options for getting the dataset version
   * @param options.datasetId The ID of the dataset
   * @param options.datasetName The name of the dataset
   * @param options.asOf The timestamp of the dataset to retrieve
   * @param options.tag The tag of the dataset to retrieve
   * @returns The dataset version
   */
  async readDatasetVersion({ datasetId, datasetName, asOf, tag }) {
    let resolvedDatasetId;
    if (!datasetId) {
      const dataset = await this.readDataset({ datasetName });
      resolvedDatasetId = dataset.id;
    } else {
      resolvedDatasetId = datasetId;
    }
    assertUuid(resolvedDatasetId);
    if (asOf && tag || !asOf && !tag) {
      throw new Error("Exactly one of asOf and tag must be specified.");
    }
    const params = new URLSearchParams();
    if (asOf !== void 0) {
      params.append("as_of", typeof asOf === "string" ? asOf : asOf.toISOString());
    }
    if (tag !== void 0) {
      params.append("tag", tag);
    }
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets/${resolvedDatasetId}/version?${params.toString()}`, {
      method: "GET",
      headers: { ...this.headers },
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "read dataset version");
    return await response.json();
  }
  async listDatasetSplits({ datasetId, datasetName, asOf }) {
    let datasetId_;
    if (datasetId === void 0 && datasetName === void 0) {
      throw new Error("Must provide dataset name or ID");
    } else if (datasetId !== void 0 && datasetName !== void 0) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (datasetId === void 0) {
      const dataset = await this.readDataset({ datasetName });
      datasetId_ = dataset.id;
    } else {
      datasetId_ = datasetId;
    }
    assertUuid(datasetId_);
    const params = new URLSearchParams();
    const dataset_version = asOf ? typeof asOf === "string" ? asOf : asOf?.toISOString() : void 0;
    if (dataset_version) {
      params.append("as_of", dataset_version);
    }
    const response = await this._get(`/datasets/${datasetId_}/splits`, params);
    return response;
  }
  async updateDatasetSplits({ datasetId, datasetName, splitName, exampleIds, remove = false }) {
    let datasetId_;
    if (datasetId === void 0 && datasetName === void 0) {
      throw new Error("Must provide dataset name or ID");
    } else if (datasetId !== void 0 && datasetName !== void 0) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (datasetId === void 0) {
      const dataset = await this.readDataset({ datasetName });
      datasetId_ = dataset.id;
    } else {
      datasetId_ = datasetId;
    }
    assertUuid(datasetId_);
    const data = {
      split_name: splitName,
      examples: exampleIds.map((id) => {
        assertUuid(id);
        return id;
      }),
      remove
    };
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets/${datasetId_}/splits`, {
      method: "PUT",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(data),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "update dataset splits", true);
  }
  /**
   * @deprecated This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.
   */
  async evaluateRun(run, evaluator, { sourceInfo, loadChildRuns, referenceExample } = { loadChildRuns: false }) {
    warnOnce("This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.");
    let run_;
    if (typeof run === "string") {
      run_ = await this.readRun(run, { loadChildRuns });
    } else if (typeof run === "object" && "id" in run) {
      run_ = run;
    } else {
      throw new Error(`Invalid run type: ${typeof run}`);
    }
    if (run_.reference_example_id !== null && run_.reference_example_id !== void 0) {
      referenceExample = await this.readExample(run_.reference_example_id);
    }
    const feedbackResult = await evaluator.evaluateRun(run_, referenceExample);
    const [_, feedbacks] = await this._logEvaluationFeedback(feedbackResult, run_, sourceInfo);
    return feedbacks[0];
  }
  async createFeedback(runId, key, { score, value, correction, comment, sourceInfo, feedbackSourceType = "api", sourceRunId, feedbackId, feedbackConfig, projectId, comparativeExperimentId }) {
    if (!runId && !projectId) {
      throw new Error("One of runId or projectId must be provided");
    }
    if (runId && projectId) {
      throw new Error("Only one of runId or projectId can be provided");
    }
    const feedback_source = {
      type: feedbackSourceType ?? "api",
      metadata: sourceInfo ?? {}
    };
    if (sourceRunId !== void 0 && feedback_source?.metadata !== void 0 && !feedback_source.metadata["__run"]) {
      feedback_source.metadata["__run"] = { run_id: sourceRunId };
    }
    if (feedback_source?.metadata !== void 0 && feedback_source.metadata["__run"]?.run_id !== void 0) {
      assertUuid(feedback_source.metadata["__run"].run_id);
    }
    const feedback = {
      id: feedbackId ?? v4_default2(),
      run_id: runId,
      key,
      score: _formatFeedbackScore(score),
      value,
      correction,
      comment,
      feedback_source,
      comparative_experiment_id: comparativeExperimentId,
      feedbackConfig,
      session_id: projectId
    };
    const url = `${this.apiUrl}/feedback`;
    const response = await this.caller.call(_getFetchImplementation(this.debug), url, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(feedback),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "create feedback", true);
    return feedback;
  }
  async updateFeedback(feedbackId, { score, value, correction, comment }) {
    const feedbackUpdate = {};
    if (score !== void 0 && score !== null) {
      feedbackUpdate["score"] = _formatFeedbackScore(score);
    }
    if (value !== void 0 && value !== null) {
      feedbackUpdate["value"] = value;
    }
    if (correction !== void 0 && correction !== null) {
      feedbackUpdate["correction"] = correction;
    }
    if (comment !== void 0 && comment !== null) {
      feedbackUpdate["comment"] = comment;
    }
    assertUuid(feedbackId);
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/feedback/${feedbackId}`, {
      method: "PATCH",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(feedbackUpdate),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "update feedback", true);
  }
  async readFeedback(feedbackId) {
    assertUuid(feedbackId);
    const path = `/feedback/${feedbackId}`;
    const response = await this._get(path);
    return response;
  }
  async deleteFeedback(feedbackId) {
    assertUuid(feedbackId);
    const path = `/feedback/${feedbackId}`;
    const response = await this.caller.call(_getFetchImplementation(this.debug), this.apiUrl + path, {
      method: "DELETE",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, `delete ${path}`);
    await response.json();
  }
  async *listFeedback({ runIds, feedbackKeys, feedbackSourceTypes } = {}) {
    const queryParams = new URLSearchParams();
    if (runIds) {
      queryParams.append("run", runIds.join(","));
    }
    if (feedbackKeys) {
      for (const key of feedbackKeys) {
        queryParams.append("key", key);
      }
    }
    if (feedbackSourceTypes) {
      for (const type of feedbackSourceTypes) {
        queryParams.append("source", type);
      }
    }
    for await (const feedbacks of this._getPaginated("/feedback", queryParams)) {
      yield* feedbacks;
    }
  }
  /**
   * Creates a presigned feedback token and URL.
   *
   * The token can be used to authorize feedback metrics without
   * needing an API key. This is useful for giving browser-based
   * applications the ability to submit feedback without needing
   * to expose an API key.
   *
   * @param runId The ID of the run.
   * @param feedbackKey The feedback key.
   * @param options Additional options for the token.
   * @param options.expiration The expiration time for the token.
   *
   * @returns A promise that resolves to a FeedbackIngestToken.
   */
  async createPresignedFeedbackToken(runId, feedbackKey, { expiration, feedbackConfig } = {}) {
    const body = {
      run_id: runId,
      feedback_key: feedbackKey,
      feedback_config: feedbackConfig
    };
    if (expiration) {
      if (typeof expiration === "string") {
        body["expires_at"] = expiration;
      } else if (expiration?.hours || expiration?.minutes || expiration?.days) {
        body["expires_in"] = expiration;
      }
    } else {
      body["expires_in"] = {
        hours: 3
      };
    }
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/feedback/tokens`, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(body),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    const result = await response.json();
    return result;
  }
  async createComparativeExperiment({ name, experimentIds, referenceDatasetId, createdAt, description, metadata, id }) {
    if (experimentIds.length === 0) {
      throw new Error("At least one experiment is required");
    }
    if (!referenceDatasetId) {
      referenceDatasetId = (await this.readProject({
        projectId: experimentIds[0]
      })).reference_dataset_id;
    }
    if (!referenceDatasetId == null) {
      throw new Error("A reference dataset is required");
    }
    const body = {
      id,
      name,
      experiment_ids: experimentIds,
      reference_dataset_id: referenceDatasetId,
      description,
      created_at: (createdAt ?? /* @__PURE__ */ new Date())?.toISOString(),
      extra: {}
    };
    if (metadata)
      body.extra["metadata"] = metadata;
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets/comparative`, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(body),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    return await response.json();
  }
  /**
   * Retrieves a list of presigned feedback tokens for a given run ID.
   * @param runId The ID of the run.
   * @returns An async iterable of FeedbackIngestToken objects.
   */
  async *listPresignedFeedbackTokens(runId) {
    assertUuid(runId);
    const params = new URLSearchParams({ run_id: runId });
    for await (const tokens of this._getPaginated("/feedback/tokens", params)) {
      yield* tokens;
    }
  }
  _selectEvalResults(results) {
    let results_;
    if ("results" in results) {
      results_ = results.results;
    } else if (Array.isArray(results)) {
      results_ = results;
    } else {
      results_ = [results];
    }
    return results_;
  }
  async _logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {
    const evalResults = this._selectEvalResults(evaluatorResponse);
    const feedbacks = [];
    for (const res of evalResults) {
      let sourceInfo_ = sourceInfo || {};
      if (res.evaluatorInfo) {
        sourceInfo_ = { ...res.evaluatorInfo, ...sourceInfo_ };
      }
      let runId_ = null;
      if (res.targetRunId) {
        runId_ = res.targetRunId;
      } else if (run) {
        runId_ = run.id;
      }
      feedbacks.push(await this.createFeedback(runId_, res.key, {
        score: res.score,
        value: res.value,
        comment: res.comment,
        correction: res.correction,
        sourceInfo: sourceInfo_,
        sourceRunId: res.sourceRunId,
        feedbackConfig: res.feedbackConfig,
        feedbackSourceType: "model"
      }));
    }
    return [evalResults, feedbacks];
  }
  async logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {
    const [results] = await this._logEvaluationFeedback(evaluatorResponse, run, sourceInfo);
    return results;
  }
  /**
   * API for managing annotation queues
   */
  /**
   * List the annotation queues on the LangSmith API.
   * @param options - The options for listing annotation queues
   * @param options.queueIds - The IDs of the queues to filter by
   * @param options.name - The name of the queue to filter by
   * @param options.nameContains - The substring that the queue name should contain
   * @param options.limit - The maximum number of queues to return
   * @returns An iterator of AnnotationQueue objects
   */
  async *listAnnotationQueues(options = {}) {
    const { queueIds, name, nameContains, limit } = options;
    const params = new URLSearchParams();
    if (queueIds) {
      queueIds.forEach((id, i) => {
        assertUuid(id, `queueIds[${i}]`);
        params.append("ids", id);
      });
    }
    if (name)
      params.append("name", name);
    if (nameContains)
      params.append("name_contains", nameContains);
    params.append("limit", (limit !== void 0 ? Math.min(limit, 100) : 100).toString());
    let count = 0;
    for await (const queues of this._getPaginated("/annotation-queues", params)) {
      yield* queues;
      count++;
      if (limit !== void 0 && count >= limit)
        break;
    }
  }
  /**
   * Create an annotation queue on the LangSmith API.
   * @param options - The options for creating an annotation queue
   * @param options.name - The name of the annotation queue
   * @param options.description - The description of the annotation queue
   * @param options.queueId - The ID of the annotation queue
   * @returns The created AnnotationQueue object
   */
  async createAnnotationQueue(options) {
    const { name, description, queueId, rubricInstructions } = options;
    const body = {
      name,
      description,
      id: queueId || v4_default2(),
      rubric_instructions: rubricInstructions
    };
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/annotation-queues`, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(Object.fromEntries(Object.entries(body).filter(([_, v]) => v !== void 0))),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "create annotation queue");
    const data = await response.json();
    return data;
  }
  /**
   * Read an annotation queue with the specified queue ID.
   * @param queueId - The ID of the annotation queue to read
   * @returns The AnnotationQueueWithDetails object
   */
  async readAnnotationQueue(queueId) {
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "read annotation queue");
    const data = await response.json();
    return data;
  }
  /**
   * Update an annotation queue with the specified queue ID.
   * @param queueId - The ID of the annotation queue to update
   * @param options - The options for updating the annotation queue
   * @param options.name - The new name for the annotation queue
   * @param options.description - The new description for the annotation queue
   */
  async updateAnnotationQueue(queueId, options) {
    const { name, description, rubricInstructions } = options;
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}`, {
      method: "PATCH",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify({
        name,
        description,
        rubric_instructions: rubricInstructions
      }),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "update annotation queue");
  }
  /**
   * Delete an annotation queue with the specified queue ID.
   * @param queueId - The ID of the annotation queue to delete
   */
  async deleteAnnotationQueue(queueId) {
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}`, {
      method: "DELETE",
      headers: { ...this.headers, Accept: "application/json" },
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "delete annotation queue");
  }
  /**
   * Add runs to an annotation queue with the specified queue ID.
   * @param queueId - The ID of the annotation queue
   * @param runIds - The IDs of the runs to be added to the annotation queue
   */
  async addRunsToAnnotationQueue(queueId, runIds) {
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}/runs`, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(runIds.map((id, i) => assertUuid(id, `runIds[${i}]`).toString())),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "add runs to annotation queue");
  }
  /**
   * Get a run from an annotation queue at the specified index.
   * @param queueId - The ID of the annotation queue
   * @param index - The index of the run to retrieve
   * @returns A Promise that resolves to a RunWithAnnotationQueueInfo object
   * @throws {Error} If the run is not found at the given index or for other API-related errors
   */
  async getRunFromAnnotationQueue(queueId, index) {
    const baseUrl = `/annotation-queues/${assertUuid(queueId, "queueId")}/run`;
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}${baseUrl}/${index}`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "get run from annotation queue");
    return await response.json();
  }
  /**
   * Delete a run from an an annotation queue.
   * @param queueId - The ID of the annotation queue to delete the run from
   * @param queueRunId - The ID of the run to delete from the annotation queue
   */
  async deleteRunFromAnnotationQueue(queueId, queueRunId) {
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}/runs/${assertUuid(queueRunId, "queueRunId")}`, {
      method: "DELETE",
      headers: { ...this.headers, Accept: "application/json" },
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "delete run from annotation queue");
  }
  /**
   * Get the size of an annotation queue.
   * @param queueId - The ID of the annotation queue
   */
  async getSizeFromAnnotationQueue(queueId) {
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}/size`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "get size from annotation queue");
    return await response.json();
  }
  async _currentTenantIsOwner(owner) {
    const settings = await this._getSettings();
    return owner == "-" || settings.tenant_handle === owner;
  }
  async _ownerConflictError(action, owner) {
    const settings = await this._getSettings();
    return new Error(`Cannot ${action} for another tenant.

      Current tenant: ${settings.tenant_handle}

      Requested tenant: ${owner}`);
  }
  async _getLatestCommitHash(promptOwnerAndName) {
    const res = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/commits/${promptOwnerAndName}/?limit=${1}&offset=${0}`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    const json2 = await res.json();
    if (!res.ok) {
      const detail = typeof json2.detail === "string" ? json2.detail : JSON.stringify(json2.detail);
      const error = new Error(`Error ${res.status}: ${res.statusText}
${detail}`);
      error.statusCode = res.status;
      throw error;
    }
    if (json2.commits.length === 0) {
      return void 0;
    }
    return json2.commits[0].commit_hash;
  }
  async _likeOrUnlikePrompt(promptIdentifier, like) {
    const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/likes/${owner}/${promptName}`, {
      method: "POST",
      body: JSON.stringify({ like }),
      headers: { ...this.headers, "Content-Type": "application/json" },
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, `${like ? "like" : "unlike"} prompt`);
    return await response.json();
  }
  async _getPromptUrl(promptIdentifier) {
    const [owner, promptName, commitHash] = parsePromptIdentifier(promptIdentifier);
    if (!await this._currentTenantIsOwner(owner)) {
      if (commitHash !== "latest") {
        return `${this.getHostUrl()}/hub/${owner}/${promptName}/${commitHash.substring(0, 8)}`;
      } else {
        return `${this.getHostUrl()}/hub/${owner}/${promptName}`;
      }
    } else {
      const settings = await this._getSettings();
      if (commitHash !== "latest") {
        return `${this.getHostUrl()}/prompts/${promptName}/${commitHash.substring(0, 8)}?organizationId=${settings.id}`;
      } else {
        return `${this.getHostUrl()}/prompts/${promptName}?organizationId=${settings.id}`;
      }
    }
  }
  async promptExists(promptIdentifier) {
    const prompt = await this.getPrompt(promptIdentifier);
    return !!prompt;
  }
  async likePrompt(promptIdentifier) {
    return this._likeOrUnlikePrompt(promptIdentifier, true);
  }
  async unlikePrompt(promptIdentifier) {
    return this._likeOrUnlikePrompt(promptIdentifier, false);
  }
  async *listCommits(promptOwnerAndName) {
    for await (const commits of this._getPaginated(`/commits/${promptOwnerAndName}/`, new URLSearchParams(), (res) => res.commits)) {
      yield* commits;
    }
  }
  async *listPrompts(options) {
    const params = new URLSearchParams();
    params.append("sort_field", options?.sortField ?? "updated_at");
    params.append("sort_direction", "desc");
    params.append("is_archived", (!!options?.isArchived).toString());
    if (options?.isPublic !== void 0) {
      params.append("is_public", options.isPublic.toString());
    }
    if (options?.query) {
      params.append("query", options.query);
    }
    for await (const prompts of this._getPaginated("/repos", params, (res) => res.repos)) {
      yield* prompts;
    }
  }
  async getPrompt(promptIdentifier) {
    const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/repos/${owner}/${promptName}`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    if (response.status === 404) {
      return null;
    }
    await raiseForStatus(response, "get prompt");
    const result = await response.json();
    if (result.repo) {
      return result.repo;
    } else {
      return null;
    }
  }
  async createPrompt(promptIdentifier, options) {
    const settings = await this._getSettings();
    if (options?.isPublic && !settings.tenant_handle) {
      throw new Error(`Cannot create a public prompt without first

        creating a LangChain Hub handle. 
        You can add a handle by creating a public prompt at:

        https://smith.langchain.com/prompts`);
    }
    const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);
    if (!await this._currentTenantIsOwner(owner)) {
      throw await this._ownerConflictError("create a prompt", owner);
    }
    const data = {
      repo_handle: promptName,
      ...options?.description && { description: options.description },
      ...options?.readme && { readme: options.readme },
      ...options?.tags && { tags: options.tags },
      is_public: !!options?.isPublic
    };
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/repos/`, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(data),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "create prompt");
    const { repo } = await response.json();
    return repo;
  }
  async createCommit(promptIdentifier, object, options) {
    if (!await this.promptExists(promptIdentifier)) {
      throw new Error("Prompt does not exist, you must create it first.");
    }
    const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);
    const resolvedParentCommitHash = options?.parentCommitHash === "latest" || !options?.parentCommitHash ? await this._getLatestCommitHash(`${owner}/${promptName}`) : options?.parentCommitHash;
    const payload = {
      manifest: JSON.parse(JSON.stringify(object)),
      parent_commit: resolvedParentCommitHash
    };
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/commits/${owner}/${promptName}`, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(payload),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "create commit");
    const result = await response.json();
    return this._getPromptUrl(`${owner}/${promptName}${result.commit_hash ? `:${result.commit_hash}` : ""}`);
  }
  /**
   * Update examples with attachments using multipart form data.
   * @param updates List of ExampleUpdateWithAttachments objects to upsert
   * @returns Promise with the update response
   */
  async updateExamplesMultipart(datasetId, updates = []) {
    return this._updateExamplesMultipart(datasetId, updates);
  }
  async _updateExamplesMultipart(datasetId, updates = []) {
    if (!await this._getMultiPartSupport()) {
      throw new Error("Your LangSmith deployment does not allow using the multipart examples endpoint, please upgrade your deployment to the latest version.");
    }
    const formData = new FormData();
    for (const example of updates) {
      const exampleId = example.id;
      const exampleBody = {
        ...example.metadata && { metadata: example.metadata },
        ...example.split && { split: example.split }
      };
      const stringifiedExample = serialize(exampleBody, `Serializing body for example with id: ${exampleId}`);
      const exampleBlob = new Blob([stringifiedExample], {
        type: "application/json"
      });
      formData.append(exampleId, exampleBlob);
      if (example.inputs) {
        const stringifiedInputs = serialize(example.inputs, `Serializing inputs for example with id: ${exampleId}`);
        const inputsBlob = new Blob([stringifiedInputs], {
          type: "application/json"
        });
        formData.append(`${exampleId}.inputs`, inputsBlob);
      }
      if (example.outputs) {
        const stringifiedOutputs = serialize(example.outputs, `Serializing outputs whle updating example with id: ${exampleId}`);
        const outputsBlob = new Blob([stringifiedOutputs], {
          type: "application/json"
        });
        formData.append(`${exampleId}.outputs`, outputsBlob);
      }
      if (example.attachments) {
        for (const [name, attachment] of Object.entries(example.attachments)) {
          let mimeType;
          let data;
          if (Array.isArray(attachment)) {
            [mimeType, data] = attachment;
          } else {
            mimeType = attachment.mimeType;
            data = attachment.data;
          }
          const attachmentBlob = new Blob([data], {
            type: `${mimeType}; length=${data.byteLength}`
          });
          formData.append(`${exampleId}.attachment.${name}`, attachmentBlob);
        }
      }
      if (example.attachments_operations) {
        const stringifiedAttachmentsOperations = serialize(example.attachments_operations, `Serializing attachments while updating example with id: ${exampleId}`);
        const attachmentsOperationsBlob = new Blob([stringifiedAttachmentsOperations], {
          type: "application/json"
        });
        formData.append(`${exampleId}.attachments_operations`, attachmentsOperationsBlob);
      }
    }
    const datasetIdToUse = datasetId ?? updates[0]?.dataset_id;
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/v1/platform/datasets/${datasetIdToUse}/examples`, {
      method: "PATCH",
      headers: this.headers,
      body: formData
    });
    const result = await response.json();
    return result;
  }
  /**
   * Upload examples with attachments using multipart form data.
   * @param uploads List of ExampleUploadWithAttachments objects to upload
   * @returns Promise with the upload response
   * @deprecated This method is deprecated and will be removed in future LangSmith versions, please use `createExamples` instead
   */
  async uploadExamplesMultipart(datasetId, uploads = []) {
    return this._uploadExamplesMultipart(datasetId, uploads);
  }
  async _uploadExamplesMultipart(datasetId, uploads = []) {
    if (!await this._getMultiPartSupport()) {
      throw new Error("Your LangSmith deployment does not allow using the multipart examples endpoint, please upgrade your deployment to the latest version.");
    }
    const formData = new FormData();
    for (const example of uploads) {
      const exampleId = (example.id ?? v4_default2()).toString();
      const exampleBody = {
        created_at: example.created_at,
        ...example.metadata && { metadata: example.metadata },
        ...example.split && { split: example.split },
        ...example.source_run_id && { source_run_id: example.source_run_id },
        ...example.use_source_run_io && {
          use_source_run_io: example.use_source_run_io
        },
        ...example.use_source_run_attachments && {
          use_source_run_attachments: example.use_source_run_attachments
        }
      };
      const stringifiedExample = serialize(exampleBody, `Serializing body for uploaded example with id: ${exampleId}`);
      const exampleBlob = new Blob([stringifiedExample], {
        type: "application/json"
      });
      formData.append(exampleId, exampleBlob);
      if (example.inputs) {
        const stringifiedInputs = serialize(example.inputs, `Serializing inputs for uploaded example with id: ${exampleId}`);
        const inputsBlob = new Blob([stringifiedInputs], {
          type: "application/json"
        });
        formData.append(`${exampleId}.inputs`, inputsBlob);
      }
      if (example.outputs) {
        const stringifiedOutputs = serialize(example.outputs, `Serializing outputs for uploaded example with id: ${exampleId}`);
        const outputsBlob = new Blob([stringifiedOutputs], {
          type: "application/json"
        });
        formData.append(`${exampleId}.outputs`, outputsBlob);
      }
      if (example.attachments) {
        for (const [name, attachment] of Object.entries(example.attachments)) {
          let mimeType;
          let data;
          if (Array.isArray(attachment)) {
            [mimeType, data] = attachment;
          } else {
            mimeType = attachment.mimeType;
            data = attachment.data;
          }
          const attachmentBlob = new Blob([data], {
            type: `${mimeType}; length=${data.byteLength}`
          });
          formData.append(`${exampleId}.attachment.${name}`, attachmentBlob);
        }
      }
    }
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/v1/platform/datasets/${datasetId}/examples`, {
      method: "POST",
      headers: this.headers,
      body: formData
    });
    await raiseForStatus(response, "upload examples");
    const result = await response.json();
    return result;
  }
  async updatePrompt(promptIdentifier, options) {
    if (!await this.promptExists(promptIdentifier)) {
      throw new Error("Prompt does not exist, you must create it first.");
    }
    const [owner, promptName] = parsePromptIdentifier(promptIdentifier);
    if (!await this._currentTenantIsOwner(owner)) {
      throw await this._ownerConflictError("update a prompt", owner);
    }
    const payload = {};
    if (options?.description !== void 0)
      payload.description = options.description;
    if (options?.readme !== void 0)
      payload.readme = options.readme;
    if (options?.tags !== void 0)
      payload.tags = options.tags;
    if (options?.isPublic !== void 0)
      payload.is_public = options.isPublic;
    if (options?.isArchived !== void 0)
      payload.is_archived = options.isArchived;
    if (Object.keys(payload).length === 0) {
      throw new Error("No valid update options provided");
    }
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/repos/${owner}/${promptName}`, {
      method: "PATCH",
      body: JSON.stringify(payload),
      headers: {
        ...this.headers,
        "Content-Type": "application/json"
      },
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "update prompt");
    return response.json();
  }
  async deletePrompt(promptIdentifier) {
    if (!await this.promptExists(promptIdentifier)) {
      throw new Error("Prompt does not exist, you must create it first.");
    }
    const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);
    if (!await this._currentTenantIsOwner(owner)) {
      throw await this._ownerConflictError("delete a prompt", owner);
    }
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/repos/${owner}/${promptName}`, {
      method: "DELETE",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    return await response.json();
  }
  async pullPromptCommit(promptIdentifier, options) {
    const [owner, promptName, commitHash] = parsePromptIdentifier(promptIdentifier);
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/commits/${owner}/${promptName}/${commitHash}${options?.includeModel ? "?include_model=true" : ""}`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "pull prompt commit");
    const result = await response.json();
    return {
      owner,
      repo: promptName,
      commit_hash: result.commit_hash,
      manifest: result.manifest,
      examples: result.examples
    };
  }
  /**
   * This method should not be used directly, use `import { pull } from "langchain/hub"` instead.
   * Using this method directly returns the JSON string of the prompt rather than a LangChain object.
   * @private
   */
  async _pullPrompt(promptIdentifier, options) {
    const promptObject = await this.pullPromptCommit(promptIdentifier, {
      includeModel: options?.includeModel
    });
    const prompt = JSON.stringify(promptObject.manifest);
    return prompt;
  }
  async pushPrompt(promptIdentifier, options) {
    if (await this.promptExists(promptIdentifier)) {
      if (options && Object.keys(options).some((key) => key !== "object")) {
        await this.updatePrompt(promptIdentifier, {
          description: options?.description,
          readme: options?.readme,
          tags: options?.tags,
          isPublic: options?.isPublic
        });
      }
    } else {
      await this.createPrompt(promptIdentifier, {
        description: options?.description,
        readme: options?.readme,
        tags: options?.tags,
        isPublic: options?.isPublic
      });
    }
    if (!options?.object) {
      return await this._getPromptUrl(promptIdentifier);
    }
    const url = await this.createCommit(promptIdentifier, options?.object, {
      parentCommitHash: options?.parentCommitHash
    });
    return url;
  }
  /**
     * Clone a public dataset to your own langsmith tenant.
     * This operation is idempotent. If you already have a dataset with the given name,
     * this function will do nothing.
  
     * @param {string} tokenOrUrl The token of the public dataset to clone.
     * @param {Object} [options] Additional options for cloning the dataset.
     * @param {string} [options.sourceApiUrl] The URL of the langsmith server where the data is hosted. Defaults to the API URL of your current client.
     * @param {string} [options.datasetName] The name of the dataset to create in your tenant. Defaults to the name of the public dataset.
     * @returns {Promise<void>}
     */
  async clonePublicDataset(tokenOrUrl, options = {}) {
    const { sourceApiUrl = this.apiUrl, datasetName } = options;
    const [parsedApiUrl, tokenUuid] = this.parseTokenOrUrl(tokenOrUrl, sourceApiUrl);
    const sourceClient = new _Client({
      apiUrl: parsedApiUrl,
      // Placeholder API key not needed anymore in most cases, but
      // some private deployments may have API key-based rate limiting
      // that would cause this to fail if we provide no value.
      apiKey: "placeholder"
    });
    const ds = await sourceClient.readSharedDataset(tokenUuid);
    const finalDatasetName = datasetName || ds.name;
    try {
      if (await this.hasDataset({ datasetId: finalDatasetName })) {
        console.log(`Dataset ${finalDatasetName} already exists in your tenant. Skipping.`);
        return;
      }
    } catch (_) {
    }
    const examples = await sourceClient.listSharedExamples(tokenUuid);
    const dataset = await this.createDataset(finalDatasetName, {
      description: ds.description,
      dataType: ds.data_type || "kv",
      inputsSchema: ds.inputs_schema_definition ?? void 0,
      outputsSchema: ds.outputs_schema_definition ?? void 0
    });
    try {
      await this.createExamples({
        inputs: examples.map((e) => e.inputs),
        outputs: examples.flatMap((e) => e.outputs ? [e.outputs] : []),
        datasetId: dataset.id
      });
    } catch (e) {
      console.error(`An error occurred while creating dataset ${finalDatasetName}. You should delete it manually.`);
      throw e;
    }
  }
  parseTokenOrUrl(urlOrToken, apiUrl, numParts = 2, kind = "dataset") {
    try {
      assertUuid(urlOrToken);
      return [apiUrl, urlOrToken];
    } catch (_) {
    }
    try {
      const parsedUrl = new URL(urlOrToken);
      const pathParts = parsedUrl.pathname.split("/").filter((part) => part !== "");
      if (pathParts.length >= numParts) {
        const tokenUuid = pathParts[pathParts.length - numParts];
        return [apiUrl, tokenUuid];
      } else {
        throw new Error(`Invalid public ${kind} URL: ${urlOrToken}`);
      }
    } catch (error) {
      throw new Error(`Invalid public ${kind} URL or token: ${urlOrToken}`);
    }
  }
  /**
   * Awaits all pending trace batches. Useful for environments where
   * you need to be sure that all tracing requests finish before execution ends,
   * such as serverless environments.
   *
   * @example
   * ```
   * import { Client } from "langsmith";
   *
   * const client = new Client();
   *
   * try {
   *   // Tracing happens here
   *   ...
   * } finally {
   *   await client.awaitPendingTraceBatches();
   * }
   * ```
   *
   * @returns A promise that resolves once all currently pending traces have sent.
   */
  async awaitPendingTraceBatches() {
    if (this.manualFlushMode) {
      console.warn("[WARNING]: When tracing in manual flush mode, you must call `await client.flush()` manually to submit trace batches.");
      return Promise.resolve();
    }
    await Promise.all([
      ...this.autoBatchQueue.items.map(({ itemPromise }) => itemPromise),
      this.batchIngestCaller.queue.onIdle()
    ]);
    if (this.langSmithToOTELTranslator !== void 0) {
      await getDefaultOTLPTracerComponents()?.DEFAULT_LANGSMITH_SPAN_PROCESSOR?.forceFlush();
    }
  }
};
function isExampleCreate(input) {
  return "dataset_id" in input || "dataset_name" in input;
}

// node_modules/langsmith/dist/env.js
var isTracingEnabled = (tracingEnabled) => {
  if (tracingEnabled !== void 0) {
    return tracingEnabled;
  }
  const envVars = ["TRACING_V2", "TRACING"];
  return !!envVars.find((envVar) => getLangSmithEnvironmentVariable(envVar) === "true");
};

// node_modules/langsmith/dist/singletons/constants.js
var _LC_CONTEXT_VARIABLES_KEY = Symbol.for("lc:context_variables");

// node_modules/langsmith/dist/run_trees.js
function stripNonAlphanumeric2(input) {
  return input.replace(/[-:.]/g, "");
}
function convertToDottedOrderFormat2(epoch, runId, executionOrder = 1) {
  const paddedOrder = executionOrder.toFixed(0).slice(0, 3).padStart(3, "0");
  return stripNonAlphanumeric2(`${new Date(epoch).toISOString().slice(0, -1)}${paddedOrder}Z`) + runId;
}
var Baggage = class _Baggage {
  constructor(metadata, tags, project_name, replicas) {
    Object.defineProperty(this, "metadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "tags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "project_name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "replicas", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.metadata = metadata;
    this.tags = tags;
    this.project_name = project_name;
    this.replicas = replicas;
  }
  static fromHeader(value) {
    const items = value.split(",");
    let metadata = {};
    let tags = [];
    let project_name;
    let replicas;
    for (const item of items) {
      const [key, uriValue] = item.split("=");
      const value2 = decodeURIComponent(uriValue);
      if (key === "langsmith-metadata") {
        metadata = JSON.parse(value2);
      } else if (key === "langsmith-tags") {
        tags = value2.split(",");
      } else if (key === "langsmith-project") {
        project_name = value2;
      } else if (key === "langsmith-replicas") {
        replicas = JSON.parse(value2);
      }
    }
    return new _Baggage(metadata, tags, project_name, replicas);
  }
  toHeader() {
    const items = [];
    if (this.metadata && Object.keys(this.metadata).length > 0) {
      items.push(`langsmith-metadata=${encodeURIComponent(JSON.stringify(this.metadata))}`);
    }
    if (this.tags && this.tags.length > 0) {
      items.push(`langsmith-tags=${encodeURIComponent(this.tags.join(","))}`);
    }
    if (this.project_name) {
      items.push(`langsmith-project=${encodeURIComponent(this.project_name)}`);
    }
    return items.join(",");
  }
};
var RunTree = class _RunTree {
  constructor(originalConfig) {
    Object.defineProperty(this, "id", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "run_type", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "project_name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "parent_run", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "child_runs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "start_time", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "end_time", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "extra", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "tags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "error", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "serialized", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "inputs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "outputs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "reference_example_id", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "client", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "events", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "trace_id", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "dotted_order", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "tracingEnabled", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "execution_order", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "child_execution_order", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "attachments", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "replicas", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    if (isRunTree(originalConfig)) {
      Object.assign(this, { ...originalConfig });
      return;
    }
    const defaultConfig = _RunTree.getDefaultConfig();
    const { metadata, ...config } = originalConfig;
    const client2 = config.client ?? _RunTree.getSharedClient();
    const dedupedMetadata = {
      ...metadata,
      ...config?.extra?.metadata
    };
    config.extra = { ...config.extra, metadata: dedupedMetadata };
    Object.assign(this, { ...defaultConfig, ...config, client: client2 });
    if (!this.trace_id) {
      if (this.parent_run) {
        this.trace_id = this.parent_run.trace_id ?? this.id;
      } else {
        this.trace_id = this.id;
      }
    }
    this.execution_order ??= 1;
    this.child_execution_order ??= 1;
    if (!this.dotted_order) {
      const currentDottedOrder = convertToDottedOrderFormat2(this.start_time, this.id, this.execution_order);
      if (this.parent_run) {
        this.dotted_order = this.parent_run.dotted_order + "." + currentDottedOrder;
      } else {
        this.dotted_order = currentDottedOrder;
      }
    }
  }
  set metadata(metadata) {
    this.extra = {
      ...this.extra,
      metadata: {
        ...this.extra?.metadata,
        ...metadata
      }
    };
  }
  get metadata() {
    return this.extra?.metadata;
  }
  static getDefaultConfig() {
    return {
      id: v4_default2(),
      run_type: "chain",
      project_name: getDefaultProjectName(),
      child_runs: [],
      api_url: getEnvironmentVariable2("LANGCHAIN_ENDPOINT") ?? "http://localhost:1984",
      api_key: getEnvironmentVariable2("LANGCHAIN_API_KEY"),
      caller_options: {},
      start_time: Date.now(),
      serialized: {},
      inputs: {},
      extra: {}
    };
  }
  static getSharedClient() {
    if (!_RunTree.sharedClient) {
      _RunTree.sharedClient = new Client();
    }
    return _RunTree.sharedClient;
  }
  createChild(config) {
    const child_execution_order = this.child_execution_order + 1;
    const child = new _RunTree({
      ...config,
      parent_run: this,
      project_name: this.project_name,
      replicas: this.replicas,
      client: this.client,
      tracingEnabled: this.tracingEnabled,
      execution_order: child_execution_order,
      child_execution_order
    });
    if (_LC_CONTEXT_VARIABLES_KEY in this) {
      child[_LC_CONTEXT_VARIABLES_KEY] = this[_LC_CONTEXT_VARIABLES_KEY];
    }
    const LC_CHILD = Symbol.for("lc:child_config");
    const presentConfig = config.extra?.[LC_CHILD] ?? this.extra[LC_CHILD];
    if (isRunnableConfigLike(presentConfig)) {
      const newConfig = { ...presentConfig };
      const callbacks = isCallbackManagerLike(newConfig.callbacks) ? newConfig.callbacks.copy?.() : void 0;
      if (callbacks) {
        Object.assign(callbacks, { _parentRunId: child.id });
        callbacks.handlers?.find(isLangChainTracerLike)?.updateFromRunTree?.(child);
        newConfig.callbacks = callbacks;
      }
      child.extra[LC_CHILD] = newConfig;
    }
    const visited = /* @__PURE__ */ new Set();
    let current = this;
    while (current != null && !visited.has(current.id)) {
      visited.add(current.id);
      current.child_execution_order = Math.max(current.child_execution_order, child_execution_order);
      current = current.parent_run;
    }
    this.child_runs.push(child);
    return child;
  }
  async end(outputs, error, endTime = Date.now(), metadata) {
    this.outputs = this.outputs ?? outputs;
    this.error = this.error ?? error;
    this.end_time = this.end_time ?? endTime;
    if (metadata && Object.keys(metadata).length > 0) {
      this.extra = this.extra ? { ...this.extra, metadata: { ...this.extra.metadata, ...metadata } } : { metadata };
    }
  }
  _convertToCreate(run, runtimeEnv, excludeChildRuns = true) {
    const runExtra = run.extra ?? {};
    if (runExtra?.runtime?.library === void 0) {
      if (!runExtra.runtime) {
        runExtra.runtime = {};
      }
      if (runtimeEnv) {
        for (const [k, v] of Object.entries(runtimeEnv)) {
          if (!runExtra.runtime[k]) {
            runExtra.runtime[k] = v;
          }
        }
      }
    }
    let child_runs;
    let parent_run_id;
    if (!excludeChildRuns) {
      child_runs = run.child_runs.map((child_run) => this._convertToCreate(child_run, runtimeEnv, excludeChildRuns));
      parent_run_id = void 0;
    } else {
      parent_run_id = run.parent_run?.id;
      child_runs = [];
    }
    return {
      id: run.id,
      name: run.name,
      start_time: run.start_time,
      end_time: run.end_time,
      run_type: run.run_type,
      reference_example_id: run.reference_example_id,
      extra: runExtra,
      serialized: run.serialized,
      error: run.error,
      inputs: run.inputs,
      outputs: run.outputs,
      session_name: run.project_name,
      child_runs,
      parent_run_id,
      trace_id: run.trace_id,
      dotted_order: run.dotted_order,
      tags: run.tags,
      attachments: run.attachments,
      events: run.events
    };
  }
  _remapForProject(projectName, runtimeEnv, excludeChildRuns = true) {
    const baseRun = this._convertToCreate(this, runtimeEnv, excludeChildRuns);
    if (projectName === this.project_name) {
      return baseRun;
    }
    const createRemappedId = (originalId) => {
      return v5_default(`${originalId}:${projectName}`, v5_default.DNS);
    };
    const newId = createRemappedId(baseRun.id);
    const newTraceId = baseRun.trace_id ? createRemappedId(baseRun.trace_id) : void 0;
    const newParentRunId = baseRun.parent_run_id ? createRemappedId(baseRun.parent_run_id) : void 0;
    let newDottedOrder;
    if (baseRun.dotted_order) {
      const segments = _parseDottedOrder(baseRun.dotted_order);
      const rebuilt = [];
      for (let i = 0; i < segments.length - 1; i++) {
        const [timestamp, segmentId] = segments[i];
        const remappedId = createRemappedId(segmentId);
        rebuilt.push(timestamp.toISOString().replace(/[-:]/g, "").replace(".", "") + remappedId);
      }
      const [lastTimestamp] = segments[segments.length - 1];
      rebuilt.push(lastTimestamp.toISOString().replace(/[-:]/g, "").replace(".", "") + newId);
      newDottedOrder = rebuilt.join(".");
    } else {
      newDottedOrder = void 0;
    }
    const remappedRun = {
      ...baseRun,
      id: newId,
      trace_id: newTraceId,
      parent_run_id: newParentRunId,
      dotted_order: newDottedOrder,
      session_name: projectName
    };
    return remappedRun;
  }
  async postRun(excludeChildRuns = true) {
    try {
      const runtimeEnv = getRuntimeEnvironment2();
      if (this.replicas && this.replicas.length > 0) {
        for (const [projectName] of this.replicas) {
          const runCreate = this._remapForProject(projectName, runtimeEnv, true);
          await this.client.createRun(runCreate);
        }
      } else {
        const runCreate = this._convertToCreate(this, runtimeEnv, excludeChildRuns);
        await this.client.createRun(runCreate);
      }
      if (!excludeChildRuns) {
        warnOnce("Posting with excludeChildRuns=false is deprecated and will be removed in a future version.");
        for (const childRun of this.child_runs) {
          await childRun.postRun(false);
        }
      }
    } catch (error) {
      console.error(`Error in postRun for run ${this.id}:`, error);
    }
  }
  async patchRun() {
    if (this.replicas && this.replicas.length > 0) {
      for (const [projectName, updates] of this.replicas) {
        const runData = this._remapForProject(projectName);
        await this.client.updateRun(runData.id, {
          inputs: runData.inputs,
          outputs: runData.outputs,
          error: runData.error,
          parent_run_id: runData.parent_run_id,
          session_name: runData.session_name,
          reference_example_id: runData.reference_example_id,
          end_time: runData.end_time,
          dotted_order: runData.dotted_order,
          trace_id: runData.trace_id,
          events: runData.events,
          tags: runData.tags,
          extra: runData.extra,
          attachments: this.attachments,
          ...updates
        });
      }
    } else {
      try {
        const runUpdate = {
          end_time: this.end_time,
          error: this.error,
          inputs: this.inputs,
          outputs: this.outputs,
          parent_run_id: this.parent_run?.id,
          reference_example_id: this.reference_example_id,
          extra: this.extra,
          events: this.events,
          dotted_order: this.dotted_order,
          trace_id: this.trace_id,
          tags: this.tags,
          attachments: this.attachments,
          session_name: this.project_name
        };
        await this.client.updateRun(this.id, runUpdate);
      } catch (error) {
        console.error(`Error in patchRun for run ${this.id}`, error);
      }
    }
  }
  toJSON() {
    return this._convertToCreate(this, void 0, false);
  }
  /**
   * Add an event to the run tree.
   * @param event - A single event or string to add
   */
  addEvent(event) {
    if (!this.events) {
      this.events = [];
    }
    if (typeof event === "string") {
      this.events.push({
        name: "event",
        time: (/* @__PURE__ */ new Date()).toISOString(),
        message: event
      });
    } else {
      this.events.push({
        ...event,
        time: event.time ?? (/* @__PURE__ */ new Date()).toISOString()
      });
    }
  }
  static fromRunnableConfig(parentConfig, props) {
    const callbackManager = parentConfig?.callbacks;
    let parentRun;
    let projectName;
    let client2;
    let tracingEnabled = isTracingEnabled();
    if (callbackManager) {
      const parentRunId = callbackManager?.getParentRunId?.() ?? "";
      const langChainTracer = callbackManager?.handlers?.find((handler) => handler?.name == "langchain_tracer");
      parentRun = langChainTracer?.getRun?.(parentRunId);
      projectName = langChainTracer?.projectName;
      client2 = langChainTracer?.client;
      tracingEnabled = tracingEnabled || !!langChainTracer;
    }
    if (!parentRun) {
      return new _RunTree({
        ...props,
        client: client2,
        tracingEnabled,
        project_name: projectName
      });
    }
    const parentRunTree = new _RunTree({
      name: parentRun.name,
      id: parentRun.id,
      trace_id: parentRun.trace_id,
      dotted_order: parentRun.dotted_order,
      client: client2,
      tracingEnabled,
      project_name: projectName,
      tags: [
        ...new Set((parentRun?.tags ?? []).concat(parentConfig?.tags ?? []))
      ],
      extra: {
        metadata: {
          ...parentRun?.extra?.metadata,
          ...parentConfig?.metadata
        }
      }
    });
    return parentRunTree.createChild(props);
  }
  static fromDottedOrder(dottedOrder) {
    return this.fromHeaders({ "langsmith-trace": dottedOrder });
  }
  static fromHeaders(headers, inheritArgs) {
    const rawHeaders = "get" in headers && typeof headers.get === "function" ? {
      "langsmith-trace": headers.get("langsmith-trace"),
      baggage: headers.get("baggage")
    } : headers;
    const headerTrace = rawHeaders["langsmith-trace"];
    if (!headerTrace || typeof headerTrace !== "string")
      return void 0;
    const parentDottedOrder = headerTrace.trim();
    const parsedDottedOrder = parentDottedOrder.split(".").map((part) => {
      const [strTime, uuid] = part.split("Z");
      return { strTime, time: Date.parse(strTime + "Z"), uuid };
    });
    const traceId = parsedDottedOrder[0].uuid;
    const config = {
      ...inheritArgs,
      name: inheritArgs?.["name"] ?? "parent",
      run_type: inheritArgs?.["run_type"] ?? "chain",
      start_time: inheritArgs?.["start_time"] ?? Date.now(),
      id: parsedDottedOrder.at(-1)?.uuid,
      trace_id: traceId,
      dotted_order: parentDottedOrder
    };
    if (rawHeaders["baggage"] && typeof rawHeaders["baggage"] === "string") {
      const baggage = Baggage.fromHeader(rawHeaders["baggage"]);
      config.metadata = baggage.metadata;
      config.tags = baggage.tags;
      config.project_name = baggage.project_name;
      config.replicas = baggage.replicas;
    }
    return new _RunTree(config);
  }
  toHeaders(headers) {
    const result = {
      "langsmith-trace": this.dotted_order,
      baggage: new Baggage(this.extra?.metadata, this.tags, this.project_name, this.replicas).toHeader()
    };
    if (headers) {
      for (const [key, value] of Object.entries(result)) {
        headers.set(key, value);
      }
    }
    return result;
  }
};
Object.defineProperty(RunTree, "sharedClient", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: null
});
function isRunTree(x) {
  return x !== void 0 && typeof x.createChild === "function" && typeof x.postRun === "function";
}
function isLangChainTracerLike(x) {
  return typeof x === "object" && x != null && typeof x.name === "string" && x.name === "langchain_tracer";
}
function containsLangChainTracerLike(x) {
  return Array.isArray(x) && x.some((callback) => isLangChainTracerLike(callback));
}
function isCallbackManagerLike(x) {
  return typeof x === "object" && x != null && Array.isArray(x.handlers);
}
function isRunnableConfigLike(x) {
  return x !== void 0 && typeof x.callbacks === "object" && // Callback manager with a langchain tracer
  (containsLangChainTracerLike(x.callbacks?.handlers) || // Or it's an array with a LangChainTracerLike object within it
  containsLangChainTracerLike(x.callbacks));
}
function _parseDottedOrder(dottedOrder) {
  const parts = dottedOrder.split(".");
  return parts.map((part) => {
    const timestampStr = part.slice(0, -36);
    const uuidStr = part.slice(-36);
    const year = parseInt(timestampStr.slice(0, 4));
    const month = parseInt(timestampStr.slice(4, 6)) - 1;
    const day = parseInt(timestampStr.slice(6, 8));
    const hour = parseInt(timestampStr.slice(9, 11));
    const minute = parseInt(timestampStr.slice(11, 13));
    const second = parseInt(timestampStr.slice(13, 15));
    const microsecond = parseInt(timestampStr.slice(15, 21));
    const timestamp = new Date(year, month, day, hour, minute, second, microsecond / 1e3);
    return [timestamp, uuidStr];
  });
}

// node_modules/@sap-ai-sdk/langchain/node_modules/@langchain/core/dist/singletons/tracer.js
var client;
var getDefaultLangChainClientSingleton = () => {
  if (client === void 0) {
    const clientParams = getEnvironmentVariable("LANGCHAIN_CALLBACKS_BACKGROUND") === "false" ? {
      // LangSmith has its own backgrounding system
      blockOnRootRunFinalization: true
    } : {};
    client = new Client(clientParams);
  }
  return client;
};

// node_modules/@sap-ai-sdk/langchain/node_modules/@langchain/core/dist/tracers/tracer_langchain.js
var LangChainTracer = class _LangChainTracer extends BaseTracer {
  constructor(fields = {}) {
    super(fields);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "langchain_tracer"
    });
    Object.defineProperty(this, "projectName", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "exampleId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "client", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    const { exampleId, projectName, client: client2 } = fields;
    this.projectName = projectName ?? getEnvironmentVariable("LANGCHAIN_PROJECT") ?? getEnvironmentVariable("LANGCHAIN_SESSION");
    this.exampleId = exampleId;
    this.client = client2 ?? getDefaultLangChainClientSingleton();
    const traceableTree = _LangChainTracer.getTraceableRunTree();
    if (traceableTree) {
      this.updateFromRunTree(traceableTree);
    }
  }
  async _convertToCreate(run, example_id = void 0) {
    return {
      ...run,
      extra: {
        ...run.extra,
        runtime: await getRuntimeEnvironment()
      },
      child_runs: void 0,
      session_name: this.projectName,
      reference_example_id: run.parent_run_id ? void 0 : example_id
    };
  }
  async persistRun(_run) {
  }
  async onRunCreate(run) {
    const persistedRun = await this._convertToCreate(run, this.exampleId);
    await this.client.createRun(persistedRun);
  }
  async onRunUpdate(run) {
    const runUpdate = {
      end_time: run.end_time,
      error: run.error,
      outputs: run.outputs,
      events: run.events,
      inputs: run.inputs,
      trace_id: run.trace_id,
      dotted_order: run.dotted_order,
      parent_run_id: run.parent_run_id,
      extra: run.extra
    };
    await this.client.updateRun(run.id, runUpdate);
  }
  getRun(id) {
    return this.runMap.get(id);
  }
  updateFromRunTree(runTree) {
    let rootRun = runTree;
    const visited = /* @__PURE__ */ new Set();
    while (rootRun.parent_run) {
      if (visited.has(rootRun.id))
        break;
      visited.add(rootRun.id);
      if (!rootRun.parent_run)
        break;
      rootRun = rootRun.parent_run;
    }
    visited.clear();
    const queue2 = [rootRun];
    while (queue2.length > 0) {
      const current = queue2.shift();
      if (!current || visited.has(current.id))
        continue;
      visited.add(current.id);
      this.runMap.set(current.id, current);
      if (current.child_runs) {
        queue2.push(...current.child_runs);
      }
    }
    this.client = runTree.client ?? this.client;
    this.projectName = runTree.project_name ?? this.projectName;
    this.exampleId = runTree.reference_example_id ?? this.exampleId;
  }
  convertToRunTree(id) {
    const runTreeMap = {};
    const runTreeList = [];
    for (const [id2, run] of this.runMap) {
      const runTree = new RunTree({
        ...run,
        child_runs: [],
        parent_run: void 0,
        // inherited properties
        client: this.client,
        project_name: this.projectName,
        reference_example_id: this.exampleId,
        tracingEnabled: true
      });
      runTreeMap[id2] = runTree;
      runTreeList.push([id2, run.dotted_order]);
    }
    runTreeList.sort((a, b) => {
      if (!a[1] || !b[1])
        return 0;
      return a[1].localeCompare(b[1]);
    });
    for (const [id2] of runTreeList) {
      const run = this.runMap.get(id2);
      const runTree = runTreeMap[id2];
      if (!run || !runTree)
        continue;
      if (run.parent_run_id) {
        const parentRunTree = runTreeMap[run.parent_run_id];
        if (parentRunTree) {
          parentRunTree.child_runs.push(runTree);
          runTree.parent_run = parentRunTree;
        }
      }
    }
    return runTreeMap[id];
  }
  static getTraceableRunTree() {
    try {
      return getCurrentRunTree();
    } catch {
      return void 0;
    }
  }
};

// node_modules/@sap-ai-sdk/langchain/node_modules/@langchain/core/dist/singletons/callbacks.js
var import_p_queue2 = __toESM(require_dist14(), 1);

// node_modules/@sap-ai-sdk/langchain/node_modules/@langchain/core/dist/singletons/async_local_storage/globals.js
var TRACING_ALS_KEY2 = Symbol.for("ls:tracing_async_local_storage");
var _CONTEXT_VARIABLES_KEY = Symbol.for("lc:context_variables");
var setGlobalAsyncLocalStorageInstance = (instance) => {
  globalThis[TRACING_ALS_KEY2] = instance;
};
var getGlobalAsyncLocalStorageInstance = () => {
  return globalThis[TRACING_ALS_KEY2];
};

// node_modules/@sap-ai-sdk/langchain/node_modules/@langchain/core/dist/singletons/callbacks.js
var queue;
function createQueue() {
  const PQueue = "default" in import_p_queue2.default ? import_p_queue2.default.default : import_p_queue2.default;
  return new PQueue({
    autoStart: true,
    concurrency: 1
  });
}
function getQueue() {
  if (typeof queue === "undefined") {
    queue = createQueue();
  }
  return queue;
}
async function consumeCallback(promiseFn, wait) {
  if (wait === true) {
    const asyncLocalStorageInstance = getGlobalAsyncLocalStorageInstance();
    if (asyncLocalStorageInstance !== void 0) {
      await asyncLocalStorageInstance.run(void 0, async () => promiseFn());
    } else {
      await promiseFn();
    }
  } else {
    queue = getQueue();
    void queue.add(async () => {
      const asyncLocalStorageInstance = getGlobalAsyncLocalStorageInstance();
      if (asyncLocalStorageInstance !== void 0) {
        await asyncLocalStorageInstance.run(void 0, async () => promiseFn());
      } else {
        await promiseFn();
      }
    });
  }
}

// node_modules/@sap-ai-sdk/langchain/node_modules/@langchain/core/dist/utils/callbacks.js
var isTracingEnabled2 = (tracingEnabled) => {
  if (tracingEnabled !== void 0) {
    return tracingEnabled;
  }
  const envVars = [
    "LANGSMITH_TRACING_V2",
    "LANGCHAIN_TRACING_V2",
    "LANGSMITH_TRACING",
    "LANGCHAIN_TRACING"
  ];
  return !!envVars.find((envVar) => getEnvironmentVariable(envVar) === "true");
};

// node_modules/@sap-ai-sdk/langchain/node_modules/@langchain/core/dist/singletons/async_local_storage/context.js
function getContextVariable(name) {
  const asyncLocalStorageInstance = getGlobalAsyncLocalStorageInstance();
  if (asyncLocalStorageInstance === void 0) {
    return void 0;
  }
  const runTree = asyncLocalStorageInstance.getStore();
  return runTree?.[_CONTEXT_VARIABLES_KEY]?.[name];
}
var LC_CONFIGURE_HOOKS_KEY = Symbol("lc:configure_hooks");
var _getConfigureHooks = () => getContextVariable(LC_CONFIGURE_HOOKS_KEY) || [];

// node_modules/@sap-ai-sdk/langchain/node_modules/@langchain/core/dist/callbacks/manager.js
var BaseCallbackManager = class {
  setHandler(handler) {
    return this.setHandlers([handler]);
  }
};
var BaseRunManager = class {
  constructor(runId, handlers, inheritableHandlers, tags, inheritableTags, metadata, inheritableMetadata, _parentRunId) {
    Object.defineProperty(this, "runId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: runId
    });
    Object.defineProperty(this, "handlers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: handlers
    });
    Object.defineProperty(this, "inheritableHandlers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: inheritableHandlers
    });
    Object.defineProperty(this, "tags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: tags
    });
    Object.defineProperty(this, "inheritableTags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: inheritableTags
    });
    Object.defineProperty(this, "metadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: metadata
    });
    Object.defineProperty(this, "inheritableMetadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: inheritableMetadata
    });
    Object.defineProperty(this, "_parentRunId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: _parentRunId
    });
  }
  get parentRunId() {
    return this._parentRunId;
  }
  async handleText(text) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      try {
        await handler.handleText?.(text, this.runId, this._parentRunId, this.tags);
      } catch (err) {
        const logFunction = handler.raiseError ? console.error : console.warn;
        logFunction(`Error in handler ${handler.constructor.name}, handleText: ${err}`);
        if (handler.raiseError) {
          throw err;
        }
      }
    }, handler.awaitHandlers)));
  }
  async handleCustomEvent(eventName, data, _runId, _tags, _metadata) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      try {
        await handler.handleCustomEvent?.(eventName, data, this.runId, this.tags, this.metadata);
      } catch (err) {
        const logFunction = handler.raiseError ? console.error : console.warn;
        logFunction(`Error in handler ${handler.constructor.name}, handleCustomEvent: ${err}`);
        if (handler.raiseError) {
          throw err;
        }
      }
    }, handler.awaitHandlers)));
  }
};
var CallbackManagerForRetrieverRun = class extends BaseRunManager {
  getChild(tag) {
    const manager = new CallbackManager(this.runId);
    manager.setHandlers(this.inheritableHandlers);
    manager.addTags(this.inheritableTags);
    manager.addMetadata(this.inheritableMetadata);
    if (tag) {
      manager.addTags([tag], false);
    }
    return manager;
  }
  async handleRetrieverEnd(documents) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      if (!handler.ignoreRetriever) {
        try {
          await handler.handleRetrieverEnd?.(documents, this.runId, this._parentRunId, this.tags);
        } catch (err) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleRetriever`);
          if (handler.raiseError) {
            throw err;
          }
        }
      }
    }, handler.awaitHandlers)));
  }
  async handleRetrieverError(err) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      if (!handler.ignoreRetriever) {
        try {
          await handler.handleRetrieverError?.(err, this.runId, this._parentRunId, this.tags);
        } catch (error) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleRetrieverError: ${error}`);
          if (handler.raiseError) {
            throw err;
          }
        }
      }
    }, handler.awaitHandlers)));
  }
};
var CallbackManagerForLLMRun = class extends BaseRunManager {
  async handleLLMNewToken(token, idx, _runId, _parentRunId, _tags, fields) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      if (!handler.ignoreLLM) {
        try {
          await handler.handleLLMNewToken?.(token, idx ?? { prompt: 0, completion: 0 }, this.runId, this._parentRunId, this.tags, fields);
        } catch (err) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleLLMNewToken: ${err}`);
          if (handler.raiseError) {
            throw err;
          }
        }
      }
    }, handler.awaitHandlers)));
  }
  async handleLLMError(err, _runId, _parentRunId, _tags, extraParams) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      if (!handler.ignoreLLM) {
        try {
          await handler.handleLLMError?.(err, this.runId, this._parentRunId, this.tags, extraParams);
        } catch (err2) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleLLMError: ${err2}`);
          if (handler.raiseError) {
            throw err2;
          }
        }
      }
    }, handler.awaitHandlers)));
  }
  async handleLLMEnd(output, _runId, _parentRunId, _tags, extraParams) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      if (!handler.ignoreLLM) {
        try {
          await handler.handleLLMEnd?.(output, this.runId, this._parentRunId, this.tags, extraParams);
        } catch (err) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleLLMEnd: ${err}`);
          if (handler.raiseError) {
            throw err;
          }
        }
      }
    }, handler.awaitHandlers)));
  }
};
var CallbackManagerForChainRun = class extends BaseRunManager {
  getChild(tag) {
    const manager = new CallbackManager(this.runId);
    manager.setHandlers(this.inheritableHandlers);
    manager.addTags(this.inheritableTags);
    manager.addMetadata(this.inheritableMetadata);
    if (tag) {
      manager.addTags([tag], false);
    }
    return manager;
  }
  async handleChainError(err, _runId, _parentRunId, _tags, kwargs) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      if (!handler.ignoreChain) {
        try {
          await handler.handleChainError?.(err, this.runId, this._parentRunId, this.tags, kwargs);
        } catch (err2) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleChainError: ${err2}`);
          if (handler.raiseError) {
            throw err2;
          }
        }
      }
    }, handler.awaitHandlers)));
  }
  async handleChainEnd(output, _runId, _parentRunId, _tags, kwargs) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      if (!handler.ignoreChain) {
        try {
          await handler.handleChainEnd?.(output, this.runId, this._parentRunId, this.tags, kwargs);
        } catch (err) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleChainEnd: ${err}`);
          if (handler.raiseError) {
            throw err;
          }
        }
      }
    }, handler.awaitHandlers)));
  }
  async handleAgentAction(action) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      if (!handler.ignoreAgent) {
        try {
          await handler.handleAgentAction?.(action, this.runId, this._parentRunId, this.tags);
        } catch (err) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleAgentAction: ${err}`);
          if (handler.raiseError) {
            throw err;
          }
        }
      }
    }, handler.awaitHandlers)));
  }
  async handleAgentEnd(action) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      if (!handler.ignoreAgent) {
        try {
          await handler.handleAgentEnd?.(action, this.runId, this._parentRunId, this.tags);
        } catch (err) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleAgentEnd: ${err}`);
          if (handler.raiseError) {
            throw err;
          }
        }
      }
    }, handler.awaitHandlers)));
  }
};
var CallbackManagerForToolRun = class extends BaseRunManager {
  getChild(tag) {
    const manager = new CallbackManager(this.runId);
    manager.setHandlers(this.inheritableHandlers);
    manager.addTags(this.inheritableTags);
    manager.addMetadata(this.inheritableMetadata);
    if (tag) {
      manager.addTags([tag], false);
    }
    return manager;
  }
  async handleToolError(err) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      if (!handler.ignoreAgent) {
        try {
          await handler.handleToolError?.(err, this.runId, this._parentRunId, this.tags);
        } catch (err2) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleToolError: ${err2}`);
          if (handler.raiseError) {
            throw err2;
          }
        }
      }
    }, handler.awaitHandlers)));
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async handleToolEnd(output) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      if (!handler.ignoreAgent) {
        try {
          await handler.handleToolEnd?.(output, this.runId, this._parentRunId, this.tags);
        } catch (err) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleToolEnd: ${err}`);
          if (handler.raiseError) {
            throw err;
          }
        }
      }
    }, handler.awaitHandlers)));
  }
};
var CallbackManager = class _CallbackManager extends BaseCallbackManager {
  constructor(parentRunId, options) {
    super();
    Object.defineProperty(this, "handlers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "inheritableHandlers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "tags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "inheritableTags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "metadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "inheritableMetadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "callback_manager"
    });
    Object.defineProperty(this, "_parentRunId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.handlers = options?.handlers ?? this.handlers;
    this.inheritableHandlers = options?.inheritableHandlers ?? this.inheritableHandlers;
    this.tags = options?.tags ?? this.tags;
    this.inheritableTags = options?.inheritableTags ?? this.inheritableTags;
    this.metadata = options?.metadata ?? this.metadata;
    this.inheritableMetadata = options?.inheritableMetadata ?? this.inheritableMetadata;
    this._parentRunId = parentRunId;
  }
  /**
   * Gets the parent run ID, if any.
   *
   * @returns The parent run ID.
   */
  getParentRunId() {
    return this._parentRunId;
  }
  async handleLLMStart(llm, prompts, runId = void 0, _parentRunId = void 0, extraParams = void 0, _tags = void 0, _metadata = void 0, runName = void 0) {
    return Promise.all(prompts.map(async (prompt, idx) => {
      const runId_ = idx === 0 && runId ? runId : v4_default();
      await Promise.all(this.handlers.map((handler) => {
        if (handler.ignoreLLM) {
          return;
        }
        if (isBaseTracer(handler)) {
          handler._createRunForLLMStart(llm, [prompt], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);
        }
        return consumeCallback(async () => {
          try {
            await handler.handleLLMStart?.(llm, [prompt], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);
          } catch (err) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`);
            if (handler.raiseError) {
              throw err;
            }
          }
        }, handler.awaitHandlers);
      }));
      return new CallbackManagerForLLMRun(runId_, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
    }));
  }
  async handleChatModelStart(llm, messages, runId = void 0, _parentRunId = void 0, extraParams = void 0, _tags = void 0, _metadata = void 0, runName = void 0) {
    return Promise.all(messages.map(async (messageGroup, idx) => {
      const runId_ = idx === 0 && runId ? runId : v4_default();
      await Promise.all(this.handlers.map((handler) => {
        if (handler.ignoreLLM) {
          return;
        }
        if (isBaseTracer(handler)) {
          handler._createRunForChatModelStart(llm, [messageGroup], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);
        }
        return consumeCallback(async () => {
          try {
            if (handler.handleChatModelStart) {
              await handler.handleChatModelStart?.(llm, [messageGroup], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);
            } else if (handler.handleLLMStart) {
              const messageString = getBufferString(messageGroup);
              await handler.handleLLMStart?.(llm, [messageString], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);
            }
          } catch (err) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`);
            if (handler.raiseError) {
              throw err;
            }
          }
        }, handler.awaitHandlers);
      }));
      return new CallbackManagerForLLMRun(runId_, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
    }));
  }
  async handleChainStart(chain, inputs, runId = v4_default(), runType = void 0, _tags = void 0, _metadata = void 0, runName = void 0) {
    await Promise.all(this.handlers.map((handler) => {
      if (handler.ignoreChain) {
        return;
      }
      if (isBaseTracer(handler)) {
        handler._createRunForChainStart(chain, inputs, runId, this._parentRunId, this.tags, this.metadata, runType, runName);
      }
      return consumeCallback(async () => {
        try {
          await handler.handleChainStart?.(chain, inputs, runId, this._parentRunId, this.tags, this.metadata, runType, runName);
        } catch (err) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleChainStart: ${err}`);
          if (handler.raiseError) {
            throw err;
          }
        }
      }, handler.awaitHandlers);
    }));
    return new CallbackManagerForChainRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
  }
  async handleToolStart(tool, input, runId = v4_default(), _parentRunId = void 0, _tags = void 0, _metadata = void 0, runName = void 0) {
    await Promise.all(this.handlers.map((handler) => {
      if (handler.ignoreAgent) {
        return;
      }
      if (isBaseTracer(handler)) {
        handler._createRunForToolStart(tool, input, runId, this._parentRunId, this.tags, this.metadata, runName);
      }
      return consumeCallback(async () => {
        try {
          await handler.handleToolStart?.(tool, input, runId, this._parentRunId, this.tags, this.metadata, runName);
        } catch (err) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleToolStart: ${err}`);
          if (handler.raiseError) {
            throw err;
          }
        }
      }, handler.awaitHandlers);
    }));
    return new CallbackManagerForToolRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
  }
  async handleRetrieverStart(retriever, query, runId = v4_default(), _parentRunId = void 0, _tags = void 0, _metadata = void 0, runName = void 0) {
    await Promise.all(this.handlers.map((handler) => {
      if (handler.ignoreRetriever) {
        return;
      }
      if (isBaseTracer(handler)) {
        handler._createRunForRetrieverStart(retriever, query, runId, this._parentRunId, this.tags, this.metadata, runName);
      }
      return consumeCallback(async () => {
        try {
          await handler.handleRetrieverStart?.(retriever, query, runId, this._parentRunId, this.tags, this.metadata, runName);
        } catch (err) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleRetrieverStart: ${err}`);
          if (handler.raiseError) {
            throw err;
          }
        }
      }, handler.awaitHandlers);
    }));
    return new CallbackManagerForRetrieverRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
  }
  async handleCustomEvent(eventName, data, runId, _tags, _metadata) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      if (!handler.ignoreCustomEvent) {
        try {
          await handler.handleCustomEvent?.(eventName, data, runId, this.tags, this.metadata);
        } catch (err) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleCustomEvent: ${err}`);
          if (handler.raiseError) {
            throw err;
          }
        }
      }
    }, handler.awaitHandlers)));
  }
  addHandler(handler, inherit = true) {
    this.handlers.push(handler);
    if (inherit) {
      this.inheritableHandlers.push(handler);
    }
  }
  removeHandler(handler) {
    this.handlers = this.handlers.filter((_handler) => _handler !== handler);
    this.inheritableHandlers = this.inheritableHandlers.filter((_handler) => _handler !== handler);
  }
  setHandlers(handlers, inherit = true) {
    this.handlers = [];
    this.inheritableHandlers = [];
    for (const handler of handlers) {
      this.addHandler(handler, inherit);
    }
  }
  addTags(tags, inherit = true) {
    this.removeTags(tags);
    this.tags.push(...tags);
    if (inherit) {
      this.inheritableTags.push(...tags);
    }
  }
  removeTags(tags) {
    this.tags = this.tags.filter((tag) => !tags.includes(tag));
    this.inheritableTags = this.inheritableTags.filter((tag) => !tags.includes(tag));
  }
  addMetadata(metadata, inherit = true) {
    this.metadata = { ...this.metadata, ...metadata };
    if (inherit) {
      this.inheritableMetadata = { ...this.inheritableMetadata, ...metadata };
    }
  }
  removeMetadata(metadata) {
    for (const key of Object.keys(metadata)) {
      delete this.metadata[key];
      delete this.inheritableMetadata[key];
    }
  }
  copy(additionalHandlers = [], inherit = true) {
    const manager = new _CallbackManager(this._parentRunId);
    for (const handler of this.handlers) {
      const inheritable = this.inheritableHandlers.includes(handler);
      manager.addHandler(handler, inheritable);
    }
    for (const tag of this.tags) {
      const inheritable = this.inheritableTags.includes(tag);
      manager.addTags([tag], inheritable);
    }
    for (const key of Object.keys(this.metadata)) {
      const inheritable = Object.keys(this.inheritableMetadata).includes(key);
      manager.addMetadata({ [key]: this.metadata[key] }, inheritable);
    }
    for (const handler of additionalHandlers) {
      if (
        // Prevent multiple copies of console_callback_handler
        manager.handlers.filter((h) => h.name === "console_callback_handler").some((h) => h.name === handler.name)
      ) {
        continue;
      }
      manager.addHandler(handler, inherit);
    }
    return manager;
  }
  static fromHandlers(handlers) {
    class Handler extends BaseCallbackHandler {
      constructor() {
        super();
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: v4_default()
        });
        Object.assign(this, handlers);
      }
    }
    const manager = new this();
    manager.addHandler(new Handler());
    return manager;
  }
  static configure(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options) {
    return this._configureSync(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options);
  }
  // TODO: Deprecate async method in favor of this one.
  static _configureSync(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options) {
    let callbackManager;
    if (inheritableHandlers || localHandlers) {
      if (Array.isArray(inheritableHandlers) || !inheritableHandlers) {
        callbackManager = new _CallbackManager();
        callbackManager.setHandlers(inheritableHandlers?.map(ensureHandler) ?? [], true);
      } else {
        callbackManager = inheritableHandlers;
      }
      callbackManager = callbackManager.copy(Array.isArray(localHandlers) ? localHandlers.map(ensureHandler) : localHandlers?.handlers, false);
    }
    const verboseEnabled = getEnvironmentVariable("LANGCHAIN_VERBOSE") === "true" || options?.verbose;
    const tracingV2Enabled = LangChainTracer.getTraceableRunTree()?.tracingEnabled || isTracingEnabled2();
    const tracingEnabled = tracingV2Enabled || (getEnvironmentVariable("LANGCHAIN_TRACING") ?? false);
    if (verboseEnabled || tracingEnabled) {
      if (!callbackManager) {
        callbackManager = new _CallbackManager();
      }
      if (verboseEnabled && !callbackManager.handlers.some((handler) => handler.name === ConsoleCallbackHandler.prototype.name)) {
        const consoleHandler = new ConsoleCallbackHandler();
        callbackManager.addHandler(consoleHandler, true);
      }
      if (tracingEnabled && !callbackManager.handlers.some((handler) => handler.name === "langchain_tracer")) {
        if (tracingV2Enabled) {
          const tracerV2 = new LangChainTracer();
          callbackManager.addHandler(tracerV2, true);
          callbackManager._parentRunId = LangChainTracer.getTraceableRunTree()?.id ?? callbackManager._parentRunId;
        }
      }
    }
    for (const { contextVar, inheritable = true, handlerClass, envVar } of _getConfigureHooks()) {
      const createIfNotInContext = envVar && getEnvironmentVariable(envVar) === "true" && handlerClass;
      let handler;
      const contextVarValue = contextVar !== void 0 ? getContextVariable(contextVar) : void 0;
      if (contextVarValue && isBaseCallbackHandler(contextVarValue)) {
        handler = contextVarValue;
      } else if (createIfNotInContext) {
        handler = new handlerClass({});
      }
      if (handler !== void 0) {
        if (!callbackManager) {
          callbackManager = new _CallbackManager();
        }
        if (!callbackManager.handlers.some((h) => h.name === handler.name)) {
          callbackManager.addHandler(handler, inheritable);
        }
      }
    }
    if (inheritableTags || localTags) {
      if (callbackManager) {
        callbackManager.addTags(inheritableTags ?? []);
        callbackManager.addTags(localTags ?? [], false);
      }
    }
    if (inheritableMetadata || localMetadata) {
      if (callbackManager) {
        callbackManager.addMetadata(inheritableMetadata ?? {});
        callbackManager.addMetadata(localMetadata ?? {}, false);
      }
    }
    return callbackManager;
  }
};
function ensureHandler(handler) {
  if ("name" in handler) {
    return handler;
  }
  return BaseCallbackHandler.fromMethods(handler);
}

// node_modules/@sap-ai-sdk/langchain/node_modules/@langchain/core/dist/singletons/async_local_storage/index.js
var MockAsyncLocalStorage2 = class {
  getStore() {
    return void 0;
  }
  run(_store, callback) {
    return callback();
  }
  enterWith(_store) {
    return void 0;
  }
};
var mockAsyncLocalStorage2 = new MockAsyncLocalStorage2();
var LC_CHILD_KEY = Symbol.for("lc:child_config");
var AsyncLocalStorageProvider2 = class {
  getInstance() {
    return getGlobalAsyncLocalStorageInstance() ?? mockAsyncLocalStorage2;
  }
  getRunnableConfig() {
    const storage = this.getInstance();
    return storage.getStore()?.extra?.[LC_CHILD_KEY];
  }
  runWithConfig(config, callback, avoidCreatingRootRunTree) {
    const callbackManager = CallbackManager._configureSync(config?.callbacks, void 0, config?.tags, void 0, config?.metadata);
    const storage = this.getInstance();
    const previousValue = storage.getStore();
    const parentRunId = callbackManager?.getParentRunId();
    const langChainTracer = callbackManager?.handlers?.find((handler) => handler?.name === "langchain_tracer");
    let runTree;
    if (langChainTracer && parentRunId) {
      runTree = langChainTracer.convertToRunTree(parentRunId);
    } else if (!avoidCreatingRootRunTree) {
      runTree = new RunTree({
        name: "<runnable_lambda>",
        tracingEnabled: false
      });
    }
    if (runTree) {
      runTree.extra = { ...runTree.extra, [LC_CHILD_KEY]: config };
    }
    if (previousValue !== void 0 && previousValue[_CONTEXT_VARIABLES_KEY] !== void 0) {
      if (runTree === void 0) {
        runTree = {};
      }
      runTree[_CONTEXT_VARIABLES_KEY] = previousValue[_CONTEXT_VARIABLES_KEY];
    }
    return storage.run(runTree, callback);
  }
  initializeGlobalInstance(instance) {
    if (getGlobalAsyncLocalStorageInstance() === void 0) {
      setGlobalAsyncLocalStorageInstance(instance);
    }
  }
};
var AsyncLocalStorageProviderSingleton2 = new AsyncLocalStorageProvider2();

// node_modules/@sap-ai-sdk/langchain/node_modules/@langchain/core/dist/utils/async_caller.js
var import_p_retry2 = __toESM(require_p_retry(), 1);
var import_p_queue3 = __toESM(require_dist14(), 1);
var STATUS_NO_RETRY2 = [
  400,
  401,
  402,
  403,
  404,
  405,
  406,
  407,
  409
  // Conflict
];
var defaultFailedAttemptHandler = (error) => {
  if (error.message.startsWith("Cancel") || error.message.startsWith("AbortError") || error.name === "AbortError") {
    throw error;
  }
  if (error?.code === "ECONNABORTED") {
    throw error;
  }
  const status = (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    error?.response?.status ?? error?.status
  );
  if (status && STATUS_NO_RETRY2.includes(+status)) {
    throw error;
  }
  if (error?.error?.code === "insufficient_quota") {
    const err = new Error(error?.message);
    err.name = "InsufficientQuotaError";
    throw err;
  }
};
var AsyncCaller2 = class {
  constructor(params) {
    Object.defineProperty(this, "maxConcurrency", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "maxRetries", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "onFailedAttempt", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "queue", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.maxConcurrency = params.maxConcurrency ?? Infinity;
    this.maxRetries = params.maxRetries ?? 6;
    this.onFailedAttempt = params.onFailedAttempt ?? defaultFailedAttemptHandler;
    const PQueue = "default" in import_p_queue3.default ? import_p_queue3.default.default : import_p_queue3.default;
    this.queue = new PQueue({ concurrency: this.maxConcurrency });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  call(callable, ...args) {
    return this.queue.add(() => (0, import_p_retry2.default)(() => callable(...args).catch((error) => {
      if (error instanceof Error) {
        throw error;
      } else {
        throw new Error(error);
      }
    }), {
      onFailedAttempt: this.onFailedAttempt,
      retries: this.maxRetries,
      randomize: true
      // If needed we can change some of the defaults here,
      // but they're quite sensible.
    }), { throwOnTimeout: true });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  callWithOptions(options, callable, ...args) {
    if (options.signal) {
      return Promise.race([
        this.call(callable, ...args),
        new Promise((_, reject) => {
          options.signal?.addEventListener("abort", () => {
            reject(new Error("AbortError"));
          });
        })
      ]);
    }
    return this.call(callable, ...args);
  }
  fetch(...args) {
    return this.call(() => fetch(...args).then((res) => res.ok ? res : Promise.reject(res)));
  }
};

// node_modules/@sap-ai-sdk/langchain/node_modules/@langchain/core/dist/utils/js-sha1/hash.js
var root = typeof window === "object" ? window : {};
var HEX_CHARS = "0123456789abcdef".split("");
var EXTRA = [-2147483648, 8388608, 32768, 128];
var SHIFT = [24, 16, 8, 0];
var blocks = [];
function Sha1(sharedMemory) {
  if (sharedMemory) {
    blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
    this.blocks = blocks;
  } else {
    this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  }
  this.h0 = 1732584193;
  this.h1 = 4023233417;
  this.h2 = 2562383102;
  this.h3 = 271733878;
  this.h4 = 3285377520;
  this.block = this.start = this.bytes = this.hBytes = 0;
  this.finalized = this.hashed = false;
  this.first = true;
}
Sha1.prototype.update = function(message) {
  if (this.finalized) {
    return;
  }
  var notString = typeof message !== "string";
  if (notString && message.constructor === root.ArrayBuffer) {
    message = new Uint8Array(message);
  }
  var code, index = 0, i, length = message.length || 0, blocks2 = this.blocks;
  while (index < length) {
    if (this.hashed) {
      this.hashed = false;
      blocks2[0] = this.block;
      blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
    }
    if (notString) {
      for (i = this.start; index < length && i < 64; ++index) {
        blocks2[i >> 2] |= message[index] << SHIFT[i++ & 3];
      }
    } else {
      for (i = this.start; index < length && i < 64; ++index) {
        code = message.charCodeAt(index);
        if (code < 128) {
          blocks2[i >> 2] |= code << SHIFT[i++ & 3];
        } else if (code < 2048) {
          blocks2[i >> 2] |= (192 | code >> 6) << SHIFT[i++ & 3];
          blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
        } else if (code < 55296 || code >= 57344) {
          blocks2[i >> 2] |= (224 | code >> 12) << SHIFT[i++ & 3];
          blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
          blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
        } else {
          code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
          blocks2[i >> 2] |= (240 | code >> 18) << SHIFT[i++ & 3];
          blocks2[i >> 2] |= (128 | code >> 12 & 63) << SHIFT[i++ & 3];
          blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
          blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
        }
      }
    }
    this.lastByteIndex = i;
    this.bytes += i - this.start;
    if (i >= 64) {
      this.block = blocks2[16];
      this.start = i - 64;
      this.hash();
      this.hashed = true;
    } else {
      this.start = i;
    }
  }
  if (this.bytes > 4294967295) {
    this.hBytes += this.bytes / 4294967296 << 0;
    this.bytes = this.bytes % 4294967296;
  }
  return this;
};
Sha1.prototype.finalize = function() {
  if (this.finalized) {
    return;
  }
  this.finalized = true;
  var blocks2 = this.blocks, i = this.lastByteIndex;
  blocks2[16] = this.block;
  blocks2[i >> 2] |= EXTRA[i & 3];
  this.block = blocks2[16];
  if (i >= 56) {
    if (!this.hashed) {
      this.hash();
    }
    blocks2[0] = this.block;
    blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
  }
  blocks2[14] = this.hBytes << 3 | this.bytes >>> 29;
  blocks2[15] = this.bytes << 3;
  this.hash();
};
Sha1.prototype.hash = function() {
  var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4;
  var f, j, t, blocks2 = this.blocks;
  for (j = 16; j < 80; ++j) {
    t = blocks2[j - 3] ^ blocks2[j - 8] ^ blocks2[j - 14] ^ blocks2[j - 16];
    blocks2[j] = t << 1 | t >>> 31;
  }
  for (j = 0; j < 20; j += 5) {
    f = b & c | ~b & d;
    t = a << 5 | a >>> 27;
    e = t + f + e + 1518500249 + blocks2[j] << 0;
    b = b << 30 | b >>> 2;
    f = a & b | ~a & c;
    t = e << 5 | e >>> 27;
    d = t + f + d + 1518500249 + blocks2[j + 1] << 0;
    a = a << 30 | a >>> 2;
    f = e & a | ~e & b;
    t = d << 5 | d >>> 27;
    c = t + f + c + 1518500249 + blocks2[j + 2] << 0;
    e = e << 30 | e >>> 2;
    f = d & e | ~d & a;
    t = c << 5 | c >>> 27;
    b = t + f + b + 1518500249 + blocks2[j + 3] << 0;
    d = d << 30 | d >>> 2;
    f = c & d | ~c & e;
    t = b << 5 | b >>> 27;
    a = t + f + a + 1518500249 + blocks2[j + 4] << 0;
    c = c << 30 | c >>> 2;
  }
  for (; j < 40; j += 5) {
    f = b ^ c ^ d;
    t = a << 5 | a >>> 27;
    e = t + f + e + 1859775393 + blocks2[j] << 0;
    b = b << 30 | b >>> 2;
    f = a ^ b ^ c;
    t = e << 5 | e >>> 27;
    d = t + f + d + 1859775393 + blocks2[j + 1] << 0;
    a = a << 30 | a >>> 2;
    f = e ^ a ^ b;
    t = d << 5 | d >>> 27;
    c = t + f + c + 1859775393 + blocks2[j + 2] << 0;
    e = e << 30 | e >>> 2;
    f = d ^ e ^ a;
    t = c << 5 | c >>> 27;
    b = t + f + b + 1859775393 + blocks2[j + 3] << 0;
    d = d << 30 | d >>> 2;
    f = c ^ d ^ e;
    t = b << 5 | b >>> 27;
    a = t + f + a + 1859775393 + blocks2[j + 4] << 0;
    c = c << 30 | c >>> 2;
  }
  for (; j < 60; j += 5) {
    f = b & c | b & d | c & d;
    t = a << 5 | a >>> 27;
    e = t + f + e - 1894007588 + blocks2[j] << 0;
    b = b << 30 | b >>> 2;
    f = a & b | a & c | b & c;
    t = e << 5 | e >>> 27;
    d = t + f + d - 1894007588 + blocks2[j + 1] << 0;
    a = a << 30 | a >>> 2;
    f = e & a | e & b | a & b;
    t = d << 5 | d >>> 27;
    c = t + f + c - 1894007588 + blocks2[j + 2] << 0;
    e = e << 30 | e >>> 2;
    f = d & e | d & a | e & a;
    t = c << 5 | c >>> 27;
    b = t + f + b - 1894007588 + blocks2[j + 3] << 0;
    d = d << 30 | d >>> 2;
    f = c & d | c & e | d & e;
    t = b << 5 | b >>> 27;
    a = t + f + a - 1894007588 + blocks2[j + 4] << 0;
    c = c << 30 | c >>> 2;
  }
  for (; j < 80; j += 5) {
    f = b ^ c ^ d;
    t = a << 5 | a >>> 27;
    e = t + f + e - 899497514 + blocks2[j] << 0;
    b = b << 30 | b >>> 2;
    f = a ^ b ^ c;
    t = e << 5 | e >>> 27;
    d = t + f + d - 899497514 + blocks2[j + 1] << 0;
    a = a << 30 | a >>> 2;
    f = e ^ a ^ b;
    t = d << 5 | d >>> 27;
    c = t + f + c - 899497514 + blocks2[j + 2] << 0;
    e = e << 30 | e >>> 2;
    f = d ^ e ^ a;
    t = c << 5 | c >>> 27;
    b = t + f + b - 899497514 + blocks2[j + 3] << 0;
    d = d << 30 | d >>> 2;
    f = c ^ d ^ e;
    t = b << 5 | b >>> 27;
    a = t + f + a - 899497514 + blocks2[j + 4] << 0;
    c = c << 30 | c >>> 2;
  }
  this.h0 = this.h0 + a << 0;
  this.h1 = this.h1 + b << 0;
  this.h2 = this.h2 + c << 0;
  this.h3 = this.h3 + d << 0;
  this.h4 = this.h4 + e << 0;
};
Sha1.prototype.hex = function() {
  this.finalize();
  var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4;
  return HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15] + HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15] + HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15] + HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h4 >> 28 & 15] + HEX_CHARS[h4 >> 24 & 15] + HEX_CHARS[h4 >> 20 & 15] + HEX_CHARS[h4 >> 16 & 15] + HEX_CHARS[h4 >> 12 & 15] + HEX_CHARS[h4 >> 8 & 15] + HEX_CHARS[h4 >> 4 & 15] + HEX_CHARS[h4 & 15];
};
Sha1.prototype.toString = Sha1.prototype.hex;
Sha1.prototype.digest = function() {
  this.finalize();
  var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4;
  return [
    h0 >> 24 & 255,
    h0 >> 16 & 255,
    h0 >> 8 & 255,
    h0 & 255,
    h1 >> 24 & 255,
    h1 >> 16 & 255,
    h1 >> 8 & 255,
    h1 & 255,
    h2 >> 24 & 255,
    h2 >> 16 & 255,
    h2 >> 8 & 255,
    h2 & 255,
    h3 >> 24 & 255,
    h3 >> 16 & 255,
    h3 >> 8 & 255,
    h3 & 255,
    h4 >> 24 & 255,
    h4 >> 16 & 255,
    h4 >> 8 & 255,
    h4 & 255
  ];
};
Sha1.prototype.array = Sha1.prototype.digest;
Sha1.prototype.arrayBuffer = function() {
  this.finalize();
  var buffer = new ArrayBuffer(20);
  var dataView = new DataView(buffer);
  dataView.setUint32(0, this.h0);
  dataView.setUint32(4, this.h1);
  dataView.setUint32(8, this.h2);
  dataView.setUint32(12, this.h3);
  dataView.setUint32(16, this.h4);
  return buffer;
};

// node_modules/js-tiktoken/dist/chunk-ZDNLBERF.js
var import_base64_js = __toESM(require_base64_js(), 1);
var __defProp2 = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
function bytePairMerge(piece, ranks) {
  let parts = Array.from(
    { length: piece.length },
    (_, i) => ({ start: i, end: i + 1 })
  );
  while (parts.length > 1) {
    let minRank = null;
    for (let i = 0; i < parts.length - 1; i++) {
      const slice = piece.slice(parts[i].start, parts[i + 1].end);
      const rank = ranks.get(slice.join(","));
      if (rank == null)
        continue;
      if (minRank == null || rank < minRank[0]) {
        minRank = [rank, i];
      }
    }
    if (minRank != null) {
      const i = minRank[1];
      parts[i] = { start: parts[i].start, end: parts[i + 1].end };
      parts.splice(i + 1, 1);
    } else {
      break;
    }
  }
  return parts;
}
function bytePairEncode(piece, ranks) {
  if (piece.length === 1)
    return [ranks.get(piece.join(","))];
  return bytePairMerge(piece, ranks).map((p) => ranks.get(piece.slice(p.start, p.end).join(","))).filter((x) => x != null);
}
function escapeRegex(str) {
  return str.replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
}
var _Tiktoken = class {
  /** @internal */
  specialTokens;
  /** @internal */
  inverseSpecialTokens;
  /** @internal */
  patStr;
  /** @internal */
  textEncoder = new TextEncoder();
  /** @internal */
  textDecoder = new TextDecoder("utf-8");
  /** @internal */
  rankMap = /* @__PURE__ */ new Map();
  /** @internal */
  textMap = /* @__PURE__ */ new Map();
  constructor(ranks, extendedSpecialTokens) {
    this.patStr = ranks.pat_str;
    const uncompressed = ranks.bpe_ranks.split("\n").filter(Boolean).reduce((memo, x) => {
      const [_, offsetStr, ...tokens] = x.split(" ");
      const offset = Number.parseInt(offsetStr, 10);
      tokens.forEach((token, i) => memo[token] = offset + i);
      return memo;
    }, {});
    for (const [token, rank] of Object.entries(uncompressed)) {
      const bytes = import_base64_js.default.toByteArray(token);
      this.rankMap.set(bytes.join(","), rank);
      this.textMap.set(rank, bytes);
    }
    this.specialTokens = { ...ranks.special_tokens, ...extendedSpecialTokens };
    this.inverseSpecialTokens = Object.entries(this.specialTokens).reduce((memo, [text, rank]) => {
      memo[rank] = this.textEncoder.encode(text);
      return memo;
    }, {});
  }
  encode(text, allowedSpecial = [], disallowedSpecial = "all") {
    const regexes = new RegExp(this.patStr, "ug");
    const specialRegex = _Tiktoken.specialTokenRegex(
      Object.keys(this.specialTokens)
    );
    const ret = [];
    const allowedSpecialSet = new Set(
      allowedSpecial === "all" ? Object.keys(this.specialTokens) : allowedSpecial
    );
    const disallowedSpecialSet = new Set(
      disallowedSpecial === "all" ? Object.keys(this.specialTokens).filter(
        (x) => !allowedSpecialSet.has(x)
      ) : disallowedSpecial
    );
    if (disallowedSpecialSet.size > 0) {
      const disallowedSpecialRegex = _Tiktoken.specialTokenRegex([
        ...disallowedSpecialSet
      ]);
      const specialMatch = text.match(disallowedSpecialRegex);
      if (specialMatch != null) {
        throw new Error(
          `The text contains a special token that is not allowed: ${specialMatch[0]}`
        );
      }
    }
    let start = 0;
    while (true) {
      let nextSpecial = null;
      let startFind = start;
      while (true) {
        specialRegex.lastIndex = startFind;
        nextSpecial = specialRegex.exec(text);
        if (nextSpecial == null || allowedSpecialSet.has(nextSpecial[0]))
          break;
        startFind = nextSpecial.index + 1;
      }
      const end = nextSpecial?.index ?? text.length;
      for (const match of text.substring(start, end).matchAll(regexes)) {
        const piece = this.textEncoder.encode(match[0]);
        const token2 = this.rankMap.get(piece.join(","));
        if (token2 != null) {
          ret.push(token2);
          continue;
        }
        ret.push(...bytePairEncode(piece, this.rankMap));
      }
      if (nextSpecial == null)
        break;
      let token = this.specialTokens[nextSpecial[0]];
      ret.push(token);
      start = nextSpecial.index + nextSpecial[0].length;
    }
    return ret;
  }
  decode(tokens) {
    const res = [];
    let length = 0;
    for (let i2 = 0; i2 < tokens.length; ++i2) {
      const token = tokens[i2];
      const bytes = this.textMap.get(token) ?? this.inverseSpecialTokens[token];
      if (bytes != null) {
        res.push(bytes);
        length += bytes.length;
      }
    }
    const mergedArray = new Uint8Array(length);
    let i = 0;
    for (const bytes of res) {
      mergedArray.set(bytes, i);
      i += bytes.length;
    }
    return this.textDecoder.decode(mergedArray);
  }
};
var Tiktoken = _Tiktoken;
__publicField(Tiktoken, "specialTokenRegex", (tokens) => {
  return new RegExp(tokens.map((i) => escapeRegex(i)).join("|"), "g");
});

// node_modules/@sap-ai-sdk/langchain/node_modules/@langchain/core/dist/embeddings.js
var Embeddings = class {
  constructor(params) {
    Object.defineProperty(this, "caller", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.caller = new AsyncCaller2(params ?? {});
  }
};

// node_modules/@sap-ai-sdk/langchain/dist/openai/embedding.js
var AzureOpenAiEmbeddingClient2 = class extends Embeddings {
  modelName;
  modelVersion;
  resourceGroup;
  openAiEmbeddingClient;
  constructor(fields, destination) {
    super(fields);
    this.openAiEmbeddingClient = new AzureOpenAiEmbeddingClient(fields, destination);
    this.modelName = fields.modelName;
    this.modelVersion = fields.modelVersion;
    this.resourceGroup = fields.resourceGroup;
  }
  /**
   * Embed a list of document chunks. All chunks are embedded in one batch.
   * @param documents - Document chunks to embed.
   * @returns Embeddings.
   */
  async embedDocuments(documents) {
    return (await this.createEmbeddings({ input: documents })).getEmbeddings();
  }
  /**
   * Embed a single string.
   * @param input - Input string to embed.
   * @returns Embedding.
   */
  async embedQuery(input) {
    return (await this.createEmbeddings({ input })).getEmbedding() ?? [];
  }
  async createEmbeddings(query) {
    return this.caller.callWithOptions({}, async () => this.openAiEmbeddingClient.run(query));
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AzureOpenAiEmbeddingClient,
  OrchestrationClient,
  buildAzureContentSafetyFilter
});
/*! Bundled license information:

voca/index.js:
  (*! 
   * Voca string library 1.4.1
   * https://vocajs.pages.dev
   *
   * Copyright Dmitri Pavlutin and other contributors
   * Released under the MIT license
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

axios/dist/node/axios.cjs:
  (*! Axios v1.11.0 Copyright (c) 2025 Matt Zabriskie and contributors *)

@langchain/core/dist/utils/fast-json-patch/src/helpers.js:
  (*!
   * https://github.com/Starcounter-Jack/JSON-Patch
   * (c) 2017-2022 Joachim Wester
   * MIT licensed
   *)

@langchain/core/dist/utils/fast-json-patch/src/duplex.js:
  (*!
   * https://github.com/Starcounter-Jack/JSON-Patch
   * (c) 2013-2021 Joachim Wester
   * MIT license
   *)

@langchain/core/dist/utils/js-sha1/hash.js:
  (*
   * [js-sha1]{@link https://github.com/emn178/js-sha1}
   *
   * @version 0.6.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2014-2017
   * @license MIT
   *)
*/
